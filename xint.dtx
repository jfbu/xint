% -*- coding: iso-latin-1; -*-
% This file: xint.dtx (1.05a, 2013/05/02)
%%
%%----------------------------------------------------------------
%% The xint bundle (version 1.05a of May 2nd, 2013)
%<xint>%% xint: Expandable operations on long numbers
%<xintgcd>%% xintgcd: Euclidean algorithm with xint package 
%<xintfrac>%% xintfrac: Expandable operations on fractions  
%<xintseries>%% xintseries: Expandable partial sums with xint package
%<xintcfrac>%% xintcfrac: Expandable continued fractions with xint package
%% Copyright (C) 2013 by Jean-Francois B. 
%%----------------------------------------------------------------
%%
% Style files in the bundle:
% (base) xint.sty       Expandable operations on long numbers
%        xintgcd.sty    Euclidean algorithm with xint package
%        xintfrac.sty   Expandable operations on fractions
%        xintseries.sty Expandable partial sums with xint package
%        xintcfrac.sty  Expandable continued fractions with xint package
% 
%  This work consists of the source file xint.dtx and of its derived files
%  xint.sty, xintgcd.sty, xintfrac.sty, xintseries.sty, xintcfrac.sty, xint.ins
%  and the documentation xint.pdf (or xint.dvi).
%
%     This work may be distributed and/or modified under the
%     conditions of the LaTeX Project Public License, either
%     version 1.3c of this license or (at your option) any later
%     version. This version of this license is in 
%          http://www.latex-project.org/lppl/lppl-1-3c.txt
%     and the latest version of this license is in
%          http://www.latex-project.org/lppl.txt
%     and version 1.3 or later is part of all distributions of
%     LaTeX version 2005/12/01 or later. 
% 
% The author of this work is Jean-Francois B. <2589111+jfbu@users.noreply.github.com>. 
% This work has the LPPL maintenance status `author-maintained'.
% 
%  Installation and Usage:
%  =======================
%
%  Run tex or latex on xint.dtx.
% 
%  This will extract the style files xint.sty, xintgcd.sty, xintfrac.sty,
%  xintseries.sty, xintcfrac.sty (and xint.ins). Files with the same
%  names and in the same repertory will be overwritten. The tex (not
%  latex) run will stop with the complaint that it does not understand
%  \NeedsTeXFormat, but the style files will already have been extracted
%  by that time.
%
%  Alternatively, run tex or latex on xint.ins if available.
%
%  To get xint.pdf run pdflatex thrice on xint.dtx
%  
%             xint.sty |
%          xintgcd.sty |
%         xintfrac.sty | --> TDS:tex/generic/xint/
%       xintseries.sty |
%        xintcfrac.sty |
%             xint.dtx   --> TDS:source/generic/xint/
%             xint.pdf   --> TDS:doc/generic/xint/
% 
% It may be necessary to then refresh the TeX installation filename
% database.
%
%  Usage with LaTeX: \usepackage{xint}
%                    \usepackage{xintgcd}    % (loads xint)
%                    \usepackage{xintfrac}   % (loads xint)
%                    \usepackage{xintseries} % (loads xintfrac)
%                    \usepackage{xintcfrac}  % (loads xintfrac)
%
%  Usage with TeX:   \input xint.sty\relax   
%                    \input xintgcd.sty\relax    % (loads xint)
%                    \input xintfrac.sty\relax   % (loads xint)
%                    \input xintseries.sty\relax % (loads xintfrac)
%                    \input xintcfrac.sty\relax  % (loads xintfrac)
%
%<*none>
\def\lasttimestamp{Time-stamp: <02-05-2013 17:37:34 CEST BURNOL>}
\def\pkgversion{1.05a}
\def\pkgdate{2013/05/02}
\def\striptimestamp #1 <#2 #3 #4 #5>{#2 at #3 #4}
\def\getdocdate #1 <#2-#3-#4 #5>{#4/#3/#2}
\edef\docdate{\expandafter\getdocdate\lasttimestamp}
\edef\dtxtimestamp{\expandafter\striptimestamp\lasttimestamp}
\begingroup
\input docstrip.tex
\askforoverwritefalse
\generate{\nopreamble
\file{xint.ins}{\from{xint.dtx}{ins}}
\usepreamble\defaultpreamble
\file{xint.sty}{\from{xint.dtx}{xint}}
\file{xintgcd.sty}{\from{xint.dtx}{xintgcd}}
\file{xintfrac.sty}{\from{xint.dtx}{xintfrac}}
\file{xintseries.sty}{\from{xint.dtx}{xintseries}}
\file{xintcfrac.sty}{\from{xint.dtx}{xintcfrac}}}
\endgroup
\iffalse
%</none>
%<*ins>
%----------- to .ins file ----------------------------------------
%%
%% This is a generated file. Run tex or latex on this file to
%% extract xint.sty, xintgcd.sty, xintfrac.sty, xintseries.sty
%% and xintcfrac.sty from xint.dtx
%%
%% See xint.dtx for the statements of copyright and conditions of
%% distribution and/or modification of this work.
%%
\input docstrip.tex
\askforoverwritefalse
\generate{\usepreamble\defaultpreamble
\file{xint.sty}{\from{xint.dtx}{xint}}
\file{xintgcd.sty}{\from{xint.dtx}{xintgcd}}
\file{xintfrac.sty}{\from{xint.dtx}{xintfrac}}
\file{xintseries.sty}{\from{xint.dtx}{xintseries}}
\file{xintcfrac.sty}{\from{xint.dtx}{xintcfrac}}}
\endbatchfile
%----------- end of .ins file ------------------------------------
%</ins>
%<*none>
\fi
\NeedsTeXFormat{LaTeX2e}
\ProvidesFile{xint.dtx}[bundle source and documentation (\dtxtimestamp)]

\documentclass[a4paper,11pt,abstract]{scrdoc}
%\OnlyDescription

\pagestyle{headings}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{multicol}

%---- GEOMETRY WILL BE CHANGED FOR SOURCE CODE SECTIONS

\usepackage[hscale=0.66,vscale=0.75]{geometry}

%---- WE NEED OUR BEAUTIFUL SELVES

%% checking that dependencies are all-right
%\usepackage{xint}
%\usepackage{xintgcd}
%\usepackage{xintfrac}

\usepackage{xintgcd}
\usepackage{xintseries}
\usepackage{xintcfrac}


\usepackage{amsmath} % for \cfrac

\usepackage{etoc}
\makeatletter

%---- CHANGING TOCDEPTH MIDWAY THROUGH THE MAIN TOC (1.04, 18 avril 2013)
\def\newtocdepth #1{\c@tocdepth #1 } % ainsi on modifie localement seulement
\def\toctransition {%
    \addtocontents {toc}{\protect\newtocdepth {1}}%
    \let\newtocdepth\@gobble
    \etocmulticolstyle [1]{\subsection *{Contents}}%
}

%---- USING ETOC FOR CUSTOM SUBSECTION STYLE (pour 1.04, 21 avril 2013)

% attention comme je crée un groupe pour les sous-sections, je dois donc faire
% attention de positionner \toctransition *après* le début de la section
% "implémentation de xint"

\let\savedsectionline\l@section
\etocsetstyle{section}{}{}
     {\savedsectionline{\numberline{\etocnumber}\etocname}{\etocpage}}{}%
\etocsetstyle{subsection}
    {\begingroup
     \setlength{\premulticols}{0pt}
     \setlength{\multicolsep}{0pt}
     \setlength{\columnsep}{1em}
     \begin{multicols}{2}}{}
    {\noindent\makebox[2.5em][l]{\etocnumber}\etocname\leaders\etoctoclineleaders\hfill\etocpage\endgraf}
    {\end{multicols}\endgroup}%

\makeatother

%--- TXFONTS, AND TXTT MADE SMALLER AND ALLOWING HYPHENATION

\usepackage{txfonts}
% malheureusement, comme j'utilise des diacritiques dans mes
% parties commentées, imprimées verbatim, je ne pourrai pas
% utiliser dvipdfmx qui a un problème avec txtt

\DeclareFontFamily{T1}{txtt}{}
\DeclareFontShape{T1}{txtt}{m}{n}{	%medium
     <->s*[.96] t1xtt%
}{}
\DeclareFontShape{T1}{txtt}{m}{sc}{	%cap & small cap
     <->s*[.96] t1xttsc%
}{}
\DeclareFontShape{T1}{txtt}{m}{sl}{	%slanted
     <->s*[.96] t1xttsl%
}{}
\DeclareFontShape{T1}{txtt}{m}{it}{	%italic
     <->ssub * txtt/m/sl%
}{}
\DeclareFontShape{T1}{txtt}{m}{ui}{   	%unslanted italic
     <->ssub * txtt/m/sl%
}{}
\DeclareFontShape{T1}{txtt}{bx}{n}{	%bold extended
     <->t1xbtt%
}{}
\DeclareFontShape{T1}{txtt}{bx}{sc}{	%bold extended cap & small cap
     <->t1xbttsc%
}{}
\DeclareFontShape{T1}{txtt}{bx}{sl}{	%bold extended slanted
     <->t1xbttsl%
}{}
\DeclareFontShape{T1}{txtt}{bx}{it}{	%bold extended italic
     <->ssub * txtt/bx/sl%
}{}
\DeclareFontShape{T1}{txtt}{bx}{ui}{  	%bold extended unslanted italic
     <->ssub * txtt/bx/sl%
}{}
\DeclareFontShape{T1}{txtt}{b}{n}{	%bold
     <->ssub * txtt/bx/n%
}{}
\DeclareFontShape{T1}{txtt}{b}{sc}{	%bold cap & small cap
     <->ssub * txtt/bx/sc%
}{}
\DeclareFontShape{T1}{txtt}{b}{sl}{	%bold slanted
     <->ssub * txtt/bx/sl%
}{}
\DeclareFontShape{T1}{txtt}{b}{it}{   	%bold italic
     <->ssub * txtt/bx/it%
}{}
\DeclareFontShape{T1}{txtt}{b}{ui}{   	%bold unslanted italic
     <->ssub * txtt/bx/ui%
}{}

\usepackage{xspace}
\usepackage{color}
\usepackage{framed}

\definecolor{joli}{RGB}{225,95,0}
\definecolor{JOLI}{RGB}{225,95,0}
\definecolor{BLUE}{RGB}{0,0,255}
\definecolor{niceone}{RGB}{38,128,192}

\usepackage[english]{babel}

\usepackage[pdfencoding=pdfdoc,bookmarks=true]{hyperref}

\hypersetup{%
linktoc=all,%
breaklinks=true,%
hidelinks,%
pdfauthor={Jean-Fran\c cois B.},%
pdftitle={The xint bundle},%
pdfsubject={Arithmetic with TeX},%
pdfkeywords={Expansion, arithmetic, TeX},%
pdfstartview=FitH,%
pdfpagemode=UseOutlines}


%---- OUR OWN LITTLE MACRO FOR CENTERING LINES
\makeatletter
% 7 mars 2013
% This macro allows to conveniently center a line inside a paragraph and still
% use therein \verb or other commands changing catcodes.
% A proposito, the \LaTeX \centerline uses \hsize and not \linewidth ! 
% (which in my humble opinion is bad)

\newcommand*\centeredline {%
      \ifhmode \\\relax
        \def\centeredline@{\hss\egroup\hskip\z@skip }%
      \else 
        \def\centeredline@{\hss\egroup }%
      \fi
      \afterassignment\@centeredline
      \let\next=}
\def\@centeredline 
{\hbox to \linewidth \bgroup \hss \bgroup \aftergroup\centeredline@ }
\makeatother

%---- ALLOWING COMMENTS INSIDE VERBATIM BLOCKS
\makeatletter
\let\original@check@percent\check@percent
\let\check@percent\relax
\makeatother

%---- A MODIFIED \verb, FITS BETTER OUR USE OF IT
\makeatletter
% le \verb de doc.sty est très chiant car il a retiré 
% \verbatim@font pour mettre un \ttfamily hard-coded
% à la place. 
% 
% Par ailleurs j'en ai marre des erreurs dues au fait que mes
% paragraphes reformatés dans emacs passent à la ligne au milieu
% d'un \verb. Je décide donc d'annuler l'effet du \dospecials sur les
% espaces dans la source. Et donc je retire le \verb@eol@error et
% il n'y a donc plus lieu d'un comportement différent pour
% l'impression des blancs, donné par la version étoilée.
% 
% Et il n'y avait donc pas de \obeylines puisque la fin de ligne
% devenait un message d'erreur dans \verb@eol@error 
%
% De plus je retire le \do@noligs qui me gêne plutôt qu'autre chose,
% surtout maintenant que les espaces ne sont pas des control spaces
% 
% attention au signe - par contre, on ne veut *pas* de ligatures avec lui
%
\def\noligminus {\kern \z@ \char`\-}
\begingroup\catcode`\-\active
\gdef\verb {\relax \ifmmode \hbox \else \leavevmode \null \fi
  \bgroup \verbatim@font
  \let \do \@makeother \dospecials \catcode`\-\active
  \let-\noligminus \catcode32 10 \@ifstar {\@sverb }{\@sverb }}
\endgroup
% ça c'est pour mes petits morceaux de code:
\def\verbatim@font {\ttfamily }
\def\MacroFont{\ttfamily\baselineskip12pt\relax}
% Mais j'ai besoin d'un verbatim différent pour les nombres car je
% ne veux pas passer en mode mathématique et je ne veux pas les 0
% du txtt pour cela. Comme je n'utilise pas de tabulation, je vais
% prendre & 
\catcode`\& 13
\def&{\begingroup\let\do\@makeother\dospecials\catcode`\& 13 \@jfverb }
\def\@jfverb #1&{#1\endgroup }
\makeatother

% Note: il n'y a plus de \hyphenchar-1 dans le \DeclareFontFamily de t1txtt
% ATTENTION CEPENDANT À CE QUI SE PASSE EN CAS DE CHANGEMENT DE TAILLE

\DeclareRobustCommand\csa[1]{{\ttfamily\hyphenchar\font45 \char`\\#1}}
\DeclareRobustCommand\csb[1]{\hyperref[#1]{\color{blue}\ttfamily
                                           \hyphenchar\font45 \char`\\#1}}
\DeclareRobustCommand\csbnolk[1]{{\color{blue}\ttfamily
                                  \hyphenchar\font45 \char`\\#1}}

\newcommand\csh[1]{\texorpdfstring{\csa{#1}}{\textbackslash #1}}
\newcommand\csbh[1]{\texorpdfstring{\csbnolk{#1}}{\textbackslash #1}}

\makeatletter
\@for\x:=xint,xintgcd,xintfrac,xintseries,xintcfrac\do
{\expandafter\edef\csname\x name\endcsname
   {\noexpand\texorpdfstring{{\noexpand\color{joli}\noexpand\ttfamily
                              \hyphenchar\font45  
                              \noexpand\bfseries \x}}
                            {\x}\noexpand\xspace}}
\makeatother

\frenchspacing
\renewcommand\familydefault\sfdefault

%---- WE WANT TO SEE ALL THOSE NUMBERS
\def\allowsplits #1%
{%
    \ifx #1\relax \else #1\hskip 0pt plus 1pt\relax
    \expandafter\allowsplits\fi
}%
\def\printnumber #1%
{\expandafter\expandafter\expandafter
    \allowsplits #1\relax }% Expands twice before printing.

\newcount\cnta
\newcount\cntb

\begin{document}
\thispagestyle{empty}
\rmfamily

\pdfbookmark[1]{Title page}{TOP}

{\normalfont\Large\parindent0pt \parfillskip 0pt\relax 
 \leftskip 2cm plus 1fil \rightskip 2cm plus 1fil
 The \xintname bundle: \xintname,
    \xintgcdname, \xintfracname, \xintseriesname and \xintcfracname.\par}%
{\centering
  \textsc{Jean-François B.}\par
  \footnotesize \ttfamily
  2589111+jfbu@users.noreply.github.com\\
  Package version: \pkgversion\ (\pkgdate)\\
  Documentation generated from the source file\\
  with timestamp ``\dtxtimestamp''\par
}

\begin{abstract}
  The \xintname package implements with expandable \TeX{} macros
  the basic arithmetic operations of addition, subtraction,
  multiplication and division, as applied to arbitrarily long
  numbers represented as chains of digits with an optional minus
  sign. The \xintgcdname package provides implementations of the
  Euclidean algorithm and of its typesetting. 

  The \xintfracname package extends the scope of \xintname to
  fractional numbers of arbitrary sizes ; \xintseriesname provides
  some basic functionality for computing in an expandable manner
  partial sums of series and power series with fractional
  coefficients. And \xintcfracname deals with the computation of
  continued fractions.

  The packages may be used with Plain and with \LaTeX. Most macros, and
  all of those doing computations, work purely by expansion without
  assignments, and may thus be used almost everywhere in \TeX{}.
\end{abstract}

\tableofcontents

\section{Raison d'\^etre of these packages}

The main goal is to allow computations with integers and fractions of arbitrary
sizes.\footnote{Here and elsewhere, ``arbitrarily big'' means roughly with
  numerators and denominators having strictly less than
  2\string^\string{31\string}=2147483648 digits. Memory constraints from the
  |etex| or |pdftex| executables presumably limit even more the possible
  computations, not to mention the time taken by them.} 

Here are some examples:

{\color{magenta}&123456^99&: }\\
{\color{blue}\csb{xintiPow}|{123456}{99}|}: \printnumber{\xintiPow {123456}{99}}

{\color{magenta}1234/56789 with 1500 digits after the decimal point: }\\
{\color{blue}\csb{xintTrunc}|{1500}{1234/56789}\dots|}: \printnumber {\xintTrunc
  {1500}{1234/56789}}\dots 

{\color{magenta}&0.99^{-100}& with 200 digits after the decimal point:}\\
{\color{blue}\csb{xintTrunc}|{200}{|\csb{xintPow}|{.99}{-100}}\dots|}:
\printnumber{\xintTrunc {200}{\xintPow {.99}{-100}}}\dots


{\color{magenta}Computation of a Bezout identity with  |7^200-3^200| and |2^200-1|:}\\
{\color{blue}|\xintAssign\xintBezout|\\
\hspace*{2cm}|{\xintiSub {\xintiPow
      {7}{200}}{\xintiPow{3}{200}}}|\\
\hspace*{2cm}|{\xintiSub {\xintiPow {2}{200}}{1}}\to\A\B\U\V\D|%
\centeredline{|\U$\times$(7^200-3^200)+\xintiOpp\V$\times$(2^200-1)=\D|}}%
\xintAssign\xintBezout {\xintiSub {\xintiPow
    {7}{200}}{\xintiPow{3}{200}}}
{\xintiSub {\xintiPow {2}{200}}{1}}\to\A\B\U\V\D
\printnumber\U$\times$(&7^200-3^200&)+\printnumber{\xintiOpp\V}$\times$(&2^200-1&)=\printnumber\D


The first example uses only the base module \xintname, the next two require
loading also the \xintfracname package, which deals with fractions. The last one
requires the \xintgcdname package. The bundle also comprises the \xintseriesname
package, for partial sums of series with fractional coefficients, and
\xintcfracname 
for continued fractions computations.

For some initially circumstantial reasons (related to the origins of the
package, which will be mentioned next) all macros performing computations are
compatible with an expansion-only context. This programming constraint of
expandability weighs in a lot on the computation time as the macros may have to
shuffle around data containing hundreds of tokens: our current implementation
of addition doesn't even achieve linear computation time! 

For addition, I try to optimize things for the 50-500 digits range. I have a
variant of addition which is twice faster on numbers with 1000 digits, but it is
slower than the original for numbers with less than 200 digits, and adding to
the code a fork to choose what to do would mean overhead; besides it wouldn't be
that easy to use this variant of addition in the other routines such as
multiplication and division. And multiplication is anyhow too slow on numbers
with 1000 digits, even dividing the time by two would not be enough.

Analogously to the not even linear addition, multiplication is worse than
quadratic. Same causes, same effects. It is about cubic in the 100-1000
digits range: on my laptop, with release |1.04| of the bundle, squaring a
randomly chosen number with 200 digits takes about 4 hundredths of a 
second, and squaring a 400 digits number about a quarter of a second. But
squaring a 500 digits number is about 1.9 times as costly as one with 400
digits, and squaring a 1000 digits number is 8 times more expensive than for a
500 digits number (about 3.5 seconds). Implementation of a Gauss-Karatsuba
scheme for intelligent multiplication has not been attempted so far. This kind
of thing is motivating when one has instant memory access!

As clearly demonstrated long ago by the
\href{http://www.ctan.org/pkg/pi}{\color{niceone}pi computing file} by
\textsc{D. Roegel} one can program \TeX{} to compute with many digits at a
much higher speed than what \xintname achieves: but, direct access to memory
storage in one form or another seems a necessity for this kind of speed
and one has to renounce at the
complete expandability.\footnote{I could, naturally,
  be proven wrong!}\,\footnote{The Lua\TeX{} project possibly makes endeavours
  such as \xintname appear even more insane that they are, in truth.}

Currently \xintname does not provide `floating-point' operations. The
\LaTeX3 project has implemented expandably floating-point computations
with 16 significant digits
(\href{http://www.ctan.org/tex-archive/macros/latex/contrib/l3kernel}{\color{niceone}l3fp}), including
special functions such as exp, log, sine and cosine.

The most blatantly lacking thing in \xintname so far is a decent input parser,
allowing to type in computations in a usual infix form such as, for example
|3*14+2.7^-2*5|. At this time, one has to type |\xintAdd {\xintMul
  {3}{14}}{\xintMul{\xintPow{2.7}{-2}}{5}}|. Previous computation results can be
stored in macros and given as arguments to the package macros (see further on
for important aspects of this).

Package |bigintcalc| by \textsc{Heiko Oberdiek} already
provides expandable arithmetic operations on ``big integers'',
exceeding the \TeX{} limits (of &2^{31}-1&), so why another
one? \footnote{this section was written before the 
  \xintfracname package; the author is not aware of another package allowing
  expandable computations with arbitrarily big fractions.}


I got started on this in early March 2013, via a thread on the
|c.t.tex| usenet group, where \textsc{Ulrich D\,i\,e\,z} used the
previously cited package together with a macro (|\ReverseOrder|)
which I had contributed to another thread.\footnote{the
  \csa{ReverseOrder} could be avoided in that circumstance, but it
  does play a crucial r\^ole here.} What I had learned in this
other thread thanks to interaction with \textsc{Ulrich D\,i\,e\,z} and
\textsc{GL} on expandable manipulations of tokens motivated me to
try my hands at addition and multiplication.

I wrote macros \csa{bigMul} and \csa{bigAdd} which I posted to the
newsgroup; they appeared to work comparatively fast. These first
versions did not use the \eTeX{} \csa{numexpr} macro, they worked
one digit at a time, having previously stored carry-arithmetic in
1200 macros.

I noticed that the |bigintcalc| package used the \csa{numexpr}
\eTeX{} primitive when available, but (as far as I could tell) not
to do computations many digits at a time. Using \csa{numexpr} for
one digit at a time for \csa{bigAdd} and \csa{bigMul} slowed them
a tiny bit but avoided cluttering \TeX{} memory with the 1200
macros storing pre-computed digit arithmetic. I wondered if some speed
could be gained by using \csa{numexpr} to do four digits at a time
for elementary multiplications (as the maximal admissible number
for \csa{numexpr} has ten digits).

The present package is the result of this initial questioning. 

\begin{framed}\centering
  \xintname requires the \eTeX{} \csa{numexpr} primitive.
\end{framed}


To see \xintname in action, jump to the
{\color{niceone}\autoref{sec:series}} describing the commands of the
\xintseriesname{} package, especially as illustrated with the
\hyperref[ssec:Machin]{\color{niceone}{traditional computations of $\pi$
    and $\log 2$}}, or also see the
{\color{niceone}\hyperlink{e-convergents}{computation of the convergents
    of $e$}} made with the \xintcfracname package. Note that almost all
of the computational results interspersed through the documentation are
not hard-coded in the source of the document but just written there
using the package macros, and were selected to not impact too much the
compilation time.

\section{Expansions}

Except for some specific macros dealing with assignments or typesetting, the
bundle macros all work in expansion-only context. For example, with the
following code snippet within |myfile.tex|:
\begin{verbatim}
\newwrite\outfile
\immediate\openout\outfile \jobname-out\relax
\immediate\write\outfile {\xintQuo{\xintPow{2}{1000}}{\xintFac{100}}}
% \immediate\closeout\outfile
\end{verbatim}
the tex run creates a file |myfile-out.tex|
containing the decimal representation of the integer quotient &2^{1000}/100!&.
Such macros can also be used inside a |\csname...\endcsname|, and
of course in an |\edef|.

\edef\x{\xintQuo{\xintPow {2}{1000}}{\xintFac{100}}}
\edef\y{\xintLen{\x}}

Furthermore the package macros give their final results in two
expansion steps. They twice expand their arguments so that they
can be arbitrarily chained. Hence \centeredline{%
  |\xintLen{\xintQuo{\xintPow{2}{1000}}{\xintFac{100}}}|} expands
in two steps and tells us that &[2^{1000}/100!]& has {\y}
digits. This is not so many, let us print them here:
\printnumber\x. 

For the sake of typesetting this documentation and not have big numbers
extend into the margin and go beyond the page physical limits, I use
these commands (not provided by the package):
\begin{verbatim}
\def\allowsplits #1{\ifx #1\relax \else #1\hskip 0pt plus 1pt \relax
                     \expandafter\allowsplits\fi}%
\def\printnumber #1{\expandafter\expandafter\expandafter
                    \allowsplits #1\relax }% 
% Expands twice before printing.
\end{verbatim}

The |\printnumber| macro is not part of the package and would need
additional thinking for more general use. It may be used as
|\printnumber {\xintQuo{\xintPow {2}{1000}}{\xintFac{100}}}|, or
as |\printnumber\mynumber| if the macro |\mynumber| was previously
defined via |\edef\mynumber {\|\texttt{xintQuo}|{\xintPow
    {2}{1000}}{\xintFac{100}}}|. A |\newcommand| or |\def| for the
definition of |\mynumber| would not do for the reason which is
explained in \autoref{item:xpxp} below (it would if we had inserted
seven, and not only three |\expandafter|'s in the definition of |\printnumber|).

Just to show off, let's print 300 digits (after the decimal point) of
the decimal expansion of &0.7^{-25}&:
\centeredline{|\printnumber {\xintTrunc {300}{\xintPow{.7}{-25}}}\dots|}
\printnumber {\xintTrunc {300}{\xintPow{.7}{-25}}}\dots

This computation uses \xintfracname wich extends to fractions the basic
arithmetic operations defined for integers by \xintname. 


Important points, to be noted, related to the double expansion of arguments:
\begin{enumerate}
\item When I say that the macros expand twice their arguments,
  this means that they expand the first token seen (for each
  argument), then expand again the first token of the result of
  the first expansion. For example
  \centeredline{|\def\x{12}\def\y{34}|%
    |\xintAdd {\x}{\x\y}|} is \emph{not} a legal construct. It works here
  by sheer luck as the |\y| gets expanded inside a |\numexpr|. But
  this would fail in general: if you need a more complete
  (expandable...) expansion of your initial input, you should use
  the \fbox{\csa{bigintcalcNum}} macro from the |bigintcalc|
  package. Or, outside of an expandable-only context, just massage
  your inputs through \csa{edef}'s.

\item Unfortunately, after |\def\x {12}|, one can not use just
  {\color{blue}|-\x|} as input to one of the package macros: the rules above
  explain that the twice expansion will act only on the minus sign,
  hence do nothing. The only way is to use the \csb{xintOpp}
  macro, which replaces a number with its opposite.

\def\x {12}%
\item \label{item:xpxp} With the definition \centeredline{%
    |\def\AplusBC #1#2#3{\xintAdd {#1}{\xintMul {#2}{#3}}}|} one
  obtains an expandable macro producing the expected result, not
  in two, but rather in three steps: a first expansion is consumed
  by the macro expanding to its definition. As a result {|\xintAdd
    {\AplusBC {1}{2}{3}}{4}|} would then miserably fail. The
  solution is to use the \emph{lowercase} form of 
  \csa{xintAdd}: \smallskip\centeredline {|\def\AplusBC
    #1#2#3{|{\color{blue}|\romannumeral0\xintadd |}|{#1}{\xintMul {#2}{#3}}}|}
  
  and then \csa{AplusBC} will share the same properties as do the
  other \xintname `primitive' macros.
% ENFIN DÉBARRASSÉ DES TRÈS TRÈS TRÈS CHIANTS EOL ERROR DE \verb !!!

The lowercase form is \emph{only} for the external highest level of
chained commands. All \xintname provided public macros have such a
lowercase form precisely to facilitate building-up higher level macros
based on them. To more fully imitate the \xintname standard habits, the
example above should thus be treated via the creation of two
macros:\par\parskip0pt \hspace*{1cm}|\def\aplusbc #1#2#3{\xintadd
  {#1}{\xintMul {#2}{#3}}}|\par
\hspace*{1cm}|\def\AplusBC {\romannumeral0\aplusbc}|\par
This then allows further definitions, such as:\par
\hspace*{1cm}|\def\aplusbcsquared #1#2#3{\aplusbc {#1}{#2}{\xintSqr{#3}}}|\par
\hspace*{1cm}|\def\AplusBCSquared {\romannumeral0\aplusbcsquared}|\par
\end{enumerate}


\section {Inputs and outputs}

\begin{framed}
  \TeX{}'s count registers cannot be directly used but must be
  prefixed by |\the| or |\number|. The same for \csa{numexpr}
  expressions.
\end{framed}

The arguments to most of the bundle macros are of three types:
\begin{enumerate}
\item `short' integers, \emph{i.e.} less in absolute value than
  \xintiSub{\xintiPow {2}{31}}1. I will refer to this as the `\TeX{}' or
  `|\numexpr|' limit. This is case for the exponent in the power function. In
  that specific case the limit is (if the number raised to this power is not 0
  or 1) even lowered to 999999999. The factorial function (since release |1.05|)
  refuses input larger than 999999. When these conditions are not met, the error
  may be signaled from a \csa{numexpr} expression rather than from a package
  macro.
\item `long' integers, which are the bread and butter of the package macros.
  They are signed integers with a number of
  digits less than the \TeX-\csa{numexpr} bound. Concretely though, multiplying
  two 1000 digits numbers is already a longish operation.
\item `gigantic' integers, with no limit on size whatsoever. Probably, they are
  made impossible by memory constraints of the \TeX{} implementations.
  Theoretically, the addition, but not the multiplication nor the division,
  could treat even such gigantic numbers. With the \xintfracname package loaded
  though, they are not accepted, even for addition.
\item fractions: they should be the ratio of two long integers. The macro
  \csa{xintLen} returns the sum of their lengths, and this sum should then obey
  the \TeX-\csa{numexpr} bound.
\end{enumerate}

\edef\z {\xintAdd
    {+--0367.8920280/-++278.289287}{-109.2882/+270.12898}}

The package macros first operate a double expansion of their arguments. They
expect these expansions to deliver numbers obeying two types of format:
\begin{enumerate}
\item the strict format is when \xintfracname is not loaded. The number should
  be a string of digits, optionally preceded by a unique minus sign. The first
  digit can be zero only if the number is zero. A plus sign is not accepted.
  There is a macro \csb{xintNum} which normalizes to this form an input having
  arbitrarily many minus and plus signs, followed by a string of zeros, then
  digits:\centeredline{|\xintNum
  {+-+-+----++-++----00000000009876543210}|\texttt{=\xintNum
    {+-+-+----++-++----0000000009876543210}}}%
  Note that |-0| is not legal input and will confuse \xintname (but not
  \csa{xintNum} which even accepts an  empty input).
\item the relaxed format is when \xintfracname is loaded. Most macros are then
  modified to accept inputs of the form |A/B| (or just |A|), where |A| and |B|
  will be automatically given to the normalizing \csb{xintNum} macro.
  Additionally, each of |A| and |B| may have an optional decimal point with
  digits following it.   Here is an example: \centeredline{|\xintAdd
    {+--0367.8920280/-++278.289287}{-109.2882/+270.12898}|}%
  Incidentally this evaluates to 
  \centeredline{{=\z}}%
  \centeredline{{=\xintIrr\z{} (irreducible)}}%
  \centeredline{{=\xintTrunc {50}{\z}\dots}}%
  where the second line was produced with |\xintIrr| and the next with
  |\xintTrunc {50}| to get fifty digits of the decimal expansion following the
  decimal mark.
\end{enumerate}
Of course, even when \xintfracname is loaded, some macros can not treat
fractions on input. With release |1.05| they have, for the most part, been also
extended to accept the relaxed format as long as the denominator turns out to be
a divisor of the numerator (once the decimal points are suitably transformed
into powers of ten). For example it used to be the case with the earlier
releases that |\xintQuo {100/2}{12/3}| would not work (the macro \csb{xintQuo}
computes a euclidean quotient). It now does, because its arguments are in truth
integers.

A number can start directly with a decimal point:
  \centeredline{|\xintPow{-.3/.7}{11}=|{\xintPow{-.3/+.7}{11}}}% 
It is
  also licit to use |\A/\B| as input if each of |\A| and |\B| expands in
  at most two steps to a ``decimal number'' as examplified above by the
  numerators and denominators. Or one may have just one macro |\C| which
  expands to such a ``fraction with optional decimal points'', or mixed
  things such as |\A 245/7.77|, where the numerator will be the
  concatenation of the expansion of |\A| and |245|. But, as explained
  already |123\A| is a no-go.


Loading \xintfracname not only relaxes the format of the inputs; it also
modifies the format of the outputs: except when filtered through the
\csb{xintIrr} macro, a fraction is always output in the |A/B[n]| form (which
stands for &(A/B)10^n&; some macros print |A[n]| when the
denominator is one). The |A| and |B| may end in zeros (\emph{i.e}, |n| does
not represent all powers of ten), and will generally have a common factor. The
denominator |B| is always strictly positive. 

Direct user input of things such as |16000/289072[17]| or |3[-4]| is authorized.
It is even possible to use |\A/\B[17]| if |\A| expands to |16000| and |\B| to
|289072|, or |\A| if |\A| expands to |3[-4]|. However, NEITHER the numerator NOR
the denominator\strut{} may then have a decimal
point.\vadjust{\vskip-\dp\strutbox
  \hbox{\smash{\color{niceone}\llap{\strut\small IMPORTANT!\ $\Bigg\{$\
      }}}\vskip\dp\strutbox } And, for this format, ONLY the numerator may carry
a UNIQUE minus sign (and no superfluous leading zeros; and NO plus sign).

  The, more demanding, format with a power of ten represented by a number within
  square brackets is the output format used by (almost all) \xintfracname
  macros dealing with fractions.
  It is allowed for user input but the parsing is minimal and it
  is very important to follow the above rules. This reduced
  flexibility, compared to the format without the square brackets,
  allows chaining package macros without too much speed impact, as
  they always output computation results in the |A/B[n]| form (or
  |A[n]|). 

  All computations done by \xintfracname on fractions are exact. Inputs
  containing decimal points do not make the package switch to a
  (currently non-existent) `floating-point' mode. The inputs, however
  long, are always converted into an exact internal representation.


Generally speaking, there should be no spaces among the digits in the inputs.
Although most would be harmless in most macros, there are some cases
where spaces could break havoc. So the best is to avoid them entirely.

\edef\z {\xintSub {\xintMul {2.3}{\xintPow {5.6}{3}}}  {17728/189.5}}

It would certainly be nice to be able to input directly expressions such as
|2.3*5.6^3-17728/189.5|, but this is not possible. One must use, for
example:
 \centeredline{|\xintSub {\xintMul {2.3}{\xintPow
    {5.6}{3}}}  {17728/189.5}|} or, an option in this case is:
\centeredline{|\xintAdd {\xintPrd {{2.3}{5.6}{5.6}{5.6}}}{-17728/189.5}|}%
%\centeredline{\texttt{=\z =\xintIrr\z =\xintTrunc {15}\z\dots}}

Syntax such as |\xintMul\A\B|
is accepted and equivalent\footnote{see however near the end of
  \hyperref[sec:outputs]{\color{niceone}this later section} for the important
  difference when used in contexts where \TeX{} expects a number, such as
  following an \csa{ifcase} or an \csa{ifnum}.} to |\xintMul {\A}{\B}|. Or
course |\xintAdd\xintMul\A\B\C| does not work, the product operation must be put
within braces: |\xintAdd{\xintMul\A\B}\C|.
It would be nice to have a functional form |\add(x,\mul(y,z))| but
this is not provided by the package. Arguments must be either
within braces or a single control sequence.

Note that |-| and |+| may serve only as unary operators, on \emph{explicit}
numbers. They can not serve to prefix macros evaluating to such numbers.

\section{More on fractions}

With package \xintfracname loaded, the routines \csb{xintAdd}, \csb{xintSub},
\csb{xintMul}, \csb{xintPow}, \csb{xintSum}, \csb{xintPrd} are modified to allow
fractions on input,\footnote{of course, the power function does not accept a
  fractional exponent. Or rather, does not expect, and errors will result if one
  is provided.}\,\footnote{macros \csb{xintiAdd}, \csb{xintiSub},
  \csb{xintiMul}, \csb{xintiPow}, \csb{xintiSum}, \csb{xintiPrd} are the
  original ones dealing only with integers. They are available as synonyms, also
  when \xintfracname is not loaded. }\,\footnote{also \csb{xintCmp},
  \csb{xintSgn}, \csb{xintOpp}, \csb{xintAbs}, \csb{xintMax}, \csb{xintMin} are
  extended to fractions and have their integer-only initial
  synonyms.}\,\footnote{and \csb{xintQuo}, \csb{xintRem}, \csb{xintDivision},
  \csb{xintGeq}, \csb{xintFDg}, \csb{xintLDg}, \csb{xintOdd}, \csb{xintMON},
  \csb{xintMMON} all accept a fractional input as long as it reduces to an
  integer. Note that \csb{xintGeq} still only works on (non-negative) integers,
  to compare fractions one must use \csb{xintCmp}.} and always produce on output
a fractional number |f=A/B[n]| where |A| and |B| are integers, with |B|
positive, and |n| is a signed ``small'' integer (\emph{i.e} less in absolute
value than |2^{31}-9|). This represents |(A/B)| times |10^n|. The fraction |f|
may be, and generally is, reducible, and |A| and |B| may well end up with zeros
(\emph{i.e.} |n| does not contain all powers of 10). Conversely, this format is
accepted on input (and is parsed more quickly than fractions containing decimal
points).\footnote{at each stage of the computations, the sum of |n| and the
  length of |A|, or of the absolute value of |n| and the length of |B|, must be
  kept less than |2\string^\string{31\string}-9|.}

The \csb{xintiAdd}, \csb{xintiSub}, \csb{xintiMul}, \csb{xintiPow},
\csb{xintiSum}, \csb{xintiPrd}, etc... are the original un-modified integer-only
versions. They have less parsing overhead.



The macro \csb{xintRaw} prints the fraction in |A/B| form, with the trailing
|[n]| converted into explicit zeros either at the numerator or the denominator.
The |B| is printed even if it has value |1|. 

Conversely (sort of), the macro \csb{xintREZ}
 puts all powers of ten into the |[n]| (REZ stands for remove zeros).
Here also, the |B| is printed even if it has value |1|.

The macro \csb{xintIrr} reduces the fraction to its irreducible form
|C/D| (thus, without a trailing |[0]|), and it prints only the |C| if
|D=1|. The macro \csb{xintNum} from \xintname is extended to act like
\csb{xintIrr} but additionally raises an error when the fraction
doesn't simplify to an integer. When one knows that necessarily the
result of a computation is an integer, and one wants to get rid of the
denominator and trailing |[n]|, one can thus use \csb{xintIrr} or
\csb{xintNum} (if the fraction has internally a denominator equal to 1,
this is quickly identified, there is little overhead; else, the
denominator will be discovered in the next step to be a divisor of the
numerator).


The macro \csb{xintTrunc}|{N}{f}| prints\footnote{`prints' does not at all mean
  that this macro is designed for typesetting; I am just using the verb here in
  analogy to the effect of the functioning of a computing software in console
  mode. The package does not provide any `printing' facility, besides its
  rudimentary \csb{xintFrac} and \csb{xintFwOver} math-mode only macros. To deal
  with really long numbers, some macros are necessary as \TeX{} by default will
  print a long number on a single line extending beyond the page limits. The
  \csa{printnumber} command used in this documentation is just one way to
  address this problem, some other method should be used if it is important that
  digits occupy the same width always.} the decimal expansion of |f| with |N|
digits after the decimal point.\footnote{the current release does not provide a
  macro to get the period of the decimal expansion.} Currently, it does not
verify that |N| is non-negative and strange things could happen with a negative
|N|. Of course a negative |f| is no problem, needless to say. When the original
fraction is negative and its truncation has only zeros, it is printed as
|-0.0...0|, with |N| zeros following the decimal point:
\centeredline{|\xintTrunc {5}{\xintPow {-13}{-9}}=|\texttt{\xintTrunc
    {5}{\xintPow {-13}{-9}}}}%
\centeredline{|\xintTrunc {20}{\xintPow {-13}{-9}}=|\texttt{\xintTrunc
    {20}{\xintPow {-13}{-9}}}} The output always contains a decimal point (even
for |N=0|) followed by |N| digits, except when the original fraction was zero.
In that case the output is |0|, with no decimal point. \centeredline{|\xintTrunc
  {10}{\xintSum {{1/2}{1/3}{1/5}{-31/30}}}=|%
  \texttt{\xintTrunc {10}{\xintSum {{1/2}{1/3}{1/5}{-31/30}}}}}

The output of \csb{xintTrunc} may of course serve as input to the other
macros. And this is almost necessary when summing hundreds of
terms of a series with fractional coefficients, as the exact
rational number quickly becomes quite big (when doing the sum from
|n=|1 to |n=|1000 of |1/n|, the raw denominator is &1000!&, which
has 2568 digits) ; but for less than fifty terms with small
denominators it is often possible to work with the exact
value without too much toll on the compilation time. 

The macro \csb{xintiTrunc}|{N}{f}| is like \csa{xintTrunc}|{N}{f}|
followed by multiplication by |10^N|. Thus, it outputs an integer
in a format acceptable by the integer-only macros. This is also
convenient when computing partial sums of series, with a fixed number of
digits after the decimal point: it is a bit
faster to sum with \csb{xintiSeries} the integers produced by
\csa{xintiTrunc}|{N}| than it is to use the general
\csb{xintSeries} on the decimal numbers produced by
\csa{xintTrunc}|{N}|. These latter macros belong to the \xintseriesname
package.

Needless to say when using \csa{xintTrunc} or \csa{xintiTrunc} on
intermediate computations the ending digits of the final result
are, pending further analysis, only indications of those of the
fraction an exact computation would have produced.

\edef\z {\xintPow {1.01}{100}}

To get the integer part of the decimal expansion of |f|, use
|\xintiTrunc{0}{f}|: \centeredline{|\xintiTrunc {0}{\xintPow
    {1.01}{100}}=|\texttt{\xintiTrunc {0}\z}}%
% \centeredline{|(\xintTrunc {30}{\xintPow
%     {1.01}{100}}=|\texttt{\xintTrunc {30}\z)}}
\centeredline{|\xintiTrunc {0}{\xintPow{0.123}{-10}}=|\texttt{\xintiTrunc
    {0}{\xintPow{0.123}{-10}}}}

\section{\csh{ifcase}, \csh{ifnum}, ... constructs}

When using things such as |\ifcase \xintSgn{\A}| one has to leave
a space after the closing brace for \TeX{} to
stop its scanning for a number: once \TeX{} has finished expanding
|\xintSgn{\A}| and has so far obtained either |1|, |0|, or |-1|, a
space (or something `unexpandable') must stop it looking for more
digits. Using |\ifcase\xintSgn\A| without the braces is very dangerous,
because the blanks (including the end of line) following |\A| will be
skipped and not serve to stop the number which |\ifcase| is looking for.
With |\def\A{1}|:
\begin{verbatim}
\ifcase \xintSgn\A   0\or OK\else ERROR\fi   ---> gives ERROR
\ifcase \xintSgn{\A} 0\or OK\else ERROR\fi   ---> gives OK
\end{verbatim}
% \def\A{1}
% \ifcase \xintSgn\A   0\or OK\else ERROR\fi\ 
% \ifcase \xintSgn{\A} 0\or OK\else ERROR\fi

\section{Multiple outputs}\label{sec:outputs}

Some macros have an output consisting of more than one number, each one is then
within braces. Examples of multiple-output macros are \csb{xintDivision} which
gives first the quotient and then the remainder of euclidean division,
\csb{xintBezout} from the \xintgcdname package which outputs five numbers,
\csb{xintFtoCv} from the \xintcfracname package which returns the list of the
convergents of a fraction, ... see the next section for ways to deal with such
outputs.

See the \autoref{xintDecSplit} for a rare example of a bundle macro which may
return an empty string, or a number prefixed by a chain of zeros. This is the
only situation where a macro from the package \xintname may output something
which could require parsing through \csa{xintNum} before further processing by
the other (integer-only) package macros from \xintname.


\section{Assignments}

\xintAssign\xintBezout{357}{323}\to\tmpA\tmpB\tmpU\tmpV\tmpD

It might not be necessary to maintain at all times complete
expandability. For example why not allow oneself the two definitions
|\edef\A {\xintQuo{100}{3}}| and |\edef\B {\xintRem {100}{3}}|. A special
  syntax is provided to make these things more efficient, as the package
  provides 
 \csa{xintDivision} which computes both quotient and
  remainder at the same time:
  \centeredline{\csb{xintAssign}\csa{xintDivision}|{100}{3}|\csbnolk{to}|\A\B|}
  \centeredline{\csb{xintAssign}\csa{xintDivision}%
|{\xintiPow {2}{1000}}{\xintFac{100}}|\csbnolk{to}|\A\B|} gives
\xintAssign\xintDivision{\xintiPow {2}{1000}}{\xintFac{100}}\to\A\B
|\meaning\A|\texttt{: \expandafter\allowsplits\meaning\A\relax} and
|\meaning\B|\texttt{: \expandafter\allowsplits\meaning\B\relax}. 


  Another example (which uses a macro from the \xintgcdname
  package):
  \centeredline{\csb{xintAssign}\csa{xintBezout}|{357}{323}|%
    \csbnolk{to}|\A\B\U\V\D|} is equivalent to setting |\A| to
  \texttt{\tmpA}, |\B| to \texttt{\tmpB}, |\U| to \texttt{\tmpU},
  |\V| to \texttt{\tmpV}, and |\D| to \texttt{\tmpD}. And indeed
  (\tmpU)$\times$\tmpA-(\tmpV)$\times$\tmpB=
   \xintiSub{\xintiMul\tmpU\tmpA}{\xintiMul\tmpV\tmpB}
  is a Bezout Identity.

  \xintAssign\xintBezout{3570902836026}{200467139463}\to\tmpA\tmpB\tmpU\tmpV\tmpD
  \centeredline{\csb{xintAssign}\csa{xintBezout}|{3570902836026}{200467139463}|%
    \csbnolk{to}|\A\B\U\V\D|} gives then |\U|\texttt{:
    \expandafter\allowsplits\meaning\tmpU\relax}, |\V|\texttt{:
    \expandafter\allowsplits\meaning\tmpV\relax} and |\D=|\texttt{\tmpD}.

  When one does not know in advance the number of tokens, one can
  use \csa{xintAssignArray} or its synonym \csa{xintDigitsOf}:
  \centeredline{\csb{xintDigitsOf}\csa{xintiPow}|{2}{100}|\csbnolk{to}\csa{Out}}
  This defines \csa{Out} to be macro with one parameter,
  \csa{Out}|{0}| gives the size |N| of the array and
  \csa{Out}|{n}|, for |n| from |1| to |N| then gives the |n|th
  element of the array, here the |n|th digit of &2^{100}&, from
  the most significant to the least significant. As usual, the
  generated macro \csa{Out} is completely expandable and expands twice its
  (unique) argument. Consider the following code snippet:
\begin{verbatim}
\newcount\cnta
\newcount\cntb
\begingroup
\xintDigitsOf\xintiPow{2}{100}\to\Out
\cnta = 1
\cntb = 0
\loop
\advance \cntb \xintiSqr{\Out{\the\cnta}}
\ifnum \cnta < \Out{0}
\advance\cnta 1
\repeat

|2^{100}| (=\xintiPow {2}{100}) has \Out{0} digits and the sum of
their squares is \the\cntb. These digits are, from the least to
the most significant: \cnta = \Out{0} 
\loop \Out{\the\cnta}\ifnum \cnta > 1 \advance\cnta -1 , \repeat.
\endgroup
\end{verbatim}

\edef\z{\xintiPow {2}{100}}

\begingroup
\xintDigitsOf\z\to\Out
\cnta = 1
\cntb = 0
\loop
\advance \cntb \xintiSqr{\Out{\the\cnta}}
\ifnum \cnta < \Out{0}
\advance\cnta 1
\repeat

&2^{100}& (=\z) has \Out{0} digits and the sum of
their squares is \the\cntb. These digits are, from the least to
the most significant: \cnta = \Out{0} 
\loop \Out{\the\cnta}\ifnum \cnta > 1 \advance\cnta -1 , \repeat.
\endgroup

We used a group in order to release the memory taken by the
\csa{Out} array: indeed internally, besides \csa{Out} itself,
additional macros are defined which are \csa{Out0}, \csa{Out00},
\csa{Out1}, \csa{Out2}, ..., \csa{OutN}, where |N| is the size of
the array (which is the value returned by |\Out{0}|; the digits
are parts of the names not arguments). 

The command \csb{xintRelaxArray}\csa{Out} sets all these macros to
\csa{relax}, but it was simpler to put everything withing a group.

Needless to say \csb{xintAssign}, \csb{xintAssignArray} and
\csb{xintDigitsOf} do not do any check on whether the macros they
define are already defined.

In the example above, we deliberately broke all rules of complete
expandability, but had we wanted to compute the sum of the digits,
not the sum of the squares, we could just have written:
\centeredline{\csb{xintiSum}|{\xintiPow{2}{100}}=|\texttt{%
    \xintiSum\z}} Indeed, \csa{xintiSum} is usually
used as in \centeredline{%
  \csb{xintiSum}|{{123}{-345}{\xintFac{7}}{\xintiOpp{\xintRem{3347}{591}}}}=|\texttt{%
    \xintiSum{{123}{-345}{\xintFac{7}}{\xintiOpp{\xintRem{3347}{591}}}}}}
but in the example above each digit of &2^{100}& is treated as
would have been a summand enclosed within braces, due to the rules
of \TeX{} for parsing macro arguments.

Note that |{-\xintRem{3347}{591}}| is not a valid input, because
the double expansion will apply only to the minus sign and leave
unaffected the |\xintRem|. So we used \csa{xint}\-|iOpp| which replaces
a number with its opposite.

\def\justone #1{1}%

Release |1.04| of \xintname has more macros returning lists of things (each one
within group braces, or a single token) such as the convergents of a continued
fraction. The two new expandable commands \csb{xintApply} and
\csb{xintListWithSep} help manipulate and display such lists without having to
go through the un-expandable \csb{xintAssignArray}.
\begin{verbatim}
\newcommand{\justone}[1]{1}%
|2^{100}| (=\xintiPow {2}{100}) has 
\xintiSum{\xintApply {\justone}{\xintiPow {2}{100}}}
digits and the sum of their squares is 
\xintiSum{\xintApply {\xintiSqr}{\xintiPow {2}{100}}}. 
These digits are, from the least to the most significant: 
\xintListWithSep {, }{\xintRev{\xintiPow {2}{100}}}.
\end{verbatim}
|2^{100}| (=\z) has \xintiSum{\xintApply\justone\z} digits and the sum of
their squares is \xintiSum{\xintApply\xintiSqr\z}. These digits are, from the
least to the most significant: \xintListWithSep {, }{\xintRev\z}. 

Of course, one could spare the CPU some repetitions with an earlier 
|\edef\z{\xintiPow {2}{100}}|, and using |\z| in place of 
  |\xintiPow {2}{100}| everywhere in the above.

As a last example with \csa{xintAssignArray} here is one line
extracted from the source code of the \xintgcdname macro
\csb{xintTypesetEuclideAlgorithm}:
\centeredline{|\xintAssignArray\xintEuclideAlgorithm
  {#1}{#2}\to\U|}
This is done inside a group. After this command |\U{1}| contains
the number |N| of steps of the algorithm (not to be confused with
|\U{0}=2N+4| which is the number of elements in the |\U| array),
and the GCD is to be found in |\U{3}|, a convenient location
between |\U{2}| and |\U{4}| which are (absolute values of the
twice expansion of) the
initial inputs. Then follow |N| quotients and remainders
from the first to the last step of the algorithm. The
\csa{xintTypesetEuclideAlgorithm} macro organizes this data
for typesetting: this is just an example of one way to do it. 


%% As an example: \xintTypesetEuclideAlgorithm {2362001530033}{981106461701}

\section{Exceptions (error messages)}

In situations such as division by zero, the package will insert in the
\TeX{} processing an undefined control sequence (we copy this method
from the |bigintcalc| package). This will trigger the writing to the log
of a message signaling an undefined control sequence. The name of the
control sequence is the message. The error is raised \emph{before} the
end of the expansion so as to not disturb further processing of the
token stream, after completion of the operation. Generally the problematic
operation will output a zero. Possible such error message control
sequences:
\begin{verbatim}
\xintError:ArrayIndexIsNegative
\xintError:ArrayIndexBeyondLimit
\xintError:FactorialOfNegativeNumber
\xintError:FactorialOfTooBigNumber
\xintError:DivisionByZero
\xintError:NaN
\xintError:FractionRoundedToZero
\xintError:NotAnInteger
\xintError:ExponentTooBig
\xintError:TooBigDecimalShift
\xintError:TooBigDecimalSplit
\xintError:NoBezoutForZeros
\end{verbatim}

\section{Common input errors when using the package macros}

Here is a list of  common input errors. Some will cause compilation errors,
others are more annoying as they may pass through unsignaled.
\begin{itemize}
\item using |-| to prefix some macro: |-\xintiSqr{35}/271|.
\item using one pair of braces too many |\xintIrr{{\xintiPow {3}{13}}/243}| (the
  computation goes through with no error signaled, but the result is completely
  wrong). 
\item using |[]| and decimal points at the same time |1.5/3.5[2]|.
\item using |[]| with a sign in the denominator |3/-5[7]|.
\item defining macros which do not expand in only two steps and then use them as
  arguments: |\def\x #1{\xintMON {#1}}|, |\xintAdd {\x{3}}{\x{2}}|.
\item making a mistake in a macro name |\xintProduct {{2}{3}{4}}|. Well I should
  |\let| it to be |\xintPrd|... at least such errors are not dangerous because
  they do provoke compilation errors.
\item loading \xintfracname and using expressions previously producing integers
  as numerators
  or denominators: |\edef\x{\xintMul {3}{5}/\xintMul{7}{9}}|. The problem is
  that this expands to |15[0]/63[0]| which is invalid on input. Using this
  |\x| in a fraction macro will most certainly cause a compilation error, with
  its usual arcane and undecipherable accompanying message. 
\end{itemize}


\section{Package namespace}

Inner macros of \xintname, \xintgcdname, \xintfracname, \xintseriesname,
and \xintcfracname{} all begin either with |\XINT@| or with |\xint@|. The
package public commands all start with |\xint|. The major forms have
their initials capitalized, and lowercase forms, prefixed with
|\romannumeral0|, allow definitions of further macros expanding in two
steps to their full expansion (and can thus be chained with the
`primitive' \xintname macros). Some other control sequence names are
used only as delimiters, and left undefined.

% The |\xintReverseOrder|\marg{tokens} macro uses |\xint@UNDEF| and
% |\xint@undef| as dummy tokens and can be used on arbitrary token
% strings not containing these control sequence names. Anything
% within braces is treated as one unit: one level of exterior braces
% is removed and the contents are not reverted.


\section{Loading and usage}

\begin{verbatim}
Usage with LaTeX: \usepackage{xint}
                  \usepackage{xintgcd}    % (loads xint)
                  \usepackage{xintfrac}   % (loads xint)
                  \usepackage{xintseries} % (loads xintfrac)
                  \usepackage{xintcfrac}  % (loads xintfrac)

Usage with TeX:   \input xint.sty\relax   
                  \input xintgcd.sty\relax    % (loads xint)
                  \input xintfrac.sty\relax   % (loads xint)
                  \input xintseries.sty\relax % (loads xintfrac)
                  \input xintcfrac.sty\relax  % (loads xintfrac)
\end{verbatim}

We have added, directly copied from packages by \textsc{Heiko
 Oberdiek}, a mecanism of re-load and \eTeX{} detection,
especially for Plain \TeX{}. As \eTeX{} is required, the
executable |tex| can not be used, |etex| or |pdftex| (version
|1.40| or later) or ..., must
be invoked.

Furthermore, the packages \xintgcdname and \xintfracname will check for
the previous loading of \xintname, and will try to load it if this was
not already done. Similarly \xintseriesname and \xintcfracname do the
necessary loading of \xintfracname.

Also inspired from the \textsc{Heiko Oberdiek} packages we have included
a complete catcode protection mecanism. The packages may be loaded in
any catcode configuration satisfying these requirements: the percent is
of category code comment character, the backslash is of category code
escape character, digits have category code other and letters have
category code letter. Nothing else is assumed, and the previous
configuration is restored after the loading of each one of the packages.

This is for the loading of the packages. For the actual use of the
macros, note that when feeding them with negative numbers the
minus sign must have category code other, as is standard. Similarly the
slash used for inputting fractions must be of category other, as usual.
And the square brackets also must be of category code other, if used on
input. 

The components of the \xintname bundle presuppose that the usual
\csa{space} and \csa{empty} macros are pre-defined, which is the case in
Plain \TeX{} as well as in \LaTeX.

Lastly, the macros \csa{xintRelaxArray} (of \xintname) and
\csa{xintTypesetEuclideAlgorithm} and
\csa{xintTypesetBezoutAlgorithm} (of \xintgcdname) use 
\csa{loop}, both Plain and \LaTeX{} incarnations are
compatible. \csa{xintTypesetBezoutAlgorithm} also uses the
\csa{endgraf} macro.
 

\section{Installation}

\begin{verbatim}
Run tex or latex on xint.dtx.

This will extract the style files xint.sty, xintgcd.sty, xintfrac.sty,
xintseries.sty, xintcfrac.sty (and xint.ins). Files with the same
names and in the same repertory will be overwritten. The tex (not
latex) run will stop with the complaint that it does not understand
\NeedsTeXFormat, but the style files will already have been extracted
by that time.

Alternatively, run tex or latex on xint.ins if available.

To get xint.pdf run pdflatex thrice on xint.dtx

           xint.sty |
        xintgcd.sty |
       xintfrac.sty | --> TDS:tex/generic/xint/
     xintseries.sty |
      xintcfrac.sty |
           xint.dtx   --> TDS:source/generic/xint/
           xint.pdf   --> TDS:doc/generic/xint/
 
It may be necessary to then refresh the TeX installation filename
database.
\end{verbatim}


\section{Commands of the \xintname package}

\def\n{\string{N\string}}
\def\m{\string{M\string}}
\def\x{\string{x\string}}

\n{} (resp. \m{} or \x) stands for a normalised number within braces as
described in the documentation, or for a control sequence expanding in at most
two steps to such a number (without the braces!), or for a control sequence
within braces expanding in at most two steps to such a number, of for material
within braces which expands to such a number after two expansions of the first
token.

Some of these macros are extended by \xintfracname to accept fractions
on input, and, generally, to output a fraction. This will be mentioned
and the original macro \csa{xintAbc} remains then available under the
name \csa{xintiAbc}. There are also macros such as \csa{xint\-Quo} or
\csa{xintNum} which are made to accept fractions on input, under the
condition that this fraction turns out to be an integer, but still do
produce pure integers without any forward slash mark nor trailing |[n]|.
Again the original is still available with an additional `i' in the
name, in case it is important to skip the parsing, but here the output
format is the same. See the \xintfracname
\hyperref[sec:comfrac]{\color{niceone}documentation} for more
information.

The integer-only macros are more efficient, even for simple things such
as determining the sign of a number, as there is always some overhead
due to parsing the fraction format on input; however except if one does
really a lot of computations, there is no need in general to employ the
integer-only variants. The exception is when the context requires that
the macro returns a (possibly long) integer, with no forward slash nor
trailing |[n]|. This may be because they are used in \xintname macros
which remain strictly integer-only on input, such as \csb{xintDecSplit},
or\vadjust{\vskip-\dp\strutbox
  \hbox{\smash{\color{niceone}\llap{\strut\small IMPORTANT!\ $\Bigg\{$\
      }}}\vskip\dp\strutbox } in\strut{} places where a (short) number is
expected by \TeX{} such as after an |\ifnum| or inside a |\numexpr|.




\subsection{\csbh{xintRev}} \label{xintRev}

\csa{xintRev\n} will revert the order of the digits of the number,
keeping the optional sign. Leading zeros
resulting from the operation are not removed (see the
\csa{xintNum} macro for this).
\centeredline{|\xintRev{-123000}|\texttt{=\xintRev{-123000}}}
\centeredline{|\xintNum{\xintRev{-123000}}|\texttt{=\xintNum{\xintRev{-123000}}}}

\subsection{\csbh{xintReverseOrder}}\label{xintReverseOrder}

\csa{xintReverseOrder}\marg{list} does not do any
expansion of its argument and just reverses the order of the
tokens in the `list'.\footnote{the argument is not a token list variable, just a
  `list' of tokens.} Brace pairs encountered are removed once and the enclosed
material does not get reverted. Spaces are gobbled.
\centeredline{|\xintReverseOrder{\xintDigitsOf\xintiPow {2}{100}\to\Stuff}|}
\centeredline{gives: \ttfamily{\string\Stuff\string\to1002\string\xintiPow\string\xintDigitsOf}}

\subsection{\csbh{xintNum}}\label{xintiNum}

\csa{xintNum\n} removes chains of plus or minus signs, followed by zeros.
\centeredline{|\xintNum{+---++----+--000000000367941789479}|\texttt
  {=\xintNum{+---++----+--000000000367941789479}}} Extended by \xintfracname to
accept also a fraction on input, as long as it reduces to an integer after
division of the numerator by the denominator.
\centeredline{|\xintNum{123.48/-0.03}|\texttt{=\xintNum{123.48/-0.03}}}

\subsection{\csbh{xintLen}}\label{xintiLen}

\csa{xintLen\n} returns the length of the number, not counting the
sign.
\centeredline{|\xintLen{-12345678901234567890123456789}|\texttt
  {=\xintLen{-12345678901234567890123456789}}} Extended by
\xintfracname to fractions: the length of |A/B[n]| is the length
of |A| plus the length of |B| plus the absolute value of |n| and
minus one (an integer input as |N| is internally |N/1[0]| so the
minus one means that the extended \csa{xintLen} behaves the same
as the original for integers). The whole thing should sum up to
less than circa &2^{31}&.

\subsection{\csbh{xintLength}}\label{xintLength}

\csa{xintLength}\marg{list} does not do any expansion of
its argument and just counts how many tokens there are. Things
enclosed in braces count as one.
\centeredline{|\xintLength {\xintiPow {2}{100}}=|\texttt{\xintLength
    {\xintiPow{2}{100}}}}
\centeredline{${}\neq{}$|\xintLen {\xintiPow {2}{100}}=|\texttt{\xintLen
    {\xintiPow{2}{100}}}}


\subsection{\csbh{xintAssign}}\label{xintAssign}

\csa{xintAssign}\meta{braced things}\csa{to}%
\meta{as many cs as they are things} defines (without checking if
something gets overwritten) the control sequences on the right of
\csa{to} to be the complete expansions of the successive things on
the left of \csa{to} enclosed within braces. 

Important: a double expansion is applied first to the material
extending up to \csa{to}.

\xintAssign\xintiPow {7}{13}\to\SevenToThePowerThirteen
\xintAssign\xintDivision{1000000000000}{133333333}\to\Q\R

As a special exception, if after this initial double expansion a
brace does not immediately follows \csa{xintAssign}, it is assumed
that there is only one control sequence to define and it is then
defined to be the complete expansion of the material between
\csa{xintAssign} and \csa{to}.
\centeredline{|\xintAssign\xintDivision{1000000000000}{133333333}\to\Q\R|}
\centeredline{|\meaning\Q: |\texttt{\meaning\Q}, |\meaning\R:
  |\texttt{\meaning\R}} \centeredline{|\xintAssign\xintiPow
  {7}{13}\to\SevenToThePowerThirteen|}
\centeredline{|\SevenToThePowerThirteen=|\texttt{\SevenToThePowerThirteen}}

Of course this macro and its cousins completely break usage in
pure expansion contexts, as assignments are made via the
\csa{edef} primitive.

\subsection{\csbh{xintAssignArray}}\label{xintAssignArray}


\xintAssignArray\xintBezout {1000}{113}\to\Bez


\csa{xintAssignArray}\meta{braced things}\csa{to}\csa{myArray} first
double expands the first token then defines \csa{myArray} to be a
macro with one parameter, such that \csa{myArray\n} expands in two
steps (which include the twice-expansion of \texttt{\n}) to give
the |N|th braced thing, itself completely expanded.
\csa{myArray}|{0}| returns the number |M| of elements of the array
so that the successive elements are \csa{myArray}|{1}|, \dots,
\csa{myArray}|{M}|. \centeredline{|\xintAssignArray\xintBezout
  {1000}{113}\to\Bez|} will set |\Bez{0}| to \texttt{\Bez0},
|\Bez{1}| to \texttt{\Bez1}, |\Bez{2}| to \texttt{\Bez2},
|\Bez{3}| to \texttt{\Bez3}, |\Bez{4}| to \texttt{\Bez4}, and
|\Bez{5}| to \texttt{\Bez5}:
(\Bez3)${}\times{}$\Bez1${}-{}$(\Bez4)${}\times{}$\Bez2${}={}$\Bez5.

\subsection{\csbh{xintRelaxArray}}\label{xintRelaxArray}

\csa{xintRelaxArray}\csa{myArray} sets to \csa{relax} all 
macros which were defined by the previous \csa{xintAssignArray}
with \csa{myArray} as array name. 

\subsection{\csbh{xintDigitsOf}}\label{xintDigitsOf}

This is a synonym for \csa{xintAssignArray}, to be used to define
an array giving all the digits of a given number.
\begingroup\xintDigitsOf\xintiPow {7}{500}\to\digits
\centeredline{|\xintDigitsOf\xintiPow {7}{500}\to\digits|}
\noindent &7^500& has |\digits{0}=|\digits{0} digits, and the 123rd among them
(starting from the most significant) is
|\digits{123}=|\digits{123}.
\endgroup 

\subsection{\csbh{xintApply}}\label{xintApply}

{\small New in release |1.04|.\par}

\def\macro #1{\the\numexpr 9-#1\relax}

\csa{xintApply}|{\macro}{list}| applies the one parameter command |\macro| to
each item in the `list' (no separator) given as second argument. For each item two
expansions are done of |\macro| and the result is braced. On output, a new list
with these braced results. The `list' may itself be some macro expanding in two
steps to the list of tokens to which the command |\macro| will be applied. For
example, if the `list' expands to some positive number, then each digit will be
replaced by the result of applying |\macro| on it. \centeredline{|\def\macro
  #1{\the\numexpr 9-#1\relax}|} \centeredline{|\xintApply\macro{\xintFac
    {20}}=|\texttt{\xintApply\macro{\xintFac {20}}}}

\subsection{\csbh{xintListWithSep}}\label{xintListWithSep}

{\small New in release |1.04|.\par}

\def\macro #1{\the\numexpr 9-#1\relax}

\csa{xintListWithSep}|{sep}{list}| just inserts the given separator |sep|
in-between all elements of the given list. One level of braces is
removed. See the discussion of
\csb{xintApply}. \centeredline{|\xintListWithSep{:}{\xintFac
    {20}}=|\texttt{\xintListWithSep{:}{\xintFac {20}}}}


\subsection{\csbh{xintSgn}}\label{xintiSgn}

\csa{xintSgn\n} returns 1 if the number is positive, 0 if it is
zero and -1 if it is negative. Extended by \xintfracname to fractions.


\subsection{\csbh{xintOpp}}\label{xintiOpp}

\csa{xintOpp\n} returns the opposite |-N| of the number |N|.
Extended by \xintfracname to fractions.


\subsection{\csbh{xintAbs}}\label{xintiAbs}

\csa{xintAbs\n} returns the absolute value of the number. Extended
by \xintfracname to fractions. 

\subsection{\csbh{xintAdd}}\label{xintiAdd}

\csa{xintAdd\n\m} returns the sum of the two numbers. Extended by
\xintfracname to fractions.

\subsection{\csbh{xintSub}}\label{xintiSub}

\csa{xintSub\n\m} returns the difference |N-M|. Extended by
\xintfracname to fractions.

\subsection{\csbh{xintCmp}}\label{xintiCmp}

\csa{xintCmp\n\m} returns 1 if |N>M|, 0 if |N=M|, and -1 if |N<M|.
Extended by \xintfracname to fractions.

\subsection{\csbh{xintGeq}}\label{xintGeq}

\csa{xintGeq\n\m} returns 1 if the absolute value of the first
number is at least equal to the absolute value of the second
number. If \verb+|N|<|M|+ it returns 0.

\subsection{\csbh{xintMax}}\label{xintiMax}

\csa{xintMax\n\m} returns the largest of the two in the sense of the order
structure on the relative integers (\emph{i.e.} the right-most number if they
are put on a line with positive numbers on the right): |\xintiMax
{-5}{-6}=|\texttt{\xintiMax{-5}{-6}}. Extended by \xintfracname to fractions.

\subsection{\csbh{xintMin}}\label{xintiMin}

\csa{xintMin\n\m} returns the smallest of the two in the sense of the order
structure on the relative integers (\emph{i.e.} the left-most number if they are
put on a line with positive numbers on the right): |\xintiMin
{-5}{-6}=|\texttt{\xintiMin{-5}{-6}}. Extended by \xintfracname to fractions.

\subsection{\csbh{xintSum}}\label{xintiSum}

\csa{xintSum}\marg{braced things} after expanding its argument
twice expects to find a sequence of tokens (or braced material).
Each is twice-expanded, and the sum of all these numbers is
returned. 
\centeredline{%
  \csa{xintiSum}|{{123}{-98763450}{\xintFac{7}}{\xintiMul{3347}{591}}}=|\texttt{%
    \xintiSum{{123}{-98763450}{\xintFac{7}}{\xintiMul{3347}{591}}}}}
\centeredline{\csa{xintiSum}|{1234567890}=|\texttt{%
     \xintiSum{1234567890}}}
An empty sum is no error and returns zero: |\xintiSum
{}=|\texttt{\xintiSum {}}. A sum with only one
term returns that number: |\xintiSum {{-1234}}=|\texttt{\xintiSum
  {{-1234}}}. Attention that |\xintiSum {-1234}| is not legal input
and will make the \TeX{} run fail. On the other hand  |\xintiSum
{1234}=|\texttt{\xintiSum{1234}}. Extended by \xintfracname
to fractions.

\subsection{\csbh{xintSumExpr}}\label{xintiSumExpr}

\csa{xintSumExpr}\meta{braced things}\csa{relax} is to what
\csa{xintSum} expands. The argument is then double-expanded and should
give a list of braced quantities or macros, each one will be double
expanded in turn. \centeredline{%
  \csa{xintiSumExpr}| {123}{-98763450}|%
  |{\xintFac{7}}{\xintiMul{3347}{591}}\relax=|\texttt{%
    \xintiSumExpr
    {123}{-98763450}{\xintFac{7}}{\xintiMul{3347}{591}}\relax}}

Note: I am not so happy with the name which seems to suggest that the
|+| sign should be used instead of braces. Perhaps this will change
in the future.

Extended by \xintfracname to fractions.

\subsection{\csbh{xintMul}}\label{xintiMul}
{\small Modified in release |1.03|.\par}

\csa{xintMul\n\m} returns the product of the two numbers. Starting
with release |1.03| of \xintname, the macro checks the lengths of
the two numbers and then activates its algorithm with the best (or
at least, hoped-so) choice of which one to put first. This makes
the macro a bit slower for numbers up to 50 digits, but may give
substantial speed gain when one of the number has 100 digits or more.
Extended by \xintfracname to fractions.

\subsection{\csbh{xintSqr}}\label{xintiSqr}

\csa{xintSqr\n} returns the square. Extended by \xintfracname to fractions.

\subsection{\csbh{xintPrd}}\label{xintiPrd}

\csa{xintPrd}\marg{braced things} after expanding its argument
twice expects to find a sequence of tokens (or braced material).
Each is twice-expanded, and the product of all these numbers is
returned. \centeredline{%
  \csa{xintiPrd}|{{-9876}{\xintFac{7}}{\xintiMul{3347}{591}}}=|%
  \texttt{%
    \xintiPrd{{-9876}{\xintFac{7}}{\xintiMul{3347}{591}}}}}
\centeredline{\csa{xintiPrd}|{123456789123456789}=|\texttt{%
    \xintiPrd{123456789123456789}}} An empty product is no error
and returns 1: |\xintiPrd {}=|\texttt{\xintiPrd {}}. A product
reduced to a single term returns this number: |\xintiPrd
{{-1234}}=|\texttt{\xintiPrd {{-1234}}}. Attention that |\xintiPrd
{-1234}| is not legal input and will make the \TeX{} compilation
fail. On the other hand |\xintiPrd {1234}=|\texttt{\xintiPrd
  {1234}}.
\centeredline{&2^{200}3^{100}7^{100}&}
\centeredline{=|\xintiPrd {{\xintiPow {2}{200}}{\xintiPow
    {3}{100}}{\xintiPow {7}{100}}}|}
=\expandafter\expandafter\expandafter\allowsplits
   \xintiPrd {{\xintiPow {2}{200}}{\xintiPow {3}{100}}{\xintiPow
    {7}{100}}}\relax
\centeredline{=|\xintiPow {\xintiMul {\xintiPow {42}{9}}{43008}}{10}|}
Extended by \xintfracname to fractions.

% \printnumber{%
%    \xintPow {\xintMul {\xintPow {42}{9}}{43008}}{10}}

\subsection{\csbh{xintProductExpr}}\label{xintiProductExpr}

\csa{xintProductExpr}\marg{argument}\csa{relax} is to what
\csa{xintPrd} expands ; its argument is then twice expanded and should
give a list of braced numbers or macros. Each will be twice expanded
when it is its turn. 
\centeredline{\csa{xintiProductExpr}| 123456789123456789\relax=|\texttt{%
     \xintiProductExpr 123456789123456789\relax}}

Note: I am not so happy with the name which seems to suggest that the
|*| sign should be used instead of braces. Perhaps this will change
in the future.

Extended by \xintfracname to fractions.

\subsection{\csbh{xintFac}}\label{xintFac}

\csa{xintFac\n} returns the factorial. It is an error if the
argument is negative or at least &10^6&. It is not recommended to
launch the computation of things such as &100000!&, if you need
your computer for other tasks. 

% temps obsolètes, mettre à jour
% On my laptop &1000!& (2568 digits)
% is computed in a little less than ten seconds, &2000!& (5736
% digits) is computed in a little less than one hundred seconds, and
% &3000!& (which has 9131 digits) needs close to seven minutes\dots
% I have no idea how much time &10000!& would need (do rather
% &9999!& if you can, the algorithm has some overhead at the
% transition from &N=9999& to &10000& and higher; &10000!& has 35660
% digits). Not to mention &100000!& which, from the Stirling formula,
% should have 456574 digits.

\subsection{\csbh{xintPow}}\label{xintiPow}

\csa{xintPow\n\m} returns |N^M|. When |M| is zero, this is 1. Some
cases (|N| zero and |M| negative, \verb+|N|>1+ and |M| negative,
\verb+|N|>1+ and |M| at least &10^9&) make \xintname throw errors. 

Extended by \xintfracname to fractions. Of course, negative
exponents do not then cause errors anymore. 


\subsection{\csbh{xintDivision}}\label{xintDivision}

\csa{xintDivision\n\m} returns |{quotient Q}{remainder R}|. This
is euclidean division: |N = QM + R|, |0|${}\leq{}$\verb+R < |M|+. So the
remainder is always non-negative and the formula |N = QM + R|
always holds independently of the signs of |N| or |M|. Division by
zero is of course an error (even if |N| vanishes) and returns |{0}{0}|.

This macro is integer only (with \xintfracname loaded it accepts
fractions on input, but they must be integers in disguise) and not to be
confused with the \xintfracname macro \csb{xintDiv} which divides one
fraction by another.

\subsection{\csbh{xintQuo}}\label{xintQuo}

\csa{xintQuo\n\m} returns the quotient from the euclidean division. When
both |N| and |M| are positive one has \csa{xintQuo\n\m}|=\xintiTrunc
{0}{N/M}| (using package \xintfracname). With \xintfracname loaded it
accepts fractions on input, but they must be integers in disguise.

\subsection{\csbh{xintRem}}\label{xintRem}

\csa{xintRem\n\m} returns the remainder from the euclidean division.
With \xintfracname loaded it accepts fractions on input, but they must
be integers in disguise.


\subsection{\csbh{xintFDg}}\label{xintFDg}

\csa{xintFDg\n} returns the first digit (most significant) of the
decimal expansion.

\subsection{\csbh{xintLDg}}\label{xintLDg}

\csa{xintLDg\n} returns the least significant digit. When the
number is positive, this is the same as the remainder in the
euclidean division by ten.

\subsection{\csbh{xintMON}, \csbh{xintMMON}}\label{xintiMON}\label{xintiMMON}\label{xintMON}\label{xintMMON}
{\small New in version |1.03|.\par}

\csa{xintMON\n} returns |(-1)^N| and \csa{xintMMON\n} returns
|(-1)^{N-1}|. \centeredline{|\xintMON {-280914019374101929}=|\texttt{\xintMON
  {280914019374101929}}, |\xintMMON
{-280914019374101929}=|\texttt{\xintMMON {280914019374101929}}}

\subsection{\csbh{xintOdd}}\label{xintOdd}

\csa{xintOdd\n} is 1 if the number is odd and 0 otherwise. 

\subsection{\csbh{xintDSL}}\label{xintDSL}

\csa{xintDSL\n} is decimal shift left, \emph{i.e.} multiplication
by ten.

\subsection{\csbh{xintDSR}}\label{xintDSR}

\csa{xintDSR\n} is decimal shift right, \emph{i.e.} it removes the
last digit (keeping the sign). For a positive number, this is the
same as the quotient from the euclidean division by ten (of
course, done in a more efficient manner than via the general
division algorithm). For |N| from |-9| to |-1|, the macro returns
|0|.

\subsection{\csbh{xintDSH}}\label{xintDSH}

\csa{xintDSH\x\n} is parametrized decimal shift. When |x| is
negative, it is like iterating \csa{xintDSL} \verb+|x|+ times
(\emph{i.e.} multiplication by &10^{-&|x|&}&). When |x| positive,
it is like iterating \csa{DSR} |x| times (and is more efficient of
course), and for a non-negative |N| this is thus the same as the
quotient from the euclidean division by |10^x|. 

\subsection{\csbh{xintDSHr}, \csbh{xintDSx}}\label{xintDSHr}\label{xintDSx}
{\small New in release |1.01|.\par}

\csa{xintDSHr\x\n} expects |x| to be zero or positive and it returns
then a value |R| which is correlated to the value |Q| returned by
\csa{xintDSH\x\n} in the following manner:
\begin{itemize}
\item if |N| is
  positive or zero, |Q| and |R| are the quotient and remainder in
  the euclidean division by |10^x| (obtained in a more efficient
  manner than using \csa{xintDivision}),
\item if |N| is negative let
  |Q1| and |R1| be the quotient and remainder in the euclidean
  division by |10^x| of the absolute value of |N|. If |Q1|
  does not vanish, then |Q=-Q1| and |R=R1|. If |Q1| vanishes, then
  |Q=0| and |R=-R1|.
\item for |x=0|, |Q=N| and |R=0|.
\end{itemize}
So one has |N = 10^x Q + R| if |Q| turns out to be zero or
positive, and |N = 10^x Q - R| if |Q| turns out to be negative,
which is exactly the case when |N| is at most |-10^x|.


\csa{xintDSx\x\n} for |x| negative is exactly as
\csa{xintDSH\x\n}, \emph{i.e.} multiplication by &10^{-&|x|&}&.
For |x| zero or positive it returns the two numbers |{Q}{R}|
described above, each one within braces. So |Q| is
\csa{xintDSH\x\n}, and |R| is \csa{xintDSHr\x\n}, but computed
simultaneously.

\begin{flushleft}
  \xintAssign\xintDSx {-1}{-123456789}\to\M 
  \noindent{|\xintAssign\xintDSx {-1}{-123456789}\to\M|}\\
  |\meaning\M: |\texttt{\meaning\M}.\\
  \xintAssign\xintDSx {-20}{1234567689}\to\M 
  {|\xintAssign\xintDSx {-20}{123456789}\to\M|}\\ 
  |\meaning\M: |\texttt{\meaning\M}.\\
  \xintAssign\xintDSx{0}{-123004321}\to\Q\R 
  {|\xintAssign\xintDSx {0}{-123004321}\to\Q\R|}\\
  \noindent|\meaning\Q: |\texttt{\meaning\Q}, |\meaning\R:
  |\texttt{\meaning\R.}\\
  |\xintDSH {0}{-123004321}=|\texttt{\xintDSH {0}{-123004321}},
  |\xintDSHr {0}{-123004321}=|\texttt{\xintDSHr {0}{-123004321}}\\
  \xintAssign\xintDSx {6}{-123004321}\to\Q\R 
  {|\xintAssign\xintDSx {6}{-123004321}\to\Q\R|}\\ 
  |\meaning\Q: |\texttt{\meaning\Q},
  |\meaning\R: |\texttt{\meaning\R.}\\
  |\xintDSH {6}{-123004321}=|\texttt{\xintDSH {6}{-123004321}},
  |\xintDSHr {6}{-123004321}=|\texttt{\xintDSHr {6}{-123004321}}\\
  \xintAssign\xintDSx {8}{-123004321}\to\Q\R 
  {|\xintAssign\xintDSx {8}{-123004321}\to\Q\R|}\\ 
  |\meaning\Q: |\texttt{\meaning\Q},
  |\meaning\R: |\texttt{\meaning\R.} \\
  |\xintDSH {8}{-123004321}=|\texttt{\xintDSH {8}{-123004321}},
  |\xintDSHr {8}{-123004321}=|\texttt{\xintDSHr {8}{-123004321}}\\
  \xintAssign\xintDSx {9}{-123004321}\to\Q\R 
  {|\xintAssign\xintDSx {9}{-123004321}\to\Q\R|}\\ 
  |\meaning\Q: |\texttt{\meaning\Q},
  |\meaning\R: |\texttt{\meaning\R.}\\
  |\xintDSH {9}{-123004321}=|\texttt{\xintDSH {9}{-123004321}},
  |\xintDSHr {9}{-123004321}=|\texttt{\xintDSHr {9}{-123004321}}\\
\end{flushleft}

\subsection{\csbh{xintDecSplit}}\label{xintDecSplit}

{\small This has been modified in release |1.01|.\par}

\csa{xintDecSplit\x\n} cuts the number into two pieces (each one within a
pair of enclosing braces). First the sign if present is \emph{removed}.
Then, for |x| positive or null, the second piece contains the |x| least
significant digits (\emph{empty} if |x=0|) and the first piece the remaining
digits (\emph{empty} when |x| equals or exceeds the length of |N|).
Leading zeros in the second piece are not removed. When |x| is negative
the first piece contains the \verb+|x|+ most significant digits and the
second piece the remaining digits (\emph{empty} if &|x|& equals or exceeds
the length of |N|). Leading zeros in this second piece are not removed.
So the absolute value of the original number is always the concatenation
of the first and second piece.

{\footnotesize This macro's behavior for |N| non-negative is final and will not
  change. I am still hesitant about what to do with the sign of a
  negative |N|.\par}


\xintAssign\xintDecSplit {0}{-123004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {0}{-123004321}\to\L\R|}
\noindent|\meaning\L: |\texttt{\meaning\L}, |\meaning\R: |\texttt{\meaning\R.}
\xintAssign\xintDecSplit {5}{-123004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {5}{-123004321}\to\L\R|}
|\meaning\L: |\texttt{\meaning\L}, |\meaning\R: |\texttt{\meaning\R.}
\xintAssign\xintDecSplit {9}{-123004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {9}{-123004321}\to\L\R|}
|\meaning\L: |\texttt{\meaning\L}, |\meaning\R: |\texttt{\meaning\R.}
\xintAssign\xintDecSplit {10}{-123004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {10}{-123004321}\to\L\R|}
|\meaning\L: |\texttt{\meaning\L}, |\meaning\R: |\texttt{\meaning\R.}
\xintAssign\xintDecSplit {-5}{-12300004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {-5}{-12300004321}\to\L\R|}
|\meaning\L: |\texttt{\meaning\L}, |\meaning\R: |\texttt{\meaning\R.}
\xintAssign\xintDecSplit {-11}{-12300004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {-11}{-12300004321}\to\L\R|}
|\meaning\L: |\texttt{\meaning\L}, |\meaning\R: |\texttt{\meaning\R.}
\xintAssign\xintDecSplit {-15}{-12300004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {-15}{-12300004321}\to\L\R|}
|\meaning\L: |\texttt{\meaning\L}, |\meaning\R: |\texttt{\meaning\R.}

\subsection{\csbh{xintDecSplitL}}\label{xintDecSplitL}

\csa{xintDecSplitL\x\n} returns the first piece after the action
of \csa{xintDecSplit}.

\subsection{\csbh{xintDecSplitR}}\label{xintDecSplitR}

\csa{xintDecSplitR\x\n} returns the second piece after the action
of \csa{xintDecSplit}.


\section{Commands of the \xintgcdname package}

This package was included in the original release |1.0| of the
\xintname bundle. 

\subsection{\csbh{xintGCD}}\label{xintGCD}

\csa{xintGCD\n\m} computes the greatest common divisor. It is
positive, except when both |N| and |M| vanish, in which case the macro
returns zero.
\centeredline{\csa{xintGCD}|{10000}{1113}=|\texttt{\xintGCD{10000}{1113}}}
\centeredline{|\xintGCD{123456789012345}{9876543210321}=|\texttt
              {\xintGCD{123456789012345}{9876543210321}}}

\subsection{\csbh{xintBezout}}\label{xintBezout}

\xintAssign{{\xintBezout {10000}{1113}}}\to\X
\xintAssign {\xintBezout {10000}{1113}}\to\A\B\U\V\D

\csa{xintBezout\n\m} returns five numbers |A|, |B|, |U|, |V|, |D| within
braces. |A| is the first (twice-expanded) input number, |B| the
second, |D| is the GCD, and \texttt{UA - VB = D}. 
\centeredline{|\xintAssign {{\xintBezout {10000}{1113}}}\to\X|}
\centeredline{|\meaning\X: |\texttt{\meaning\X }.}
\noindent{|\xintAssign {\xintBezout {10000}{1113}}\to\A\B\U\V\D|}\\
|\A: |\texttt{\A },
|\B: |\texttt{\B },
|\U: |\texttt{\U },
|\V: |\texttt{\V },
|\D: |\texttt{\D }.\\
\xintAssign {\xintBezout {123456789012345}{9876543210321}}\to\A\B\U\V\D
\noindent{|\xintAssign {\xintBezout {123456789012345}{9876543210321}}\to\A\B\U\V\D
|}\\
|\A: |\texttt{\A },
|\B: |\texttt{\B },
|\U: |\texttt{\U },
|\V: |\texttt{\V },
|\D: |\texttt{\D }.


\subsection{\csbh{xintEuclideAlgorithm}}\label{xintEuclideAlgorithm}

\xintAssign {{\xintEuclideAlgorithm {10000}{1113}}}\to\X

\def\restorebracecatcodes
   {\catcode`\{=1 \catcode`\}=2 }

\def\allowlistsplit 
   {\catcode`\{=12 \catcode`\}=12 \allowlistsplita }

\def\allowlistsplitx {\futurelet\listnext\allowlistsplitxx }

\def\allowlistsplitxx {\ifx\listnext\relax \restorebracecatcodes
                        \else \expandafter\allowlistsplitxxx \fi }
\begingroup
\catcode`\[=1
\catcode`\]=2
\catcode`\{=12
\catcode`\}=12
\gdef\allowlistsplita #1{[#1\allowlistsplitx {]
\gdef\allowlistsplitxxx {#1}%
     [{#1}\hskip 0pt plus 1pt \allowlistsplitx ]
\endgroup

\csa{xintEuclideAlgorithm\n\m} applies the Euclide algorithm and
keeps a copy of all quotients and remainders. 
\centeredline{|\xintAssign {{\xintEuclideAlgorithm {10000}{1113}}}\to\X|}

|\meaning\X: |\texttt{\expandafter\allowlistsplit\meaning\X 
                      \relax }.
The first token is the number of steps, the second is |N|, the
third is the GCD, the fourth is |M| then the first quotient and
remainder, the second quotient and remainder, \dots until the
final quotient and last (zero) remainder.

\subsection{\csbh{xintBezoutAlgorithm}}\label{xintBezoutAlgorithm}

\catcode`\& 4

\xintAssign {{\xintBezoutAlgorithm {10000}{1113}}}\to\X

\csa{xintBezoutAlgorithm\n\m} applies the Euclide algorithm and
keeps a copy of all quotients and remainders. Furthermore it
computes the entries of the successive products of the 2 by 2 matrices 
$\left(\vcenter{\halign {\,#&\,#\cr q & 1 \cr 1 & 0 \cr}}\right)$
formed from the quotients arising in the algorithm.
\centeredline{|\xintAssign {{\xintEuclideAlgorithm {10000}{1113}}}\to\X|}

|\meaning\X: |\texttt{\expandafter\allowlistsplit\meaning\X \relax}.

The first token is the number of steps, the second is |N|, then
|0|, |1|, the GCD, |M|, |1|, |0|, the first quotient, the first
remainder, the top left entry of the first matrix, the bottom left
entry, and then these four things at each step until the end.

\catcode`\& 13

\subsection{\csbh{xintTypesetEuclideAlgorithm}\hskip1cm\hspace*{0cm}}\label{xintTypesetEuclideAlgorithm}

This macro is just an example of how to organize the data returned
by \csa{xintEuclideAlgorithm}. Copy the source code to a new macro
and modify it to what is needed.
\centeredline{|\xintTypesetEuclideAlgorithm
  {123456789012345}{9876543210321}|} \xintTypesetEuclideAlgorithm
{123456789012345}{9876543210321}


\subsection{\csbh{xintTypesetBezoutAlgorithm}}\label{xintTypesetBezoutAlgorithm}

This macro is just an example of how to organize the data returned
by \csa{xintBezoutAlgorithm}. Copy the source code to a new macro
and modify it to what is needed.
\centeredline{|\xintTypesetBezoutAlgorithm {10000}{1113}|}
\xintTypesetBezoutAlgorithm {10000}{1113}

\section{Commands of the \xintfracname package}\label{sec:comfrac}

The general rule of the bundle that each macro first double-expands each one of
its arguments applies. This package was first included in release |1.03| of the
\xintname bundle. 

\subsection{\csbh{xintLen}}\label{xintLen}

The original macro is extended to accept a fraction on input.
\centeredline {|\xintLen {201710/298219}=|\texttt{\xintLen {201710/298219}},
|\xintLen {1234/1}=|\texttt{\xintLen {1234/1}}, |\xintLen {1234}=|\texttt{\xintLen {1234}}}


\subsection{\csbh{xintRaw}}\label{xintRaw}

{\small New with release |1.04|.\par}

This macro `prints' the 
fraction |f| (after its parsing and expansion) in |A/B| form, with |A|
as returned by \csa{xintNumerator}|{f}| and |B| as returned by
\csa{xintDenominator}|{f}|.
\centeredline{|\xintRaw{\the\numexpr 571*987\relax.123/\the\numexpr
    -201+59\relax}=|}%
\centeredline{\texttt{\xintRaw{\the\numexpr
      571*987\relax.123/\the\numexpr -201+59\relax}}} 


\subsection{\csbh{xintNumerator}}\label{xintNumerator}

This returns the numerator corresponding to the internal representation of a
fraction, with positive powers of ten converted into zeros of this numerator:
\centeredline{|\xintNumerator
  {178000/25600000[17]}=|\texttt{\xintNumerator {178000/25600000[17]}}}%
\centeredline{|\xintNumerator {312.289001/20198.27}=|\texttt{\xintNumerator {312.289001/20198.27}}}%
\centeredline{|\xintNumerator {178.000/25600000}=|\texttt{\xintNumerator
    {178.000/25600000}}} As shown by the examples, no simplification of the
input is done. For a result uniquely associated to the value of the fraction
first apply \csa{xintIrr}.

\subsection{\csbh{xintDenominator}}\label{xintDenominator}

This returns the denominator corresponding to the internal representation of the
fraction:\footnote{recall that the |[]| construct excludes presence of a decimal
  point.} \centeredline{|\xintDenominator
  {178000/25600000[17]}=|\texttt{\xintDenominator {178000/25600000[17]}}}%
\centeredline{|\xintDenominator {312.289001/20198.27}=|\texttt{\xintDenominator {312.289001/20198.27}}}%
\centeredline{|\xintDenominator {178.000/25600000}=|\texttt{\xintDenominator
    {178.000/25600000}}} As shown by the examples, no simplification of the
input is done. The denominator looks wrong in the last example, but the
numerator was tacitly multiplied by &1000& through the removal of the decimal
point.   For a result uniquely associated to the value of the fraction
first apply \csa{xintIrr}.


\subsection{\csbh{xintFrac}}\label{xintFrac}

This is a \LaTeX{} only command, to be used in math mode only. It will print a
fraction, internally represented as something equivalent to |A/B[n]| as |\frac
{A}{B}10^n|. The power of ten is omitted when |n=0|, the denominator is omitted
when it has value one, the number being separated from the power of ten by a
|\cdot|. |$\xintFrac {178.000/25600000}$| gives $\xintFrac {178.000/25600000}$,
|$\xintFrac {178.000/1}$| gives $\xintFrac {178.000/1}$,  |$\xintFrac
{3.5/5.7}$| gives $\xintFrac {3.5/5.7}$, and |$\xintFrac {\xintIrr
  {\xintFac{10}/|\allowbreak|\xintiSqr{\xintFac {5}}}}$| gives $\xintFrac {\xintIrr
  {\xintFac{10}/\xintiSqr{\xintFac {5}}}}$. As shown by the examples, 
simplification of the input (apart from removing the decimal points and
moving the minus sign to the numerator) is not done automatically and must be
the result of macros such as |\xintIrr| or |\xintREZ|.

\subsection{\csbh{xintSignedFrac}}\label{xintSignedFrac}

{\small New with release |1.04|.\par}

This is as \csb{xintFrac} except that a negative fraction has the sign put in
front, not in the numerator.
\centeredline{|\[\xintFrac {-355/113}=\xintSignedFrac {-355/113}\]|}
\[\xintFrac {-355/113}=\xintSignedFrac {-355/113}\]

\subsection{\csbh{xintFwOver}}\label{xintFwOver}

This does the same as \csa{xintFrac} except that the \csa{over} primitive is
used for the fraction (in case the denominator is not one; and a pair of braces
contains the |A\over B| part). |$\xintFwOver {178.000/25600000}$| gives
$\xintFwOver {178.000/25600000}$, |$\xintFwOver {178.000/1}$| gives $\xintFwOver
{178.000/1}$, |$\xintFwOver {3.5/5.7}$| gives $\xintFwOver {3.5/5.7}$, and
|$\xintFwOver {\xintIrr {\xintFac{10}/\xintiSqr{\xintFac {5}}}}$| gives
$\xintFwOver {\xintIrr {\xintFac{10}/\xintiSqr{\xintFac {5}}}}$.

\subsection{\csbh{xintSignedFwOver}}\label{xintSignedFwOver}

{\small New with release |1.04|.\par}

This is as \csb{xintFwOver} except that a negative fraction has the sign put in
front, not in the numerator.
\centeredline{|\[\xintFwOver {-355/113}=\xintSignedFwOver {-355/113}\]|}
\[\xintFwOver {-355/113}=\xintSignedFwOver {-355/113}\]


\subsection{\csbh{xintREZ}}\label{xintREZ}

This command normalizes a fraction by removing the powers of ten in its
numerator and denominator: |\xintREZ {178000/25600000[17]}=|\texttt{\xintREZ
  {178000/25600000[17]}}. As shown by the example, it does not otherwise
simplify the fraction.

\subsection{\csbh{xintIrr}}\label{xintIrr}

This puts the fraction into its unique irreducible form: \centeredline{|\xintIrr
  {178.256/256.178}=|%
  \texttt{\xintIrr {178.256/256.178}}${}=\xintFrac{\xintIrr
    {178.256/256.178}[0]}$}%
Note that the current implementation does not cleverly first factor powers of 2
and 5, so input such as |\xintIrr {2/3[100]}| will make \xintfracname do the
Euclidean division of |2|\raisebox{.5ex}{|.|}|10^{100}| by |3|, which is a bit
stupid.

% To avoid some overhead, in the parsing by |\xintFrac| of the output of
% |\xintIrr|, add a |[0]|: |\xintFrac {\xintIrr {178.256/256.178}[0]}|. This
% advice is only for \csa{xintIrr} (or \csa{xintJrr}) as these macros do not have
% the |[n]| systematically present in the outputs of the other macros, |[n]| whose
% rôle is also to signal that the format can be parsed in a minimal way, as it is
% not arbitrary user-input but beautiful package crafted output... and, this is
% really only if some piece of code will be executed thousands of times!


\subsection{\csbh{xintJrr}}\label{xintJrr}

This also puts the fraction into its unique irreducible form:
\centeredline{|\xintJrr {178.256/256.178}=|%
  \texttt{\xintJrr {178.256/256.178}}}%
This is faster than \csa{xintIrr} for fractions having some big common
factor in the numerator and the denominator.\par
{\centering |\xintJrr {\xintiPow{\xintFac {15}}{3}/\xintiProductExpr
{\xintFac{10}}{\xintFac{30}}{\xintFac{5}}\relax }=|\texttt{%
 \xintJrr {\xintiPow{\xintFac {15}}{3}/\xintiProductExpr
{\xintFac{10}}{\xintFac{30}}{\xintFac{5}}\relax }}\par} But to notice the
difference one would need computations with much bigger numbers than in this
example.


\subsection{\csbh{xintTrunc}}\label{xintTrunc}

\csa{xintTrunc}|{N}{f}| returns the start of the decimal expansion of the
fraction |f|, with |N| digits after the decimal point. The argument |N| should
be non-negative. When |N=0|, the integer part of |f| results, with an ending
decimal point. Only when |f| evaluates to zero does \csa{xintTrunc} not print
a decimal point. When |f| is not zero, the sign is maintained in the output,
also when the digits are all zero. \centeredline{|\xintTrunc
  {16}{-803.2028/20905.298}=|\texttt{\xintTrunc {16}{-803.2028/20905.298}}}% 
 \centeredline{|\xintTrunc
  {20}{-803.2028/20905.298}=|\texttt{\xintTrunc {20}{-803.2028/20905.298}}}%
 \centeredline{|\xintTrunc
  {10}{\xintPow {-11}{-11}}=|\texttt{\xintTrunc
  {10}{\xintPow {-11}{-11}}}}%
 \centeredline{|\xintTrunc
  {12}{\xintPow {-11}{-11}}=|\texttt{\xintTrunc
  {12}{\xintPow {-11}{-11}}}}%
\centeredline{|\xintTrunc {12}{\xintAdd {-1/3}{3/9}}=|\texttt{\xintTrunc {12}{\xintAdd {-1/3}{3/9}}}} The
digits printed are exact up to and including the last one. The identity
|\xintTrunc {N}{-f}=-\xintTrunc {N}{f}| holds.\footnote{this is just a notation;
  currently |-\string\x| is not valid input to any package macro, one must use
  |\string\xintOpp\string{\string\x\string}| or |\string\xintiOpp\string{\string\x\string}|.}

\subsection{\csbh{xintiTrunc}}\label{xintiTrunc}

\csa{xintiTrunc}|{N}{f}| returns the integer equal to |10^N| times what
\csa{xintTrunc}|{N}{f}| would return. \centeredline{|\xintiTrunc
  {16}{-803.2028/20905.298}=|\texttt{\xintiTrunc {16}{-803.2028/20905.298}}}%
 \centeredline{|\xintiTrunc
  {10}{\xintPow {-11}{-11}}=|\texttt{\xintiTrunc
  {10}{\xintPow {-11}{-11}}}}%
 \centeredline{|\xintiTrunc
  {12}{\xintPow {-11}{-11}}=|\texttt{\xintiTrunc
  {12}{\xintPow {-11}{-11}}}}%
Differences between \csa{xintTrunc}|{0}{f}| and \csa{xintiTrunc}|{0}{f}|:
the former cannot be used inside integer-only macros, and the latter
removes the decimal point, and never returns |-0| (and of course removes
all superfluous leading zeros.)

\subsection{\csbh{xintRound}}\label{xintRound}

{\small New with release |1.04|.\par}

\csa{xintRound}|{N}{f}| returns the start of the decimal expansion of the
fraction |f|, rounded to |N| digits precision after the decimal point. The
argument |N| should be non-negative. Only when |f| evaluates exactly to zero
does \csa{xintRound} return |0| without decimal point. When |f| is not zero, its
sign is given in the output, also when the digits printed are all zero.
\centeredline{|\xintRound {16}{-803.2028/20905.298}=|\texttt{\xintRound
    {16}{-803.2028/20905.298}}}% 
 \centeredline{|\xintRound
  {20}{-803.2028/20905.298}=|\texttt{\xintRound {20}{-803.2028/20905.298}}}%
 \centeredline{|\xintRound
  {10}{\xintPow {-11}{-11}}=|\texttt{\xintRound
  {10}{\xintPow {-11}{-11}}}}%
 \centeredline{|\xintRound
  {12}{\xintPow {-11}{-11}}=|\texttt{\xintRound
  {12}{\xintPow {-11}{-11}}}}%
\centeredline{|\xintRound {12}{\xintAdd {-1/3}{3/9}}=|\texttt{\xintRound
    {12}{\xintAdd {-1/3}{3/9}}}} 
The identity |\xintRound {N}{-f}=-\xintRound {N}{f}| holds. And regarding
$(-11)^{-11}$ here is some more or its expansion: 
\centeredline{\xintTrunc  {50}{\xintPow {-11}{-11}}\dots} 

\subsection{\csbh{xintiRound}}\label{xintiRound}

{\small New with release |1.04|.\par}

\csa{xintiRound}|{N}{f}| returns the integer equal to |10^N| times what
\csa{xintRound}|{N}{f}| would return. \centeredline{|\xintiRound
  {16}{-803.2028/20905.298}=|\texttt{\xintiRound {16}{-803.2028/20905.298}}}%
\centeredline{|\xintiRound {10}{\xintPow {-11}{-11}}=|\texttt{\xintiRound
    {10}{\xintPow {-11}{-11}}}}%
Differences between \csa{xintRound}|{0}{f}| and \csa{xintiRound}|{0}{f}|: 
the former cannot be used inside integer-only macros, and the 
latter removes the decimal point, and never returns |-0| (and of course removes
all superfluous leading zeros.)

\subsection{\csbh{xintAdd}}\label{xintAdd}

The original macro is extended to accept fractions on input. Its output will now
always be in the form |A/B[n]| or |A[n]|.
The original is available as \csb{xintiAdd}.

\subsection{\csbh{xintSub}}\label{xintSub}

The original macro is extended to accept fractions on input. Its output will now
always be in the form |A/B[n]| or |A[n]|.
The original is available as \csb{xintiSub}.

\subsection{\csbh{xintMul}}\label{xintMul}

The original macro is extended to accept fractions on input. Its output will now
always be in the form |A/B[n]| or |A[n]|. 
The original is available as \csb{xintiMul}.

\subsection{\csbh{xintSqr}}\label{xintSqr}

The original macro is extended to accept a fraction on input. Its output will
now always be in the form |A/B[n]| or |A[n]|. The original is available as
\csb{xintiSqr}.

\subsection{\csbh{xintPow}}\label{xintPow}

The original macro is extended to accept a fraction on input (the exponent must
be a signed integer of course). Its output will now always be in the form
|A/B[n]| or |A[n]|. The original is available as \csb{xintiPow}.

\subsection{\csbh{xintSum}, \csbh{xintSumExpr}}\label{xintSum}\label{xintSumExpr}

The original commands are extended to accept fractions on input and produce
fractions on output. Their outputs will now always be in the form |A/B[n]| or
|A[n]|. The originals are available as \csa{xintiSum} and \csa{xintiSumExpr}.


\subsection{\csbh{xintPrd}, \csbh{xintProductExpr}}\label{xintPrd}\label{xintProductExpr}

The originals are extended to accept fractions on input and produce fractions on
output. Their outputs will now always be in the form |A/B[n]| or |A[n]|. The
originals are available as \csa{xintiPrd} and \csa{xintiPrdExpr}.

\subsection{\csbh{xintDiv}}\label{xintDiv}

\csa{xintDiv}|{f}{g}| computes the fraction |f/g|. As with all other computation
macros, no simplification is done on the output, which is in the form |A/B[n]|
or |A[n]|.

\subsection{\csbh{xintCmp}}\label{xintCmp}

The macro is extended to fractions. Of course its output is still either
|-1|, |0|, or |1| with no forward slash nor trailing |[n]|. 
The original, which skips the overhead of
the fraction format parsing, is available as \csb{xintiCmp}.

\subsection{\csbh{xintMax}}\label{xintMax}

The macro is extended to fractions. But now |\xintMax {2}{3}| returns
\texttt{\xintMax {2}{3}}. The original is available as
\csb{xintiMax}.

\subsection{\csbh{xintMin}}\label{xintMin}

The macro is extended to fractions. The original is available as
\csb{xintiMin}.

\subsection{\csbh{xintAbs}}\label{xintAbs}

The macro is extended to fractions. The original is available as
\csb{xintiAbs}. Note that |\xintAbs {-2}=|\texttt{\xintAbs {-2}} whereas
|\xintiAbs {-2}=|\texttt{\xintiAbs {-2}}.

\subsection{\csbh{xintSgn}}\label{xintSgn}

The macro is extended to fractions. Of course its output is still either
|-1|, |0|, or |1| with no forward slash nor trailing |[n]|. The
original, which skips the overhead of the fraction format parsing, is
available as \csb{xintiSgn}.

\subsection{\csbh{xintOpp}}\label{xintOpp}

The macro is extended to fractions. The original is available as
\csb{xintiOpp}. Note that |\xintOpp {3}| now outputs \texttt{\xintOpp {3}}.

\subsection{\csbh{xintGeq},~\csbh{xintDivision},~\csbh{xint\-Quo},~\csbh{xint\-Rem},~\csbh{xintFDg},~\csbh{xintLDg},~\csbh{xintMON},~\csbh{xintMMON}}

These macros are extended to accept a fraction on input if this fraction
in fact reduces to an integer (if not an |\xintError:NotAnInteger| will
be raised). As usual, the `{\color{blue}i}' variants all exist, they
accept on input only integers in the strict format and have less
overhead. There is no difference in the output, the difference is only
in the accepted format for the inputs.

\subsection{\csbh{xintNum}}\label{xintNum}

The macro is extended to accept a fraction on input. But this fraction should
reduce to an integer. If not an error will be raised. The original is available
as \csb{xintiNum}.



\section{Commands of the \xintseriesname package}\label{sec:series}

There will be some exceptions to the general rule that
each macro first double-expands each one of its arguments. This package was
first released with version |1.03| of the \xintname bundle.

\subsection{\csbh{xintSeries}}\label{xintSeries}

\def\coeff #1{\romannumeral0\xintimon{#1}/#1.5} % (-1)^n/(n+1/2)
\edef\w {\xintSeries {0}{50}{\coeff}}
\edef\z {\xintJrr {\w}[0]}

\csa{xintSeries}|{A}{B}{\coeff}| evaluates the sum of all values of the |\coeff
{n}| from |n=A| to and including |n=B|. The initial and final indices must
(after double-expansion) obey the \TeX{} and |\numexpr| constraint of being
explicit numbers at most |2^31-1| (these conditions are not checked by
the macro). The |\coeff| macro (which, as argument to \csa{xintSeries} is
double-expanded only at the time of computing the successive |\coeff {n}|)
should be defined as a one-parameter command, accepting on input a number (not a
count register) and needing at most two expansions to compute its final result.
\begin{verbatim}
\def\coeff #1{\romannumeral0\xintimon{#1}/#1.5} % (-1)^n/(n+1/2)
\edef\w {\xintSeries {0}{50}{\coeff}} % we want to re-use it
\edef\z {\xintJrr {\w}[0]}            % the [0] for a microsecond gain.  
% \xintJrr preferred to \xintIrr: a big common factor is suspected.
% But numbers much bigger would be needed to show the greater efficiency.
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} = \xintFrac\z \]
\end{verbatim}
\vspace*{-.5\baselineskip}
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} = \xintFrac\z \] For info,
before action by |\xintJrr| the inner representation of the result has a
denominator of |\xintLen {\xintDenominator\w}=|\xintLen
{\xintDenominator\w} digits. This troubled me as &101!!& has only 81
digits: |\xintLen {\xintQuo {\xintFac {101}}{\xintiMul {\xintiPow
      {2}{50}}{\xintFac{50}}}}=|\texttt{\xintLen {\xintQuo {\xintFac
      {101}}{\xintiMul {\xintiPow {2}{50}}{\xintFac{50}}}}}. The
explanation lies in the too clever to be efficient |#1.5| trick. It
leads to a silly extra &5^{51}& (which has \xintLen {\xintPow {5}{51}}
digits) in the denominator. See the explanations in the next section.

\begin{framed}
  Note: as soon as the coefficients look like factorials, it is more
  efficient to use the \csb{xintRationalSeries} macro whose evaluation
  will avoid a denominator build-up; indeed the raw operations of
  addition and subtraction of fractions blindly multiply out
  denominators. So the raw evaluation of $\sum_{n=0}^{|N|}1/n!$ with
  \csa{xintSeries} will have a denominator equal to $\prod_{n=0}^{|N|}
  n!$. Needless to say this makes it more difficult to compute the exact
  value of this sum with |N=50|, for example, whereas with
  \csb{xintRationalSeries} the denominator does not
  get bigger than $50!$.

\footnotesize
  For info: by the way $\prod_{n=0}^{50} n!$ is easily computed by \xintname
  and is a number with 1394 digits. And $\prod_{n=0}^{100} n!$ is also
  computable by \xintname (24 seconds on my laptop for the brute force
  iterated multiplication of all factorials, a
  specialized routine would do it faster) and has 6941 digits (this
  means more than two pages if printed...). Whereas $100!$ only has
  158 digits.
\end{framed}

% \newcount\cntb
% \cnta 2
% \loop
% \advance\cntb by \xintLen{\xintFac{\the\cnta}}%
% \ifnum\cnta < 50
% \advance\cnta 1
% \repeat
% \the\cntb

% \cnta 2
% \def\z{1}
% \pdfresettimer
% \loop
% \edef\z {\xintiMul\z{\xintFac{\the\cnta}}}%
% \ifnum\cnta < 100
% \advance\cnta 1
% \repeat
% \edef\temps{\the\pdfelapsedtime}%

% \temps: \xintQuo\temps{\xintiMul{60}{65536}} minutes, 
% \xintQuo{\xintRem\temps{\xintiMul{60}{65536}}}{65536} secondes et 
% \xintiTrunc {2}{\xintRem\temps{65536}/65536} centièmes de secondes
% 1573518: 0 minutes, 24 secondes et 0 centièmes de secondes
% nota bene, marrant c'était 0,99 centièmes en fait.

% \xintLen\z

% \printnumber\z

\setlength{\columnsep}{0pt}
\begin{verbatim}
\def\coeffleibnitz #1{\the\numexpr\ifodd #1 1\else-1\fi\relax/#1[0]}
\cnta 1
\loop  % in this loop we recompute from scratch each partial sum! 
% we can afford that, as \xintSeries is fast enough.
\noindent\hbox to 2em{\hfil\texttt{\the\cnta.} }%  
         \xintTrunc {12}
                    {\xintSeries {1}{\the\cnta}{\coeffleibnitz}}\dots
\endgraf
\ifnum\cnta < 30 \advance\cnta 1 \repeat
\end{verbatim}
\begin{multicols}{3}
  \def\coeffleibnitz #1{\the\numexpr\ifodd #1 1\else-1\fi\relax/#1[0]} \cnta 1
  \loop
  \noindent\hbox to 2em{\hfil\texttt{\the\cnta.} }% 
  \xintTrunc {12}{\xintSeries {1}{\the\cnta}{\coeffleibnitz}}\dots
    \endgraf
    \ifnum\cnta < 30 \advance\cnta 1 \repeat
\end{multicols}

\subsection{\csbh{xintiSeries}}\label{xintiSeries}

\def\coeff #1{\romannumeral0\xintitrunc {40}
   {\the\numexpr\ifodd #1 -2\else2\fi\relax/\the\numexpr 2*#1+1\relax [0]}}% 

\csa{xintiSeries}|{A}{B}{\coeff}| evaluates the sum of |\coeff
{n}| from |n=A| to and including |n=B|. The initial and final indices must
(after double-expansion) be explicit numbers at most |2^31-1| (these conditions
are not checked by the macro). The 
|\coeff| macro (which, as argument to \csa{xintiSeries} is double-expanded only
at the time of computing |\coeff {n}|) should be defined as a
one-parameter command, accepting on input a number (not a count register) and
needing at most two expansions to compute its final result, \emph{which must be
  an integer}, in the format understood by the integer-only
\csa{xintiAdd}.
\begin{verbatim}
\def\coeff #1{\romannumeral0\xintitrunc {40}{\xintMON{#1}/#1.5}}%
% better:
\def\coeff #1{\romannumeral0\xintitrunc {40}
        {\the\numexpr 2*\xintiMON{#1}\relax/\the\numexpr 2*#1+1\relax [0]}}% 
% better still:
\def\coeff #1{\romannumeral0\xintitrunc {40}
   {\the\numexpr\ifodd #1 -2\else2\fi\relax/\the\numexpr 2*#1+1\relax [0]}}% 
% (-1)^n/(n+1/2) times 10^40, truncated to an integer.
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} \approx
        \xintTrunc {40}{\xintiSeries {0}{50}{\coeff}[-40]}\dots\]
\end{verbatim}
The |#1.5| trick to define the |\coeff| macro was neat, but |1/3.5|, for
example, turns internally into |10/35| whereas it would be more efficient to
have |2/7|. The second way of coding the wanted coefficient avoids a superfluous
factor of five and leads to a faster evaluation. The third way is faster, after
all there is no need to use \csb{xintMON} (or rather \csb{xintiMON}) on integers
obeying the \TeX{} bound. The denominator having no sign, we have added the
|[0]| as this speeds up (infinitesimally) the parsing.
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} \approx \xintTrunc
{40}{\xintiSeries {0}{50}{\coeff}[-40]}\] We should have cut out at
least the last two digits: truncating errors originating with the first
coefficients of the sum will never go away, and each truncation
introduces an uncertainty in the last digit, so as we have 40 terms, we
should trash the last two digits, or at least round at 38 digits. It is
interesting to compare with the computation where rounding rather than
truncation is used, and with the decimal
expansion of the exactly computed partial sum of the series:
\begin{verbatim}
\def\coeff #1{\romannumeral0\xintiround {40} % rounding at 40
  {\the\numexpr\ifodd #1 -2\else2\fi\relax/\the\numexpr 2*#1+1\relax [0]}}% 
% (-1)^n/(n+1/2) times 10^40, rounded to an integer.
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} \approx
        \xintTrunc {40}{\xintiSeries {0}{50}{\coeff}[-40]}\]
\def\exactcoeff #1%
  {\the\numexpr\ifodd #1 -2\else2\fi\relax/\the\numexpr 2*#1+1\relax [0]}%
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} 
   = \xintTrunc {50}{\xintSeries {0}{50}{\exactcoeff}}\dots\]
\end{verbatim}
\def\coeff #1{\romannumeral0\xintiround {40}
   {\the\numexpr\ifodd #1 -2\else2\fi\relax/\the\numexpr 2*#1+1\relax [0]}}% 
% (-1)^n/(n+1/2) times 10^40, rounded to an integer.
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} \approx
        \xintTrunc {40}{\xintiSeries {0}{50}{\coeff}[-40]}\]
\def\exactcoeff #1%
  {\the\numexpr\ifodd #1 -2\else2\fi\relax/\the\numexpr 2*#1+1\relax [0]}%
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} 
   = \xintTrunc {50}{\xintSeries {0}{50}{\exactcoeff}}\dots\]
This shows indeed that our sum of truncated terms
estimated wrongly the 39th and 40th digits of the exact result\footnote{as
  the series 
  is alternating, we can roughly expect an error of $\sqrt{40}$ and the
  last two digits are off by 4 units, which is not contradictory to our
  expectations.} and that the sum of rounded terms fared a bit better. 

\subsection{\csbh{xintRationalSeries}}\label{xintRationalSeries}

{\small New with release |1.04|.\par}

\csa{xintRationalSeries}|{A}{B}{f}{\ratio}| evaluates the sum of
|F(n)|\footnote{the macro is designed to be useful when |F(n)/F(n-1)| is a
  rational function of |n| but it may be used of course with any sort of general
  term.} from |n=A| up to and including |n=B|, with the parameter |f| being (or
expanding in two steps to) the value |F(A)| and |\ratio| being a one-parameter
command, accepting on input a number |n| (not a count register, but also obeying
the constraint of having value at most |2^31-1|) and producing after at most two
expansions |F(n)/F(n-1)|. The initial and final indices must (after
double-expansion) obey the \TeX{} and |\numexpr| constraint of being explicit
numbers at most |2^31-1| (these conditions are not checked by the macro).
\begin{verbatim}
\def\ratio #1{2/#1[0]}% 2/n, comes from the series of exp(2)
\cnta 0 % previously declared count
\loop   
\edef\z {\xintRationalSeries {0}{\the\cnta}{1}{\ratio }}% 
\noindent$\sum_{n=0}^{\the\cnta} \frac{2^n}{n!}= 
           \xintTrunc{12}\z\dots=
           \xintFrac\z=\xintFrac{\xintIrr\z}$\vtop to 5pt{}\endgraf
\ifnum\cnta<20 \advance\cnta 1 \repeat
\end{verbatim}
\def\ratio #1{2/#1[0]}% 2/n, comes from the series of exp(2)
\cnta 0
\loop
\edef\z {\xintRationalSeries {0}{\the\cnta}{1}{\ratio }}%
\noindent$\sum_{n=0}^{\the\cnta} \frac{2^n}{n!}= 
           \xintTrunc{12}\z\dots=
           \xintFrac\z=\xintFrac{\xintIrr\z}$\vtop to 5pt{}\endgraf
\ifnum\cnta<20 \advance\cnta 1 \repeat

\medskip
Such computations would become quickly completely inaccessible via the
\csb{xintSeries} macros, as the factorials in the denominators would get
all multiplied together: the raw addition and subtraction on fractions
just blindly multiplies denominators! Whereas \csa{xintRationalSeries}
evaluate the partial sums via a less silly iterative scheme. 
\vspace*{-.5\baselineskip}
\begin{verbatim}
\def\ratio #1{-1/#1[0]}% -1/n, comes from the series of exp(-1)
\cnta 0 % previously declared count
\loop   
\edef\z {\xintRationalSeries {0}{\the\cnta}{1}{\ratio }}% 
\noindent$\sum_{n=0}^{\the\cnta} \frac{(-1)^n}{n!}= 
           \xintTrunc{20}\z\dots=\xintFrac{\z}=\xintFrac{\xintIrr\z}$
         \vtop to 5pt{}\endgraf
\ifnum\cnta<20 \advance\cnta 1 \repeat
\end{verbatim}
\def\ratio #1{-1/#1[0]}% -1/n, comes from the series of exp(-1)
\cnta 0 % previously declared count

\loop   
\edef\z {\xintRationalSeries {0}{\the\cnta}{1}{\ratio }}% 
\noindent$\sum_{n=0}^{\the\cnta} \frac{(-1)^n}{n!}= 
           \xintTrunc{20}\z\dots=\xintFrac{\z}=\xintFrac{\xintIrr\z}$
         \vtop to 5pt{}\endgraf
\ifnum\cnta<20 \advance\cnta 1 \repeat


 \def\ratioexp #1#2{\romannumeral0\xintdiv{#1}{#2}}% #1/#2

\medskip We can incorporate an indeterminate if we define |\ratio| to be
a macro with two parameters: |\def\ratioexp
  #1#2{\romannumeral0\xintdiv{#1}{#2}}|\texttt{\%}| x/n: x=#1, n=#2|.
Then, if |\x| expands (in two steps at most) to some fraction |x|, the
command \centeredline{|\xintRationalSeries {0}{b}{1}{\ratioexp{\x}}|}
will compute $\sum_{n=0}^{n=b} x^n/n!$:\par
\vspace*{-.5\baselineskip}
\begin{verbatim}
\cnta 0
\def\ratioexp #1#2{\romannumeral0\xintdiv{#1}{#2}}% #1/#2
\loop
\noindent
$\sum_{n=0}^{\the\cnta} (.57)^n/n! = \xintTrunc {50}
     {\xintRationalSeries {0}{\the\cnta}{1}{\ratioexp{.57}}}\dots$
     \vtop to 5pt {}\endgraf
\ifnum\cnta<50 \advance\cnta 10 \repeat
\end{verbatim}

\cnta 0
\loop
\noindent
$\sum_{n=0}^{\the\cnta} (.57)^n/n! = \xintTrunc {50}
     {\xintRationalSeries {0}{\the\cnta}{1}{\ratioexp{.57}}}\dots$
     \vtop to 5pt {}\endgraf
\ifnum\cnta<50 \advance\cnta 10 \repeat
Observe that in this last example the |x| was directly inserted; if it
had been a more complicated explicit fraction it would have been
worthwile to use |\ratioexp\x| with |\x| defined to expand to its value.
In the further situation where this fraction |x| is not explicit but
itself defined via a complicated, and time-costly, formula, it should be
noted that \csa{xintRationalSeries} will do again the evaluation of |\x|
for each term of the partial sum. The easiest is thus when |x| can be
defined as an |\edef|. If however, you are in an expandable-only context
and cannot store in a macro like |\x| the value to be used, a variant of
\csa{xintRationalSeries} is needed which will first evaluate this |\x| and then
use this result without recomputing it. This is \csb{xintRationalSeriesX},
documented next.

Here is a slightly more complicated evaluation:
\begin{verbatim}
\cnta 1
\loop \edef\z {\xintRationalSeries 
                   {\the\cnta}
                   {\the\numexpr 2*\cnta-1\relax} 
                   {\xintiPow {\the\cnta}{\the\cnta}/\xintFac{\the\cnta}}
                   {\ratioexp{\the\cnta}}}%
\edef\w {\xintRationalSeries {0}{\the\numexpr 2*\cnta-1\relax}{1}
                             {\ratioexp{\the\cnta}}}%
\noindent
$\sum_{n=\the\cnta}^{\the\numexpr 2*\cnta-1\relax} \frac{\the\cnta^n}{n!}/%
          \sum_{n=0}^{\the\numexpr 2*\cnta-1\relax} \frac{\the\cnta^n}{n!} =
          \xintTrunc{8}{\xintDiv\z\w}\dots$ \vtop to 5pt{}\endgraf
\ifnum\cnta<20 \advance\cnta 1 \repeat
\end{verbatim}
\cnta 1
\begin{multicols}{2}
\loop \edef\z {\xintRationalSeries 
                   {\the\cnta}
                   {\the\numexpr 2*\cnta-1\relax} 
                   {\xintiPow {\the\cnta}{\the\cnta}/\xintFac{\the\cnta}}
                   {\ratioexp{\the\cnta}}}%
\edef\w {\xintRationalSeries {0}{\the\numexpr 2*\cnta-1\relax}{1}
                             {\ratioexp{\the\cnta}}}%
\noindent$\sum_{n=\the\cnta}^{\the\numexpr 2*\cnta-1\relax} \frac{\the\cnta^n}{n!}/%
          \sum_{n=0}^{\the\numexpr 2*\cnta-1\relax} \frac{\the\cnta^n}{n!} =
          \xintTrunc{8}{\xintDiv\z\w}\dots$ \vtop to 5pt{}\endgraf
\ifnum\cnta<20 \advance\cnta 1 \repeat
\end{multicols}

\subsection{\csbh{xintRationalSeriesX}}\label{xintRationalSeriesX}

{\small New with release |1.04|.\par}

\csa{xintRationalSeriesX}|{A}{B}{\first}{\ratio}{\x}| evaluates the sum of
|F(n,x)| from |n=A| up to and including |n=B|, where |\x| expands in two
steps at most to a fraction |x|, |\first| is a one-parameter macro such that
|\first{\x}| expands in two steps at most to the first term |F(A,x)| of the
series, and |\ratio| is a two parameter macro such that |\ratio{\x}{n}|
expands in two steps at most to the ratio |F(n,x)/F(n-1,x)|. Thus, this
is a parametrized version of \csa{xintRationalSeries}, where the
parameter |\x| is evaluated only once at the beginning of the
computation, and can thus itself be the yet unevaluated result of a
previous computation. 

Note the subtle differences between 
\centeredline{|\xintRationalSeries {a}{b}{\first}{\ratio{\x}}|}%
\centeredline{|\xintRationalSeriesX {a}{b}{\first}{\ratio}{\x}|}
First the location of braces differ... then, in the first one
|\first| is a macro expanding to a fractional number, but in the |X|
one, it is a one-parameter macro which will use |\x|. The |\ratio| macro
is in both cases a two-parameters macro, the difference is that in the
|X| variant the |\x| will be evaluated at the very beginning whereas the
former variant replaces it by its evaluation each time it needs it
(which is bad if this evaluation is time-costly, but good if it just a big
explicit fraction encapsulated in a macro).


The example will use the macro \csb{xintPowerSeries} which computes
efficiently exact partial sums of power series, and is discussed in the
next section.
\begin{verbatim}
\def\firstterm #1{1[0]}% first term of the exponential series
% although it is the constant 1, here it must be defined as a
% one-parameter macro. Next comes the ratio function for exp:
\def\ratioexp  #1#2{\romannumeral0\xintdiv {#1}{#2}}% x/n
% These are the (-1)^{n-1}/n of the log(1+h) series:
\def\coefflog #1{\the\numexpr\ifodd #1 1\else-1\fi\relax/#1[0]}% 
% Let L(h) be the first 10 terms of the log(1+h) series and
% let E(t) be the first 10 terms of the exp(t) series.
% The following computes E(L(a/10)) for a=1,...,12.
\cnta 0
\loop
\noindent\xintTrunc {18}{%
     \xintRationalSeriesX {0}{9}{\firstterm}{\ratioexp}
         {\xintPowerSeries{1}{10}{\coefflog}{\the\cnta[-1]}}}\dots 
\endgraf
\ifnum\cnta < 12 \advance \cnta 1 \repeat
\end{verbatim}

\def\firstterm #1{1[0]}% first term of the exponential series
% although it is the constant 1, here it must be defined as a
% one-parameter macro. Next comes the ratio function for exp:
\def\ratioexp  #1#2{\romannumeral0\xintdiv {#1}{#2}}% x/n
% These are the (-1)^{n-1}/n of the log(1+h) series
\def\coefflog #1{\the\numexpr\ifodd #1 1\else-1\fi\relax/#1[0]}% 
% Let L(h) be the first 10 terms of the log(1+h) series and
% let E(t) be the first 10 terms of the exp(t) series.
% The following computes E(L(a/12)) for a=1,..., 12.
\begin{multicols}{3}\raggedcolumns
  \cnta 1
  \loop
  \noindent\xintTrunc {18}{%
            \xintRationalSeriesX {0}{9}{\firstterm}{\ratioexp}
    {\xintPowerSeries{1}{10}{\coefflog}{\the\cnta[-1]}}}\dots
  \endgraf
  \ifnum\cnta < 12 \advance \cnta 1 \repeat
\end{multicols}
  % to see how they look like...
  % \loop
  % \noindent\printnumber{%
  %   \xintRationalSeriesX {0}{9}{\firstterm}{\ratioexp}
  %   {\xintPowerSeries{1}{10}{\coefflog}{\the\cnta[-2]}}}\dots
  % \endgraf
  % \ifnum\cnta < 60 \advance \cnta 1 \repeat

These completely exact operations rapidly create numbers with many digits. Let
us print in full the raw fractions created by the operation illustrated above:

\edef\z{\xintRationalSeriesX {0}{9}{\firstterm}
{\ratioexp}{\xintPowerSeries{1}{10}{\coefflog}{1[-1]}}}

|E(L(1[-1]))=|\printnumber{\z} (length of numerator:
\xintLen {\xintNumerator \z})

\edef\z{\xintRationalSeriesX {0}{9}{\firstterm}
{\ratioexp}{\xintPowerSeries{1}{10}{\coefflog}{12[-2]}}}

|E(L(12[-2]))=|\printnumber{\z} (length of numerator:
\xintLen {\xintNumerator \z})

\edef\z{\xintRationalSeriesX {0}{9}{\firstterm}
{\ratioexp}{\xintPowerSeries{1}{10}{\coefflog}{123[-3]}}}

|E(L(123[-3]))=|\printnumber{\z} (length of numerator:
\xintLen {\xintNumerator \z})


We see that the denominators here remain the same, as our input only had various
powers of ten as denominators, and \xintfracname efficiently assemble (some
only, as we can see) powers of ten. Notice that 1 more digit in an input
denominator seems to mean 90 more in the raw output. We can check that with some
other test cases:


\edef\z{\xintRationalSeriesX {0}{9}{\firstterm}
{\ratioexp}{\xintPowerSeries{1}{10}{\coefflog}{1/7}}}

|E(L(1/7))=|\printnumber{\z} (length of numerator:
\xintLen {\xintNumerator \z}; length of denominator:
\xintLen {\xintDenominator \z})

\edef\z{\xintRationalSeriesX {0}{9}{\firstterm}
{\ratioexp}{\xintPowerSeries{1}{10}{\coefflog}{1/71}}}

|E(L(1/71))=|\printnumber{\z} (length of numerator:
\xintLen {\xintNumerator \z}; length of denominator:
\xintLen {\xintDenominator \z})


\edef\z{\xintRationalSeriesX {0}{9}{\firstterm}
{\ratioexp}{\xintPowerSeries{1}{10}{\coefflog}{1/712}}}

|E(L(1/712))=|\printnumber{\z} (length of numerator:
\xintLen {\xintNumerator \z}; length of denominator:
\xintLen {\xintDenominator \z})

% \pdfresettimer
% \edef\w{\xintDenominator{\xintIrr{\z}}}
% \the\pdfelapsedtime

For info the last fraction put into irreducible form still has 288 digits in its
denominator.\footnote{putting this fraction in irreducible form takes more time
  than is typical of the other computations in this document; so exceptionally I
  have hard-coded the 288 in the document source.} The first conclusion is that decimal numbers such as |0.123| (equivalently
|123[-3]|) give less computing intensive tasks than fractions such as |1/712|:
in the case of decimal numbers the (raw) denominators originate in the
coefficients of the series themselves, powers of ten of the input within
brackets being treated separately. The second conclusion is that even then the
numerators will grow with the size of the input in a sort of linear way, the
coefficient being given by the order of series: here 10 from the log and 9 from
the exp, so 90. One more digit in the input means 90 more digits in the
numerator of the output: obviously we can not go on composing such partial sums
of series and hope that \xintname will joyfully do all at the speed of light!
Briefly said, imagine that the rules of the game make the programmer like a
security guard at an airport scanning machine: a never-ending flux of passengers
keep on arriving and all you can do is re-shuffle the first nine of them,
organize marriages among some, execute some, move children farther back among
the first nine only. If a passenger comes along with many hand luggages, this
will slow down the process even if you move him to ninth position, because
sooner or later you will have to digest him, and the children will be big too.
There is no way to move some guy out of the file and to a discrete interrogatory
room for separate treatment or to give him/her some badge saying ``I left my
stuff in storage box 357''.

Hence, truncating the output (or better, rounding) is the only way to go if one
needs a general calculus of special functions. Floating point representation of
numbers is currently unimplemented in \xintname. But fixed point computations
are available via the commands \csb{xintTrunc} and \csb{xintRound}.

\subsection{\csbh{xintPowerSeries}}\label{xintPowerSeries}

\csa{xintPowerSeries}|{A}{B}{\coeff}{x}| evaluates the sum of
|\coeff{n}|\raisebox{.5ex}{|.|}|x^n| from |n=A| up to and including |n=B|. The
initial and final indices must (after double-expansion) be
explicit numbers at most |2^31-1| (these
conditions are not checked by the macro). The |\coeff| macro (which, as argument
to \csa{xintPowerSeries} is double-expanded only at the time 
|\coeff{n}| is needed) should be defined as a one-parameter command, accepting
on input a number (not a count register) and needing at most two expansions to
compute its final result.

The |x| can be either a fraction directly input or a macro expanding in
at most two steps to such a fraction. It is actually more efficient to
encapsulate an explicit fraction |x| in such a macro (say |\x|), if it
has big numerators and denominators (`big' means hundreds of
digits) as it will then take less space in the processing until being
(repeatedly) used.

This macro computes the \emph{exact} result (one can use it also for
polynomial evaluation). With release |1.04| the Horner scheme for
polynomial evaluation is used, this avoids a denominator build-up which
was plaguing the |1.03| version. \footnote{with powers |x\string^k|,
  from |k=0| to |N|, a denominator |d| of |x| became
  |d\string^\string{1+2+\dots+N\string}|, which is bad. With the |1.04|
  method, the part of the denominator originating from |x| does not
  accumulate to more than |d\string^N|. }

\begin{framed}
  Note: as soon as the coefficients look like factorials, it is more efficient
  to use the \csb{xintRationalSeries} macro whose evaluation, also based on a
  similar Horner scheme, will avoid a denominator build-up originating in the
  coefficients themselves.
\end{framed}

\begin{verbatim}
\def\geom #1{1[0]} % the geometric series
\def\x {5/17[0]}   
\[ \sum_{n=0}^{n=20} \Bigl(\frac 5{17}\Bigr)^n 
 =\xintFrac{\xintIrr{\xintPowerSeries {0}{20}{\geom}{\x}}}
 =\xintFrac{\xintiSub{\xintiPow {17}{21}}{\xintiPow{5}{21}}%
                    /\xintiMul{12}{\xintiPow {17}{20}}}\]
% a parser for arbitrary algebraic expressions with the +,-,/,*,and ^
% operations would be dearly appreciated here ; implementing a completely
% expandable one would be quite a lot of work, even if we plagiarize l3fp!
\end{verbatim}
\def\geom #1{1[0]} % the geometric series
\def\x {5/17[0]}   %  
\[ \sum_{n=0}^{n=20} \Bigl(\frac 5{17}\Bigr)^n 
 =\xintFrac{\xintIrr{\xintPowerSeries {0}{20}{\geom}{\x}}}
 =\xintFrac{\xintiSub{\xintiPow {17}{21}}{\xintiPow{5}{21}}%
                    /\xintiMul{12}{\xintiPow {17}{20}}}\]

\begin{verbatim}
\def\coefflog #1{1/#1[0]}% 1/n
\def\x {1/2[0]}%
\[ \log 2 \approx \sum_{n=1}^{20} \frac1{n\cdot 2^n} 
    = \xintFrac {\xintIrr {\xintPowerSeries {1}{20}{\coefflog}{\x}}}\]
\[ \log 2 \approx \sum_{n=1}^{50} \frac1{n\cdot 2^n} 
    = \xintFrac {\xintIrr {\xintPowerSeries {1}{50}{\coefflog}{\x}}}\]
\end{verbatim}
\def\coefflog #1{1/#1[0]} % 1/n
\def\x {1/2[0]}%
\[ \log 2 \approx \sum_{n=1}^{20} \frac1{n\cdot 2^n} 
         = \xintFrac {\xintIrr {\xintPowerSeries
             {1}{20}{\coefflog}{\x}}}\]
\[ \log 2 \approx \sum_{n=1}^{50} \frac1{n\cdot 2^n} 
    = \xintFrac {\xintIrr {\xintPowerSeries {1}{50}{\coefflog}{\x}}}\]
\begin{verbatim}
\cnta 1 % previously declared count
\loop   % in this loop we recompute from scratch each partial sum! 
% we can afford that, as \xintPowerSeries is fast enough.
\noindent\hbox to 2em{\hfil\texttt{\the\cnta.} }% 
         \xintTrunc {12}
             {\xintPowerSeries {1}{\the\cnta}{\coefflog}{\x}}\dots
\endgraf
\ifnum \cnta < 30 \advance\cnta 1 \repeat
\end{verbatim}
\setlength{\columnsep}{0pt}
\begin{multicols}{3}
      \cnta 1 % previously declared count
      \loop % in this loop we recompute from scratch each partial sum!
% we can afford that, as \xintPowerSeries is fast enough.
\noindent\hbox to 2em{\hfil\texttt{\the\cnta.} }% 
         \xintTrunc {12}{\xintPowerSeries {1}{\the\cnta}{\coefflog}{\x}}\dots
\endgraf
\ifnum \cnta < 30 \advance\cnta 1 \repeat
\end{multicols}
\begin{verbatim}
%\def\coeffarctg #1{1/\the\numexpr\xintMON{#1}*(2*#1+1)\relax }% 
\def\coeffarctg  #1{1/\the\numexpr\ifodd #1 -2*#1-1\else2*#1+1\fi\relax }% 
% the above gives (-1)^n/(2n+1). The sign being in the denominator, 
%             **** no [0] should be added ****, 
% else nothing is guaranteed to work (even if it could by sheer luck)
% NOTE in passing this aspect of \numexpr: 
%         ****  \numexpr -(1)\relax does not work!!! ****
\def\x {1/25[0]}% 1/5^2
\[\mathrm{Arctg}(\frac15)\approx
            \frac15\sum_{n=0}^{15} \frac{(-1)^n}{(2n+1)25^n} 
= \xintFrac{\xintIrr {\xintDiv 
            {\xintPowerSeries {0}{15}{\coeffarctg}{\x}}{5}}}\]
\end{verbatim}
\def\coeffarctg #1{1/\the\numexpr\ifodd #1 -2*#1-1\else2*#1+1\fi\relax }% 
\def\x {1/25[0]}% 1/5^2
\[\mathrm{Arctg}(\frac15)\approx
            \frac15\sum_{n=0}^{15} \frac{(-1)^n}{(2n+1)25^n} 
= \xintFrac{\xintIrr {\xintDiv 
            {\xintPowerSeries {0}{15}{\coeffarctg}{\x}}{5}}}\]

\subsection{\csbh{xintPowerSeriesX}}\label{xintPowerSeriesX}

{\small New with release |1.04|.\par}

This is the same as \csb{xintPowerSeries} apart from the fact that the last
parameter (aka |x|), is first twice expanded. If the |x| parameter is to be an
explicit big fraction |f| with many (dozens) digits, rather than using
|f| directly it is slightly better to have some macro |\x| |\def'|ined to expand
to the explicit |f| and use \csb{xintPowerSeries}; but if |f| has not yet been
evaluated and will be the output of a complicated expansion of some |\x|, and
if, due to an expanding only context, an |\edef\z{\x}| is no option, then
\csa{xintPowerSeriesX} should be used with |\x| as last parameter. This |\x|
will be expanded (as usual, twice) and then its (explicit) output will be used.
The reason why \csa{xintPowerSeries} doesn't do the same is that explicit
fractions with many (dozens) digits slow down a bit the processing as
there is some shuffling of tokens going on. With \csa{xintPowerSeriesX} the
slowing down in token shuffling due to a very big fraction will not be avoided,
but the far worse cost of re-doing each time the computations leading to
such a fraction will be. The constraints of expandability make it impossible
to encapsulate the result of this initial computation in a macro and have the
best of both worlds.
\begin{verbatim}
\def\ratioexp  #1#2{\romannumeral0\xintdiv {#1}{#2}}% x/n
% These are the (-1)^{n-1}/n of the log(1+h) series:
\def\coefflog #1{\the\numexpr\ifodd #1 1\else-1\fi\relax/#1[0]}% 
% Let L(h) be the first 10 terms of the log(1+h) series and
% let E(t) be the first 10 terms of the exp(t) series.
% The following computes L(E(a/10)-1) for a=1,..., 12.
\cnta 1
\loop
\noindent\xintTrunc {18}{%
   \xintPowerSeriesX {1}{10}{\coefflog}
  {\xintSub
      {\xintRationalSeries {0}{9}{1[0]}{\ratioexp{\the\cnta[-1]}}}
      {1}}}\dots
\endgraf
\ifnum\cnta < 12 \advance \cnta 1 \repeat
\end{verbatim}
\cnta 0
\def\ratioexp  #1#2{\romannumeral0\xintdiv {#1}{#2}}% x/n
% These are the (-1)^{n-1}/n of the log(1+h) series
\def\coefflog #1{\the\numexpr\ifodd #1 1\else-1\fi\relax/#1[0]}% 
% Let L(h) be the first 10 terms of the log(1+h) series and
% let E(t) be the first 10 terms of the exp(t) series.
% The following computes L(E(a/10)-1) for a=1,..., 12.
\begin{multicols}{3}\raggedcolumns
\cnta 1
  \loop
  \noindent\xintTrunc {18}{%
     \xintPowerSeriesX {1}{10}{\coefflog}
    {\xintSub
        {\xintRationalSeries {0}{9}{1[0]}{\ratioexp{\the\cnta[-1]}}}
        {1}}}\dots
  \endgraf
  \ifnum\cnta < 12 \advance \cnta 1 \repeat
\end{multicols}


\subsection{\csbh{xintFxPtPowerSeries}}\label{xintFxPtPowerSeries}

\csa{xintFxPtPowerSeries}|{A}{B}{\coeff}{x}{D}| computes the sum of
|\coeff{n}|\raisebox{.5ex}{|.|}|x^n| from |n=A| to |n=B| with each term of the
series truncated to |D| digits after the decimal point. As usual, |A|
and |B| are first twice-expanded. Regarding |D| it will be twice-expanded each
time it will be used inside an \csa{xintTrunc}. The one-parameter macro |\coeff|
is similarly only expanded when it is used inside the computations. Idem for
|x|. If |x| itself is some complicated macro it is thus better to use the
variant \csb{xintFxPtPowerSeriesX} which expands it first and then uses the
result of that (double) expansion.

The current (|1.04|) implementation is: the first power |x^A| is
computed exactly, then \emph{truncated}. Then each successive power is
obtained from the previous one by multiplication by the exact value of
|x|, and truncated. And |\coeff{n}|\raisebox{.5ex}{|.|}|x^n| is obtained
from that by multiplying by |\coeff{n}| (untruncated) and then
truncating. Finally the sum is computed exactly. Apart from that
\csa{xintFxPtPowerSeries} (where |FxPt| means `fixed-point') is like
\csa{xintPowerSeries}.

\def\coeffexp #1{1/\xintFac {#1}[0]}% [0] for faster parsing
\def\x {-1/2[0]}%
\def\ApproxExp #1#2{\xintFxPtPowerSeries {0}{#1}{\coeffexp}{\x}{#2}}%
\newcount\cnta 

\noindent\begin{minipage}{0.3\linewidth}
\centeredline{$e^{-\frac12}\approx{}$}%
\cnta 0 
\loop
$\ApproxExp {\the\cnta}{20}$\\
\ifnum\cnta<19
\advance\cnta 1
\repeat\par
\end{minipage}
\hfil
\begin{minipage}{0.65\linewidth}
\ttfamily\hyphenchar\font-1
\begin{verbatim}
\def\coeffexp #1{1/\xintFac {#1}[0]}% 
\def\x {-1/2[0]}% [0] for faster parsing
\def\ApproxExp #1#2{\xintFxPtPowerSeries 
                 {0}{#1}{\coeffexp}{\x}{#2}}%
\cnta 0 % previously declared \count register
\loop
$\ApproxExp {\the\cnta}{20}$\\
% truncates 20 digits after decimal point
\ifnum\cnta<19
\advance\cnta 1
\repeat\par
% One should **not** trust the final digits,
% as the potential truncation errors of up to
% 10^{-20} per term accumulate and never
% disappear! (the effect is attenuated by the
% alternating signs in the series). We  can
% confirm that the last two digits (of our
% evaluation of the nineteenth partial sum)
% are wrong via the evaluation with more
% digits: 
\end{verbatim}
\end{minipage}

\centeredline{|\xintFxPtPowerSeries {0}{19}{\coeffexp}{\x}{25}=|}%
\centeredline{%
\xintFxPtPowerSeries {0}{19}{\coeffexp}{\x}{25}}

\texttt{\hyphenchar\font45 }

There should be a variant for things of the
type $\sum c_n \frac {x^n}{n!}$ to avoid having to compute the factorial
from scratch at each coefficient, the same way \csa{xintFxPtPowerSeries}
does not compute |x^n| from scratch at each |n|. Perhaps in the next package
release.

\edef\z{\xintIrr {\xintPowerSeries {0}{19}{\coeffexp}{\x}}}

It is no difficulty for \xintfracname to compute exactly, with the help
of \csa{xintPowerSeries}, the nineteenth partial sum, and to then give
(the start of) its exact decimal expansion:
\centeredline{|\xintPowerSeries {0}{19}{\coeffexp}{\x}| ${}=
  \displaystyle\xintFrac{\z}$%
  \vphantom{\vrule height 20pt depth 12pt}}%
\centeredline{${}=\xintTrunc {30}{\z}\dots$} Thus, one should always
estimate a priori how many ending digits are not reliable: if there are
|N| terms and |N| has |k| digits, then digits up to but excluding the
last |k| may usually be trusted. If we are optimistic and the series is
alternating we may even replace |N| with $\sqrt{|N|}$ to get the number |k|
of digits possibly of dubious significance.


\subsection{\csbh{xintFxPtPowerSeriesX}}\label{xintFxPtPowerSeriesX}

{\small New with release |1.04|.\par}

\csa{xintFxPtPowerSeriesX}|{A}{B}{\coeff}{\x}{D}| computes, exactly as
\csa{xintFxPtPowerSeries}, the sum of
|\coeff{n}|\raisebox{.5ex}{|.|}|\x^n| from |n=A| to |n=B| with each term
of the series being \emph{truncated} to |D| digits after the decimal
point. The sole difference is that |\x| is first expanded (twice) and it
is the result of this which is used in the computations.

% Let us illustrate this on the computation of |(1+y)^{5/3}| where
% |1+y=(1+x)^{3/5}| and each of the two binomial series is evaluated with ten
% terms, the results being computed with |8| digits after the decimal point, and &|x|<1/10&.


Let us illustrate this on the numerical exploration of the identity
\centeredline{|log(1+x) = -log(1/(1+x))|}%
Let |L(h)=log(1+h)|, and |D(h)=L(h)+L(-h/(1+h))|. Theoretically thus,
|D(h)=0| but we shall evaluate |L(h)| and |-h/(1+h)| keeping only 10
terms of their respective series. We will assume &|h|<0.5&. With only
ten terms kept in the power series we do not have quite 3 digits
precision as &2^10=1024&. So it wouldn't make sense to evaluate things
more precisely than, say circa 5 digits after the decimal points.
\begin{verbatim}
\cnta 0
\def\coefflog #1{\the\numexpr\ifodd#1 1\else-1\fi\relax/#1[0]}% (-1)^{n-1}/n
\def\coeffalt #1{\the\numexpr\ifodd#1 -1\else1\fi\relax [0]}%   (-1)^n
\loop
\noindent \hbox to 2.5cm {\hss\texttt{D(\the\cnta/100): }}%
\xintAdd {\xintFxPtPowerSeriesX {1}{10}{\coefflog}{\the\cnta [-2]}{5}}
         {\xintFxPtPowerSeriesX {1}{10}{\coefflog} 
             {\xintFxPtPowerSeriesX {1}{10}{\coeffalt}{\the\cnta [-2]}{5}} 
          {5}}\endgraf 
\ifnum\cnta < 49 \advance\cnta 7 \repeat
\end{verbatim}

\cnta 0
\def\coefflog #1{\the\numexpr\ifodd#1 1\else-1\fi\relax/#1[0]}% (-1)^{n-1}/n
\def\coeffalt #1{\the\numexpr\ifodd#1 -1\else1\fi\relax [0]}%   (-1)^n


\begin{multicols}2
\loop
\noindent \hbox to 2.5cm {\hss\texttt{D(\the\cnta/100): }}%
\xintAdd {\xintFxPtPowerSeriesX {1}{10}{\coefflog}{\the\cnta [-2]}{5}}
         {\xintFxPtPowerSeriesX {1}{10}{\coefflog} 
             {\xintFxPtPowerSeriesX {1}{10}{\coeffalt}{\the\cnta [-2]}{5}} 
          {5}}\endgraf 
\ifnum\cnta < 49 \advance\cnta 7 \repeat
\end{multicols}

Let's say we evaluate functions on |[-1/2,+1/2]| with values more or less also
in |[-1/2,+1/2]| and we want to keep 4 digits of precision. So, roughly we need
at least 14 terms in series like the geometric or log series. Let's make this
15. Then it doesn't make sense to compute intermediate summands with more than 6
digits precision. So we compute with 6 digits
precision but return only 4 digits (rounded) after the decimal point.
This result with 4 post-decimal points precision is then used as input
to the next evaluation.
\begin{verbatim}
\loop
\noindent \hbox to 2.5cm {\hss\texttt{D(\the\cnta/100): }}%
\xintRound{4}
 {\xintAdd {\xintFxPtPowerSeriesX {1}{15}{\coefflog}{\the\cnta [-2]}{6}}
           {\xintFxPtPowerSeriesX {1}{15}{\coefflog} 
                  {\xintRound {4}{\xintFxPtPowerSeriesX {1}{15}{\coeffalt}
                                 {\the\cnta [-2]}{6}}} 
            {6}}%
 }\endgraf 
\ifnum\cnta < 49 \advance\cnta 7 \repeat
\end{verbatim}

\begin{multicols}2
\loop
\noindent \hbox to 2.5cm {\hss\texttt{D(\the\cnta/100): }}%
\xintRound{4}
 {\xintAdd {\xintFxPtPowerSeriesX {1}{15}{\coefflog}{\the\cnta [-2]}{6}}
           {\xintFxPtPowerSeriesX {1}{15}{\coefflog} 
                  {\xintRound {4}{\xintFxPtPowerSeriesX {1}{15}{\coeffalt}
                                 {\the\cnta [-2]}{6}}} 
            {6}}%
 }\endgraf 
\ifnum\cnta < 49 \advance\cnta 7 \repeat
\end{multicols}


Not bad... I have cheated a bit: the `four-digits precise' numeric
evaluations were left unrounded in the final addition. However the inner
rounding to four digits worked fine and made the next step faster than
it would have been with longer inputs. The morale is that one should not
use the raw results of \csa{xintFxPtPowerSeriesX} with the |D| digits
with which it was computed, as the last are to be considered garbage.
Rather, one should keep from the output only some smaller number of
digits. This will make further computations faster and not less precise.
I guess there should be some command to do this final truncating, or
better, rounding, at a given number |D'<D| of digits. Maybe for the next
release.



\subsection{Computing \texorpdfstring{$\log 2$}{log(2)} and \texorpdfstring{$\pi$}{pi}}\label{ssec:Machin}

In this final section, the use of \csb{xintFxPtPowerSeries} (and
\csb{xintPowerSeries}) will be
illustrated on the (expandable... why make things simple when it is so easy to
make them difficult!) computations of the first digits of the decimal expansion
of the familiar constants $\log 2$ and $\pi$.

Let us start with $\log 2$. We will get it from this formula (which is
left as an exercise): \centeredline{\texttt{log(2)=-2\,log(1-13/256)-%
  5\,log(1-1/9)}}%
The number of terms to be kept in the log series, for a desired
precision of |10^{-D}| was roughly estimated without much theoretical
analysis. Computing exactly the partial sums with \csa{xintPowerSeries}
and then printing the truncated values, from |D=0| up to |D=100| showed
that it worked in terms of quality of the approximation. Because of
possible strings of zeros or nines in the exact decimal expansion (in
the present case of $\log 2$, strings of zeros around the fourtieth and
the sixtieth decimals), this
does not mean though that all digits printed were always exact. In
the end one always end up having to compute at some higher level of
desired precision to validate the earlier result.

Then we tried with \csa{xintFxPtPowerSeries}: this is worthwile only for
|D|'s at least 50, as the exact evaluations are faster (with these
short-length |x|'s) for a lower
number of digits. And as expected the degradation in the quality of
approximation was in this range of the order of two or three digits.
This meant roughly that the 3+1=4 ending digits were wrong. Again, we ended
up having to compute with five more digits and compare with the earlier
value to validate it. We use truncation rather than rounding because our
goal is not to obtain the correct rounded decimal expansion but the
correct exact truncated one.

% 693147180559945309417232121458176568075500134360255254120680009493

\begin{verbatim}
\def\coefflog #1{1/#1[0]}% 1/n
\def\xa {13/256[0]}%  we will compute log(1-13/256)
\def\xb {1/9[0]}%     we will compute log(1-1/9)
\def\LogTwo #1%
%  get log(2)=-2log(1-13/256)- 5log(1-1/9) 
{% 
  \romannumeral0\expandafter\LogTwoDoIt \expandafter
    % Nb Terms for 1/9:
  {\the\numexpr #1*150/143\expandafter}\expandafter
    % Nb Terms for 13/256:
  {\the\numexpr #1*100/129\expandafter}\expandafter
    % We print #1 digits, but we know the ending ones are garbage
  {\the\numexpr #1\relax}% allows #1 to be a count register
}%
\def\LogTwoDoIt #1#2#3% 
%  #1=nb of terms for 1/9, #2=nb of terms for 13/256, 
{% #3=nb of digits for computations, also used for printing
 \xinttrunc {#3} % lowercase form to stop the \romannumeral0 expansion!
 {\xintAdd
  {\xintMul {2}{\xintFxPtPowerSeries {1}{#2}{\coefflog}{\xa}{#3}}}
  {\xintMul {5}{\xintFxPtPowerSeries {1}{#1}{\coefflog}{\xb}{#3}}}%
 }%
}%
\noindent $\log 2 \approx \LogTwo {60}\dots$\endgraf
\noindent\phantom{$\log 2$}${}\approx{}$\printnumber{\LogTwo {65}}\dots\endgraf
\noindent\phantom{$\log 2$}${}\approx{}$\printnumber{\LogTwo {70}}\dots\endgraf
\end{verbatim}
\def\coefflog #1{1/#1[0]}% 1/n
\def\xa {13/256[0]}% we will compute log(1-13/256)
\def\xb {1/9[0]}%    we will compute log(1-1/9)
\def\LogTwo #1% get log(2)=-2log(1-13/256)- 5log(1-1/9) with #1 digits precision
{% this #1 may be a count register, if desired
    \romannumeral0\expandafter\LogTwoDoIt \expandafter
    {\the\numexpr #1*150/143\expandafter}\expandafter % Nb Terms for 1/9
    {\the\numexpr #1*100/129\expandafter}\expandafter % Nb Terms for 13/256
    {\the\numexpr #1\relax }%
}% 
\def\LogTwoDoIt #1#2#3% #1=nb of terms for 1/9, #2=nb of terms for 13/256, 
{%                     #3=nb of digits for computations
  \xinttrunc {#3}
    {\xintAdd
      {\xintMul {2}{\xintFxPtPowerSeries {1}{#2}{\coefflog}{\xa}{#3}}}
      {\xintMul {5}{\xintFxPtPowerSeries {1}{#1}{\coefflog}{\xb}{#3}}}%
    }%
}%

\noindent $\log 2 \approx \LogTwo {60}\dots$\endgraf
\noindent\phantom{$\log 2$}${}\approx{}$\printnumber{\LogTwo {65}}\dots\endgraf
\noindent\phantom{$\log 2$}${}\approx{}$\printnumber{\LogTwo {70}}\dots\endgraf

Here is the code doing an exact evaluation of the partial sums. We have
added a |+1| to the number of digits for estimating the number of terms
to keep from the log series: we experimented that this gets exactly the
first |D| digits, for all values from |D=0| to |D=100|, except in one
case (|D=40|) where the last digit is wrong. For values of |D|
higher than |100| it is more efficient to use the code using
\csa{xintFxPtPowerSeries}. 
\begin{verbatim}
\def\LogTwo #1% get log(2)=-2log(1-13/256)- 5log(1-1/9)
{% 
    \romannumeral0\expandafter\LogTwoDoIt \expandafter
    {\the\numexpr (#1+1)*150/143\expandafter}\expandafter
    {\the\numexpr (#1+1)*100/129\expandafter}\expandafter
    {\the\numexpr #1\relax}%
}% 
\def\LogTwoDoIt #1#2#3%
{%   #3=nb of digits for truncating an EXACT partial sum
  \xinttrunc {#3}
    {\xintAdd
      {\xintMul {2}{\xintPowerSeries {1}{#2}{\coefflog}{\xa}}}
      {\xintMul {5}{\xintPowerSeries {1}{#1}{\coefflog}{\xb}}}%
    }%
}%
\end{verbatim}

Let us turn now to Pi, computed with the Machin formula. Again the
numbers of terms to keep in the two |arctg| series were roughly estimated,
and some experimentations showed that removing the last three
digits was enough (at least for |D=0-100| range). And the
algorithm does print the correct digits when used with |D=1000| (to be
convinced of that one needs to run it for |D=1000| and again, say for
|D=1010|.) A theoretical analysis could help confirm that this algorithm
always gets better than |10^{-D}| precision, but again, strings of zeros or nines
encountered in the decimal expansion may falsify the ending digits,
nines may be zeros (and the last non-nine one should be increased) and
zeros may be nine (and the last non-zero one should be decreased).
\begin{verbatim}
% pi = 16 Arctg(1/5) - 4 Arctg(1/239) (John Machin's formula)
\def\coeffarctg #1{\the\numexpr\ifodd#1 -1\else1\fi\relax/% 
                                       \the\numexpr 2*#1+1\relax [0]}% 
% the above computes (-1)^n/(2n+1).
% Alternatives: 
% \def\coeffarctg #1{1/\the\numexpr\xintiMON{#1}*(2*#1+1)\relax }%
% The [0] can *not* be used above, as the denominator is signed.
% \def\coeffarctg #1{\the\numexpr\xintiMON{#1}\relax/%
                                  \the\numexpr 2*#1+1\relax [0]}%
% \def\coeffarctg #1%
    {\romannumeral0\xintmon{#1}/\the\numexpr 2*#1+1\relax [0]}% 
\def\xa {1/25[0]}%      1/5^2, the [0] for faster parsing
\def\xb {1/57121[0]}% 1/239^2, the [0] for faster parsing
\def\Machin #1{% \Machin {\mycount} is allowed
    \romannumeral0\expandafter\MachinA \expandafter
     % number of terms for arctg(1/5):
    {\the\numexpr (#1+3)*5/7\expandafter}\expandafter 
     % number of terms for arctg(1/239):  
    {\the\numexpr (#1+3)*10/45\expandafter}\expandafter
     % do the computations with 4 additional digits:
    {\the\numexpr #1+3\expandafter}\expandafter
     % allow #1 to be a count register:
    {\the\numexpr #1\relax }}%
\def\MachinA #1#2#3#4% 
% #4: digits to keep after decimal point for final printing
% #3=#4+3: digits for evaluation of the necessary number of terms
% to be kept in the arctangent series, also used to truncate each
% individual summand.
{\xinttrunc {#4} % must be lowercase to stop \romannumeral0! 
 {\xintSub  
  {\xintMul {16/5}{\xintFxPtPowerSeries {0}{#1}{\coeffarctg}{\xa}{#3}}}
  {\xintMul {4/239}{\xintFxPtPowerSeries {0}{#2}{\coeffarctg}{\xb}{#3}}}%
 }}%
\[ \pi = \Machin {60}\dots \]
\end{verbatim}
\vspace*{-\baselineskip}
\def\coeffarctg #1{\the\numexpr\ifodd#1 -1\else1\fi\relax/% 
                                       \the\numexpr 2*#1+1\relax [0]}% 
%\def\coeffarctg #1{\romannumeral0\xintmon{#1}/\the\numexpr 2*#1+1\relax }% 
\def\xa {1/25[0]}%      1/5^2, the [0] for faster parsing
\def\xb {1/57121[0]}% 1/239^2, the [0] for faster parsing
\def\Machin #1{% #1 may be a count register, \Machin {\mycount} is allowed
    \romannumeral0\expandafter\MachinA \expandafter
     % number of terms for arctg(1/5):
    {\the\numexpr (#1+3)*5/7\expandafter}\expandafter 
     % number of terms for arctg(1/239):  
    {\the\numexpr (#1+3)*10/45\expandafter}\expandafter
     % do the computations with 4 additional digits:
    {\the\numexpr #1+3\expandafter}\expandafter
     % allow #1 to be a count register:
    {\the\numexpr #1\relax }}%
\def\MachinA #1#2#3#4% 
{\xinttrunc {#4} 
 {\xintSub  
  {\xintMul {16/5}{\xintFxPtPowerSeries {0}{#1}{\coeffarctg}{\xa}{#3}}}
  {\xintMul{4/239}{\xintFxPtPowerSeries {0}{#2}{\coeffarctg}{\xb}{#3}}}%
 }}%
\begin{framed}
  \[ \pi = \Machin {60}\dots \]
\end{framed}
Here is a variant|\MachinBis|,
which evaluates the partial sums \emph{exactly} using
\csa{xintPowerSeries}, before their final truncation. No need for a
``|+3|'' then.
\begin{verbatim}
\def\MachinBis #1{% #1 may be a count register,
% the final result will be truncated to #1 digits post decimal point
    \romannumeral0\expandafter\MachinBisA \expandafter
     % number of terms for arctg(1/5):
    {\the\numexpr #1*5/7\expandafter}\expandafter 
     % number of terms for arctg(1/239):  
    {\the\numexpr #1*10/45\expandafter}\expandafter
      % allow #1 to be a count register:
    {\the\numexpr #1\relax }}%
\def\MachinBisA #1#2#3% 
{\xinttrunc {#3} %
 {\xintSub  
   {\xintMul {16/5}{\xintPowerSeries {0}{#1}{\coeffarctg}{\xa}}}
   {\xintMul{4/239}{\xintPowerSeries {0}{#2}{\coeffarctg}{\xb}}}%
}}%
\end{verbatim}

\def\MachinBis #1{% #1 may be a count register,
% the final result will be truncated to #1 digits post decimal point
    \romannumeral0\expandafter\MachinBisA \expandafter
     % number of terms for arctg(1/5):
    {\the\numexpr #1*5/7\expandafter}\expandafter 
     % number of terms for arctg(1/239):  
    {\the\numexpr #1*10/45\expandafter}\expandafter
      % allow #1 to be a count register:
    {\the\numexpr #1\relax }}%
\def\MachinBisA #1#2#3% 
{\xinttrunc {#3} %
 {\xintSub  
   {\xintMul {16/5}{\xintPowerSeries {0}{#1}{\coeffarctg}{\xa}}}
   {\xintMul{4/239}{\xintPowerSeries {0}{#2}{\coeffarctg}{\xb}}}%
}}%

Let us use this variant for a loop showing the build-up of digits:
\begin{verbatim}
    \cnta 0 % previously declared \count register
    \loop
    \MachinBis{\cnta} \endgraf  % TeX's \loop does not accept \par
    \ifnum\cnta < 30 \advance\cnta 1 \repeat
\end{verbatim}
\begin{multicols}{2}
  \cnta 0 % previously declared \count register
  \loop \noindent
        \centeredline{\MachinBis{\cnta}}%
  \ifnum\cnta < 30
  \advance\cnta 1 \repeat
\end{multicols}


You want more digits and have some time? Copy the |\Machin|
code to a Plain \TeX{} or \LaTeX{} document loading \xintseriesname, and
compile:
\begin{verbatim}
\newwrite\outfile
\immediate\openout\outfile \jobname-out\relax
\immediate\write\outfile {\Machin {1000}}
\immediate\closeout\outfile
\end{verbatim}
This will create a file with the correct first 1000 digits of $\pi$
after the decimal point. On my laptop (a 2012 model) this took about 44 
seconds last time I tried (and for 200 digits it is less than 1 second).
As mentioned in the introduction, the file
\href{http://www.ctan.org/pkg/pi}{\color{niceone}pi.tex} by \textsc{D.
  Roegel} shows that orders of magnitude faster computations are
possible within \TeX{}, but recall our constraints of complete
expandability and be merciful, please.

% \newwrite\outfile
% \immediate\openout\outfile \jobname-out\relax
% \pdfresettimer
% \immediate\write\outfile {\Machin {1000}}
% \edef\temps{\the\pdfelapsedtime}
% \immediate\closeout\outfile

% \temps: \xintQuo\temps{\xintiMul{60}{65536}} minutes, 
% \xintQuo{\xintRem\temps{\xintiMul{60}{65536}}}{65536} secondes et 
% \xintiRound {2}{\xintRem\temps{65536}/65536} centiemes de secondes

% 2882370: 0 minutes, 43 secondes et 98 centiemes de secondes

% je l'ai déjà fait en 42 secondes...

\textbf{Why truncating rather than rounding?} One of our main competitors
on the market of scientific computing, a canadian product (not
encumbered with expandability constraints, and having barely ever heard
of \TeX{} ;-), prints numbers rounded in the last digit. Why didn't we
follow suit in the macros \csa{xintFxPtPowerSeries} and
\csa{xintFxPtPowerSeriesX}? To round at |D| digits, and excluding a
rewrite or cloning of the division algorithm which anyhow would add to
it some overhead in its final steps, \xintfracname needs to truncate at
|D+1|, then round. And rounding loses information! So, with more time
spent, we obtain a worst result than the one truncated at |D+1| (one
could imagine that additions and so on, done with only |D| digits, cost
less; true, but this is a negligeable effect per summand compared to the
additional cost for this term of having been truncated at |D+1| then
rounded). Rounding is the way to go when setting up algorithms to
evaluate functions destined to be composed one after the other: exact
algebraic operations with many summands and an |x| variable which is a
fraction are costly and create an even bigger fraction; replacing |x|
with a reasonable rounding, and rounding the result, is necessary to
allow arbitrary chaining.

But, for the
computation of a single constant, we are really interested in the exact
decimal expansion, so we truncate and compute more terms until the
earlier result gets validated. Finally if we do want the rounding we can
always do it on a value computed with |D+1| truncation.


\section{Commands of the \xintcfracname package} 

This package was first included in release |1.04| of the \xintname bundle. 

\subsection{Package overview}

A \emph{simple} continued fraction has coefficients
|[c0,c1,...,cN]| (usually called partial quotients, but I really
dislike this entrenched terminology), where |c0| is a positive or
negative integer and the others are positive integers. As we will
see it is possible with \xintcfracname to specify the coefficient
function |c:n->cn|. Note that the index then starts at zero as
indicated. With the |amsmath| macro |\cfrac| one can display such a
continued fraction as 
\[ c_0 + \cfrac{1}{c_1+\cfrac1{c_2+\cfrac1{c_3+\cfrac1{\ddots}}}}\]
Here is a concrete example:
\[ \xintFrac {208341/66317}=\xintCFrac {208341/66317}\] But the
difference with |amsmath|'s |\cfrac| is that this was input as
\centeredline{|\[ \xintFrac {208341/66317}=\xintCFrac
  {208341/66317} \]|} The command \csb{xintCFrac} produces in two
expansion steps the whole thing with the many chained |\cfrac|'s and all
necessary braces, ready to be printed, in math mode. This is \LaTeX{}
only and with the |amsmath| package (we shall mention another method for
Plain \TeX{} users of |amstex|).

A \emph{generalized} continued fraction has the same structure but
the numerators are not restricted to be ones, and numbers used in
the continued fraction may be arbitrary, also fractions,
irrationals, indeterminates. The \emph{centered} continued
fraction associated to a rational number is an
example:\centeredline{|\[ \xintFrac {915286/188421}=\xintGCFrac {\xintFtoCC
  {915286/188421}} \]|}
\[ \xintFrac {915286/188421}=\xintGCFrac {\xintFtoCC {915286/188421}}
=\xintCFrac {915286/188421}\] The command \csb{xintGCFrac}, contrarily to
\csb{xintCFrac}, does not compute anything, it just typesets. Here, it is the
command \csb{xintFtoCC} which did the computation of
the centered continued fraction of |f|. Its output has the `inline format'
described in the next paragraph. In the display, we also used \csa{xintCFrac}
(code not shown), for comparison of the two types of continued fractions.

A generalized continued fraction may be input `inline' as:
\centeredline{|a0+b0/a1+b1/a2+b2/...../a(n-1)+b(n-1)/an|}%
Fractions among the coefficients are allowed but they must be enclosed
within braces. Signed integers may be left without braces (but the |+|
signs are mandatory). Or, they may
be macros expanding (in two steps) to some number or fractional number.
\centeredline{|\xintGCFrac {1+-1/57+\xintPow {-3}{7}/\xintQuo {132}{25}}|}
\[ \xintFrac{\xintGCtoF  {1+-1/57+\xintPow {-3}{7}/\xintQuo {132}{25}}}=
   \xintGCFrac {1+-1/57+\xintPow {-3}{7}/\xintQuo {132}{25}}\]
The left hand side was obtained with the following code:
\centeredline{|\xintFrac{\xintGCtoF  {1+-1/57+\xintPow {-3}{7}/\xintQuo
      {132}{25}}}|}
It uses the macro \csb{xintGCtoF} to convert a generalized fraction from the
`inline format' to the fraction it evaluates to.

A simple continued fraction is a special case of a generalized continued
fraction and may be input as such to macros expecting the `inline format', for
example |-7+1/6+1/19+1/1+1/33|. There is a simpler comma separated format:
\centeredline{|\xintFrac{\xintCstoF{-7,6,19,1,33}}=\xintCFrac{\xintCstoF{-7,6,19,1,33}}|}
\[
\xintFrac{\xintCstoF{-7,6,19,1,33}}=\xintCFrac{\xintCstoF{-7,6,19,1,33}}\] This
comma separated format may also be used with fractions among the coefficients:
of course in that case, computing with \csb{xintFtoCs} from the resulting |f|
its real coefficients will give a new comma separated list
with only integers. This list has no spaces: the spaces in the display below
arise from the math mode processing.
\centeredline{|\xintFrac{1084483/398959}=[\xintFtoCs{1084483/398959}]|}
\[\xintFrac{1084483/398959}=[\xintFtoCs{1084483/398959}]\]
If one prefers other separators, one can use \csb{xintFtoCx} whose first
argument will be the separator to be used. 
\centeredline{|\xintFrac{2721/1001}=\xintFtoCx {+1/(}{2721/1001})\cdots)|}
\[\xintFrac{2721/1001}=\xintFtoCx {+1/(}{2721/1001})\cdots)\]
People using Plain \TeX{} and |amstex| can achieve the same effect as
|\xintCFrac| with:
|$$\xintFwOver{2721/1001}=\xintFtoCx {+\cfrac1\\ }{2721/1001}\endcfrac$$|

Using \csa{xintFtoCx} with first argument an empty pair of braces |{}| will
return the list of the coefficients of the continued fraction of |f|, without
separator, and each one enclosed in a pair of group braces. This can then be
manipulated by the non-expandable macro \csb{xintAssignArray} or the expandable
ones \csb{xintApply} and \csb{xintListWithSep}.

As a shortcut to using \csa{xintFtoCx} with separator |1+/|, there is
\csb{xintFtoGC}:
\centeredline{|2721/1001=\xintFtoGC {2721/1001}|}%
\centeredline{\texttt{2721/1001=\xintFtoGC {2721/1001}}}
Let us compare in that case with the output of \csb{xintFtoCC}:
\centeredline{|2721/1001=\xintFtoCC {2721/1001}|}%
\centeredline{\texttt{2721/1001=\xintFtoCC {2721/1001}}}

The `|\printnumber|' macro which we use to print long numbers can also
be useful on long continued fractions. 
\centeredline{|\printnumber{\xintFtoCC {35037018906350720204351049/%|}%
\centeredline{|244241737886197404558180}}|}%
\texttt{\printnumber{\xintFtoCC {35037018906350720204351049/244241737886197404558180}}}.
If we apply \csb{xintGCtoF} to this generalized continued fraction, we
discover that the original fraction was reducible:
\centeredline{|\xintGCtoF
  {143+1/2+...+-1/9}=|\texttt{\xintGCtoF{143+1/2+1/5+-1/4+-1/4+-1/4+-1/3+1/2+1/2+1/6+-1/22+1/2+1/10+-1/5+-1/11+-1/3+1/4+-1/2+1/2+1/4+-1/2+1/23+1/3+1/8+-1/6+-1/9}}}

\def\mymacro #1{$\xintFrac{#1}=[\xintFtoCs{#1}]$\vtop to 6pt{}}

\catcode`\& 4 
When a generalized continued fraction is built with integers, and
numerators are only |1|'s or |-1|'s, the produced fraction is
irreducible. And if we compute it again with the last sub-fraction
omitted we get another irreducible fraction related to the bigger one by
a Bezout identity. Doing this here we get:
\centeredline{|\xintGCtoF {143+1/2+...+-1/6}=|\texttt{\xintGCtoF{143+1/2+1/5+-1/4+-1/4+-1/4+-1/3+1/2+1/2+1/6+-1/22+1/2+1/10+-1/5+-1/11+-1/3+1/4+-1/2+1/2+1/4+-1/2+1/23+1/3+1/8+-1/6}}}
and indeed:
\[ \begin{vmatrix}
    2897319801297630107 & 328124887710626729\\
      20197107104701740 & 2287346221788023 
   \end{vmatrix} = \texttt{\xintiSub {\xintiMul {2897319801297630107}{2287346221788023}}{\xintiMul{20197107104701740}{328124887710626729}}}\]

\catcode`\& 13

More generally the various fractions obtained from the truncation of a
continued fraction to its initial terms are called the convergents. The
commands of \xintcfracname such as \csb{xintFtoCv}, \csb{xintFtoCCv},
and others which compute such convergents, return them as a list of
braced items, with no separator. This list can then be treated either
with \csa{xint\-AssignArray}, or \csa{xintListWithSep}, or any other way
(but then, some \TeX{} programming knowledge will be necessary). Here
is an example:

\noindent
\centeredline{|$$\xintFrac{915286/188421}\to \xintListWithSep {,}%|}%
\centeredline{|{\xintApply{\xintFrac}{\xintFtoCv{915286/188421}}}$$|}
\[ \xintFrac{915286/188421}\to \xintListWithSep {,}
{\xintApply\xintFrac{\xintFtoCv{915286/188421}}}\]
\centeredline{|$$\xintFrac{915286/188421}\to \xintListWithSep {,}%|}%
\centeredline{|{\xintApply{\xintFrac}{\xintFtoCCv{915286/188421}}}$$|}
\[ \xintFrac{915286/188421}\to \xintListWithSep {,}
{\xintApply\xintFrac{\xintFtoCCv{915286/188421}}}\] We thus see that the
`centered convergents' obtained with \csb{xintFtoCCv} are among the fuller list
of convergents as returned by \csb{xintFtoCv}. 

Here is a more complicated use of \csa{xintApply}
and \csa{xintListWithSep}. We first define a macro which will be applied to each
convergent:\centeredline{|\newcommand{\mymacro}[1]|%
  |{$\xintFrac{#1}=[\xintFtoCs{#1}]$\vtop to 6pt{}}|}%
Next, we use the following code:
\centeredline{|$\xintFrac{49171/18089}\to{}$|}%
\centeredline{|\xintListWithSep {,
  }{\xintApply{\mymacro}{\xintFtoCv{49171/18089}}}|}
It produces:\par
\noindent$ \xintFrac{49171/18089}\to {}$\xintListWithSep {,
  }{\xintApply{\mymacro}{\xintFtoCv{49171/18089}}}.


\def\cn #1{\romannumeral0\xintipow {2}{#1}}%

The macro \csb{xintCntoF} allows to specify the coefficients as
functions of the index. The values to which expand the
coefficient function do not have to be integers. \centeredline{|\def\cn
  #1{\romannumeral0\xintipow {2}{#1}}% 2^n|}%
  \centeredline{|\[\xintFrac{\xintCntoF {6}{\cn}}=\xintCFrac
    [l]{\xintCntoF {6}{\cn}}\]|}%
\[\xintFrac{\xintCntoF {6}{\cn}}=\xintCFrac [l]{\xintCntoF
    {6}{\cn}}\]
Notice the use of the optional argument |[l]| to \csa{xintCFrac}. Other
possibilities are |[r]| and (default) |[c]|.
\def\cn #1{\romannumeral0\xintpow {2}{-#1}}%
\centeredline{|\def\cn #1{\romannumeral0\xintpow {2}{-#1}}% 1/2^n|}%
\centeredline{%
|\[\xintFrac{\xintCntoF {6}{\cn}} = \xintGCFrac [r]{\xintCntoGC {6}{\cn}}|}%
\centeredline{| = [\xintFtoCs {\xintCntoF {6}{\cn}}]\]|}%
\[\xintFrac{\xintCntoF {6}{\cn}}=\xintGCFrac [r]{\xintCntoGC {6}{\cn}}= 
  [\xintFtoCs {\xintCntoF {6}{\cn}}]\]
We used \csb{xintCntoGC} as we wanted to display also the continued fraction and
not only the fraction returned by \csa{xintCntoF}. 

There are also \csb{xintGCntoF} and \csb{xintGCntoGC} which allow the same for
generalized fractions. The following initial portion of a generalized continued
fraction for $\pi$:
\def\an #1{\the\numexpr 2*#1+1\relax }%
\def\bn #1{\the\numexpr (#1+1)*(#1+1)\relax }%
\[ \xintFrac{\xintDiv {4}{\xintGCntoF {5}{\an}{\bn}}} = 
        \cfrac{4}{\xintGCFrac{\xintGCntoGC {5}{\an}{\bn}}} =
\xintTrunc {10}{\xintDiv {4}{\xintGCntoF {5}{\an}{\bn}}}\dots\]
was obtained with this code:
\begin{verbatim}
\def\an #1{\the\numexpr 2*#1+1\relax }%
\def\bn #1{\the\numexpr (#1+1)*(#1+1)\relax }%
\[ \xintFrac{\xintDiv {4}{\xintGCntoF {5}{\an}{\bn}}} = 
        \cfrac{4}{\xintGCFrac{\xintGCntoGC {5}{\an}{\bn}}} =
\xintTrunc {10}{\xintDiv {4}{\xintGCntoF {5}{\an}{\bn}}}\dots\]
\end{verbatim}
We see that the quality of approximation is not fantastic compared to the simple
continued fraction of $\pi$ with about as many terms:
\begin{verbatim}
\[ \xintFrac{\xintCstoF{3,7,15,1,292,1,1}}=
   \xintGCFrac{3+1/7+1/15+1/1+1/292+1/1+1/1}=
   \xintTrunc{10}{\xintCstoF{3,7,15,1,292,1,1}}\dots\]
\end{verbatim}
\[ \xintFrac{\xintCstoF{3,7,15,1,292,1,1}}=
\xintGCFrac{3+1/7+1/15+1/1+1/292+1/1+1/1}=
\xintTrunc{10}{\xintCstoF{3,7,15,1,292,1,1}}\dots\]

\hypertarget{e-convergents}{To}
conclude this overview of most of the package functionalities, let us explore
the convergents of Euler's number $e$.
\begin{verbatim}
\def\cn #1{\the\numexpr\ifcase \numexpr #1+3-3*((#1+2)/3)\relax
                           1\or1\or2*(#1/3)\fi\relax }
% produces the pattern 1,1,2,1,1,4,1,1,6,1,1,8,... which are the
% coefficients of the simple continued fraction of e-1.
\cnta 0
\def\mymacro #1{\advance\cnta by 1
                \noindent
                \hbox to 3em {\hfil\small\texttt{\the\cnta.} }%
                $\xintTrunc {30}{\xintAdd {1[0]}{#1}}\dots=
                 \xintFrac{\xintAdd {1[0]}{#1}}$}%
\xintListWithSep{\vtop to 6pt{}\vbox to 12pt{}\par}
    {\xintApply\mymacro{\xintiCstoCv{\xintCntoCs {35}{\cn}}}}
\end{verbatim}
\smallskip The volume of computation is kept minimal by the following steps:
\begin{itemize}
\item a comma separated list of the first 36 coefficients is produced by
  \csb{xintCntoCs},
\item this is then given to \csb{xintiCstoCv} which produces the list of the
  convergents (there is also \csb{xintCstoCv}, but our
  coefficients being integers we used the infinitesimally
  faster \csb{xintiCstoCv}),
\item then the whole list was converted into a sequence of one-line paragraphs,
  each convergent becomes the argument to a  macro printing it
  together with its decimal expansion with 30 digits after the decimal point.
\item A count register |\cnta| was used to give a line count serving as a visual
  aid: we could also have done that in an expandable way, but well, let's relax
  from time to time\dots
\end{itemize}


\def\cn #1{\the\numexpr\ifcase \numexpr #1+3-3*((#1+2)/3)\relax
                           1\or1\or2*(#1/3)\fi\relax }
% produces the pattern 1,1,2,1,1,4,1,1,6,1,1,8,... which are the
% coefficients of the simple continued fraction of e-1.
\cnta 0
\def\mymacro #1{\advance\cnta by 1
                \noindent
                \hbox to 3em {\hfil\small\texttt{\the\cnta.} }%
                $\xintTrunc {30}{\xintAdd {1[0]}{#1}}\dots=
                 \xintFrac{\xintAdd {1[0]}{#1}}$}%
\xintListWithSep{\vtop to 6pt{}\vbox to 12pt{}\par}
    {\xintApply\mymacro{\xintiCstoCv{\xintCntoCs {35}{\cn}}}}

% \def\testmacro #1{\xintTrunc {30}{\xintAdd {1[0]}{#1}}\xintAdd {1[0]}{#1}}
% \pdfresettimer
% \edef\z{\xintApply\testmacro{\xintiCstoCv{\xintCntoCs {35}{\cn}}}}
% (\the\pdfelapsedtime)


\smallskip The actual computation of the list of all 36 convergents accounts for
only 8\% of the total time (total time equal to about 5 hundredths of a second
in my testing, on my laptop): another 80\% is occupied with the computation of
the truncated decimal expansions (and the addition of 1 to everything as the
formula gives the continued fraction of $e-1$). One can with no problem compute
much bigger convergents. Let's get the 200th convergent. It turns out to
have the same first 268 digits after the decimal point as $e-1$. Higher
convergents get more and more digits in proportion to their index: the 500th
convergent already gets 799 digits correct! To allow speedy compilation of the
source of this document when the need arises, I limit here to the 200th
convergent (getting the 500th took about 1.2s on my laptop last time I tried,
and the 200th convergent is obtained ten times faster).
\begin{verbatim}
\edef\z {\xintCntoF {199}{\cn}}%
\begingroup\parindent 0pt \leftskip 2.5cm
\indent\llap {Numerator = }\printnumber{\xintNumerator\z}\par
\indent\llap {Denominator = }\printnumber{\xintDenominator\z}\par
\indent\llap {Expansion = }\printnumber{\xintTrunc{268}\z}\dots
\par\endgroup
\end{verbatim}

\edef\z {\xintCntoF {199}{\cn}}%

\begingroup\parindent 0pt \leftskip 2.5cm
\indent\llap {Numerator = }\printnumber{\xintNumerator\z}\par
\indent\llap {Denominator = }\printnumber{\xintDenominator\z}\par
\indent\llap {Expansion = }\printnumber{\xintTrunc{268}\z}\dots\par\endgroup

One can also use a centered continued fraction: we get more digits but there are
also more computations as the numerators may be either
$1$ or $-1$.

\subsection{\csbh{xintCFrac}}\label{xintCFrac}

\csa{xintCFrac}|{f}| is a math-mode only, \LaTeX{} with |amsmath| only, macro
which first computes then displays with the help of |\cfrac| the simple
continued fraction corresponding to the given fraction (or macro expanding in
two steps to one such). It admits an optional argument which may be |[l]|, |[r]|
or (the default) |[c]| to specify the location of the one's in the numerators.
Each numerator is typeset using the \csb{xintFrac} macro from the \xintfracname
package. 

\subsection{\csbh{xintGCFrac}}\label{xintGCFrac}

\csa{xintGCFrac}|{a+b/c+d/e+f/g+h/...}| uses similarly |\cfrac| to typeset a
generalized continued fraction in inline format.  It admits the same optional
argument as \csa{xintCFrac}.
\centeredline{|\[\xintGCFrac {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}}\]|}
\[\xintGCFrac {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}}\]
As can be seen this is typesetting macro, although it does proceed to the
evaluation of the coefficients themselves. See \csb{xintGCtoF} if you are
impatient to see this fraction computed. Numerators and denominators are made
arguments to the
\csb{xintFrac} macro.

\subsection{\csbh{xintGCtoGCx}}\label{xintGCtoGCx}
{\small New with release |1.05|.\par}


\csa{xintGCtoGCx}|{sepa}{sepb}{a+b/c+d/e+f/...+x/y}| returns the list of the
coefficients of the generalized continued fraction of |f|, each one within a
pair of braces, and separated with the help of |sepa| and |sepb|. Thus
\centeredline{|\xintGCtoGCx :;{1+2/3+4/5+6/7}| gives \xintGCtoGCx
  :;{1+2/3+4/5+6/7}} Plain \TeX{}+|amstex| users may be interested in:\par
\noindent|$$\xintGCtoGCx {+\cfrac}{\\}{a+b/...}\endcfrac$$|\par
\noindent|$$\xintGCtoGCx {+\cfrac\xintFwOver}{\\\xintFwOver}{a+b/...}\endcfrac$$|\par


\subsection{\csbh{xintFtoCs}}\label{xintFtoCs}

\csa{xintFtoCs}|{f}| returns the comma separated list of the coefficients of the
simple continued fraction of |f|.
\centeredline{%
|\[ \xintSignedFrac{-5262046/89233} = [\xintFtoCs{-5262046/89233}]\]|}%
\[ \xintSignedFrac{-5262046/89233} = [\xintFtoCs{-5262046/89233}]\]


\subsection{\csbh{xintFtoCx}}\label{xintFtoCx}

\csa{xintFtoCx}|{sep}{f}| returns the list of the coefficients of the simple
continued fraction of |f|, withing group braces and separated with the help of
|sep|. \centeredline{|$$\xintFtoCx {+\cfrac1\\ }{f}\endcfrac$$|} will
display the 
continued fraction in |\cfrac| format, with Plain \TeX{} and |amstex|.

\subsection{\csbh{xintFtoGC}}\label{xintFtoGC}

\csa{xintFtoGC}|{f}| does the same as \csa{xintFtoCx}|{+1/}{f}|. Its
output may thus be used in the package macros expecting such an `inline
format'. This continued fraction is a \emph{simple} one, not a
\emph{generalized} one, but as it is produced in the format used for
user input of generalized continued fractions, the macro was called
\csa{xintFtoGC} rather than \csa{xintFtoC} for example.
\centeredline{|566827/208524=\xintFtoGC {566827/208524}|}%
\centeredline{566827/208524=\xintFtoGC {566827/208524}}

\subsection{\csbh{xintFtoCC}}\label{xintFtoCC}

\csa{xintFtoCC}|{f}| returns the `centered' continued fraction of |f|, in
`inline format'.
\centeredline{|566827/208524=\xintFtoCC {566827/208524}|}%
\centeredline{566827/208524=\xintFtoCC {566827/208524}}
\centeredline{%
|\[\xintFrac{566827/208524} = \xintGCFrac{\xintFtoCC{566827/208524}}\]|}%
\[\xintFrac{566827/208524} = \xintGCFrac{\xintFtoCC{566827/208524}}\]

\subsection{\csbh{xintFtoCv}}\label{xintFtoCv}

\csa{xintFtoCv}|{f}| returns the list of the (braced) convergents of |f|, with
no separator. To be treated with \csb{xintAssignArray} or \csb{xintListWithSep}.
\centeredline{%
|\[\xintListWithSep{\to}{\xintApply\xintFrac{\xintFtoCv{5211/3748}}}\]|}%
\[\xintListWithSep{\to}{\xintApply\xintFrac{\xintFtoCv{5211/3748}}}\]

\subsection{\csbh{xintFtoCCv}}\label{xintFtoCCv}

\csa{xintFtoCCv}|{f}| returns the list of the (braced) centered convergents of
|f|, with no separator. To be treated with \csb{xintAssignArray} or
\csb{xintListWithSep}.
\centeredline{%
|\[\xintListWithSep{\to}{\xintApply\xintFrac{\xintFtoCCv{5211/3748}}}\]|}%
\[\xintListWithSep{\to}{\xintApply\xintFrac{\xintFtoCCv{5211/3748}}}\]

\subsection{\csbh{xintCstoF}}\label{xintCstoF}

\csa{xintCstoF}|{a,b,c,d,...,z}| computes the fraction corresponding to the
coefficients, which may be fractions or even macros expanding to such
fractions (in two steps). The final fraction may then be highly
reducible.
\centeredline{|\[\xintGCFrac {-1+1/3+1/-5+1/7+1/-9+1/11+1/-13}|}%
\centeredline{|=\xintSignedFrac{\xintCstoF {-1,3,-5,7,-9,11,-13}}|}%
\centeredline{|=\xintSignedFrac{\xintGCtoF  
                {-1+1/3+1/-5+1/7+1/-9+1/11+1/-13}}\]|}%
\[\xintGCFrac {-1+1/3+1/-5+1/7+1/-9+1/11+1/-13}=
\xintSignedFrac{\xintCstoF {-1,3,-5,7,-9,11,-13}}
=\xintSignedFrac{\xintGCtoF  {-1+1/3+1/-5+1/7+1/-9+1/11+1/-13}}\]
\centeredline{|\xintGCFrac{{1/2}+1/{1/3}+1/{1/4}+1/{1/5}}= |}%
\centeredline{|  \xintFrac{\xintCstoF {1/2,1/3,1/4,1/5}}|}%
\[\xintGCFrac{{1/2}+1/{1/3}+1/{1/4}+1/{1/5}}= 
\xintFrac{\xintCstoF {1/2,1/3,1/4,1/5}}\] A generalized continued fraction may
produce a reducible fraction (\csa{xintCstoF} tries its best not to accumulate
in a silly way superfluous factors but will not do simplifications which would
be obvious to a human, like simplification by 3 in the result above).

\subsection{\csbh{xintCstoCv}}\label{xintCstoCv}

\csa{xintCstoCv}|{a,b,c,d,...,z}| returns the list of the corresponding
convergents. It is allowed to use fractions as coefficients (the computed
convergents have then no reason to be the real convergents of the final
fraction). When the coefficients are integers, the convergents are irreducible
fractions, but otherwise it is of course not necessarily the case.
\centeredline{|\xintListWithSep:{\xintCstoCv{1,2,3,4,5,6}}|}%
\centeredline{\texttt{\xintListWithSep:{\xintCstoCv{1,2,3,4,5,6}}}}
\centeredline{|\xintListWithSep:{\xintCstoCv{1,1/2,1/3,1/4,1/5,1/6}}|}%
\centeredline{\texttt{\xintListWithSep:{\xintCstoCv{1,1/2,1/3,1/4,1/5,1/6}}}} I
know that these |[0]| are a bit annoying\footnote{and the awful truth is that it
  is added forcefully by \csa{xintCstoCv} at the last step\dots } but this is
the way \xintfracname likes to reception fractions: this format is best for
further processing by the bundle macros. For `inline' printing, one may apply
\csb{xintRaw} and for display in math mode \csb{xintFrac}.
\centeredline{|\[\xintListWithSep{\to}{\xintApply\xintFrac{\xintCstoCv|}%
    \centeredline{|{\xintPow {-.3}{-5},7.3/4.57,\xintCstoF{3/4,9,-1/3}}}}\]|}%
\[\xintListWithSep{\to}{\xintApply\xintFrac{\xintCstoCv
       {\xintPow {-.3}{-5},7.3/4.57,\xintCstoF{3/4,9,-1/3}}}}\]


\subsection{\csbh{xintCstoGC}}\label{xintCstoGC}

\csa{xintCstoGC}|{a,b,..,z}| transforms a comma separated list (or
something expanding to such a list) into an
`inline format' continued fraction |{a}+1/{b}+1/...+1/{z}|. The
coefficients are just copied and put within braces, without expansion.
The output can then be used in \csb{xintGCFrac} for example.
\centeredline{|\[\xintGCFrac {\xintCstoGC {-1,1/2,-1/3,1/4,-1/5}}|}%
\centeredline{|=\xintSignedFrac {\xintCstoF {-1,1/2,-1/3,1/4,-1/5}}\]|}%
\[\xintGCFrac {\xintCstoGC {-1,1/2,-1/3,1/4,-1/5}} =
\xintSignedFrac{\xintCstoF {-1,1/2,-1/3,1/4,-1/5}}\]

\subsection{\csbh{xintGCtoF}}\label{xintGCtoF}

\csa{xintGCtoF}|{a+b/c+d/e+f/g+......+v/w+x/y}| computes the fraction defined by
the inline generalized continued fraction. Coefficients may be fractions but
must then be put within braces. They can be macros. The plus signs are
mandatory.
\begin{verbatim}
\[\xintGCFrac {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}} = 
\xintFrac{\xintGCtoF {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}}} =
\xintFrac{\xintIrr{\xintGCtoF 
                  {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}}}}\]
\end{verbatim}
\[\xintGCFrac {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}} = 
\xintFrac{\xintGCtoF {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}}} =
\xintFrac{\xintIrr{\xintGCtoF {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}}}}\]
\begin{verbatim}
\[ \xintGCFrac{{1/2}+{2/3}/{4/5}+{1/2}/{1/5}+{3/2}/{5/3}} = 
   \xintFrac{\xintGCtoF {{1/2}+{2/3}/{4/5}+{1/2}/{1/5}+{3/2}/{5/3}}} \]
\end{verbatim}
\[ \xintGCFrac{{1/2}+{2/3}/{4/5}+{1/2}/{1/5}+{3/2}/{5/3}} = 
   \xintFrac{\xintGCtoF {{1/2}+{2/3}/{4/5}+{1/2}/{1/5}+{3/2}/{5/3}}} \] 
The macro tries its best not to accumulate superfluous factor in the
denominators, but doesn't reduce the fraction to irreducible form before
returning it and does not do simplifications which would be obvious to a human.

\subsection{\csbh{xintGCtoCv}}\label{xintGCtoCv}

\csa{xintGCtoCv}|{a+b/c+d/e+f/g+......+v/w+x/y}| returns the list of the
corresponding convergents. The coefficients may be fractions, but must
then be inside braces. Or they may be macros, too. 

The convergents will in the general case be reducible. To put them into
irreducible form, one needs one more step, for example it can be done
with |\xintApply\xintIrr|.
\begin{verbatim}
\[\xintListWithSep{,}{\xintApply\xintFrac
                {\xintGCtoCv{3+{-2}/{7/2}+{3/4}/12+{-56}/3}}}\]
\[\xintListWithSep{,}{\xintApply\xintFrac{\xintApply\xintIrr
                {\xintGCtoCv{3+{-2}/{7/2}+{3/4}/12+{-56}/3}}}}\]
\end{verbatim}
\[\xintListWithSep{,}{\xintApply\xintFrac
                {\xintGCtoCv{3+{-2}/{7/2}+{3/4}/12+{-56}/3}}}\]
\[\xintListWithSep{,}{\xintApply\xintFrac{\xintApply\xintIrr
                {\xintGCtoCv{3+{-2}/{7/2}+{3/4}/12+{-56}/3}}}}\]

\subsection{\csbh{xintCntoF}}\label{xintCntoF}

\def\macro #1{\the\numexpr 1+#1*#1\relax}

\csa{xintCntoF}|{N}{\macro}| computes the fraction |f| having
coefficients |c(j)=\macro{j}| for |j=0,1,...,N|. The values do not have
to be positive, nor integers, and it is thus not necessarily the case
that the original |c(j)| are the true coefficients of the final |f|.
One usually has to define the one-parameter |\macro| in advance.
\centeredline{%
|\def\macro #1{\the\numexpr 1+#1*#1\relax}\xintCntoF {5}{\macro}|}%
\centeredline{\xintCntoF {5}{\macro}}

\subsection{\csbh{xintGCntoF}}\label{xintGCntoF}

\def\coeffA #1{\the\numexpr #1+4-3*((#1+2)/3)\relax }%
\def\coeffB #1{\romannumeral0\xintmon{#1}}% (-1)^n

\csa{xintGCntoF}|{N}{\macroA}{\macroB}| returns the fraction |f| corresponding
to the inline generalized continued fraction |a0+b0/a1+b1/a2+....+b(N-1)/aN|,
with |a(j)=\macroA{j}| and |b(j)=\macroB{j}|.
\[\xintGCFrac{\xintGCntoGC {6}{\coeffA}{\coeffB}}
= \xintFrac{\xintGCntoF {6}{\coeffA}{\coeffB}}\]
There is also \csb{xintGCntoGC} to get the `inline format' continued
fraction. The previous display was obtained with:
\centeredline{|\def\coeffA #1{\the\numexpr #1+4-3*((#1+2)/3)\relax }%|}%
\centeredline{|\def\coeffB #1{\romannumeral0\xintmon{#1}}% (-1)^n|}%
\centeredline{|\[\xintGCFrac{\xintGCntoGC {6}{\coeffA}{\coeffB}}|}%
\centeredline{|  = \xintFrac{\xintGCntoF  {6}{\coeffA}{\coeffB}}\]|}


\subsection{\csbh{xintCntoCs}}\label{xintCntoCs}

\csa{xintCntoCs}|{N}{\macro}| produces the comma separated list of the
corresponding coefficients, from |n=0| to |n=N|. 
\centeredline{%
|\def\macro #1{\the\numexpr 1+#1*#1\relax}\xintCntoCs {5}{\macro}|}%
\centeredline{\xintCntoCs {5}{\macro}}%
\centeredline{|\[\xintFrac{\xintCntoF
    {5}{\macro}}=\xintCFrac{\xintCntoF {5}{\macro}}\]|}%
\[ \xintFrac{\xintCntoF
    {5}{\macro}}=\xintCFrac{\xintCntoF {5}{\macro}}\]

\subsection{\csbh{xintCntoGC}}\label{xintCntoGC}

\def\macro #1{\the\numexpr\ifodd#1 -1-#1\else1+#1\fi\relax/%
               \the\numexpr 1+#1*#1\relax}

\csa{xintCntoGC}|{N}{\macro}| evaluates the |c(j)=\macro{j}| from |j=0|
to |j=N| and returns a continued fraction written in inline
format: |{c(0)}+1/{c(1)}+1/...+1/{c(N)}|. It may then serve as input to
other macros. The coefficients, after expansion, are, as shown, being
enclosed in an added pair of braces, they may thus be
fractions.
\centeredline{%
|\def\macro #1{\the\numexpr\ifodd#1 -1-#1\else1+#1\fi\relax/%|}%
\centeredline{|\the\numexpr 1+#1*#1\relax}|}%
\centeredline{|\edef\x{\xintCntoGC {5}{\macro}}\texttt{\meaning\x}|}%
\centeredline{|\[\xintGCFrac{\xintCntoGC {5}{\macro}}\]|}%
\centeredline{\edef\x{\xintCntoGC {5}{\macro}}\texttt{\meaning\x}}
\[\xintGCFrac{\xintCntoGC {5}{\macro}}\]

\subsection{\csbh{xintGCntoGC}}\label{xintGCntoGC}

\csa{xintGCntoGC}|{N}{\macroA}{\macroB}| evaluates the coefficients and
then returns the corresponding
|{a0}+{b0}/{a1}+{b1}/{a2}+...+{b(N-1)}/{aN}| inline generalized
fraction. As shown, the coefficients are enclosed into added pairs of
braces, and may thus be fractions.
\begin{verbatim}
\def\an #1{\the\numexpr #1*#1*#1+1\relax}%
\def\bn #1{\the\numexpr \xintiMON{#1}*(#1+1)\relax}%
\texttt{\xintGCntoGC {5}{\an}{\bn}}%
       ${}=\xintGCFrac {\xintGCntoGC {5}{\an}{\bn}}
        = \displaystyle\xintFrac    {\xintGCntoF  {5}{\an}{\bn}}$\par
\end{verbatim}
\def\an #1{\the\numexpr #1*#1*#1+1\relax}%
\def\bn #1{\the\numexpr \xintiMON{#1}*(#1+1)\relax}%
\noindent\texttt{\xintGCntoGC {5}{\an}{\bn}}%
      ${}=\xintGCFrac {\xintGCntoGC {5}{\an}{\bn}}
       = \displaystyle\xintFrac {\xintGCntoF{5}{\an}{\bn}}$\par


\subsection{\csbh{xintiCstoF},~\csbh{xintiGCtoF},~\csbh{xint\-iCstoCv},~\csbh{xintiGCtoCv}}\label{xintiCstoF}
\label{xintiGCtoF}
\label{xintiCstoCv}
\label{xintiGCtoCv}

The same as the corresponding macros without the `i', but for
integer-only input. Infinitesimally faster; to notice the higher
efficiency one would need to use them with an input having (at least)
hundreds of coefficients.


\subsection{\csbh{xintGCtoGC}}\label{xintGCtoGC}

\csa{xintGCtoGC}|{a+b/c+d/e+f/g+......+v/w+x/y}| twice-expands each one of the
coefficients and returns an inline continued fraction of the same type, each
coefficient being enclosed withing braces.
\begin{verbatim}
\edef\x {\xintGCtoGC 
  {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}+\xintCstoF {2,-7,-5}/16}}
\texttt{\meaning\x}
\end{verbatim}
\edef\x {\xintGCtoGC 
     {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}+\xintCstoF {2,-7,-5}/16}}
\texttt{\meaning\x}

To be honest I have, it seems, forgotten why I wrote this macro in the
first place.


\catcode`\& 4

\makeatletter
\let\check@percent\original@check@percent
\StopEventually{\end{document}\endinput}
\makeatother

\newgeometry{hmarginratio=4:3,hscale=0.75}

\def\MacroFont{\ttfamily\small\baselineskip12pt\relax}

\MakePercentIgnore
% 
% \catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
% \let</none>\relax
% \def<*xint>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12}
%
%</none>
%<*xint>
% \section {Package \xintname implementation}
% 
% The commenting of the macros is currently (\docdate) very
% sparse. Some comments may be left-overs from previous versions
% of the macro, with parameters in another order for example.
%
% \toctransition
% \localtableofcontents
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
% 
% The method for package identification and reload detection is
% copied verbatim from the packages by \textsc{Heiko Oberdiek}.
%
% The method for catcodes was also inspired by these packages, we
% proceed slightly differently. |1.05| adds a |\relax| near the end of
% |\XINT@restorecatcodes@endinput|. Plain TeX users following the doc
% instruction to do |\input xint.sty\relax| were anyhow protected from
% any side effect. I didn't realize earlier that the |\endinput| would
% not have had the effect of stopping the scanning from the last
% |\the\catcode61|.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \expandafter\let\expandafter\x\csname ver@xint.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xint}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax % plain-TeX, first loading
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
      \else
        \y{xint}{I was already loaded, aborting input}%
        \aftergroup\endinput
      \fi
    \fi
  \fi
  \def\ChangeCatcodesIfInputNotAborted
  {%
      \endgroup
      \edef\XINT@restorecatcodes@endinput
      {%
        \catcode47=\the\catcode47   % /
        \catcode41=\the\catcode41   % )
        \catcode40=\the\catcode40   % (
        \catcode42=\the\catcode42   % *
        \catcode43=\the\catcode43   % +
        \catcode62=\the\catcode62   % >
        \catcode60=\the\catcode60   % <
        \catcode58=\the\catcode58   % :
        \catcode46=\the\catcode46   % .
        \catcode45=\the\catcode45   % -
        \catcode44=\the\catcode44   % ,
        \catcode35=\the\catcode35   % #
        \catcode64=\the\catcode64   % @
        \catcode125=\the\catcode125 % }
        \catcode123=\the\catcode123 % {
        \endlinechar=\the\endlinechar
        \catcode13=\the\catcode13   % ^^M
        \catcode32=\the\catcode32   % 
        \catcode61=\the\catcode61\relax   % =
        \noexpand\endinput
      }%
      \def\XINT@setcatcodes
      {%
        \catcode61=12   % =
        \catcode32=10   % space
        \catcode13=5    % ^^M
        \endlinechar=13 % 
        \catcode123=1   % {
        \catcode125=2   % }
        \catcode64=11   % @
        \catcode35=6    % #
        \catcode44=12   % ,
        \catcode45=12   % -
        \catcode46=12   % .
        \catcode58=11   % : (made letter for error cs)
        \catcode60=12   % <
        \catcode62=12   % >
        \catcode43=12   % +
        \catcode42=12   % *
        \catcode40=12   % (
        \catcode41=12   % )
        \catcode47=12   % /
      }%
      \XINT@setcatcodes
  }%
\ChangeCatcodesIfInputNotAborted 
%    \end{macrocode}
% \subsection{Package identification}
%
% Copied verbatim from \textsc{Heiko Oberdiek}'s packages.
%
%    \begin{macrocode}
\begingroup
  \catcode91=12 % [
  \catcode93=12 % ]
  \catcode58=12 % : (does not really matter, was letter)
  \expandafter\ifx\csname ProvidesPackage\endcsname\relax
    \def\x#1#2#3[#4]{\endgroup
      \immediate\write-1{Package: #3 #4}%
      \xdef#1{#4}%
    }%
  \else
    \def\x#1#2[#3]{\endgroup
      #2[{#3}]%
      \ifx#1\@undefined
        \xdef#1{#3}%
      \fi
      \ifx#1\relax
        \xdef#1{#3}%
      \fi
    }%
  \fi
\expandafter\x\csname ver@xint.sty\endcsname
\ProvidesPackage{xint}%
  [2013/05/02 v1.05a Expandable operations on long numbers (jfB)]%
%    \end{macrocode}
% \subsection{Token management macros}
%    \begin{macrocode}
\def\xint@gobble       #1{}%
\def\xint@gobble@one   #1{}%
\def\xint@gobble@two   #1#2{}%
\def\xint@gobble@three #1#2#3{}%
\def\xint@gobble@four  #1#2#3#4{}%
\def\xint@gobble@five  #1#2#3#4#5{}%
\def\xint@gobble@six   #1#2#3#4#5#6{}%
\def\xint@gobble@seven #1#2#3#4#5#6#7{}%
\def\xint@gobble@eight #1#2#3#4#5#6#7#8{}%
\def\xint@firstoftwo   #1#2{#1}%
\def\xint@secondoftwo  #1#2{#2}%
\def\xint@firstoftwo@andstop  #1#2{ #1}%
\def\xint@secondoftwo@andstop #1#2{ #2}%
\def\xint@exchangetwo@keepbraces #1#2{{#2}{#1}}%
\def\xint@exchangetwo@keepbraces@andstop #1#2{ {#2}{#1}}%
\def\xint@xpxp@andstop {\expandafter\expandafter\expandafter\space }%
\def\xint@minus@andstop { -}%
\def\xint@r     #1\R {}%
\def\xint@w     #1\W {}%
\def\xint@z     #1\Z {}%
\def\xint@zero  #10{}%
\def\xint@one   #11{}%
\def\xint@minus #1-{}%
\def\xint@relax #1\relax {}%
\def\xint@quatrezeros #10000{}%
\def\xint@bracedundef {\xint@undef }%
\def\xint@UDzerofork      #10\dummy  #2#3\xint@UDkrof {#2}%
\def\xint@UDsignfork      #1-\dummy  #2#3\xint@UDkrof {#2}%
\def\xint@UDwfork         #1\W\dummy #2#3\xint@UDkrof {#2}%
\def\xint@UDzerosfork     #100\dummy #2#3\xint@UDkrof {#2}%
\def\xint@UDonezerofork   #110\dummy #2#3\xint@UDkrof {#2}%
\def\xint@UDzerominusfork #10-\dummy #2#3\xint@UDkrof {#2}%
\def\xint@UDsignsfork     #1--\dummy #2#3\xint@UDkrof {#2}%
\def\xint@afterfi #1#2\fi {\fi #1}%
%    \end{macrocode}
% \subsection{\csh{xintRev}, \csh{xintReverseOrder}}
% \begin{verbatim}
% \xintRev: fait la double expansion, vérifie le signe
% \xintReverseOrder: ne fait PAS la double expansion, ne regarde
% PAS le signe.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintRev {\romannumeral0\xintrev }%
\def\xintrev #1%
{% 
    \expandafter\expandafter\expandafter
      \xint@rev
    \expandafter\expandafter\expandafter
      {#1}%
}%
\def\xint@rev #1%
{%
    \XINT@rev@fork #1\Z
}%
\def\XINT@rev@fork #1#2%
{%
    \xint@UDsignfork
      #1\dummy \XINT@rev@negative
       -\dummy \XINT@rev@nonnegative
    \xint@UDkrof
    #1#2%
}%
\def\XINT@rev@negative #1#2\Z
{%
    \expandafter\xint@minus@andstop\romannumeral0\XINT@rev {#2}%
}%
\def\XINT@rev@nonnegative #1\Z
{%
    \XINT@rev {#1}%
}%
\def\XINT@Rev {\romannumeral0\XINT@rev }%
\let\xintReverseOrder \XINT@Rev
\def\XINT@rev #1%  
{%
    \XINT@rord@main {}#1%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
}%
\def\XINT@rord@main #1#2#3#4#5#6#7#8#9%  
{%
    \XINT@strip@undef #9\XINT@rord@cleanup\xint@undef
    \XINT@rord@main {#9#8#7#6#5#4#3#2#1}%
}%
\def\XINT@rord@cleanup\xint@undef\XINT@rord@main #1#2\xint@UNDEF 
{%
    \expandafter\space\XINT@strip@UNDEF #1%
}%
\def\XINT@strip@undef #1\xint@undef {}%
\def\XINT@strip@UNDEF #1\xint@UNDEF {}%
%    \end{macrocode}
% \subsection{\csh{XINT@RQ}}
% \begin{verbatim}
% cette macro renverse et ajoute le nombre minimal de zéros à
% la fin pour que la longueur soit alors multiple de 4
% \romannumeral0\XINT@RQ {}<le truc à renverser>\R\R\R\R\R\R\R\R\Z
% Attention, ceci n'est utilisé que pour des chaînes de chiffres, et donc le
% comportement avec des {..} ou autres espaces n'a fait l'objet d'aucune
% attention 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@RQ #1#2#3#4#5#6#7#8#9%  
{%
    \xint@r #9\XINT@RQ@end\R\XINT@RQ {#9#8#7#6#5#4#3#2#1}%
}%
\def\XINT@RQ@end\R\XINT@RQ #1#2\Z 
{%
    \XINT@RQ@end@ #1\Z
}%
\def\XINT@RQ@end@ #1#2#3#4#5#6#7#8%  
{%
    \xint@r #8\XINT@RQ@end@viii 
            #7\XINT@RQ@end@vii
            #6\XINT@RQ@end@vi
            #5\XINT@RQ@end@v
            #4\XINT@RQ@end@iv
            #3\XINT@RQ@end@iii
            #2\XINT@RQ@end@ii
            \R\XINT@RQ@end@i
            \Z #2#3#4#5#6#7#8%
}%
\def\XINT@RQ@end@viii #1\Z #2#3#4#5#6#7#8#9\Z { #9}%
\def\XINT@RQ@end@vii  #1\Z #2#3#4#5#6#7#8#9\Z { #8#9000}%
\def\XINT@RQ@end@vi   #1\Z #2#3#4#5#6#7#8#9\Z { #7#8#900}%
\def\XINT@RQ@end@v    #1\Z #2#3#4#5#6#7#8#9\Z { #6#7#8#90}%
\def\XINT@RQ@end@iv   #1\Z #2#3#4#5#6#7#8#9\Z { #5#6#7#8#9}%
\def\XINT@RQ@end@iii  #1\Z #2#3#4#5#6#7#8#9\Z { #4#5#6#7#8#9000}%
\def\XINT@RQ@end@ii   #1\Z #2#3#4#5#6#7#8#9\Z { #3#4#5#6#7#8#900}%
\def\XINT@RQ@end@i      \Z #1#2#3#4#5#6#7#8\Z { #1#2#3#4#5#6#7#80}%
%    \end{macrocode}
% \subsection{\csh{XINT@cuz}}
%    \begin{macrocode}
\def\xint@cleanupzeros@andstop #1#2#3#4%
{%
    \expandafter\space\the\numexpr #1#2#3#4\relax 
}%
\def\xint@cleanupzeros@nospace #1#2#3#4%
{%
    \the\numexpr #1#2#3#4\relax 
}%
\def\XINT@rev@andcuz #1%
{%
    \expandafter\xint@cleanupzeros@andstop 
    \romannumeral0\XINT@rord@main {}#1%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF 
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% routine CleanUpZeros. Utilisée en particulier par la
% soustraction.
% INPUT:  longueur **multiple de 4**  (<-- ATTENTION)
% OUTPUT: on a retiré tous les leading zéros, on n'est **plus*
% nécessairement de longueur 4n
% Délimiteur pour @main: \W\W\W\W\W\W\W\Z avec SEPT \W
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@cuz #1%
{%
    \XINT@cuz@loop #1\W\W\W\W\W\W\W\Z%
}%
\def\XINT@cuz@loop #1#2#3#4#5#6#7#8%
{%
    \xint@w #8\xint@cuz@enda\W
    \xint@z #8\xint@cuz@endb\Z
    \XINT@cuz@checka {#1#2#3#4#5#6#7#8}%
}%
\def\xint@cuz@enda #1\XINT@cuz@checka #2%
{%
    \xint@cuz@endaa #2%
}%
\def\xint@cuz@endaa #1#2#3#4#5\Z 
{%
    \expandafter\space\the\numexpr #1#2#3#4\relax
}%
\def\xint@cuz@endb\Z\XINT@cuz@checka #1{ 0}%
\def\XINT@cuz@checka #1%
{%
    \expandafter \XINT@cuz@checkb \the\numexpr #1\relax
}%
\def\XINT@cuz@checkb #1%
{%
    \xint@zero #1\xint@cuz@backtoloop 0\XINT@cuz@Stop #1%
}%
\def\XINT@cuz@Stop #1\W #2\Z{ #1}%
\def\xint@cuz@backtoloop 0\XINT@cuz@Stop 0{\XINT@cuz@loop }%
%    \end{macrocode}
% \subsection{\csh{XINT@isOne}}
% Added in |1.03|. Attention: does not do any expansion.
%    \begin{macrocode}
\def\XINT@isOne #1{\romannumeral0\XINT@isone #1\W\Z }%
\def\XINT@isone #1#2%
{%
    \xint@one #1\XINT@isone@b 1\expandafter\space\expandafter 0\xint@z #2%
}%
\def\XINT@isone@b #1\xint@z #2%
{%
   \xint@w #2\XINT@isone@yes\W\expandafter\space\expandafter 0\xint@z
}%
\def\XINT@isone@yes #1\Z{ 1}%
%    \end{macrocode}
% \subsection{\csh{xintNum}}
% \begin{verbatim}
% For example \xintNum {----+-+++---+----000000000000003}
% 1.05 defines \xintiNum, as the original \xintNum will be a made a synonym of
% \xintIrr in xintfrac 
% \end{verbatim}
%    \begin{macrocode}
\def\xintiNum {\romannumeral0\xintinum }%
\def\xintinum #1%
{%
    \expandafter\expandafter\expandafter
    \XINT@num
    \expandafter\expandafter\expandafter
    {#1}%
}%
\let\xintNum\xintiNum \let\xintnum\xintinum
\def\XINT@Num {\romannumeral0\XINT@num }%
\def\XINT@num #1{\XINT@num@loop #1\R\R\R\R\R\R\R\R\Z }%
\def\XINT@num@loop #1#2#3#4#5#6#7#8%
{% 
    \xint@r #8\XINT@num@end\R\XINT@num@NumEight #1#2#3#4#5#6#7#8%
}%
\def\XINT@num@end\R\XINT@num@NumEight #1\R #2\Z
{%
    \expandafter\space\the\numexpr #1+0\relax
}%
\def\XINT@num@NumEight #1#2#3#4#5#6#7#8%
{%
    \ifnum \numexpr #1#2#3#4#5#6#7#8+0\relax = 0
      \xint@afterfi {\expandafter\XINT@num@keepsign@a
                     \the\numexpr #1#2#3#4#5#6#7#81\relax}%
    \else
      \xint@afterfi {\expandafter\XINT@num@finish
                     \the\numexpr #1#2#3#4#5#6#7#8\relax}%
    \fi
}%
\def\XINT@num@keepsign@a #1%
{%
    \xint@one#1\XINT@num@gobacktoloop 1\XINT@num@keepsign@b  
}%
\def\XINT@num@gobacktoloop 1\XINT@num@keepsign@b {\XINT@num@loop }%
\def\XINT@num@keepsign@b #1{\XINT@num@loop -}%
\def\XINT@num@finish #1\R #2\Z { #1}%
%    \end{macrocode}
% \subsection{\csh{xintLen}, \csh{xintLength}}
% \begin{verbatim}
% \xintLen    -> fait la double expansion, ne compte PAS le signe
% \xintLength -> ne fait PAS la double expansion, compte le signe
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintiLen {\romannumeral0\xintilen }%
\def\xintilen #1%
{%
    \expandafter\expandafter\expandafter
    \XINT@length@fork #1\R\R\R\R\R\R\R\R\Z
}%
\let\xintLen\xintiLen \let\xintlen\xintilen
\def\XINT@Len #1{\romannumeral0\XINT@length@fork #1\R\R\R\R\R\R\R\R\Z }%
\def\XINT@length@fork #1%
{%
    \expandafter\XINT@length@loop
    \xint@UDsignfork
      #1\dummy {{0}}%
       -\dummy {{0}#1}%
    \xint@UDkrof
}%
\def\XINT@Length #1{\romannumeral0\XINT@length@loop {0}#1\R\R\R\R\R\R\R\R\Z }%
\def\XINT@length #1{\XINT@length@loop {0}#1\R\R\R\R\R\R\R\R\Z }%
\let\xintLength\XINT@Length
\def\XINT@length@loop #1#2#3#4#5#6#7#8#9%  
{%
    \xint@r  #9\XINT@length@end {#2#3#4#5#6#7#8#9}\R
    \expandafter\XINT@length@loop\expandafter {\the\numexpr #1+8\relax}%
}%
\def\XINT@length@end #1\R\expandafter\XINT@length@loop\expandafter #2#3\Z
{%
    \XINT@length@end@ #1\W\W\W\W\W\W\W\W\Z {#2}%
}%
\def\XINT@length@end@ #1\R #2#3#4#5#6#7#8#9\Z 
{%
    \xint@w #2\XINT@length@end@i
            #3\XINT@length@end@ii
            #4\XINT@length@end@iii
            #5\XINT@length@end@iv
            #6\XINT@length@end@v
            #7\XINT@length@end@vi
            #8\XINT@length@end@vii
            \W\XINT@length@end@viii
}%
\def\XINT@length@end@viii #1%
    {\expandafter\space\the\numexpr #1-8\relax}%
\def\XINT@length@end@vii  #1\XINT@length@end@viii #2%
    {\expandafter\space\the\numexpr #2-7\relax}%
\def\XINT@length@end@vi   #1\XINT@length@end@viii #2%
    {\expandafter\space\the\numexpr #2-6\relax}%
\def\XINT@length@end@v    #1\XINT@length@end@viii #2%
    {\expandafter\space\the\numexpr #2-5\relax}%
\def\XINT@length@end@iv   #1\XINT@length@end@viii #2%
    {\expandafter\space\the\numexpr #2-4\relax}%
\def\XINT@length@end@iii  #1\XINT@length@end@viii #2%
    {\expandafter\space\the\numexpr #2-3\relax}%
\def\XINT@length@end@ii   #1\XINT@length@end@viii #2%
    {\expandafter\space\the\numexpr #2-2\relax}%
\def\XINT@length@end@i    #1\XINT@length@end@viii #2%
    {\expandafter\space\the\numexpr #2-1\relax}%
%    \end{macrocode}
% \subsection{\csh{xintAssign},~\csh{xintAssignArray},~\csh{xintDigitsOf}}
% \begin{verbatim}
% \xintAssign {a}{b}..{z}\to\A\B...\Z, 
% \xintAssignArray {a}{b}..{z}\to\U
% version 1.01 corrects an oversight in 1.0 related to the value of
% \escapechar at the time of using \xintAssignArray or \xintRelaxArray
% These macros are an exception in the xint bundle, they do not care at
% all about compatibility with expansion-only contexts. 
% In version 1.05a I suddenly discover incongruous \expandafter's in 
%  \XINT@assignarray@@@@end, which I remove.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintAssign #1\to
{%
    \expandafter\expandafter\expandafter
    \XINT@assign@a #1{}\to
}%
\def\XINT@assign@a #1% attention to the # at the beginning of next line
#{%
    \def\xint@temp {#1}%
    \ifx\empty\xint@temp
        \expandafter\XINT@assign@b 
    \else
        \expandafter\XINT@assign@B
    \fi
}%
\def\XINT@assign@b #1#2\to #3%
{% 
    \edef #3{#1}\def\xint@temp {#2}%
    \ifx\empty\xint@temp
      \else
      \xint@afterfi{\XINT@assign@a #2\to }%
    \fi
}%
\def\XINT@assign@B #1\to #2%
{%
    \edef #2{\xint@temp}%
}%
\def\xintRelaxArray #1%
{%
    \edef\XINT@restoreescapechar {\escapechar\the\escapechar\relax}%
    \escapechar -1
    \edef\xint@arrayname {\string #1}%
    \XINT@restoreescapechar
    \expandafter\let\expandafter\xint@temp
                \csname\xint@arrayname 0\endcsname
    \count 255 0
    \loop
      \global\expandafter\let
             \csname\xint@arrayname\the\count255\endcsname\relax
      \ifnum \count 255 < \xint@temp
      \advance\count 255 1
    \repeat  
    \global\expandafter\let\csname\xint@arrayname 00\endcsname\relax
    \global\let #1\relax    
}%
\def\xintAssignArray #1\to #2%
{% 
    \edef\XINT@restoreescapechar {\escapechar\the\escapechar\relax}%
    \escapechar -1
    \edef\xint@arrayname {\string #1}%
    \XINT@restoreescapechar
    \count 255 0
        \expandafter\expandafter\expandafter
    \XINT@assignarray@loop #1\xint@undef 
    \csname\xint@arrayname 00\endcsname
    \csname\xint@arrayname 0\endcsname 
    {\xint@arrayname}%
    #2%
}%
\def\XINT@assignarray@loop #1%
{%
    \def\xint@temp {#1}%
    \ifx\xint@bracedundef\xint@temp
       \edef\xint@temp{\the\count 255 }%
       \expandafter\let\csname\xint@arrayname0\endcsname\xint@temp
       \expandafter\XINT@assignarray@end
    \else
       \advance\count 255 1
       \expandafter\edef
          \csname\xint@arrayname\the\count 255\endcsname{\xint@temp}%
       \expandafter\XINT@assignarray@loop
    \fi
}%
\def\XINT@assignarray@end {\expandafter\XINT@assignarray@@end  }%
\def\XINT@assignarray@@end #1%
{%
    \expandafter\XINT@assignarray@@@end\expandafter #1%
}%
\def\XINT@assignarray@@@end #1#2#3%
{%
    \expandafter\XINT@assignarray@@@@end
    \expandafter #1\expandafter #2\expandafter{#3}%
}%
\def\XINT@assignarray@@@@end #1#2#3#4%
{%
    \def #4##1%
    {\romannumeral0%
        \expandafter\expandafter\expandafter
          #1%
        \expandafter\expandafter\expandafter
          {##1}%
    }%
    \def #1##1%
    {%
        \ifnum ##1< 0
            \xint@afterfi {\xintError:ArrayIndexIsNegative\space 0}%
        \else
            \xint@afterfi {%
              \ifnum ##1> #2
                  \xint@afterfi {\xintError:ArrayIndexBeyondLimit\space 0}%
              \else
                  \xint@afterfi
                  {\expandafter\expandafter\expandafter
                   \space\csname #3##1\endcsname}%
              \fi}%
        \fi
     }%
}%
\let\xintDigitsOf\xintAssignArray
%    \end{macrocode}
% \subsection{\csh{xintApply}}
% \begin{verbatim}
% \xintApply {\macro}{{a}{b}...{z}} returns {\macro{a}}...{\macro{b}}
% where each instance of \macro is twice expanded. The list is first twice
% expanded. Introduced with release 1.04.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintApply {\romannumeral0\xintapply }%
\def\xintapply #1#2%
{%
    \expandafter\expandafter\expandafter
    \XINT@apply 
    \expandafter\expandafter\expandafter
    {#2}{#1}%
}%
\def\XINT@apply #1#2%
{%
    \XINT@apply@loop@a {}{#2}#1\Z
}%
\def\XINT@apply@loop@a #1#2#3%
{%
    \xint@z #3\XINT@apply@end\Z 
    \expandafter\expandafter\expandafter
    \XINT@apply@loop@b 
    \expandafter\expandafter\expandafter {#2{#3}}{#1}{#2}%
}%
\def\XINT@apply@loop@b #1#2{\XINT@apply@loop@a {#2{#1}}}%
\def\XINT@apply@end\Z
    \expandafter\expandafter\expandafter
    \XINT@apply@loop@b 
    \expandafter\expandafter\expandafter #1#2#3{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintListWithSep}}
% \begin{verbatim}
% \xintListWithSep {sep}{{a}{b}...{z}} returns a sep b sep .... sep z
% Introduced with release 1.04. The 'sep' can be \par, as the macro
% xintlistwithsep etc... are declared long. 'sep' does not have to be a
% single token. 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintListWithSep {\romannumeral0\xintlistwithsep }%
\long\def\xintlistwithsep #1#2%
{%
    \expandafter\expandafter\expandafter
    \XINT@lws
    \expandafter\expandafter\expandafter
    {#2}{#1}%
}%
\long\def\XINT@lws #1#2%
{%
    \XINT@lws@start {#2}#1\Z
}%
\long\def\XINT@lws@start #1#2%
{%
    \xint@z #2\XINT@lws@dont\Z 
    \XINT@lws@loop@a {#2}{#1}%
}%
\long\def\XINT@lws@dont\Z\XINT@lws@loop@a #1#2{ #2}%
\long\def\XINT@lws@loop@a #1#2#3%
{%
    \xint@z #3\XINT@lws@end\Z
    \XINT@lws@loop@b {#1}{#2#3}{#2}%
}%
\long\def\XINT@lws@loop@b #1#2{\XINT@lws@loop@a {#1#2}}%
\long\def\XINT@lws@end\Z\XINT@lws@loop@b #1#2#3{ #1}%
%    \end{macrocode}
% \subsection{\csh{xintSgn}}
% \begin{verbatim}
% Changed in 1.05. Earlier code was unnecessarily strange.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintiSgn {\romannumeral0\xintisgn }%
\def\xintisgn #1%
{%
    \expandafter\expandafter\expandafter
    \XINT@sgn #1\Z%
}%
\let\xintSgn\xintiSgn \let\xintsgn\xintisgn
\def\XINT@Sgn #1{\romannumeral0\XINT@sgn #1\Z }%
\def\XINT@sgn #1#2\Z
{%
    \xint@UDzerominusfork
      #1-\dummy  { 0}%
      0#1\dummy  { -1}%
       0-\dummy  { 1}%
    \xint@UDkrof
}%
%    \end{macrocode}
% \subsection{\csh{xintOpp}}
%    \begin{macrocode}
\def\xintiOpp {\romannumeral0\xintiopp }%
\def\xintiopp #1%
{%
    \expandafter\expandafter\expandafter
        \XINT@opp #1%
}%
\let\xintOpp\xintiOpp \let\xintopp\xintiopp
\def\XINT@Opp #1{\romannumeral0\XINT@opp #1}%
\def\XINT@opp #1%
{%
    \expandafter\space
    \xint@UDzerominusfork
      #1-\dummy  0%      zero
      0#1\dummy  {}%     negative
       0-\dummy  {-#1}%  positive
    \xint@UDkrof
}%
%    \end{macrocode}
% \subsection{\csh{xintAbs}}
%    \begin{macrocode}
\def\xintiAbs {\romannumeral0\xintiabs }%
\def\xintiabs #1%
{%
    \expandafter\expandafter\expandafter
    \XINT@abs #1%
}%
\let\xintAbs\xintiAbs \let\xintabs\xintiabs
\def\XINT@Abs #1{\romannumeral0\XINT@abs #1}%
\def\XINT@abs #1%
{%
    \xint@UDsignfork
      #1\dummy  \space
       -\dummy  { #1}%
    \xint@UDkrof
}%
%    \end{macrocode}
% \begin{verbatim}
%-----------------------------------------------------------------
%-----------------------------------------------------------------
% ARITHMETIC OPERATIONS: ADDITION, SUBTRACTION, SUMS, 
% MULTIPLICATION, PRODUCTS, FACTORIAL, POWERS, EUCLIDEAN DIVISION.
%
% Release 1.03 re-organizes sub-routines to facilitate future developments: the
% diverse variants of addition, with diverse conditions on inputs and output are
% first listed; they will be used in multiplication, or in the summation, or in
% the power routines. 
%
% ADDITION
% I: \XINT@add@A
% INPUT:
% \romannumeral0\XINT@add@A 0{}<N1>\W\X\Y\Z <N2>\W\X\Y\Z
%     1.    <N1> et <N2> renversés 
%     2.    de longueur 4n (avec des leading zéros éventuels)
%     3.    l'un des deux ne doit pas se terminer par 0000
% [Donc on peut avoir 0000 comme input si l'autre est >0 et ne se termine pas en
% 0000 bien sûr]. On peut avoir l'un des deux vides. Mais alors l'autre ne doit
% être ni vide ni 0000.
% OUTPUT: la somme <N1>+<N2>, order normal, plus sur 4n, pas de leading zeros
% La procédure est plus rapide lorsque <N1> est le plus court des deux.
% Nota bene: (30 avril 2013). J'ai une version qui est deux fois plus rapide sur
% des nombres d'environ 1000 chiffres chacun, et qui commence à être avantageuse
% pour des nombres d'au moins 200 chiffres. Cependant il serait vraiment
% compliqué d'en étendre l'utilisation aux emplois de l'addition dans les
% autres routines, comme celle de multiplication ou celle de division; et son
% implémentation ajouterait au minimum la mesure de la longueur des summands.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@add@A #1#2#3#4#5#6%  
{%
    \xint@w #3\xint@add@az\W\XINT@add@AB #1{#3#4#5#6}{#2}% 
}%
\def\xint@add@az\W\XINT@add@AB #1#2%  
{%
    \XINT@add@AC@checkcarry #1% 
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% ici #2 est prévu pour l'addition, mais attention il devra être renversé pour
% \numexpr. #3 = résultat partiel. #4 = chiffres qui restent. On vérifie si le
% deuxième nombre s'arrête.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@add@AB #1#2#3#4\W\X\Y\Z #5#6#7#8%  
{%
    \xint@w #5\xint@add@bz\W 
    \XINT@add@ABE #1#2{#8#7#6#5}{#3}#4\W\X\Y\Z 
}%
\def\XINT@add@ABE #1#2#3#4#5#6%
{%
    \expandafter\XINT@add@ABEA\the\numexpr #1+10#5#4#3#2+#6\relax.%
}%
\def\XINT@add@ABEA #1#2#3.#4%  
{%
    \XINT@add@A  #2{#3#4}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% ici le deuxième nombre est fini
% #6 part à la poubelle, #2#3#4#5 est le #2 dans \XINT@add@AB
% on ne vérifie pas la retenue cette fois, mais les fois suivantes
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xint@add@bz\W\XINT@add@ABE #1#2#3#4#5#6%
{%
    \expandafter\XINT@add@CC\the\numexpr #1+10#5#4#3#2\relax.%
}%
\def\XINT@add@CC #1#2#3.#4%  
{%
    \XINT@add@AC@checkcarry  #2{#3#4}% on va examiner et \'eliminer #2
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% retenue plus chiffres qui restent de l'un des deux nombres.
% #2 = résultat partiel
% #3#4#5#6 = summand, avec plus significatif à droite
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@add@AC@checkcarry #1%
{%
    \xint@zero #1\xint@add@AC@nocarry 0\XINT@add@C 
}%
\def\xint@add@AC@nocarry 0\XINT@add@C #1#2\W\X\Y\Z
{%
    \expandafter
    \xint@cleanupzeros@andstop
    \romannumeral0%
    \XINT@rord@main {}#2%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
    #1%
}%
\def\XINT@add@C #1#2#3#4#5%  
{%
    \xint@w #2\xint@add@cz\W\XINT@add@CD {#5#4#3#2}{#1}%q
}%
\def\XINT@add@CD #1%
{%
    \expandafter\XINT@add@CC\the\numexpr 1+10#1\relax.%
}%
\def\xint@add@cz\W\XINT@add@CD #1#2{ 1#2}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Addition II: \XINT@addr@A. 
% INPUT:
% \romannumeral0\XINT@addr@A 0{}<N1>\W\X\Y\Z <N2>\W\X\Y\Z
% Comme \XINT@add@A, la différence principale c'est qu'elle donne son résultat
% aussi *sur 4n*, renversé. De plus cette variante accepte que l'un ou même les
% deux inputs soient vides.  
% Utilisé par la sommation et par la division (pour les quotients). Et aussi
% par la multiplication d'ailleurs. 
% INPUT: comme pour \XINT@add@A
%     1.    <N1> et <N2> renversés 
%     2.    de longueur 4n (avec des leading zéros éventuels)
%     3.    l'un des deux ne doit pas se terminer par 0000
% OUTPUT: la somme <N1>+<N2>, *aussi renversée* et *sur 4n*
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@addr@A #1#2#3#4#5#6%  
{%
    \xint@w #3\xint@addr@az\W\XINT@addr@B #1{#3#4#5#6}{#2}% 
}%
\def\xint@addr@az\W\XINT@addr@B #1#2%  
{%
    \XINT@addr@AC@checkcarry #1%
}%
\def\XINT@addr@B #1#2#3#4\W\X\Y\Z #5#6#7#8%  
{%
    \xint@w #5\xint@addr@bz\W\XINT@addr@E #1#2{#8#7#6#5}{#3}#4\W\X\Y\Z 
}%
\def\XINT@addr@E #1#2#3#4#5#6%
{%
    \expandafter\XINT@addr@ABEA\the\numexpr #1+10#5#4#3#2+#6\relax
}%
\def\XINT@addr@ABEA #1#2#3#4#5#6#7%  
{%
    \XINT@addr@A  #2{#7#6#5#4#3}%
}%
\def\xint@addr@bz\W\XINT@addr@E #1#2#3#4#5#6%
{%
    \expandafter\XINT@addr@CC\the\numexpr #1+10#5#4#3#2\relax
}%
\def\XINT@addr@CC #1#2#3#4#5#6#7%  
{%
    \XINT@addr@AC@checkcarry  #2{#7#6#5#4#3}%
}%
\def\XINT@addr@AC@checkcarry #1%
{%
    \xint@zero #1\xint@addr@AC@nocarry 0\XINT@addr@C 
}%
\def\xint@addr@AC@nocarry 0\XINT@addr@C #1#2\W\X\Y\Z { #1#2}%
\def\XINT@addr@C #1#2#3#4#5%  
{%
    \xint@w #2\xint@addr@cz\W\XINT@addr@D {#5#4#3#2}{#1}%
}%
\def\XINT@addr@D #1%
{%
    \expandafter\XINT@addr@CC\the\numexpr 1+10#1\relax
}%
\def\xint@addr@cz\W\XINT@addr@D #1#2{ #21000}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% ADDITION III, \XINT@addm@A
% INPUT:
% \romannumeral0\XINT@addm@A 0{}<N1>\W\X\Y\Z <N2>\W\X\Y\Z
%     1.    <N1> et <N2> renversés
%     2.    <N1> de longueur 4n ; <N2> non
%     3.    <N2> est *garanti au moins aussi long* que <N1>
% OUTPUT: la somme <N1>+<N2>, ordre normal, pas sur 4n, leading zeros retirés.
% Utilisé par la multiplication.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@addm@A #1#2#3#4#5#6%  
{%
    \xint@w #3\xint@addm@az\W\XINT@addm@AB #1{#3#4#5#6}{#2}% 
}%
\def\xint@addm@az\W\XINT@addm@AB #1#2%  
{%
    \XINT@addm@AC@checkcarry #1%
}%
\def\XINT@addm@AB #1#2#3#4\W\X\Y\Z #5#6#7#8%  
{%
    \XINT@addm@ABE #1#2{#8#7#6#5}{#3}#4\W\X\Y\Z 
}%
\def\XINT@addm@ABE #1#2#3#4#5#6%
{%
    \expandafter\XINT@addm@ABEA\the\numexpr #1+10#5#4#3#2+#6\relax.%
}%
\def\XINT@addm@ABEA #1#2#3.#4%  
{%
    \XINT@addm@A  #2{#3#4}%
}%
\def\XINT@addm@AC@checkcarry #1%
{%
    \xint@zero #1\xint@addm@AC@nocarry 0\XINT@addm@C 
}%
\def\xint@addm@AC@nocarry 0\XINT@addm@C #1#2\W\X\Y\Z
{%
    \expandafter
    \xint@cleanupzeros@andstop
    \romannumeral0%
    \XINT@rord@main {}#2%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
    #1%
}%
\def\XINT@addm@C #1#2#3#4#5%  
{%
    \xint@w 
    #5\xint@addm@cw
    #4\xint@addm@cx 
    #3\xint@addm@cy 
    #2\xint@addm@cz 
    \W\XINT@addm@CD {#5#4#3#2}{#1}%
}%
\def\XINT@addm@CD #1%
{%
    \expandafter\XINT@addm@CC\the\numexpr 1+10#1\relax.%
}%
\def\XINT@addm@CC #1#2#3.#4%  
{%
    \XINT@addm@AC@checkcarry  #2{#3#4}%
}%
\def\xint@addm@cw 
    #1\xint@addm@cx
    #2\xint@addm@cy
    #3\xint@addm@cz
    \W\XINT@addm@CD 
{%
    \expandafter\XINT@addm@CDw\the\numexpr 1+#1#2#3\relax.%
}%
\def\XINT@addm@CDw #1.#2#3\X\Y\Z 
{%
    \XINT@addm@end #1#3%
}%
\def\xint@addm@cx 
    #1\xint@addm@cy
    #2\xint@addm@cz
    \W\XINT@addm@CD 
{%
    \expandafter\XINT@addm@CDx\the\numexpr 1+#1#2\relax.%
}%
\def\XINT@addm@CDx #1.#2#3\Y\Z 
{%
    \XINT@addm@end #1#3%
}%
\def\xint@addm@cy 
    #1\xint@addm@cz
    \W\XINT@addm@CD
{%
    \expandafter\XINT@addm@CDy\the\numexpr 1+#1\relax.%
}%
\def\XINT@addm@CDy  #1.#2#3\Z 
{%
    \XINT@addm@end #1#3%
}%
\def\xint@addm@cz\W\XINT@addm@CD #1#2#3{\XINT@addm@end #1#3}%
\def\XINT@addm@end #1#2#3#4#5%
    {\expandafter\space\the\numexpr #1#2#3#4#5\relax}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% ADDITION IV, variante \XINT@addp@A
% INPUT:
% \romannumeral0\XINT@addp@A 0{}<N1>\W\X\Y\Z <N2>\W\X\Y\Z
%     1.    <N1> et <N2> renversés
%     2.    <N1> de longueur 4n ; <N2> non
%     3.    <N2> est *garanti au moins aussi long* que <N1>
% OUTPUT: la somme <N1>+<N2>, dans l'ordre renversé, sur 4n, et en faisant
% attention de ne pas terminer en 0000.
% Utilisé par la multiplication servant pour le calcul des puissances.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@addp@A #1#2#3#4#5#6%  
{%
    \xint@w #3\xint@addp@az\W\XINT@addp@AB #1{#3#4#5#6}{#2}% 
}%
\def\xint@addp@az\W\XINT@addp@AB #1#2%  
{%
    \XINT@addp@AC@checkcarry #1%
}%
\def\XINT@addp@AC@checkcarry #1%
{%
    \xint@zero #1\xint@addp@AC@nocarry 0\XINT@addp@C 
}%
\def\xint@addp@AC@nocarry 0\XINT@addp@C 
{%
    \XINT@addp@F
}%
\def\XINT@addp@AB #1#2#3#4\W\X\Y\Z #5#6#7#8%  
{%
    \XINT@addp@ABE #1#2{#8#7#6#5}{#3}#4\W\X\Y\Z 
}%
\def\XINT@addp@ABE #1#2#3#4#5#6%
{%
    \expandafter\XINT@addp@ABEA\the\numexpr #1+10#5#4#3#2+#6\relax
}%
\def\XINT@addp@ABEA #1#2#3#4#5#6#7%  
{% 
   \XINT@addp@A  #2{#7#6#5#4#3}%<-- attention on met donc \`a droite
}%
\def\XINT@addp@C #1#2#3#4#5%  
{%
    \xint@w 
    #5\xint@addp@cw
    #4\xint@addp@cx 
    #3\xint@addp@cy 
    #2\xint@addp@cz 
    \W\XINT@addp@CD   {#5#4#3#2}{#1}%
}%
\def\XINT@addp@CD #1%
{%
    \expandafter\XINT@addp@CC\the\numexpr 1+10#1\relax
}%
\def\XINT@addp@CC #1#2#3#4#5#6#7%
{%
    \XINT@addp@AC@checkcarry  #2{#7#6#5#4#3}%
}%
\def\xint@addp@cw 
    #1\xint@addp@cx
    #2\xint@addp@cy
    #3\xint@addp@cz
    \W\XINT@addp@CD 
{%
    \expandafter\XINT@addp@CDw\the\numexpr 1+10#1#2#3\relax
}%
\def\XINT@addp@CDw #1#2#3#4#5#6%  
{%
    \xint@quatrezeros #2#3#4#5\XINT@addp@endDw@zeros 
                          0000\XINT@addp@endDw #2#3#4#5%
}%
\def\XINT@addp@endDw@zeros 0000\XINT@addp@endDw 0000#1\X\Y\Z{ #1}%
\def\XINT@addp@endDw #1#2#3#4#5\X\Y\Z{ #5#4#3#2#1}%
\def\xint@addp@cx 
    #1\xint@addp@cy
    #2\xint@addp@cz
    \W\XINT@addp@CD 
{%
    \expandafter\XINT@addp@CDx\the\numexpr 1+100#1#2\relax
}%
\def\XINT@addp@CDx #1#2#3#4#5#6%  
{%
    \xint@quatrezeros #2#3#4#5\XINT@addp@endDx@zeros
                          0000\XINT@addp@endDx #2#3#4#5%
}%
\def\XINT@addp@endDx@zeros 0000\XINT@addp@endDx 0000#1\Y\Z{ #1}%
\def\XINT@addp@endDx #1#2#3#4#5\Y\Z{ #5#4#3#2#1}%
\def\xint@addp@cy 
    #1\xint@addp@cz
    \W\XINT@addp@CD 
{%
    \expandafter\XINT@addp@CDy\the\numexpr 1+1000#1\relax
}%
\def\XINT@addp@CDy #1#2#3#4#5#6%  
{%
    \xint@quatrezeros #2#3#4#5\XINT@addp@endDy@zeros
                          0000\XINT@addp@endDy #2#3#4#5%
}%
\def\XINT@addp@endDy@zeros 0000\XINT@addp@endDy 0000#1\Z{ #1}%
\def\XINT@addp@endDy #1#2#3#4#5\Z{ #5#4#3#2#1}%
\def\xint@addp@cz\W\XINT@addp@CD #1#2{ #21000}%
\def\XINT@addp@F #1#2#3#4#5%  
{%
    \xint@w 
    #5\xint@addp@Gw
    #4\xint@addp@Gx 
    #3\xint@addp@Gy 
    #2\xint@addp@Gz 
    \W\XINT@addp@G   {#2#3#4#5}{#1}%
}%
\def\XINT@addp@G #1#2%
{%
    \XINT@addp@F {#2#1}%
}%
\def\xint@addp@Gw 
    #1\xint@addp@Gx
    #2\xint@addp@Gy
    #3\xint@addp@Gz
    \W\XINT@addp@G #4%
{%
    \xint@quatrezeros  #3#2#10\XINT@addp@endGw@zeros 
                          0000\XINT@addp@endGw #3#2#10%
}%
\def\XINT@addp@endGw@zeros 0000\XINT@addp@endGw 0000#1\X\Y\Z{ #1}%
\def\XINT@addp@endGw #1#2#3#4#5\X\Y\Z{ #5#1#2#3#4}%
\def\xint@addp@Gx
    #1\xint@addp@Gy
    #2\xint@addp@Gz
    \W\XINT@addp@G #3%
{%
    \xint@quatrezeros  #2#100\XINT@addp@endGx@zeros 
                         0000\XINT@addp@endGx #2#100%
}%
\def\XINT@addp@endGx@zeros 0000\XINT@addp@endGx 0000#1\Y\Z{ #1}%
\def\XINT@addp@endGx #1#2#3#4#5\Y\Z{ #5#1#2#3#4}%
\def\xint@addp@Gy
    #1\xint@addp@Gz
    \W\XINT@addp@G #2%
{%
    \xint@quatrezeros   #1000\XINT@addp@endGy@zeros 
                         0000\XINT@addp@endGy #1000%
}%
\def\XINT@addp@endGy@zeros 0000\XINT@addp@endGy 0000#1\Z{ #1}%
\def\XINT@addp@endGy #1#2#3#4#5\Z{ #5#1#2#3#4}%
\def\xint@addp@Gz\W\XINT@addp@G #1#2{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintAdd}}
%    \begin{macrocode}
\def\xintiAdd {\romannumeral0\xintiadd }%
\def\xintiadd #1%
{%
    \expandafter\expandafter\expandafter
           \xint@add
    \expandafter\expandafter\expandafter
           {#1}%
}%
\let\xintAdd\xintiAdd \let\xintadd\xintiadd
\def\xint@add #1#2%
{%
    \expandafter\expandafter\expandafter
    \XINT@add@fork #2\Z #1\Z 
}%
\def\XINT@Add #1#2{\romannumeral0\XINT@add@fork #2\Z #1\Z }%
\def\XINT@add #1#2{\XINT@add@fork #2\Z #1\Z }%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
%    ADDITION 
% Ici #1#2 vient du *deuxième* argument de \xintAdd
% et  #3#4 donc du *premier* [algo plus efficace lorsque
% le premier est plus long que le second]
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@add@fork #1#2\Z #3#4\Z
{%
    \xint@UDzerofork
      #1\dummy \XINT@add@secondiszero
      #3\dummy \XINT@add@firstiszero
       0\dummy 
        {\xint@UDsignsfork
          #1#3\dummy \XINT@add@minusminus          % #1 = #3 = -
           #1-\dummy \XINT@add@minusplus           % #1 = -
           #3-\dummy \XINT@add@plusminus           % #3 = -
            --\dummy \XINT@add@plusplus
         \xint@UDkrof }%
    \xint@UDkrof
    {#2}{#4}#1#3%
}%
\def\XINT@add@secondiszero #1#2#3#4{ #4#2}%
\def\XINT@add@firstiszero #1#2#3#4{ #3#1}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1 vient du *deuxième* et #2 vient du *premier*
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@add@minusminus #1#2#3#4%
{%
    \expandafter\xint@minus@andstop%
    \romannumeral0\XINT@add@pre {#2}{#1}%
}%
\def\XINT@add@minusplus #1#2#3#4%
{%
    \XINT@sub@pre {#4#2}{#1}%
}%
\def\XINT@add@plusminus #1#2#3#4%
{%
    \XINT@sub@pre {#3#1}{#2}%
}%
\def\XINT@add@plusplus #1#2#3#4%
{%
    \XINT@add@pre {#4#2}{#3#1}%
}%
\def\XINT@add@pre #1%
{%
  \expandafter\XINT@add@@pre\expandafter{%
  \romannumeral0\XINT@RQ {}#1\R\R\R\R\R\R\R\R\Z
  }%
}%
\def\XINT@add@@pre #1#2%
{% 
    \expandafter\XINT@add@A
        \expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT@RQ {}#2\R\R\R\R\R\R\R\R\Z
        \W\X\Y\Z #1\W\X\Y\Z
}%
%    \end{macrocode}
% \subsection{\csh{xintSub}}
%    \begin{macrocode}
\def\xintiSub {\romannumeral0\xintisub }%
\def\xintisub #1%
{%
    \expandafter\expandafter\expandafter
           \xint@sub
    \expandafter\expandafter\expandafter
           {#1}%
}%
\let\xintSub\xintiSub \let\xintsub\xintisub
\def\xint@sub #1#2%
{%
    \expandafter\expandafter\expandafter
    \XINT@sub@fork #2\Z #1\Z 
}%
\def\XINT@Sub #1#2{\romannumeral0\XINT@sub@fork #2\Z #1\Z }%
\def\XINT@sub #1#2{\XINT@sub@fork #2\Z #1\Z }%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% SOUSTRACTION
% #3#4-#1#2
% #3#4 vient du *premier*
% #1#2 vient du *second*
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@sub@fork #1#2\Z #3#4\Z
{%
    \xint@UDsignsfork
          #1#3\dummy \XINT@sub@minusminus
           #1-\dummy \XINT@sub@minusplus   % attention, #3=0 possible
           #3-\dummy \XINT@sub@plusminus   % attention, #1=0 possible
            --\dummy {\xint@UDzerofork
                      #1\dummy \XINT@sub@secondiszero
                      #3\dummy \XINT@sub@firstiszero
                       0\dummy \XINT@sub@plusplus
                      \xint@UDkrof }%
    \xint@UDkrof
    {#2}{#4}#1#3%
}%
\def\XINT@sub@secondiszero #1#2#3#4{ #4#2}%
\def\XINT@sub@firstiszero  #1#2#3#4{ -#3#1}%
\def\XINT@sub@plusplus #1#2#3#4%
{%
    \XINT@sub@pre {#4#2}{#3#1}%
}%
\def\XINT@sub@minusminus #1#2#3#4%
{%
    \XINT@sub@pre {#1}{#2}%
}%
\def\XINT@sub@minusplus #1#2#3#4% 
{%
    \xint@zero #4\xint@sub@mp0\XINT@add@pre {#4#2}{#1}%
}%
\def\xint@sub@mp0\XINT@add@pre #1#2{ #2}%
\def\XINT@sub@plusminus #1#2#3#4% 
{%
    \xint@zero #3\xint@sub@pm0\expandafter\xint@minus@andstop%
    \romannumeral0\XINT@add@pre {#2}{#3#1}%
}%
\def\xint@sub@pm #1\XINT@add@pre #2#3{ -#2}%
\def\XINT@sub@pre #1%
{%
  \expandafter\XINT@sub@@pre\expandafter{%
  \romannumeral0\XINT@RQ {}#1\R\R\R\R\R\R\R\R\Z
  }%
}%
\def\XINT@sub@@pre #1#2%
{% 
    \expandafter\XINT@sub@A
        \expandafter1\expandafter{\expandafter}%
    \romannumeral0\XINT@RQ {}#2\R\R\R\R\R\R\R\R\Z
        \W\X\Y\Z #1 \W\X\Y\Z
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% \romannumeral0\XINT@sub@A 1{}<N1>\W\X\Y\Z<N2>\W\X\Y\Z
% N1 et N2 sont présentés à l'envers ET ON A RAJOUTÉ DES ZÉROS
% POUR QUE LEURS LONGUEURS À CHACUN SOIENT MULTIPLES DE 4, MAIS
% AUCUN NE SE TERMINE EN 0000
% output: N2 - N1
% Elle donne le résultat dans le **bon ordre**, avec le bon signe,
% et sans zéros superflus.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@sub@A #1#2#3\W\X\Y\Z #4#5#6#7%  
{%
    \xint@w 
    #4\xint@sub@az 
    \W\XINT@sub@B #1{#4#5#6#7}{#2}#3\W\X\Y\Z 
}%
\def\XINT@sub@B #1#2#3#4#5#6#7%  
{%
    \xint@w 
    #4\xint@sub@bz 
    \W\XINT@sub@onestep #1#2{#7#6#5#4}{#3}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% d'abord la branche principale
% #6 = 4 chiffres de N1, plus significatif en *premier*, 
% #2#3#4#5 chiffres de N2, plus significatif en *dernier*
% On veut N2 - N1.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@sub@onestep #1#2#3#4#5#6%
{%
    \expandafter\XINT@sub@backtoA\the\numexpr 11#5#4#3#2-#6+#1-1\relax.%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% ON PRODUIT LE RÉSULTAT DANS LE BON ORDRE
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@sub@backtoA #1#2#3.#4%
{%
    \XINT@sub@A #2{#3#4}%
}%
\def\xint@sub@bz 
    \W\XINT@sub@onestep #1#2#3#4#5#6#7%
{%
    \xint@UDzerofork
      #1\dummy  \XINT@sub@C   % une retenue
       0\dummy  \XINT@sub@D   % pas de retenue
    \xint@UDkrof
    {#7}#2#3#4#5%
}%
\def\XINT@sub@D #1#2\W\X\Y\Z
{%
    \expandafter
    \xint@cleanupzeros@andstop
    \romannumeral0%
    \XINT@rord@main {}#2%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
    #1%
}%
\def\XINT@sub@C #1#2#3#4#5%
{%
    \xint@w 
    #2\xint@sub@cz 
    \W\XINT@sub@AC@onestep {#5#4#3#2}{#1}%
}%
\def\XINT@sub@AC@onestep #1%
{%
    \expandafter\XINT@sub@backtoC\the\numexpr 11#1-1\relax.%
}%
\def\XINT@sub@backtoC #1#2#3.#4%
{%
    \XINT@sub@AC@checkcarry #2{#3#4}% la retenue va \^etre examin\'ee
}%
\def\XINT@sub@AC@checkcarry #1%
{%
    \xint@one #1\xint@sub@AC@nocarry 1\XINT@sub@C 
}%
\def\xint@sub@AC@nocarry 1\XINT@sub@C #1#2\W\X\Y\Z
{%
    \expandafter
    \XINT@cuz@loop
    \romannumeral0%
    \XINT@rord@main {}#2%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
    #1\W\W\W\W\W\W\W\Z
}%
\def\xint@sub@cz\W\XINT@sub@AC@onestep #1%
{%
    \XINT@cuz
}%
\def\xint@sub@az\W\XINT@sub@B #1#2#3#4#5#6#7%  
{%
    \xint@w 
    #4\xint@sub@ez 
    \W\XINT@sub@Eenter #1{#3}#4#5#6#7%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% le premier nombre continue, le résultat sera < 0.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@sub@Eenter #1#2%
{%
    \expandafter
    \XINT@sub@E\expandafter1\expandafter{\expandafter}%
    \romannumeral0%
    \XINT@rord@main {}#2%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
    \W\X\Y\Z #1%
}%
\def\XINT@sub@E #1#2#3#4#5#6%
{%
    \xint@w #3\xint@sub@F\W\XINT@sub@Eonestep
    #1{#6#5#4#3}{#2}%
}%
\def\XINT@sub@Eonestep #1#2%
{%
    \expandafter\XINT@sub@backtoE\the\numexpr 109999-#2+#1\relax.%
}%
\def\XINT@sub@backtoE #1#2#3.#4%
{%
    \XINT@sub@E #2{#3#4}%
}%
\def\xint@sub@F\W\XINT@sub@Eonestep #1#2#3#4%
{%
    \xint@UDonezerofork
      #4#1\dummy {\XINT@sub@Fdec 0}% soustraire  1. Et faire signe -
      #1#4\dummy {\XINT@sub@Finc 1}% additionner 1. Et faire signe -
        10\dummy  \XINT@sub@DD     % terminer. Mais avec signe -
    \xint@UDkrof
    {#3}%
}%
\def\XINT@sub@DD {\expandafter\xint@minus@andstop\romannumeral0\XINT@sub@D }%
\def\XINT@sub@Fdec #1#2#3#4#5#6%
{%
    \xint@w 
    #3\xint@sub@Fdec@finish\W\XINT@sub@Fdec@onestep
    #1{#6#5#4#3}{#2}%
}%
\def\XINT@sub@Fdec@onestep #1#2%
{%
    \expandafter\XINT@sub@backtoFdec\the\numexpr 11#2+#1-1\relax.%
}%
\def\XINT@sub@backtoFdec #1#2#3.#4%
{%
    \XINT@sub@Fdec #2{#3#4}%
}%
\def\xint@sub@Fdec@finish\W\XINT@sub@Fdec@onestep #1#2%
{%
    \expandafter\xint@minus@andstop\romannumeral0\XINT@cuz
}%
\def\XINT@sub@Finc #1#2#3#4#5#6%
{%
    \xint@w 
    #3\xint@sub@Finc@finish\W\XINT@sub@Finc@onestep
    #1{#6#5#4#3}{#2}%
}%
\def\XINT@sub@Finc@onestep #1#2%
{%
    \expandafter\XINT@sub@backtoFinc\the\numexpr 10#2+#1\relax.%
}%
\def\XINT@sub@backtoFinc #1#2#3.#4%
{%
    \XINT@sub@Finc #2{#3#4}%
}%
\def\xint@sub@Finc@finish\W\XINT@sub@Finc@onestep #1#2#3%
{%
    \xint@UDzerofork
     #1\dummy {\expandafter\xint@minus@andstop%
               \xint@cleanupzeros@nospace}%
      0\dummy { -1}%
    \xint@UDkrof
    #3%
}%
\def\xint@sub@ez\W\XINT@sub@Eenter #1%
{%
    \xint@UDzerofork
      #1\dummy \XINT@sub@K % il y a une retenue
       0\dummy \XINT@sub@L % pas de retenue
    \xint@UDkrof
}%
\def\XINT@sub@L #1\W\X\Y\Z 
   {\XINT@cuz@loop #1\W\W\W\W\W\W\W\Z }%
\def\XINT@sub@K #1%
{%
    \expandafter
    \XINT@sub@KK\expandafter1\expandafter{\expandafter}%
    \romannumeral0%
    \XINT@rord@main {}#1%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
}%
\def\XINT@sub@KK #1#2#3#4#5#6%
{%
    \xint@w 
    #3\xint@sub@KK@finish\W\XINT@sub@KK@onestep
    #1{#6#5#4#3}{#2}%
}%
\def\XINT@sub@KK@onestep #1#2%
{%
    \expandafter\XINT@sub@backtoKK\the\numexpr 109999-#2+#1\relax.%
}%
\def\XINT@sub@backtoKK #1#2#3.#4%
{%
    \XINT@sub@KK #2{#3#4}%
}%
\def\xint@sub@KK@finish\W\XINT@sub@KK@onestep #1#2#3%
{%
    \expandafter\xint@minus@andstop\romannumeral
    0\XINT@cuz@loop #3\W\W\W\W\W\W\W\Z
}%
%    \end{macrocode}
% \subsection{\csh{xintCmp}}
%    \begin{macrocode}
\def\xintiCmp {\romannumeral0\xinticmp }%
\def\xinticmp #1%
{%
    \expandafter\expandafter\expandafter
        \xint@cmp
    \expandafter\expandafter\expandafter
        {#1}%
}%
\let\xintCmp\xintiCmp \let\xintcmp\xinticmp
\def\xint@cmp #1#2%
{%
    \expandafter\expandafter\expandafter
    \XINT@cmp@fork #2\Z #1\Z 
}%
\def\XINT@Cmp #1#2{\romannumeral0\XINT@cmp@fork #2\Z #1\Z }%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
%    COMPARAISON 
% 1 si #3#4>#1#2, 0 si #3#4=#1#2, -1 si #3#4<#1#2
% #3#4 vient du *premier*
% #1#2 vient du *second*
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@cmp@fork #1#2\Z #3#4\Z
{%
    \xint@UDsignsfork
          #1#3\dummy \XINT@cmp@minusminus
           #1-\dummy \XINT@cmp@minusplus   
           #3-\dummy \XINT@cmp@plusminus   
            --\dummy {\xint@UDzerosfork
                      #1#3\dummy \XINT@cmp@zerozero
                       #10\dummy \XINT@cmp@zeroplus
                       #30\dummy \XINT@cmp@pluszero
                        00\dummy \XINT@cmp@plusplus
                      \xint@UDkrof }%
    \xint@UDkrof
    {#2}{#4}#1#3%
}%
\def\XINT@cmp@minusplus #1#2#3#4{ 1}%
\def\XINT@cmp@plusminus #1#2#3#4{ -1}%
\def\XINT@cmp@zerozero  #1#2#3#4{ 0}%
\def\XINT@cmp@zeroplus  #1#2#3#4{ 1}%
\def\XINT@cmp@pluszero  #1#2#3#4{ -1}%
\def\XINT@cmp@plusplus #1#2#3#4%
{%
    \XINT@cmp@pre {#4#2}{#3#1}%
}%
\def\XINT@cmp@minusminus #1#2#3#4%
{%
    \XINT@cmp@pre {#1}{#2}%
}%
\def\XINT@cmp@pre #1%
{%
  \expandafter\XINT@cmp@@pre\expandafter{%
  \romannumeral0\XINT@RQ {}#1\R\R\R\R\R\R\R\R\Z
  }%
}%
\def\XINT@cmp@@pre #1#2%
{% 
    \expandafter\XINT@cmp@A
    \expandafter1\expandafter{\expandafter}%
    \romannumeral0\XINT@RQ {}#2\R\R\R\R\R\R\R\R\Z
        \W\X\Y\Z #1\W\X\Y\Z
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% COMPARAISON
% N1 et N2 sont présentés à l'envers ET ON A RAJOUTÉ DES ZÉROS
% POUR QUE LEURS LONGUEURS À CHACUN SOIENT MULTIPLES DE 4, MAIS
% AUCUN NE SE TERMINE EN 0000
% routine appelée via \XINT@cmp@A 1{}<N1>\W\X\Y\Z<N2>\W\X\Y\Z
% ATTENTION RENVOIE 1 SI N1 < N2, 0 si N1 = N2, -1 si N1 > N2
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@cmp@A #1#2#3\W\X\Y\Z #4#5#6#7%  
{%
    \xint@w 
    #4\xint@cmp@az 
    \W\XINT@cmp@B #1{#4#5#6#7}{#2}#3\W\X\Y\Z 
}%
\def\XINT@cmp@B #1#2#3#4#5#6#7%  
{%
    \xint@w 
    #4\xint@cmp@bz 
    \W\XINT@cmp@onestep #1#2{#7#6#5#4}{#3}%
}%
\def\XINT@cmp@onestep #1#2#3#4#5#6%
{%
    \expandafter\XINT@cmp@backtoA\the\numexpr 11#5#4#3#2-#6+#1-1\relax.%
}%
\def\XINT@cmp@backtoA #1#2#3.#4%
{%
    \XINT@cmp@A #2{#3#4}%
}%
\def\xint@cmp@bz 
    \W\XINT@cmp@onestep #1\Z { 1}%
\def\xint@cmp@az\W\XINT@cmp@B #1#2#3#4#5#6#7%  
{%
    \xint@w 
    #4\xint@cmp@ez 
    \W\XINT@cmp@Eenter #1{#3}#4#5#6#7%
}%
\def\XINT@cmp@Eenter #1\Z { -1}%
\def\xint@cmp@ez\W\XINT@cmp@Eenter #1%
{%
    \xint@UDzerofork
      #1\dummy \XINT@cmp@K             %     il y a une retenue
       0\dummy \XINT@cmp@L             %     pas de retenue
    \xint@UDkrof
}%
\def\XINT@cmp@K #1\Z { -1}%
\def\XINT@cmp@L #1{\XINT@OneIfPositive@main #1}%
\def\XINT@OneIfPositive #1%
{%
    \XINT@OneIfPositive@main #1\W\X\Y\Z%
}%
\def\XINT@OneIfPositive@main #1#2#3#4%
{%
    \xint@z #4\xint@OneIfPositive@terminated\Z\XINT@OneIfPositive@onestep
    #1#2#3#4%
}%
\def\xint@OneIfPositive@terminated\Z\XINT@OneIfPositive@onestep\W\X\Y\Z { 0}%
\def\XINT@OneIfPositive@onestep #1#2#3#4%
{%
    \expandafter\XINT@OneIfPositive@check
    \the\numexpr #1#2#3#4\relax
}%
\def\XINT@OneIfPositive@check #1%
{%
    \xint@zero
    #1\xint@OneIfPositive@backtomain 0\XINT@OneIfPositive@finish #1%
}%
\def\XINT@OneIfPositive@finish #1\W\X\Y\Z{ 1}%
\def\xint@OneIfPositive@backtomain 0\XINT@OneIfPositive@finish 0%
                   {\XINT@OneIfPositive@main }%
%    \end{macrocode}
% \subsection{\csh{xintGeq}}
% \begin{verbatim}
%    PLUS GRAND OU ÉGAL
% attention compare les **valeurs absolues**
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintiGeq {\romannumeral0\xintigeq }%
\def\xintigeq #1%
{%
    \expandafter\expandafter\expandafter
      \xint@geq
    \expandafter\expandafter\expandafter
      {#1}%
}%
\let\xintGeq\xintiGeq \let\xintgeq\xintigeq
\def\xint@geq #1#2%
{%
    \expandafter\expandafter\expandafter\XINT@geq@fork #2\Z #1\Z 
}%
\def\XINT@Geq #1#2{\romannumeral0\XINT@geq@fork #2\Z #1\Z }%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
%    PLUS GRAND OU ÉGAL 
% ATTENTION, TESTE les VALEURS ABSOLUES
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@geq@fork #1#2\Z #3#4\Z
{%
    \xint@UDzerofork
      #1\dummy \XINT@geq@secondiszero % |#1#2|=0
      #3\dummy \XINT@geq@firstiszero % |#1#2|>0
       0\dummy {\xint@UDsignsfork
                  #1#3\dummy \XINT@geq@minusminus
                   #1-\dummy \XINT@geq@minusplus   
                   #3-\dummy \XINT@geq@plusminus
                    --\dummy \XINT@geq@plusplus
                \xint@UDkrof }%
    \xint@UDkrof
    {#2}{#4}#1#3%
}%
\def\XINT@geq@secondiszero     #1#2#3#4{ 1}%
\def\XINT@geq@firstiszero      #1#2#3#4{ 0}%
\def\XINT@geq@plusplus  #1#2#3#4%
         {\XINT@geq@pre {#4#2}{#3#1}}%
\def\XINT@geq@minusminus  #1#2#3#4%
         {\XINT@geq@pre {#2}{#1}}%
\def\XINT@geq@minusplus #1#2#3#4%
         {\XINT@geq@pre {#4#2}{#1}}%
\def\XINT@geq@plusminus #1#2#3#4%
         {\XINT@geq@pre {#2}{#3#1}}%
\def\XINT@geq@pre #1%
{%
  \expandafter\XINT@geq@@pre\expandafter{%
  \romannumeral0\XINT@RQ {}#1\R\R\R\R\R\R\R\R\Z
  }%
}%
\def\XINT@geq@@pre #1#2%
{% 
    \expandafter\XINT@geq@A
    \expandafter1\expandafter{\expandafter}%
    \romannumeral0\XINT@RQ {}#2\R\R\R\R\R\R\R\R\Z
        \W\X\Y\Z #1 \W\X\Y\Z
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% PLUS GRAND OU ÉGAL
% N1 et N2 sont présentés à l'envers ET ON A RAJOUTÉ DES ZÉROS
% POUR QUE LEURS LONGUEURS À CHACUN SOIENT MULTIPLES DE 4, MAIS
% AUCUN NE SE TERMINE EN 0000
% routine appelée via 
% \romannumeral0\XINT@geq@A 1{}<N1>\W\X\Y\Z<N2>\W\X\Y\Z
% ATTENTION RENVOIE 1 SI N1 < N2 ou N1 = N2 et 0 si N1 > N2
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@geq@A #1#2#3\W\X\Y\Z #4#5#6#7%  
{%
    \xint@w 
    #4\xint@geq@az 
    \W\XINT@geq@B #1{#4#5#6#7}{#2}#3\W\X\Y\Z 
}%
\def\XINT@geq@B #1#2#3#4#5#6#7%  
{%
    \xint@w 
    #4\xint@geq@bz 
    \W\XINT@geq@onestep #1#2{#7#6#5#4}{#3}%
}%
\def\XINT@geq@onestep #1#2#3#4#5#6%
{%
    \expandafter\XINT@geq@backtoA\the\numexpr 11#5#4#3#2-#6+#1-1\relax.%
}%
\def\XINT@geq@backtoA #1#2#3.#4%
{%
    \XINT@geq@A #2{#3#4}%
}%
\def\xint@geq@bz\W\XINT@geq@onestep #1\W\X\Y\Z { 1}%
\def\xint@geq@az\W\XINT@geq@B #1#2#3#4#5#6#7%  
{%
    \xint@w 
    #4\xint@geq@ez 
    \W\XINT@geq@Eenter #1%
}%
\def\XINT@geq@Eenter #1\W\X\Y\Z { 0}%
\def\xint@geq@ez\W\XINT@geq@Eenter #1%
{%
    \xint@UDzerofork
      #1\dummy { 0}             %     il y a une retenue
       0\dummy { 1}             %     pas de retenue
    \xint@UDkrof
}%
%    \end{macrocode}
% \subsection{\csh{xintMax}}
% \begin{verbatim}
% The rationale is that it is more efficient than using \xintCmp.
% 1.03 makes the code a tiny bit slower but easier to re-use for fractions. 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintiMax {\romannumeral0\xintimax }%
\def\xintimax #1%
{%
    \expandafter\expandafter\expandafter
        \xint@max
    \expandafter\expandafter\expandafter
        {#1}%
}%
\let\xintMax\xintiMax \let\xintmax\xintimax
\def\xint@max #1#2%
{%
    \expandafter\expandafter\expandafter
    \XINT@max@pre
    \expandafter\expandafter\expandafter {#2}{#1}%
}%
\def\XINT@max@pre #1#2{\XINT@max@fork #1\Z #2\Z {#2}{#1}}%
\def\XINT@Max #1#2{\romannumeral0\XINT@max@fork #2\Z #1\Z {#1}{#2}}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #3#4 vient du *premier*
% #1#2 vient du *second*
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@max@fork #1#2\Z #3#4\Z
{%
    \xint@UDsignsfork
          #1#3\dummy \XINT@max@minusminus  % A < 0, B < 0
           #1-\dummy \XINT@max@minusplus   % B < 0, A >= 0   
           #3-\dummy \XINT@max@plusminus   % A < 0, B >= 0 
            --\dummy {\xint@UDzerosfork
                      #1#3\dummy \XINT@max@zerozero % A = B = 0
                       #10\dummy \XINT@max@zeroplus % B = 0, A > 0
                       #30\dummy \XINT@max@pluszero % A = 0, B > 0
                        00\dummy \XINT@max@plusplus % A, B > 0
                      \xint@UDkrof }%
    \xint@UDkrof
    {#2}{#4}#1#3%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% A = #4#2, B = #3#1
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@max@zerozero  #1#2#3#4{\xint@firstoftwo@andstop }%
\def\XINT@max@zeroplus  #1#2#3#4{\xint@firstoftwo@andstop }%
\def\XINT@max@pluszero  #1#2#3#4{\xint@secondoftwo@andstop }%
\def\XINT@max@minusplus #1#2#3#4{\xint@firstoftwo@andstop }%
\def\XINT@max@plusminus #1#2#3#4{\xint@secondoftwo@andstop }%
\def\XINT@max@plusplus  #1#2#3#4%
{%
    \ifodd\XINT@Geq {#4#2}{#3#1}
      \expandafter\xint@firstoftwo@andstop
    \else
      \expandafter\xint@secondoftwo@andstop
    \fi
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #3=-, #4=-, #1 = |B| = -B, #2 = |A| = -A
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@max@minusminus #1#2#3#4%
{%
    \ifodd\XINT@Geq {#1}{#2}
      \expandafter\xint@firstoftwo@andstop
    \else
      \expandafter\xint@secondoftwo@andstop
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintMin}}
%    \begin{macrocode}
\def\xintiMin {\romannumeral0\xintimin }%
\def\xintimin #1%
{%
    \expandafter\expandafter\expandafter
        \xint@min
    \expandafter\expandafter\expandafter
        {#1}%
}%
\let\xintMin\xintiMin \let\xintmin\xintimin
\def\xint@min #1#2%
{%
    \expandafter\expandafter\expandafter
    \XINT@min@pre
    \expandafter\expandafter\expandafter {#2}{#1}%
}%
\def\XINT@min@pre #1#2{\XINT@min@fork #1\Z #2\Z {#2}{#1}}%
\def\XINT@Min #1#2{\romannumeral0\XINT@min@fork #2\Z #1\Z {#1}{#2}}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #3#4 vient du *premier*
% #1#2 vient du *second*
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@min@fork #1#2\Z #3#4\Z
{%
    \xint@UDsignsfork
          #1#3\dummy \XINT@min@minusminus  % A < 0, B < 0
           #1-\dummy \XINT@min@minusplus   % B < 0, A >= 0   
           #3-\dummy \XINT@min@plusminus   % A < 0, B >= 0 
            --\dummy {\xint@UDzerosfork
                      #1#3\dummy \XINT@min@zerozero % A = B = 0
                       #10\dummy \XINT@min@zeroplus % B = 0, A > 0
                       #30\dummy \XINT@min@pluszero % A = 0, B > 0
                        00\dummy \XINT@min@plusplus % A, B > 0
                      \xint@UDkrof }%
    \xint@UDkrof
    {#2}{#4}#1#3%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% A = #4#2, B = #3#1
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@min@zerozero  #1#2#3#4{\xint@firstoftwo@andstop }%
\def\XINT@min@zeroplus  #1#2#3#4{\xint@secondoftwo@andstop }%
\def\XINT@min@pluszero  #1#2#3#4{\xint@firstoftwo@andstop }%
\def\XINT@min@minusplus #1#2#3#4{\xint@secondoftwo@andstop }%
\def\XINT@min@plusminus #1#2#3#4{\xint@firstoftwo@andstop }%
\def\XINT@min@plusplus #1#2#3#4%
{%
    \ifodd\XINT@Geq {#4#2}{#3#1}
      \expandafter\xint@secondoftwo@andstop
    \else
      \expandafter\xint@firstoftwo@andstop
    \fi
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #3=-, #4=-, #1 = |B| = -B, #2 = |A| = -A
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@min@minusminus #1#2#3#4%
{%
    \ifodd\XINT@Geq {#1}{#2}
      \expandafter\xint@secondoftwo@andstop
    \else
      \expandafter\xint@firstoftwo@andstop
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintSum}, \csh{xintSumExpr}}
% \begin{verbatim}
% \xintSum {{a}{b}...{z}}
% \xintSumExpr {a}{b}...{z}\relax
% 1.03 (drastically) simplifies and makes the routines more efficient (for big
% computations). Also the way \xintSum and \xintSumExpr ...\relax are related.
% has been modified. Now \xintSumExpr \z \relax is accepted input when
% \z expands to a list of braced terms (prior only \xintSum {\z} or \xintSum \z
% was possible).  
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintiSum {\romannumeral0\xintisum }%
\def\xintisum #1{\xintisumexpr #1\relax }%
\def\xintiSumExpr {\romannumeral0\xintisumexpr }%
\def\xintisumexpr
{%
    \expandafter\expandafter\expandafter\XINT@sumexpr
}%
\let\xintSum\xintiSum \let\xintsum\xintisum 
\let\xintSumExpr\xintiSumExpr \let\xintsumexpr\xintisumexpr
\def\XINT@sumexpr {\XINT@sum@loop {0000}{0000}}%
\def\XINT@sum@loop #1#2#3%
{%
    \expandafter\expandafter\expandafter\XINT@sum@checksign #3\Z {#1}{#2}%
}%
\def\XINT@sum@checksign #1%
{%
    \xint@relax #1\XINT@sum@finished\relax
    \xint@zero #1\XINT@sum@skipzeroinput0%
    \xint@UDsignfork
      #1\dummy \XINT@sum@N
       -\dummy {\XINT@sum@P #1}%
    \xint@UDkrof
}%
\def\XINT@sum@finished #1\Z #2#3%
{%
    \XINT@sub@A 1{}#3\W\X\Y\Z #2\W\X\Y\Z
}%
\def\XINT@sum@skipzeroinput #1\xint@UDkrof #2\Z {\XINT@sum@loop }%
\def\XINT@sum@P #1\Z #2%
{%
    \expandafter\XINT@sum@loop\expandafter
    {\romannumeral0\expandafter
     \XINT@addr@A\expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT@RQ {}#1\R\R\R\R\R\R\R\R\Z
    \W\X\Y\Z #2\W\X\Y\Z }%
}%
\def\XINT@sum@N #1\Z #2#3%
{%
    \expandafter\XINT@sum@NN\expandafter
    {\romannumeral0\expandafter
     \XINT@addr@A\expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT@RQ {}#1\R\R\R\R\R\R\R\R\Z
    \W\X\Y\Z #3\W\X\Y\Z }{#2}%
}%
\def\XINT@sum@NN #1#2{\XINT@sum@loop {#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintMul}}
%    \begin{macrocode}
\def\xintiMul {\romannumeral0\xintimul }%
\def\xintimul #1%
{%
    \expandafter\expandafter\expandafter
        \xint@mul
    \expandafter\expandafter\expandafter
        {#1}%
}%
\let\xintMul\xintiMul \let\xintmul\xintimul
\def\xint@mul #1#2%
{\expandafter\expandafter\expandafter
       \XINT@mul@fork #2\Z #1\Z 
}%
\def\XINT@Mul #1#2{\romannumeral0\XINT@mul@fork #2\Z #1\Z }%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
%   MULTIPLICATION
% Ici #1#2 = 2e input et #3#4 = 1er input 
% Release 1.03 adds some overhead to first compute and compare the
% lengths of the two inputs. The algorithm is asymmetrical and whether
% the first input is the longest or the shortest sometimes has a strong
% impact. 50 digits times 1000 digits used to be 5 times faster
% than 1000 digits times 50 digits. With the new code, the user input
% order does not matter as it is decided by the routine what is best.
% This is important for  the extension to fractions, as there is no way
% then to generally control or guess the most frequent sizes of the
% inputs besides actually computing their lengths.  
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@mul@fork #1#2\Z #3#4\Z
{%
    \xint@UDzerofork
      #1\dummy \XINT@mul@zero
      #3\dummy \XINT@mul@zero
       0\dummy 
        {\xint@UDsignsfork
          #1#3\dummy \XINT@mul@minusminus          % #1 = #3 = -
           #1-\dummy {\XINT@mul@minusplus #3}%          % #1 = -
           #3-\dummy {\XINT@mul@plusminus #1}%          % #3 = -
            --\dummy {\XINT@mul@plusplus #1#3}%
         \xint@UDkrof }%
    \xint@UDkrof
    {#2}{#4}%
}%
\def\XINT@mul@zero #1#2{ 0}%
\def\XINT@mul@minusminus #1#2%
{%
      \expandafter\XINT@mul@choice@a
      \expandafter{\romannumeral0\XINT@length {#2}}%
      {\romannumeral0\XINT@length {#1}}{#1}{#2}%
}%
\def\XINT@mul@minusplus #1#2#3%
{%
      \expandafter\xint@minus@andstop\romannumeral0\expandafter
      \XINT@mul@choice@a
      \expandafter{\romannumeral0\XINT@length {#1#3}}%
      {\romannumeral0\XINT@length {#2}}{#2}{#1#3}%
}%
\def\XINT@mul@plusminus #1#2#3%
{%
      \expandafter\xint@minus@andstop\romannumeral0\expandafter
      \XINT@mul@choice@a
      \expandafter{\romannumeral0\XINT@length {#3}}%
      {\romannumeral0\XINT@length {#1#2}}{#1#2}{#3}%
}%
\def\XINT@mul@plusplus #1#2#3#4%
{%
    \expandafter\XINT@mul@choice@a
    \expandafter{\romannumeral0\XINT@length {#2#4}}%
    {\romannumeral0\XINT@length {#1#3}}{#1#3}{#2#4}%
}%
\def\XINT@mul@choice@a #1#2%
{%
    \expandafter\XINT@mul@choice@b\expandafter{#2}{#1}%
}%
\def\XINT@mul@choice@b #1#2%
{%
    \ifnum #1<5
       \expandafter\XINT@mul@choice@littlebyfirst
    \else
    \ifnum #2<5
      \expandafter\expandafter\expandafter\XINT@mul@choice@littlebysecond
      \else
      \expandafter\expandafter\expandafter\XINT@mul@choice@compare
      \fi
    \fi      
    {#1}{#2}%
}%
\def\XINT@mul@choice@littlebyfirst #1#2#3#4%
{%
    \expandafter\XINT@mul@M
    \expandafter{\the\numexpr #3\expandafter}%
    \romannumeral0\XINT@RQ {}#4\R\R\R\R\R\R\R\R\Z \Z\Z\Z\Z
}%
\def\XINT@mul@choice@littlebysecond #1#2#3#4%
{%
    \expandafter\XINT@mul@M
    \expandafter{\the\numexpr #4\expandafter}%
    \romannumeral0\XINT@RQ {}#3\R\R\R\R\R\R\R\R\Z \Z\Z\Z\Z
}%
\def\XINT@mul@choice@compare #1#2%
{%
    \ifnum #1>#2
        \expandafter \XINT@mul@choice@i
    \else
        \expandafter \XINT@mul@choice@ii
    \fi
    {#1}{#2}%
}%
\def\XINT@mul@choice@i #1#2%
{%
   \ifcase \numexpr (#2-3)/4\relax
   \or \xint@afterfi {\ifnum #1<330 \expandafter \XINT@mul@choice@same
                      \else  \expandafter \XINT@mul@choice@permute \fi}%  
   \or \xint@afterfi {\ifnum #1<168 \expandafter \XINT@mul@choice@same
                      \else  \expandafter \XINT@mul@choice@permute \fi}%  
   \or \xint@afterfi {\ifnum #1<109 \expandafter \XINT@mul@choice@same
                      \else  \expandafter \XINT@mul@choice@permute \fi}%  
   \or \xint@afterfi {\ifnum #1<80 \expandafter \XINT@mul@choice@same
                      \else  \expandafter \XINT@mul@choice@permute \fi}%  
   \or \xint@afterfi {\ifnum #1<66 \expandafter \XINT@mul@choice@same
                      \else  \expandafter \XINT@mul@choice@permute \fi}%  
   \or \xint@afterfi {\ifnum #1<52 \expandafter \XINT@mul@choice@same
                      \else  \expandafter \XINT@mul@choice@permute \fi}%  
   \else \expandafter \XINT@mul@choice@permute
   \fi
}% 
\def\XINT@mul@choice@ii #1#2%
{%
   \ifcase \numexpr (#1-3)/4\relax
   \or \xint@afterfi {\ifnum #2<330 \expandafter \XINT@mul@choice@permute
                      \else  \expandafter \XINT@mul@choice@same \fi}%  
   \or \xint@afterfi {\ifnum #2<168 \expandafter \XINT@mul@choice@permute
                      \else  \expandafter \XINT@mul@choice@same \fi}%  
   \or \xint@afterfi {\ifnum #2<109 \expandafter \XINT@mul@choice@permute
                      \else  \expandafter \XINT@mul@choice@same \fi}%  
   \or \xint@afterfi {\ifnum #2<80 \expandafter \XINT@mul@choice@permute
                      \else  \expandafter \XINT@mul@choice@same \fi}%  
   \or \xint@afterfi {\ifnum #2<66 \expandafter \XINT@mul@choice@permute
                      \else  \expandafter \XINT@mul@choice@same \fi}%  
   \or \xint@afterfi {\ifnum #2<52 \expandafter \XINT@mul@choice@permute
                      \else  \expandafter \XINT@mul@choice@same \fi}%  
   \else \expandafter \XINT@mul@choice@same
   \fi
}% 
\def\XINT@mul@choice@same #1#2%
{%
    \expandafter\XINT@mul@enter
    \romannumeral0\XINT@RQ {}#1\R\R\R\R\R\R\R\R\Z
    \W\X\Y\Z #2\W\X\Y\Z 
}%
\def\XINT@mul@choice@permute #1#2%
{%
    \expandafter\XINT@mul@enter
    \romannumeral0\XINT@RQ {}#2\R\R\R\R\R\R\R\R\Z
    \W\X\Y\Z #1\W\X\Y\Z 
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Cette portion de routine d'addition se branche directement sur @addr@ lorsque
% le premier nombre est épuisé, ce qui est garanti arriver avant le second
% nombre. Elle produit son résultat toujours sur 4n, renversé. Ses deux inputs
% sont garantis sur 4n.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@mul@Ar #1#2#3#4#5#6%  
{%
    \xint@z #6\xint@mul@br\Z\XINT@mul@Br #1{#6#5#4#3}{#2}% 
}%
\def\xint@mul@br\Z\XINT@mul@Br #1#2%  
{%
     \XINT@addr@AC@checkcarry #1%
}%
\def\XINT@mul@Br #1#2#3#4\W\X\Y\Z #5#6#7#8%
{%
    \expandafter\XINT@mul@ABEAr
    \the\numexpr #1+10#2+#8#7#6#5\relax.{#3}#4\W\X\Y\Z
}%
\def\XINT@mul@ABEAr #1#2#3#4#5#6.#7%
{%
    \XINT@mul@Ar #2{#7#6#5#4#3}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% << Petite >> multiplication.
% mul@Mr renvoie le résultat *à l'envers*, sur *4n*
% \romannumeral0\XINT@mul@Mr {<n>}<N>\Z\Z\Z\Z
% Fait la multiplication de <N> par <n>, qui est < 10000.
% <N> est présenté *à l'envers*, sur *4n*. Lorsque <n> vaut 0, donne 0000.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@mul@Mr #1%
{%
    \expandafter\XINT@mul@Mr@checkifzeroorone
    \expandafter{\the\numexpr #1}%
}%
\def\XINT@mul@Mr@checkifzeroorone #1%
{%
    \ifcase #1
      \expandafter\XINT@mul@Mr@zero
    \or 
      \expandafter\XINT@mul@Mr@one
    \else
      \expandafter\XINT@mul@Nr
    \fi
    {0000}{}{#1}%
}%
\def\XINT@mul@Mr@zero #1\Z\Z\Z\Z { 0000}%
\def\XINT@mul@Mr@one #1#2#3#4\Z\Z\Z\Z { #4}%
\def\XINT@mul@Nr #1#2#3#4#5#6#7%
{% 
    \xint@z #4\xint@mul@pr\Z\XINT@mul@Pr {#1}{#3}{#7#6#5#4}{#2}{#3}%
}%
\def\XINT@mul@Pr #1#2#3%
{%
    \expandafter\XINT@mul@Lr\the\numexpr 10000#1+#2*#3\relax 
}%
\def\XINT@mul@Lr 1#1#2#3#4#5#6#7#8#9%
{%
    \XINT@mul@Nr {#1#2#3#4}{#9#8#7#6#5}%
}%
\def\xint@mul@pr\Z\XINT@mul@Pr #1#2#3#4#5%
{%
    \xint@quatrezeros #1\XINT@mul@Mr@end@nocarry 0000\XINT@mul@Mr@end@carry
    #1{#4}%
}%
\def\XINT@mul@Mr@end@nocarry 0000\XINT@mul@Mr@end@carry 0000#1{ #1}%
\def\XINT@mul@Mr@end@carry #1#2#3#4#5{ #5#4#3#2#1}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% << Petite >> multiplication.
%renvoie le résultat *à l'endroit*, avec *nettoyage des leading zéros*.
% \romannumeral0\XINT@mul@M  {<n>}<N>\Z\Z\Z\Z
% Fait la multiplication de <N> par <n>, qui est < 10000.
% <N> est présenté *à l'envers*, sur *4n*. 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@mul@M #1%
{%
    \expandafter\XINT@mul@M@checkifzeroorone
    \expandafter{\the\numexpr #1}%
}%
\def\XINT@mul@M@checkifzeroorone #1%
{%
    \ifcase #1
      \expandafter\XINT@mul@M@zero
    \or 
      \expandafter\XINT@mul@M@one
    \else
      \expandafter\XINT@mul@N
    \fi
    {0000}{}{#1}%
}%
\def\XINT@mul@M@zero #1\Z\Z\Z\Z { 0}%
\def\XINT@mul@M@one #1#2#3#4\Z\Z\Z\Z 
{%
    \expandafter\xint@cleanupzeros@andstop
    \romannumeral0\XINT@rev{#4}%
}%
\def\XINT@mul@N #1#2#3#4#5#6#7%
{% 
    \xint@z #4\xint@mul@p\Z\XINT@mul@P {#1}{#3}{#7#6#5#4}{#2}{#3}%
}%
\def\XINT@mul@P #1#2#3%
{%
    \expandafter\XINT@mul@L\the\numexpr 10000#1+#2*#3\relax 
}%
\def\XINT@mul@L 1#1#2#3#4#5#6#7#8#9%
{%
    \XINT@mul@N {#1#2#3#4}{#5#6#7#8#9}%
}%
\def\xint@mul@p\Z\XINT@mul@P #1#2#3#4#5%
{%
    \XINT@mul@M@end #1#4%
}%
\def\XINT@mul@M@end #1#2#3#4#5#6#7#8%
{%
    \expandafter\space\the\numexpr #1#2#3#4#5#6#7#8\relax
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Routine de multiplication principale
% délimiteur \W\X\Y\Z
% Le résultat partiel est toujours maintenu avec significatif à
% droite et il a un nombre multiple de 4 de chiffres
% \romannumeral0\XINT@mul@enter <N1>\W\X\Y\Z <N2>\W\X\Y\Z
% avec <N1> *renversé*, *longueur 4n* (zéros éventuellement ajoutés
% au-delà du chiffre le plus significatif)
% et <N2> dans l'ordre *normal*, et pas forcément longueur 4n.
% pas de signes
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@mul@enter #1\W\X\Y\Z #2#3#4#5%
{% 
    \xint@w
    #5\xint@mul@enterw 
    #4\xint@mul@enterx 
    #3\xint@mul@entery 
    #2\xint@mul@enterz 
    \W\XINT@mul@start {#2#3#4#5}#1\W\X\Y\Z 
}%
\def\xint@mul@enterw 
    #1\xint@mul@enterx 
    #2\xint@mul@entery 
    #3\xint@mul@enterz
    \W\XINT@mul@start  #4#5\W\X\Y\Z \X\Y\Z 
{%
    \XINT@mul@M {#3#2#1}#5\Z\Z\Z\Z 
}%
\def\xint@mul@enterx 
    #1\xint@mul@entery 
    #2\xint@mul@enterz
    \W\XINT@mul@start  #3#4\W\X\Y\Z \Y\Z 
{%
    \XINT@mul@M {#2#1}#4\Z\Z\Z\Z 
}%
\def\xint@mul@entery 
    #1\xint@mul@enterz
    \W\XINT@mul@start  #2#3\W\X\Y\Z \Z 
{%
    \XINT@mul@M {#1}#3\Z\Z\Z\Z 
}%
\def\XINT@mul@start #1#2\W\X\Y\Z 
{%
    \expandafter\XINT@mul@main\expandafter
    {\romannumeral0\XINT@mul@Mr {#1}#2\Z\Z\Z\Z}#2\W\X\Y\Z 
}%
\def\XINT@mul@main #1#2\W\X\Y\Z #3#4#5#6%
{%
    \xint@w 
    #6\xint@mul@mainw
    #5\xint@mul@mainx 
    #4\xint@mul@mainy 
    #3\xint@mul@mainz 
    \W\XINT@mul@compute {#1}{#3#4#5#6}#2\W\X\Y\Z 
}%
\def\XINT@mul@compute #1#2#3\W\X\Y\Z 
{%
    \expandafter\XINT@mul@main\expandafter
    {\romannumeral0\expandafter
     \XINT@mul@Ar\expandafter0\expandafter{\expandafter}%
     \romannumeral0\XINT@mul@Mr {#2}#3\Z\Z\Z\Z 
     \W\X\Y\Z 0000#1\W\X\Y\Z }#3\W\X\Y\Z 
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Ici, le deuxième nombre se termine. Fin du calcul. On utilise la variante
% \XINT@addm@A de l'addition car on sait que le deuxième terme est au moins
% aussi long que le premier. Lorsque le multiplicateur avait longueur 4n, la
% dernière addition a fourni le résultat à l'envers, il faut donc encore le
% renverser. 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xint@mul@mainw 
    #1\xint@mul@mainx 
    #2\xint@mul@mainy 
    #3\xint@mul@mainz
    \W\XINT@mul@compute  #4#5#6\W\X\Y\Z \X\Y\Z 
{%
    \expandafter\XINT@addm@A \expandafter0\expandafter{\expandafter}%
          \romannumeral0%
    \XINT@mul@Mr {#3#2#1}#6\Z\Z\Z\Z
                 \W\X\Y\Z 000#4\W\X\Y\Z 
}%
\def\xint@mul@mainx 
    #1\xint@mul@mainy 
    #2\xint@mul@mainz
    \W\XINT@mul@compute  #3#4#5\W\X\Y\Z \Y\Z 
{%
    \expandafter\XINT@addm@A\expandafter
    0\expandafter{\expandafter}%
    \romannumeral0\XINT@mul@Mr {#2#1}#5\Z\Z\Z\Z 
    \W\X\Y\Z 00#3\W\X\Y\Z 
}%
\def\xint@mul@mainy 
    #1\xint@mul@mainz
    \W\XINT@mul@compute  #2#3#4\W\X\Y\Z \Z 
{%
    \expandafter\XINT@addm@A\expandafter
    0\expandafter{\expandafter}%
    \romannumeral0\XINT@mul@Mr {#1}#4\Z\Z\Z\Z 
     \W\X\Y\Z 0#2\W\X\Y\Z 
}%
\def\xint@mul@mainz\W\XINT@mul@compute #1#2#3\W\X\Y\Z 
{%
    \expandafter\xint@cleanupzeros@andstop\romannumeral0\XINT@rev{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
%   Variante de la Multiplication
%   \romannumeral0\XINT@mulr@enter <N1>\W\X\Y\Z <N2>\W\X\Y\Z
%   Ici <N1> est à l'envers sur 4n, et <N2> est à l'endroit, pas sur 4n, comme
%   dans \XINT@mul@enter, mais le résultat est lui-même fourni *à l'envers*, sur
%   *4n* (en faisant attention de ne pas avoir 0000 à la fin).
% Utilisé par le calcul des puissances et aussi par la division.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@mulr@enter #1\W\X\Y\Z #2#3#4#5%
{% 
    \xint@w          
    #5\xint@mulr@enterw 
    #4\xint@mulr@enterx 
    #3\xint@mulr@entery 
    #2\xint@mulr@enterz 
    \W\XINT@mulr@start {#2#3#4#5}#1\W\X\Y\Z 
}%
\def\xint@mulr@enterw 
    #1\xint@mulr@enterx 
    #2\xint@mulr@entery 
    #3\xint@mulr@enterz
    \W\XINT@mulr@start  #4#5\W\X\Y\Z \X\Y\Z 
{%
    \XINT@mul@Mr {#3#2#1}#5\Z\Z\Z\Z 
}%
\def\xint@mulr@enterx 
    #1\xint@mulr@entery 
    #2\xint@mulr@enterz
    \W\XINT@mulr@start  #3#4\W\X\Y\Z \Y\Z 
{%
    \XINT@mul@Mr {#2#1}#4\Z\Z\Z\Z 
}%
\def\xint@mulr@entery 
    #1\xint@mulr@enterz
    \W\XINT@mulr@start  #2#3\W\X\Y\Z \Z 
{%
    \XINT@mul@Mr {#1}#3\Z\Z\Z\Z 
}%
\def\XINT@mulr@start #1#2\W\X\Y\Z 
{%
    \expandafter\XINT@mulr@main\expandafter
    {\romannumeral0\XINT@mul@Mr {#1}#2\Z\Z\Z\Z }#2\W\X\Y\Z 
}%
\def\XINT@mulr@main #1#2\W\X\Y\Z #3#4#5#6%
{%
    \xint@w 
    #6\xint@mulr@mainw
    #5\xint@mulr@mainx 
    #4\xint@mulr@mainy 
    #3\xint@mulr@mainz 
    \W\XINT@mulr@compute {#1}{#3#4#5#6}#2\W\X\Y\Z 
}%
\def\XINT@mulr@compute #1#2#3\W\X\Y\Z 
{%
    \expandafter\XINT@mulr@main\expandafter
    {\romannumeral0\expandafter
       \XINT@mul@Ar \expandafter0\expandafter{\expandafter}%
       \romannumeral0\XINT@mul@Mr {#2}#3\Z\Z\Z\Z \W\X\Y\Z 0000#1\W\X\Y\Z 
    }#3\W\X\Y\Z 
}%
\def\xint@mulr@mainw 
    #1\xint@mulr@mainx 
    #2\xint@mulr@mainy 
    #3\xint@mulr@mainz
    \W\XINT@mulr@compute #4#5#6\W\X\Y\Z \X\Y\Z 
{%
    \expandafter\XINT@addp@A 
    \expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT@mul@Mr {#3#2#1}#6\Z\Z\Z\Z
                 \W\X\Y\Z 000#4\W\X\Y\Z
}%
\def\xint@mulr@mainx 
    #1\xint@mulr@mainy 
    #2\xint@mulr@mainz
    \W\XINT@mulr@compute  #3#4#5\W\X\Y\Z \Y\Z 
{%
    \expandafter\XINT@addp@A 
    \expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT@mul@Mr {#2#1}#5\Z\Z\Z\Z 
                 \W\X\Y\Z 00#3\W\X\Y\Z
}%
\def\xint@mulr@mainy 
    #1\xint@mulr@mainz
    \W\XINT@mulr@compute #2#3#4\W\X\Y\Z \Z 
{%
    \expandafter\XINT@addp@A 
    \expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT@mul@Mr {#1}#4\Z\Z\Z\Z 
                 \W\X\Y\Z 0#2\W\X\Y\Z
}%
\def\xint@mulr@mainz\W\XINT@mulr@compute #1#2#3\W\X\Y\Z { #1}%
%    \end{macrocode}
% \subsection{\csh{xintSqr}}
%    \begin{macrocode}
\def\xintiSqr {\romannumeral0\xintisqr }%
\def\xintisqr #1%
{%
    \expandafter\expandafter\expandafter
    \XINT@sqr
    \expandafter\expandafter\expandafter
    {\xintiAbs{#1}}% fait l'expansion de #1 et se d\'ebarrasse du signe
}%
\let\xintSqr\xintiSqr \let\xintsqr\xintisqr
\def\XINT@sqr #1%
{%
    \expandafter\XINT@mul@enter
          \romannumeral0%
          \XINT@RQ {}#1\R\R\R\R\R\R\R\R\Z
          \W\X\Y\Z #1\W\X\Y\Z 
}%
%    \end{macrocode}
% \subsection{\csh{xintPrd}, \csh{xintProductExpr}}
% \begin{verbatim}
% \xintPrd {{a}...{z}}
% \xintProductExpr {a}...{z}\relax
% Release 1.02 modified the product routine.  The earlier version was faster in
% situations where each new term is bigger than the product of all previous
% terms, a situation which arises in the algorithm for computing powers. The
% 1.02 version was changed to be more efficient on big products, where the new
% term is small compared to what has been computed so far (the power algorithm
% now has its own product routine). 
% 
% Finally, the 1.03 version just simplifies everything as the multiplication now
% decides what is best, with the price of a little overhead. So the code has
% been dramatically reduced here. 
% 
% In 1.03 I also modify the way \xintPrd and \xintProductExpr ...\relax are
% related. Now \xintProductExpr \z \relax is accepted input when \z expands
% to a list of braced terms (prior only \xintPrd {\z} or \xintPrd \z was
% possible). 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintiPrd {\romannumeral0\xintiprd }%
\def\xintiprd #1{\xintiproductexpr #1\relax }%
\let\xintPrd\xintiPrd 
\let\xintprd\xintiprd
\def\xintiProductExpr {\romannumeral0\xintiproductexpr }%
\def\xintiproductexpr
{%
    \expandafter\expandafter\expandafter\XINT@productexpr
}%
\let\xintProductExpr\xintiProductExpr 
\let\xintproductexpr\xintiproductexpr
\def\XINT@productexpr {\XINT@prod@loop@a 1\Z }%
\def\XINT@prod@loop@a #1\Z #2%
{%
    \expandafter\expandafter\expandafter\XINT@prod@loop@b #2\Z #1\Z \Z
}%
\def\XINT@prod@loop@b #1%
{%
   \xint@relax #1\XINT@prod@finished\relax
   \XINT@prod@loop@c #1%
}%
\def\XINT@prod@loop@c
{%
    \expandafter\XINT@prod@loop@a\romannumeral0\XINT@mul@fork
}%
\def\XINT@prod@finished #1\Z #2\Z \Z { #2}%
%    \end{macrocode}
% \subsection{\csh{xintFac}}
% \begin{verbatim}
% Modified with 1.02 and again in 1.03 for greater efficiency. I am tempted,
% here and elsewhere, to use \ifcase\XINT@Geq  {#1}{1000000000}  rather than
% \ifnum\XINT@Length {#1}>9 but for the time being I leave things as they stand.
% With release 1.05, rather than using \XINT@Length I opt finally for direct use
% of \numexpr (which will throw a suitable number too big message), and to raise
% the \xintError:FactorialOfTooBigNumber for argument larger than 1000000
% (rather than 1000000000). 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintFac {\romannumeral0\xintfac }%
\def\xintfac #1%
{%
    \expandafter\expandafter\expandafter
        \XINT@fac@fork
    \expandafter\expandafter\expandafter
        {#1}%
}%
\def\XINT@Fac {\romannumeral0\XINT@fac@fork }%
\def\XINT@fac@fork #1%
{%
    \ifcase\XINT@Sgn {#1}
       \xint@afterfi{\expandafter\space\expandafter 1\xint@gobble }%
    \or
       \expandafter\XINT@fac@checklength
    \else
       \xint@afterfi{\expandafter\xintError:FactorialOfNegativeNumber
                \expandafter\space\expandafter 1\xint@gobble }%
    \fi
    {#1}%
}%
\def\XINT@fac@checklength #1%
{%
    \ifnum\numexpr #1\relax>999999
         \xint@afterfi{\expandafter\xintError:FactorialOfTooBigNumber
                       \expandafter\space\expandafter 1\xint@gobble }%
    \else
         \xint@afterfi{\ifnum #1>9999
                          \expandafter\XINT@fac@big@loop
                       \else
                          \expandafter\XINT@fac@loop
                       \fi }%
    \fi
    {#1}%
}%
\def\XINT@fac@big@loop #1{\XINT@fac@big@loop@main {10000}{#1}{}}%
\def\XINT@fac@big@loop@main #1#2#3%
{%
    \ifnum #1<#2
        \expandafter
            \XINT@fac@big@loop@main
        \expandafter
           {\the\numexpr #1+1\expandafter }%
    \else
        \expandafter\XINT@fac@big@docomputation
    \fi
    {#2}{#3{#1}}%
}%
\def\XINT@fac@big@docomputation #1#2%
{%
    \expandafter \XINT@fac@bigcompute@loop \expandafter
    {\romannumeral0\XINT@fac@loop {9999}}#2\relax
}%
\def\XINT@fac@bigcompute@loop #1#2%
{%
    \xint@relax #2\XINT@fac@bigcompute@end\relax
    \expandafter\XINT@fac@bigcompute@loop\expandafter
    {\expandafter\XINT@mul@enter
     \romannumeral0\XINT@RQ {}#2\R\R\R\R\R\R\R\R\Z
     \W\X\Y\Z #1\W\X\Y\Z }% 
}%
\def\XINT@fac@bigcompute@end #1#2#3#4#5%
{%
    \XINT@fac@bigcompute@end@ #5%
}%
\def\XINT@fac@bigcompute@end@ #1\R #2\Z \W\X\Y\Z #3\W\X\Y\Z { #3}%
\def\XINT@fac@loop #1{\XINT@fac@loop@main 1{1000}{#1}}%
\def\XINT@fac@loop@main #1#2#3%
{%
    \ifnum #3>#1
    \else
        \expandafter\XINT@fac@loop@exit
    \fi
    \expandafter\XINT@fac@loop@main\expandafter
    {\the\numexpr #1+1\expandafter }\expandafter
    {\romannumeral0\XINT@mul@Mr {#1}#2\Z\Z\Z\Z }%
    {#3}%
}%
\def\XINT@fac@loop@exit #1#2#3#4#5#6#7%
{%
    \XINT@fac@loop@exit@ #6%
}%
\def\XINT@fac@loop@exit@ #1#2#3%
{%
    \XINT@mul@M 
}%
%    \end{macrocode}
% \subsection{\csh{xintPow}}
% \begin{verbatim}
% 1.02 modified the \XINT@posprod routine, and this meant that the original
% version was moved here and renamed to \XINT@pow@posprod, as it was well
% adapted for computing powers. Then I moved in 1.03 the special variants of
% multiplication (hence of addition) which were needed to earlier in this file. 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintiPow {\romannumeral0\xintipow }%
\def\xintipow #1%
{%
    \expandafter\expandafter\expandafter\xint@pow
       #1\Z%
}%
\let\xintPow\xintiPow \let\xintpow\xintipow
\def\xint@pow #1#2\Z 
{% 
    \xint@UDsignfork
      #1\dummy \XINT@pow@Aneg
       -\dummy \XINT@pow@Anonneg
    \xint@UDkrof
       #1{#2}%
}%
\def\XINT@pow@Aneg #1#2#3%
{%
   \expandafter\expandafter\expandafter
      \XINT@pow@Aneg@
   \expandafter\expandafter\expandafter
      {#3}{#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% B = #1, xpxp déjà fait
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@pow@Aneg@ #1%
{%
   \ifcase\XINT@Odd{#1}
   \or \expandafter\XINT@pow@Aneg@Bodd
   \fi
   \XINT@pow@Anonneg@ {#1}%
}%
\def\XINT@pow@Aneg@Bodd #1%
{%
    \expandafter\XINT@opp\romannumeral0\XINT@pow@Anonneg@ 
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% B = #3, faire le xpxp
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@pow@Anonneg #1#2#3%
{%
   \expandafter\expandafter\expandafter
      \XINT@pow@Anonneg@
   \expandafter\expandafter\expandafter
   {#3}{#1#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1 = B, #2 = |A|
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@pow@Anonneg@ #1#2%
{%
    \ifcase\XINT@Cmp {#2}{1}
        \expandafter\XINT@pow@AisOne
    \or 
        \expandafter\XINT@pow@AatleastTwo
    \else
        \expandafter\XINT@pow@AisZero
    \fi
    {#1}{#2}%
}%
\def\XINT@pow@AisOne #1#2{ 1}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1 = B
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@pow@AisZero #1#2%
{%
     \ifcase\XINT@Sgn {#1}
         \xint@afterfi { 1}%
     \or
         \xint@afterfi { 0}%
     \else
         \xint@afterfi {\xintError:DivisionByZero\space 0}%
     \fi
}%
\def\XINT@pow@AatleastTwo #1%
{%
    \ifcase\XINT@Sgn {#1}
        \expandafter\XINT@pow@BisZero
    \or
        \expandafter\XINT@pow@checkBlength
    \else
        \expandafter\XINT@pow@BisNegative
    \fi
    {#1}%
}%
\def\XINT@pow@BisNegative #1#2{\xintError:FractionRoundedToZero\space 0}%
\def\XINT@pow@BisZero #1#2{ 1}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% B = #1 > 0, A = #2 > 1. With 1.05, I replace \xintiLen{#1}>9 by direct use
% of \numexpr.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@pow@checkBlength #1#2%
{%
    \ifnum\numexpr #1\relax >999999999 
        \expandafter\XINT@pow@BtooBig
    \else
        \expandafter\XINT@pow@loop
    \fi
    {#1}{#2}\XINT@pow@posprod
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
}%
\def\XINT@pow@BtooBig #1\xint@UNDEF #2\xint@UNDEF 
                         {\xintError:ExponentTooBig\space 0}%
\def\XINT@pow@loop #1#2%
{%
    \ifnum #1 = 1
        \expandafter\XINT@pow@loop@end 
    \else
        \xint@afterfi{\expandafter\XINT@pow@loop@a
            \expandafter{\the\numexpr 2*(#1/2)-#1\expandafter }% b mod 2
            \expandafter{\the\numexpr #1-#1/2\expandafter }%     [b/2]
            \expandafter{\romannumeral0\xintisqr{#2}}}%
    \fi
    {{#2}}%
}%
\def\XINT@pow@loop@end {\romannumeral0\XINT@rord@main {}\relax }%
\def\XINT@pow@loop@a #1%
{%
    \ifnum #1 = 1
        \expandafter\XINT@pow@loop
    \else
        \expandafter\XINT@pow@loop@throwaway
    \fi
}%
\def\XINT@pow@loop@throwaway #1#2#3%
{%
   \XINT@pow@loop {#1}{#2}% 
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
%    Routine de produit servant pour le calcul des puissances. Chaque nouveau
%    terme est plus grand que ce qui a déjà été calculé. Par conséquent on a
%    intérêt à le conserver en second dans la routine de multiplication, donc le
%    précédent calcul a intérêt à avoir été donné sur 4n, à l'envers. Il faut
%    donc modifier la multiplication pour qu'elle fasse cela. Ce qui oblige à
%    utiliser une version spéciale de l'addition également.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@pow@posprod #1%
{%
    \XINT@pow@pprod@checkifempty #1\Z
}%
\def\XINT@pow@pprod@checkifempty #1%
{%
    \xint@relax #1\XINT@pow@pprod@emptyproduct\relax 
    \XINT@pow@pprod@RQfirst #1%
}%
\def\XINT@pow@pprod@emptyproduct #1\Z { 1}%
\def\XINT@pow@pprod@RQfirst #1\Z
{%
    \expandafter\XINT@pow@pprod@getnext\expandafter
    {\romannumeral0\XINT@RQ {}#1\R\R\R\R\R\R\R\R\Z}%
}%
\def\XINT@pow@pprod@getnext #1#2%
{%
    \XINT@pow@pprod@checkiffinished #2\Z {#1}%
}%
\def\XINT@pow@pprod@checkiffinished #1%
{%
    \xint@relax #1\XINT@pow@pprod@end\relax 
    \XINT@pow@pprod@compute #1%
}%
\def\XINT@pow@pprod@compute #1\Z #2%
{%
    \expandafter\XINT@pow@pprod@getnext\expandafter
    {\romannumeral0\XINT@mulr@enter #2\W\X\Y\Z #1\W\X\Y\Z}%
}%
\def\XINT@pow@pprod@end\relax\XINT@pow@pprod@compute #1\Z #2%
{%
    \expandafter\xint@cleanupzeros@andstop
    \romannumeral0\XINT@rev {#2}%
}%
%    \end{macrocode}
% \subsection{\csh{xintDivision}, \csh{xintQuo}, \csh{xintRem}}
%    \begin{macrocode}
\def\xintiQuo {\romannumeral0\xintiquo }%
\def\xintiRem {\romannumeral0\xintirem }%
\def\xintiquo {\expandafter\xint@firstoftwo@andstop
               \romannumeral0\xintidivision }%
\def\xintirem {\expandafter\xint@secondoftwo@andstop
               \romannumeral0\xintidivision }%
\let\xintQuo\xintiQuo \let\xintquo\xintiquo
\let\xintRem\xintiRem \let\xintrem\xintirem
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1 = A, #2 = B. On calcule le quotient de A par B
% 1.03 adds the detection of 1 for B.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintiDivision {\romannumeral0\xintidivision }%
\def\xintidivision #1%
{%
    \expandafter\expandafter\expandafter
        \xint@division
    \expandafter\expandafter\expandafter
        {#1}%
}%
\let\xintDivision\xintiDivision \let\xintdivision\xintidivision
\def\xint@division #1#2%
{%
    \expandafter\expandafter\expandafter
    \XINT@div@fork #2\Z #1\Z 
}%
\def\XINT@Division #1#2{\romannumeral0\XINT@div@fork #2\Z #1\Z }%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1#2 = 2e input = diviseur = B
% #3#4 = 1er input = divisé = A
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@fork #1#2\Z #3#4\Z
{%
    \xint@UDzerofork
      #1\dummy \XINT@div@BisZero
      #3\dummy \XINT@div@AisZero
       0\dummy 
        {\xint@UDsignfork
           #1\dummy \XINT@div@BisNegative  % B < 0
           #3\dummy \XINT@div@AisNegative  % A < 0, B > 0
            -\dummy \XINT@div@plusplus     % B > 0, A > 0
         \xint@UDkrof }%
    \xint@UDkrof
    {#2}{#4}#1#3% #1#2=B, #3#4=A
}%
\def\XINT@div@BisZero #1#2#3#4{\xintError:DivisionByZero\space {0}{0}}%
\def\XINT@div@AisZero #1#2#3#4{ {0}{0}}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% jusqu'à présent c'est facile.
% minusplus signifie B < 0, A > 0
% plusminus signifie B > 0, A < 0
% Ici #3#1 correspond au diviseur B et #4#2 au divisé A
% Cases with B<0 or especially A<0 are treated sub-optimally in terms of
% post-processing, things get reversed which could have been produced directly
% in the wanted order, but A,B>0 is given priority for optimization. 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@plusplus #1#2#3#4%
{%
    \XINT@div@prepare {#3#1}{#4#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% B = #3#1 < 0, A non nul positif ou négatif
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@BisNegative #1#2#3#4%
{%
    \expandafter\XINT@div@BisNegative@post
    \romannumeral0\XINT@div@fork #1\Z #4#2\Z
}%
\def\XINT@div@BisNegative@post #1%
{%
    \expandafter\space\expandafter {\romannumeral0\XINT@opp #1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% B = #3#1 > 0, A =-#2< 0
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@AisNegative #1#2#3#4%
{%
    \expandafter\XINT@div@AisNegative@post
    \romannumeral0\XINT@div@prepare {#3#1}{#2}{#3#1}%
}%
\def\XINT@div@AisNegative@post #1#2%
{%
    \ifcase\XINT@Sgn {#2}
       \expandafter \XINT@div@AisNegative@zerorem
    \or
       \expandafter \XINT@div@AisNegative@posrem
    \fi
    {#1}{#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% en #3 on a une copie de B (à l'endroit)
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@AisNegative@zerorem #1#2#3%
{%
    \expandafter\space\expandafter {\romannumeral0\XINT@opp #1}{0}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1 = quotient, #2 = reste, #3 = diviseur initial (à l'endroit)
% remplace Reste par B - Reste, après avoir remplacé Q par -(Q+1)
% de sorte que la formule a = qb + r, 0<= r < |b| est valable
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@AisNegative@posrem #1%
{%
    \expandafter \XINT@div@AisNegative@posrem@b \expandafter
       {\romannumeral0\xintiopp{\xintiAdd {#1}{1}}}%
}%
\def\XINT@div@AisNegative@posrem@b #1#2#3%
{%
    \expandafter \xint@exchangetwo@keepbraces@andstop \expandafter
    {\romannumeral0\XINT@sub {#3}{#2}}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% par la suite A et B sont > 0.
% #1 = B. Pour le moment à l'endroit.
% Calcul du plus petit K = 4n >= longueur de B
% 1.03 adds the interception of B=1
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepare #1%
{%
    \expandafter \XINT@div@prepareB@aa \expandafter
        {\romannumeral0\XINT@length {#1}}{#1}% B > 0 ici
}%
\def\XINT@div@prepareB@aa #1%
{%
    \ifnum #1=1
      \expandafter\XINT@div@prepareB@ab
    \else
      \expandafter\XINT@div@prepareB@a
    \fi
    {#1}%
}%
\def\XINT@div@prepareB@ab #1#2%
{%
    \ifnum #2=1
      \expandafter\XINT@div@prepareB@BisOne
    \else 
      \xint@afterfi{\XINT@div@prepareB@e {000}{3}{4}{#2}}%
    \fi
}%
\def\XINT@div@prepareB@BisOne #1{ {#1}{0}}%
\def\XINT@div@prepareB@a #1%
{%
    \expandafter \XINT@div@prepareB@b \expandafter
        {\the\numexpr 4*((#1+1)/4)}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1 = K
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepareB@b #1#2%
{%
    \expandafter \XINT@div@prepareB@c \expandafter
       {\the\numexpr #1-#2}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1 = c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepareB@c #1%
{%
    \ifcase #1
          \expandafter\XINT@div@prepareB@di
    \or   \expandafter\XINT@div@prepareB@dii
    \or   \expandafter\XINT@div@prepareB@diii
    \else \expandafter\XINT@div@prepareB@div
    \fi
}%
\def\XINT@div@prepareB@di   {\XINT@div@prepareB@e {}{0}}%
\def\XINT@div@prepareB@dii  {\XINT@div@prepareB@e {0}{1}}%
\def\XINT@div@prepareB@diii {\XINT@div@prepareB@e {00}{2}}%
\def\XINT@div@prepareB@div  {\XINT@div@prepareB@e {000}{3}}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1 = zéros à rajouter à B, #2=c, #3=K, #4 = B
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepareB@e #1#2#3#4%
{%
    \XINT@div@prepareB@f #4#1\Z {#3}{#2}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% x = #1#2#3#4 = 4 premiers chiffres de B. #1 est non nul.
% Ensuite on renverse B pour calculs plus rapides par la suite.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepareB@f #1#2#3#4#5\Z
{%
    \expandafter \XINT@div@prepareB@g \expandafter
        {\romannumeral0\XINT@rev {#1#2#3#4#5}}{#1#2#3#4}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #3= K, #4 = c, #5= {} ou {0} ou {00} ou {000}, #6 = A initial
% #1 = B préparé et renversé, #2 = x = quatre premiers chiffres
% On multiplie aussi A par 10^c.
% B, x, K, c, {} ou {0} ou {00} ou {000}, A initial
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepareB@g #1#2#3#4#5#6%
{%
    \XINT@div@prepareA@a {#6#5}{#2}{#3}{#1}{#4}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% A, x, K, B, c, 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepareA@a #1%
{%
    \expandafter \XINT@div@prepareA@b \expandafter
       {\romannumeral0\XINT@length {#1}}{#1}% A >0 ici
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% L0, A, x, K, B, ...
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepareA@b #1%
{%
    \expandafter\XINT@div@prepareA@c\expandafter
    {\the\numexpr 4*((#1+1)/4)}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% L, L0, A, x, K, B,...
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepareA@c #1#2%
{%
    \expandafter\XINT@div@prepareA@d \expandafter
       {\the\numexpr #1-#2}{#1}%
}%
\def\XINT@div@prepareA@d #1%
{%
    \ifcase #1
          \expandafter\XINT@div@prepareA@di
    \or   \expandafter\XINT@div@prepareA@dii
    \or   \expandafter\XINT@div@prepareA@diii
    \else \expandafter\XINT@div@prepareA@div
    \fi
}%
\def\XINT@div@prepareA@di   {\XINT@div@prepareA@e {}}%
\def\XINT@div@prepareA@dii  {\XINT@div@prepareA@e {0}}%
\def\XINT@div@prepareA@diii {\XINT@div@prepareA@e {00}}%
\def\XINT@div@prepareA@div  {\XINT@div@prepareA@e {000}}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1#3 = A préparé, #2 = longueur de ce A préparé, 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepareA@e #1#2#3%
{%
    \XINT@div@startswitch {#1#3}{#2}% 
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% A, L, x, K, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@startswitch #1#2#3#4%
{%
    \ifnum #2 > #4
      \expandafter\XINT@div@body@a
    \else
    \ifnum #2 = #4
      \expandafter\expandafter\expandafter\XINT@div@final@a
    \else
      \expandafter\expandafter\expandafter\XINT@div@finished@a
    \fi\fi {#1}{#4}{#3}{0000}{#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% A, K, x, Q, L, B, c   
% ---- "Finished"
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@finished@a #1#2#3%
{%
    \expandafter \XINT@div@finished@b \expandafter
      {\romannumeral0\XINT@cuz {#1}}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% A, Q, L, B, c
% no leading zeros in A at this stage
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@finished@b #1#2#3#4#5%
{%
    \ifcase \XINT@Sgn {#1}
       \xint@afterfi {\XINT@div@finished@c {0}}%
    \or
       \xint@afterfi {\expandafter\XINT@div@finished@c
                      \expandafter
         {\romannumeral0\XINT@dsh@checksignx #5\Z {#1}}}%
    \fi
    {#2}%
}%
\def\XINT@div@finished@c #1#2%
{%
    \expandafter\space\expandafter 
                {\romannumeral0\XINT@rev@andcuz {#2}}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% ---- "Final"
% A, K, x, Q, L, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@final@a #1%
{%
    \XINT@div@final@b #1\Z
}%
\def\XINT@div@final@b #1#2#3#4#5\Z
{%
    \xint@quatrezeros #1#2#3#4\xint@div@final@c0000%
    \XINT@div@final@c {#1#2#3#4}{#1#2#3#4#5}%
}%
\def\xint@div@final@c0000\XINT@div@final@c #1{\XINT@div@finished@a }%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% a, A, K, x, Q, L, B ,c
% 1.01: code ré-écrit pour optimisations diverses.
% 1.04: again, code rewritten for tiny speed increase (hopefully).
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@final@c #1#2#3#4%
{%
    \expandafter \XINT@div@final@da \expandafter
    {\the\numexpr #1-(#1/#4)*#4\expandafter }\expandafter
    {\the\numexpr #1/#4\expandafter }\expandafter
    {\romannumeral0\xint@cleanupzeros@andstop #2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% r, q, A sans leading zéros, Q, L, B à l'envers sur 4n, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@final@da #1%
{%
    \ifnum #1>9
       \expandafter\XINT@div@final@dP
    \else
       \xint@afterfi
       {\ifnum #1<0
        \expandafter\XINT@div@final@dN
        \else
        \expandafter\XINT@div@final@db
        \fi }%
    \fi
}%
\def\XINT@div@final@dN #1%
{%
    \expandafter\XINT@div@final@dP\the\numexpr #1-1\relax
}%
\def\XINT@div@final@dP #1#2#3#4#5% q,A,Q,L,B (puis c)
{%
    \expandafter \XINT@div@final@f \expandafter
    {\romannumeral0\xintisub {#2}%
        {\romannumeral0\XINT@mul@M {#1}#5\Z\Z\Z\Z }}%
    {\romannumeral0\XINT@add@A 0{}#1000\W\X\Y\Z #3\W\X\Y\Z }% 
}%
\def\XINT@div@final@db #1#2#3#4#5% q,A,Q,L,B (puis c)
{% 
    \expandafter\XINT@div@final@dc\expandafter
    {\romannumeral0\xintisub {#2}%
        {\romannumeral0\XINT@mul@M {#1}#5\Z\Z\Z\Z }}%
    {#1}{#2}{#3}{#4}{#5}%
}%
\def\XINT@div@final@dc #1#2%
{%
    \ifnum\XINT@Sgn{#1}<0
    \xint@afterfi {\expandafter\XINT@div@final@dP\the\numexpr #2-1\relax}%
    \else \xint@afterfi {\XINT@div@final@e {#1}#2}%
    \fi
}%
\def\XINT@div@final@e #1#2#3#4#5#6% A final, q, trash, Q, L, B
{%
    \XINT@div@final@f {#1}%
    {\romannumeral0\XINT@add@A 0{}#2000\W\X\Y\Z #4\W\X\Y\Z }%
}%
\def\XINT@div@final@f #1#2#3% R,Q à développer,c
{%
    \ifcase \XINT@Sgn {#1}
       \xint@afterfi {\XINT@div@final@end {0}}%
    \or
       \xint@afterfi {\expandafter\XINT@div@final@end
                      \expandafter % pas de leading zeros dans #1=R
                      {\romannumeral0\XINT@dsh@checksignx #3\Z {#1}}}%
    \fi
    {#2}%
}%
\def\XINT@div@final@end #1#2%
{%
    \expandafter\space\expandafter {#2}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Boucle Principale (on reviendra en div@body@b pas div@body@a)
% A, K, x, Q, L, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@a #1%
{%
    \XINT@div@body@b #1\Z {#1}%
}%
\def\XINT@div@body@b #1#2#3#4#5#6#7#8#9\Z
{%
    \XINT@div@body@c {#1#2#3#4#5#6#7#8}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% a, A, K, x, Q, L, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@c #1#2#3%
{%
    \XINT@div@body@d {#3}{}#2\Z {#1}{#3}%
}%
\def\XINT@div@body@d #1#2#3#4#5#6%
{%
    \ifnum #1 > 0
        \expandafter\XINT@div@body@d
        \expandafter{\the\numexpr #1-4\expandafter }%
    \else
        \expandafter\XINT@div@body@e
    \fi
    {#6#5#4#3#2}%
}%
\def\XINT@div@body@e #1#2\Z #3%
{%
    \XINT@div@body@f {#3}{#1}{#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% a, alpha (à l'envers), alpha' (à l'endroit), K, x, Q, L, B (à l'envers), c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@f #1#2#3#4#5#6#7#8%
{%
    \expandafter\XINT@div@body@gg
    \the\numexpr (#1+(#5+1)/2)/(#5+1)+99999\relax 
    {#8}{#2}{#8}{#4}{#5}{#3}{#6}{#7}{#8}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% q1 sur six chiffres (il en a 5 au max), B, alpha, B, K, x, alpha', Q, L, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@gg #1#2#3#4#5#6%
{%
    \xint@UDzerofork
      #2\dummy \XINT@div@body@gk 
       0\dummy {\XINT@div@body@ggk #2}%
    \xint@UDkrof
    {#3#4#5#6}%
}%
\def\XINT@div@body@gk #1#2#3%
{%
    \expandafter\XINT@div@body@h 
    \romannumeral0\XINT@div@sub@xpxp 
    {\romannumeral0\XINT@mul@Mr {#1}#2\Z\Z\Z\Z }{#3}\Z {#1}%
}%
\def\XINT@div@body@ggk #1#2#3%
{%
    \expandafter \XINT@div@body@gggk \expandafter
    {\romannumeral0\XINT@mul@Mr {#1}0000#3\Z\Z\Z\Z }%
    {\romannumeral0\XINT@mul@Mr {#2}#3\Z\Z\Z\Z }%
    {#1#2}%  
}%
\def\XINT@div@body@gggk #1#2#3#4%
{%
    \expandafter\XINT@div@body@h
    \romannumeral0\XINT@div@sub@xpxp
    {\romannumeral0\expandafter\XINT@mul@Ar
     \expandafter0\expandafter{\expandafter}#2\W\X\Y\Z #1\W\X\Y\Z }%
    {#4}\Z {#3}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% alpha1 = alpha-q1 B, \Z, q1, B, K, x, alpha', Q, L, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@h #1#2#3#4#5#6#7#8#9\Z 
{%
    \ifnum #1#2#3#4>0
        \xint@afterfi{\XINT@div@body@i {#1#2#3#4#5#6#7#8}}%
    \else
        \expandafter\XINT@div@body@k
    \fi
    {#1#2#3#4#5#6#7#8#9}%
}%
\def\XINT@div@body@k #1#2#3%
{%
    \XINT@div@body@l {#1}{#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% a1, alpha1 (à l'endroit), q1, B, K, x, alpha', Q, L, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@i #1#2#3#4#5#6%
{%
    \expandafter\XINT@div@body@j
    \expandafter{\the\numexpr (#1+(#6+1)/2)/(#6+1)-1}%
       {#2}{#3}{#4}{#5}{#6}%
}%
\def\XINT@div@body@j #1#2#3#4%
{%
    \expandafter \XINT@div@body@l \expandafter
    {\romannumeral0\XINT@div@sub@xpxp
       {\romannumeral0\XINT@mul@Mr {#1}#4\Z\Z\Z\Z }{\XINT@Rev{#2}}}%
    {#3+#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% alpha2 (à l'endroit, ou alpha1), q1+q2 (ou q1), K, x, alpha', Q, L, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@l #1#2#3#4#5#6#7%
{%
   \expandafter\XINT@div@body@m
   \the\numexpr 100000000+#2\relax
       {#6}{#3}{#7}{#1#5}{#4}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% chiffres de q, Q, K, L, A'=nouveau A, x, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@m #1#2#3#4#5#6#7#8#9%
{%
    \ifnum #2#3#4#5>0
       \xint@afterfi {\XINT@div@body@n {#9#8#7#6#5#4#3#2}}%
    \else
       \xint@afterfi {\XINT@div@body@n {#9#8#7#6}}%
    \fi
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% q renversé, Q, K, L, A', x, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@n #1#2%
{%
    \expandafter\XINT@div@body@o\expandafter
    {\romannumeral0\XINT@addr@A 0{}#1\W\X\Y\Z #2\W\X\Y\Z }%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% q+Q, K, L, A', x, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@o #1#2#3#4%
{%
    \XINT@div@body@p {#3}{#2}{}#4\Z {#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% L, K, {}, A'\Z, q+Q, x, B, c 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@p #1#2#3#4#5#6#7%
{%
    \ifnum #1 > #2
        \xint@afterfi
        {\ifnum #4#5#6#7 > 0
           \expandafter\XINT@div@body@q
         \else
           \expandafter\XINT@div@body@repeatp
         \fi }%
    \else
        \expandafter\XINT@div@gotofinal@a
    \fi
    {#1}{#2}{#3}#4#5#6#7%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% L, K, zeros,  A' avec moins de zéros\Z, q+Q, x, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@repeatp #1#2#3#4#5#6#7%
{%
    \expandafter\XINT@div@body@p\expandafter{\the\numexpr #1-4}{#2}{0000#3}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% L -> L-4, zeros->zeros+0000, répéter jusqu'à ce que soit L=K
% soit on ne trouve plus 0000
% nouveau L, K, zeros, nouveau A=#4, \Z, Q+q (à l'envers), x, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@q #1#2#3#4\Z #5#6%
{%
    \XINT@div@body@b #4\Z {#4}{#2}{#6}{#3#5}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% A, K, x, Q, L, B, c --> iterate
% ----
% Boucle Principale achevée
% ATTENTION IL FAUT AJOUTER 4 ZEROS DE MOINS QUE CEUX 
% QUI ONT ÉTÉ PRÉPARÉS DANS #3!!
% L, K (L=K), zeros, A\Z, Q, x, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@gotofinal@a #1#2#3#4\Z %
{%
    \XINT@div@gotofinal@b #3\Z {#4}{#1}%
}%
\def\XINT@div@gotofinal@b 0000#1\Z #2#3#4#5%
{%
    \XINT@div@final@a {#2}{#3}{#5}{#1#4}{#3}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% La soustraction spéciale. 
% Elle fait l'expansion (une fois pour le premier, deux fois pour le second) de
% ses arguments. Ceux-ci doivent être à l'envers sur 4n. De plus on sait a
% priori que le second est > le premier. Et le résultat de la différence est
% renvoyé **avec la même longueur que le second** (donc avec des leading zéros
% éventuels), et *à l'endroit*.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@sub@xpxp #1%
{%
    \expandafter \XINT@div@sub@xpxp@  \expandafter{#1}%
}%
\def\XINT@div@sub@xpxp@ #1#2%
{%
    \expandafter\expandafter\expandafter\XINT@div@sub@xpxp@@
     #2\W\X\Y\Z #1\W\X\Y\Z
}%
\def\XINT@div@sub@xpxp@@
{%
    \XINT@div@sub@A 1{}%
}%
\def\XINT@div@sub@A #1#2#3#4#5#6%  
{%
    \xint@w #3\xint@div@sub@az\W
    \XINT@div@sub@B #1{#3#4#5#6}{#2}% 
}%
\def\XINT@div@sub@B #1#2#3#4\W\X\Y\Z #5#6#7#8%  
{%
    \xint@w #5\xint@div@sub@bz\W
    \XINT@div@sub@onestep #1#2{#8#7#6#5}{#3}#4\W\X\Y\Z 
}%
\def\XINT@div@sub@onestep #1#2#3#4#5#6%
{%
    \expandafter\XINT@div@sub@backtoA\the\numexpr 11#5#4#3#2-#6+#1-1\relax.%
}%
\def\XINT@div@sub@backtoA #1#2#3.#4%
{%
    \XINT@div@sub@A #2{#3#4}%
}%
\def\xint@div@sub@bz\W\XINT@div@sub@onestep #1#2#3#4#5#6#7%
{%
    \xint@UDzerofork
      #1\dummy  \XINT@div@sub@C   %
       0\dummy  \XINT@div@sub@D   % pas de retenue
    \xint@UDkrof
    {#7}#2#3#4#5%
}%
\def\XINT@div@sub@D #1#2\W\X\Y\Z
{%
    \expandafter\space
    \romannumeral0%
    \XINT@rord@main {}#2%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
    #1%
}%
\def\XINT@div@sub@C #1#2#3#4#5%
{%
    \xint@w #2\xint@div@sub@cz\W
    \XINT@div@sub@AC@onestep {#5#4#3#2}{#1}%
}%
\def\XINT@div@sub@AC@onestep #1%
{%
    \expandafter\XINT@div@sub@backtoC\the\numexpr 11#1-1\relax.%
}%
\def\XINT@div@sub@backtoC #1#2#3.#4%
{%
    \XINT@div@sub@AC@checkcarry #2{#3#4}% la retenue va \^etre examin\'ee
}%
\def\XINT@div@sub@AC@checkcarry #1%
{%
    \xint@one #1\xint@div@sub@AC@nocarry 1\XINT@div@sub@C 
}%
\def\xint@div@sub@AC@nocarry 1\XINT@div@sub@C #1#2\W\X\Y\Z
{%
    \expandafter\space
    \romannumeral0%
    \XINT@rord@main {}#2%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
    #1%
}%
\def\xint@div@sub@cz\W\XINT@div@sub@AC@onestep #1#2{ #2}%
\def\xint@div@sub@az\W\XINT@div@sub@B #1#2#3#4\Z { #3}%
%    \end{macrocode}
% \begin{verbatim}
%-----------------------------------------------------------------
%-----------------------------------------------------------------
% DECIMAL OPERATIONS: FIRST DIGIT, LASTDIGIT, ODDNESS,
% MULTIPLICATION BY TEN, QUOTIENT BY TEN, QUOTIENT OR
% MULTIPLICATION BY POWER OF TEN, SPLIT OPERATION.
% \end{verbatim}
% \vspace*{-2\baselineskip}
% \subsection{\csh{xintFDg}}
% \begin{verbatim}
%    FIRST DIGIT. Code simplified in 1.05.  And prepared for redefinition by
%    xintfrac to parse through \xintNum
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintiFDg {\romannumeral0\xintifdg }%
\def\xintifdg #1%
{%
    \expandafter\expandafter\expandafter\XINT@fdg #1\W\Z
}%
\let\xintFDg\xintiFDg \let\xintfdg\xintifdg
\def\XINT@FDg #1{\romannumeral0\XINT@fdg #1\W\Z }%
\def\XINT@fdg #1#2#3\Z
{%
    \xint@UDzerominusfork
      #1-\dummy  { 0}%   zero
      0#1\dummy  { #2}%  negative
       0-\dummy  { #1}%  positive
    \xint@UDkrof
}%
%    \end{macrocode}
% \subsection{\csh{xintLDg}}
% \begin{verbatim}
%    LAST DIGIT. Simplified in 1.05. And prepared for extension by xintfrac
%    to parse through \xintNum
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintiLDg {\romannumeral0\xintildg }%
\def\xintildg #1%
{%
    \expandafter\expandafter\expandafter
        \XINT@ldg
    \expandafter\expandafter\expandafter
    {#1}%
}%
\let\xintLDg\xintiLDg \let\xintldg\xintildg
\def\XINT@LDg #1{\romannumeral0\XINT@ldg {#1}}%
\def\XINT@ldg #1%
{%
    \expandafter\XINT@ldg@\romannumeral0\XINT@rev {#1}\Z
}%
\def\XINT@ldg@ #1#2\Z{ #1}%
%    \end{macrocode}
% \subsection{\csh{xintMON}}
% \begin{verbatim}
%    MINUS ONE TO THE POWER N
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintiMON {\romannumeral0\xintimon }%
\def\xintimon #1%
{%
    \ifodd\xintiLDg {#1}
        \xint@afterfi{ -1}%
    \else
        \xint@afterfi{ 1}%
    \fi
}%
\def\xintiMMON {\romannumeral0\xintimmon }%
\def\xintimmon #1%
{%
    \ifodd\xintiLDg {#1}
        \xint@afterfi{ 1}%
    \else
        \xint@afterfi{ -1}%
    \fi
}%
\let\xintMON\xintiMON \let\xintmon\xintimon
\let\xintMMON\xintiMMON \let\xintmmon\xintimmon
%    \end{macrocode}
% \subsection{\csh{xintOdd}}
% \begin{verbatim}
%     ODDNESS. 1.05 defines \xintiOdd, so \xintOdd can be modified by xintfrac
%     to parse through \xintNum.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintiOdd {\romannumeral0\xintiodd }%
\def\xintiodd #1%
{%
    \ifodd\xintiLDg{#1}
        \xint@afterfi{ 1}%
    \else
        \xint@afterfi{ 0}%
    \fi
}%
\def\XINT@Odd #1%
{\romannumeral0%
    \ifodd\XINT@LDg{#1}
        \xint@afterfi{ 1}%
    \else
        \xint@afterfi{ 0}%
    \fi
}%
\let\xintOdd\xintiOdd \let\xintodd\xintiodd
%    \end{macrocode}
% \subsection{\csh{xintDSL}}
% \begin{verbatim}
%    DECIMAL SHIFT LEFT (=MULTIPLICATION PAR 10)
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintDSL {\romannumeral0\xintdsl }%
\def\xintdsl #1%
{%
    \expandafter\expandafter\expandafter\XINT@dsl #1\Z
}%
\def\XINT@DSL #1{\romannumeral0\XINT@dsl #1\Z }%
\def\XINT@dsl #1%
{%
    \xint@zero #1\xint@dsl@zero 0\XINT@dsl@ #1%
}%
\def\xint@dsl@zero 0\XINT@dsl@ 0#1\Z { 0}%
\def\XINT@dsl@ #1\Z { #10}%
%    \end{macrocode}
% \subsection{\csh{xintDSR}}
% \begin{verbatim}
%    DECIMAL SHIFT RIGHT (=DIVISION PAR 10)
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintDSR {\romannumeral0\xintdsr }%
\def\xintdsr #1%
{%
    \expandafter\expandafter\expandafter
       \XINT@dsr@a
    \expandafter\expandafter\expandafter
    {#1}\W\Z
}%
\def\XINT@DSR #1{\romannumeral0\XINT@dsr@a {#1}\W\Z }%
\def\XINT@dsr@a
{%
    \expandafter\XINT@dsr@b
    \romannumeral0\XINT@rev
}%
\def\XINT@dsr@b #1#2#3\Z
{%
    \xint@w #2\xint@dsr@onedigit\W
    \xint@minus #2\xint@dsr@onedigit-%
    \expandafter\XINT@dsr@removew
    \romannumeral0\XINT@rev {#2#3}%
}%
\def\xint@dsr@onedigit #1\XINT@rev #2{ 0}%
\def\XINT@dsr@removew #1\W { }%
%    \end{macrocode}
% \subsection{\csh{xintDSH}, \csh{xintDSHr}}
% \begin{verbatim}
%     DECIMAL SHIFTS
%    \xintDSH {x}{A}
% si x <= 0, fait A -> A.10^(|x|). v1.03 corrige l'oversight pour A=0.
% si x >  0, et A >=0, fait A -> quo(A,10^(x))
% si x >  0, et A < 0, fait A -> -quo(-A,10^(x))
% (donc pour x > 0 c'est comme DSR itéré x fois)
% \xintDSHr donne le `reste' (si x<=0 donne zéro).
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintDSHr {\romannumeral0\xintdshr }%
\def\xintdshr #1%
{%
    \expandafter\expandafter\expandafter\XINT@dshr@checkxpositive #1\Z
}%
\def\XINT@dshr@checkxpositive #1%
{%
    \xint@UDzerominusfork
      0#1\dummy \XINT@dshr@xzeroorneg
      #1-\dummy \XINT@dshr@xzeroorneg
       0-\dummy \XINT@dshr@xpositive
    \xint@UDkrof #1%
}%
\def\XINT@dshr@xzeroorneg #1\Z #2{ 0}%
\def\XINT@dshr@xpositive #1\Z 
{%
    \expandafter\xint@secondoftwo@andstop
    \romannumeral0\xintdsx {#1}%
}%
\def\xintDSH {\romannumeral0\xintdsh }%
\def\xintdsh #1#2%
{%
    \expandafter\expandafter\expandafter
      \xint@dsh 
    \expandafter\expandafter\expandafter
      {#2}{#1}%
}%
\def\xint@dsh #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@dsh@checksignx #2\Z {#1}%
}%
\def\XINT@dsh@checksignx #1%
{%
    \xint@UDzerominusfork
      #1-\dummy  \XINT@dsh@xiszero
      0#1\dummy  \XINT@dsx@xisNeg@checkA     % on passe direct dans DSx
       0-\dummy  {\XINT@dsh@xisPos #1}%
    \xint@UDkrof
}%
\def\XINT@dsh@xiszero #1\Z #2{ #2}%
\def\XINT@dsh@xisPos #1\Z #2%
{%
    \expandafter\xint@firstoftwo@andstop
    \romannumeral0\XINT@dsx@checksignA #2\Z {#1}% via DSx
}%
%    \end{macrocode}
% \subsection{\csh{xintDSx}}
% \begin{verbatim}
% Je fais cette routine pour la version 1.01, après modification de
% \xintDecSplit. Dorénavant \xintDSx fera appel à \xintDecSplit et de même 
% \xintDSH fera appel à \xintDSx. J'ai donc supprimé entièrement l'ancien code
% de \xintDSH et re-écrit entièrement celui de \xintDecSplit pour x positif.
% --> Attention le cas x=0 est traité dans la même catégorie que x > 0 <--
% si x < 0, fait A -> A.10^(|x|)
% si x >=  0, et A >=0, fait A -> {quo(A,10^(x))}{rem(A,10^(x))}
% si x >=  0, et A < 0, d'abord on calcule {quo(-A,10^(x))}{rem(-A,10^(x))}
%    puis, si le premier n'est pas nul on lui donne le signe -
%          si le premier est nul on donne le signe - au second.
% On peut donc toujours reconstituer l'original A par 10^x Q \pm R
% où il faut prendre le signe plus si Q est positif ou nul et le signe moins si
% Q est strictement négatif.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintDSx {\romannumeral0\xintdsx }%
\def\xintdsx #1#2%
{%
    \expandafter\expandafter\expandafter
        \xint@dsx
    \expandafter\expandafter\expandafter
    {#2}{#1}%
}%
\def\xint@dsx #1#2%
{%
    \expandafter\expandafter\expandafter\XINT@dsx@checksignx #2\Z {#1}%
}%
\def\XINT@DSx #1#2{\romannumeral0\XINT@dsx@checksignx #1\Z {#2}}%
\def\XINT@dsx #1#2{\XINT@dsx@checksignx #1\Z {#2}}%
\def\XINT@dsx@checksignx #1%
{%
    \xint@UDzerominusfork
      #1-\dummy  \XINT@dsx@xisZero
      0#1\dummy  \XINT@dsx@xisNeg@checkA
       0-\dummy  {\XINT@dsx@xisPos #1}%
    \xint@UDkrof
}%
\def\XINT@dsx@xisZero #1\Z #2{ {#2}{0}}% attention comme x > 0
\def\XINT@dsx@xisNeg@checkA #1\Z #2%
{%
    \XINT@dsx@xisNeg@checkA@ #2\Z {#1}%
}%
\def\XINT@dsx@xisNeg@checkA@ #1#2\Z #3%
{%
    \xint@zero #1\XINT@dsx@xisNeg@Azero 0\expandafter
    \XINT@dsx@xisNeg@checkx\expandafter
    {\romannumeral0\XINT@length {#3}}{#3}\Z {#1#2}%
}%
\def\XINT@dsx@xisNeg@Azero #1#2#3#4#5#6#7#8{ 0}%
\def\XINT@dsx@xisNeg@checkx #1%
{%
    \ifnum #1> 9
       \xint@afterfi {\xintError:TooBigDecimalShift\XINT@dsx@toobigx }%
    \else 
       \expandafter \XINT@dsx@zeroloop
    \fi
}%
\def\XINT@dsx@toobigx #1#2#3{ 0}%
\def\XINT@dsx@zeroloop #1%
{%
    \ifcase #1
        \XINT@dsx@exit
    \or
        \XINT@dsx@exiti
    \or
        \XINT@dsx@exitii
    \or
        \XINT@dsx@exitiii
    \or
        \XINT@dsx@exitiv
    \or
        \XINT@dsx@exitv
    \or
        \XINT@dsx@exitvi
    \or
        \XINT@dsx@exitvii
    \else
        \xint@afterfi 
         {\expandafter 
          \XINT@dsx@zeroloop
          \expandafter {\the\numexpr #1-8}00000000%
         }%
    \fi
}%
\def\XINT@dsx@exit #1\fi #2\Z {\fi \XINT@dsx@addzeros {#2}}%
\def\XINT@dsx@exiti #1\fi #2\Z {\fi \XINT@dsx@addzeros {0#2}}%
\def\XINT@dsx@exitii #1\fi #2\Z {\fi \XINT@dsx@addzeros {00#2}}%
\def\XINT@dsx@exitiii #1\fi #2\Z {\fi \XINT@dsx@addzeros {000#2}}%
\def\XINT@dsx@exitiv #1\fi #2\Z {\fi \XINT@dsx@addzeros {0000#2}}%
\def\XINT@dsx@exitv #1\fi #2\Z {\fi \XINT@dsx@addzeros {00000#2}}%
\def\XINT@dsx@exitvi #1\fi #2\Z {\fi \XINT@dsx@addzeros {000000#2}}%
\def\XINT@dsx@exitvii #1\fi #2\Z {\fi \XINT@dsx@addzeros {0000000#2}}%
\def\XINT@dsx@addzeros #1#2{ #2#1}%
\def\XINT@dsx@xisPos #1\Z #2%
{%
    \XINT@dsx@checksignA #2\Z {#1}%
}%
\def\XINT@dsx@checksignA #1%
{%
    \xint@UDzerominusfork
      #1-\dummy  \XINT@dsx@AisZero
      0#1\dummy  \XINT@dsx@AisNeg
       0-\dummy  {\XINT@dsx@AisPos #1}%
    \xint@UDkrof
}%
\def\XINT@dsx@AisZero #1\Z #2{ {0}{0}}%
\def\XINT@dsx@AisNeg #1\Z #2%
{%
    \expandafter\XINT@dsx@AisNeg@dosplit@andcheckfirst
    \romannumeral0\XINT@split@checksizex {#2}{#1}%
}%
\def\XINT@dsx@AisNeg@dosplit@andcheckfirst #1%
{%
    \XINT@dsx@AisNeg@checkiffirstempty #1\Z
}%
\def\XINT@dsx@AisNeg@checkiffirstempty #1%
{%
    \xint@z #1\XINT@dsx@AisNeg@finish@zero\Z
    \XINT@dsx@AisNeg@finish@notzero #1%
}%
\def\XINT@dsx@AisNeg@finish@zero\Z
    \XINT@dsx@AisNeg@finish@notzero\Z #1%
{%
    \expandafter\XINT@dsx@end
    \expandafter {\romannumeral0\XINT@num {-#1}}{0}%
}%
\def\XINT@dsx@AisNeg@finish@notzero #1\Z #2%
{%
    \expandafter\XINT@dsx@end
    \expandafter {\romannumeral0\XINT@num {#2}}{-#1}%
}%
\def\XINT@dsx@AisPos #1\Z #2%
{%
    \expandafter\XINT@dsx@AisPos@finish
    \romannumeral0\XINT@split@checksizex {#2}{#1}%
}%
\def\XINT@dsx@AisPos@finish #1#2%
{%
    \expandafter\XINT@dsx@end
    \expandafter {\romannumeral0\XINT@num {#2}}%
                 {\romannumeral0\XINT@num {#1}}%
}%
\def\XINT@dsx@end #1#2%
{%
    \expandafter\space\expandafter{#2}{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintDecSplit},~\csh{xintDecSplitL},~\csh{xintDecSplitR}}
% \begin{verbatim}
%     DECIMAL SPLIT
% v1.01: **New** behavior, for use in future extensions of the xint bundle:
% The macro \xintDecSplit {x}{A} first replaces A with |A| (*)
% This macro cuts the number into two pieces L and R. The concatenation LR
% always reproduces |A|, and R may be empty or have leading zeros. The
% position of the cut is specified by the first argument x. If x is zero or
% positive the cut location is x slots to the left of the right end of the
% number. If x becomes equal to or larger than the length of the number then L
% becomes empty. If x is negative the location of the cut is x slots to the
% right of the left end of the number. 
% (*) warning: this may change in a future version. Only the behavior
% for A non-negative is guaranteed to remain the same.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintDecSplitL {\romannumeral0\xintdecsplitl }%
\def\xintDecSplitR {\romannumeral0\xintdecsplitr }%
\def\xintdecsplitl 
{%
    \expandafter\xint@firstoftwo@andstop
    \romannumeral0\xintdecsplit 
}%
\def\xintdecsplitr 
{%
    \expandafter\xint@secondoftwo@andstop
    \romannumeral0\xintdecsplit 
}%
\def\xintDecSplit {\romannumeral0\xintdecsplit }%
\def\xintdecsplit #1#2%
{%
    \expandafter \xint@split \expandafter
    {\romannumeral0\xintiabs {#2}}{#1}%  fait expansion de A
}%
\def\xint@split #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@split@checksizex
    \expandafter\expandafter\expandafter
    {#2}{#1}% 
}%
\def\XINT@split@checksizex #1%
{%
    \ifnum\XINT@Len {#1} > 9  
       \xint@afterfi {\xintError:TooBigDecimalSplit\XINT@split@bigx }%
    \else
       \expandafter\XINT@split@xfork
    \fi
    #1\Z
}%
\def\XINT@split@bigx  #1\Z #2%
{%
    \ifcase\XINT@Sgn {#1}
    \or \xint@afterfi { {}{#2}}% positive big x
    \else  
        \xint@afterfi { {#2}{}}% negative big x
    \fi
}%
\def\XINT@split@xfork #1%
{%
    \xint@UDzerominusfork
      #1-\dummy  \XINT@split@zerosplit
      0#1\dummy  \XINT@split@fromleft
       0-\dummy  {\XINT@split@fromright #1}%
    \xint@UDkrof
}%
\def\XINT@split@zerosplit #1\Z #2{ {#2}{}}%
\def\XINT@split@fromleft #1\Z #2%
{%
    \XINT@split@fromleft@loop {#1}{}#2\W\W\W\W\W\W\W\W\Z 
}%
\def\XINT@split@fromleft@loop #1%
{%
    \ifcase #1
        \XINT@split@fromleft@endsplit
    \or
        \XINT@split@fromleft@one@andend
    \or
        \XINT@split@fromleft@two@andend
    \or
        \XINT@split@fromleft@three@andend
    \or
        \XINT@split@fromleft@four@andend
    \or
        \XINT@split@fromleft@five@andend
    \or
        \XINT@split@fromleft@six@andend
    \or
        \XINT@split@fromleft@seven@andend
    \else
        \expandafter \XINT@split@fromleft@loop@perhaps
        \expandafter
            {\the\numexpr #1-8\expandafter\expandafter\expandafter }%
        \expandafter
        \XINT@split@fromleft@eight
    \fi
}%
\def\XINT@split@fromleft@endsplit #1\fi #2#3\W #4\Z 
                       {\expandafter\space\fi {#2}{#3}}%
\def\XINT@split@fromleft@eight #1#2#3#4#5#6#7#8#9%
{%
    #9{#1#2#3#4#5#6#7#8#9}%
}%
\def\XINT@split@fromleft@loop@perhaps #1#2%
{%
    \xint@w #2\XINT@split@fromleft@toofar\W \XINT@split@fromleft@loop
    {#1}%
}%
\def\XINT@split@fromleft@toofar\W \XINT@split@fromleft@loop #1#2#3\Z
{%
    \XINT@split@fromleft@toofar@b #2\Z
}%
\def\XINT@split@fromleft@toofar@b #1\W #2\Z { {#1}{}}%
\def\XINT@split@fromleft@one@andend #1\fi 
{\fi\expandafter\XINT@split@fromleft@checkiftoofar\XINT@split@fromleft@one }%
\def\XINT@split@fromleft@one #1#2{#2{#1#2}}%
\def\XINT@split@fromleft@two@andend #1\fi 
{\fi\expandafter\XINT@split@fromleft@checkiftoofar\XINT@split@fromleft@two }%
\def\XINT@split@fromleft@two #1#2#3{#3{#1#2#3}}%
\def\XINT@split@fromleft@three@andend #1\fi 
{\fi\expandafter\XINT@split@fromleft@checkiftoofar\XINT@split@fromleft@three }%
\def\XINT@split@fromleft@three #1#2#3#4{#4{#1#2#3#4}}%
\def\XINT@split@fromleft@four@andend #1\fi 
{\fi\expandafter\XINT@split@fromleft@checkiftoofar\XINT@split@fromleft@four }%
\def\XINT@split@fromleft@four #1#2#3#4#5{#5{#1#2#3#4#5}}%
\def\XINT@split@fromleft@five@andend #1\fi 
{\fi\expandafter\XINT@split@fromleft@checkiftoofar\XINT@split@fromleft@five }%
\def\XINT@split@fromleft@five #1#2#3#4#5#6{#6{#1#2#3#4#5#6}}%
\def\XINT@split@fromleft@six@andend #1\fi 
{\fi\expandafter\XINT@split@fromleft@checkiftoofar\XINT@split@fromleft@six }%
\def\XINT@split@fromleft@six #1#2#3#4#5#6#7{#7{#1#2#3#4#5#6#7}}%
\def\XINT@split@fromleft@seven@andend #1\fi 
{\fi\expandafter\XINT@split@fromleft@checkiftoofar\XINT@split@fromleft@seven }%
\def\XINT@split@fromleft@seven #1#2#3#4#5#6#7#8{#8{#1#2#3#4#5#6#7#8}}%
\def\XINT@split@fromleft@checkiftoofar #1#2#3\W #4\Z 
{%
    \xint@w #1\XINT@split@fromleft@wenttoofar\W
    \space {#2}{#3}%
}%
\def\XINT@split@fromleft@wenttoofar\W\space #1%
{%
    \XINT@split@fromleft@wenttoofar@b #1\Z
}%
\def\XINT@split@fromleft@wenttoofar@b #1\W #2\Z { {#1}}%
\def\XINT@split@fromright #1\Z #2%
{%
    \expandafter \XINT@split@fromright@a \expandafter
    {\romannumeral0\XINT@rev {#2}}{#1}{#2}%
}%
\def\XINT@split@fromright@a #1#2%
{%
    \XINT@split@fromright@loop {#2}{}#1\W\W\W\W\W\W\W\W\Z
}%
\def\XINT@split@fromright@loop #1%
{%
    \ifcase #1
        \expandafter\XINT@split@fromright@endsplit
    \or
        \XINT@split@fromright@one@andend
    \or
        \XINT@split@fromright@two@andend
    \or
        \XINT@split@fromright@three@andend
    \or
        \XINT@split@fromright@four@andend
    \or
        \XINT@split@fromright@five@andend
    \or
        \XINT@split@fromright@six@andend
    \or
        \XINT@split@fromright@seven@andend
    \else
        \expandafter \XINT@split@fromright@loop@perhaps
        \expandafter
            {\the\numexpr
            #1-8\expandafter\expandafter\expandafter }%
        \expandafter
        \XINT@split@fromright@eight
    \fi
}%
\def\XINT@split@fromright@endsplit #1#2\W #3\Z #4%
{%
    \expandafter\space\expandafter {\romannumeral0\XINT@rev{#2}}{#1}%
}%
\def\XINT@split@fromright@eight #1#2#3#4#5#6#7#8#9%
{%
    #9{#9#8#7#6#5#4#3#2#1}%
}%
\def\XINT@split@fromright@loop@perhaps #1#2%
{%
    \xint@w #2\XINT@split@fromright@toofar\W\XINT@split@fromright@loop
    {#1}%
}%
\def\XINT@split@fromright@toofar\W\XINT@split@fromright@loop #1#2#3\Z { {}}%
\def\XINT@split@fromright@one@andend #1\fi {\fi\expandafter
      \XINT@split@fromright@checkiftoofar\XINT@split@fromright@one }%
\def\XINT@split@fromright@one #1#2{#2{#2#1}}%
\def\XINT@split@fromright@two@andend #1\fi {\fi\expandafter
      \XINT@split@fromright@checkiftoofar\XINT@split@fromright@two }%
\def\XINT@split@fromright@two #1#2#3{#3{#3#2#1}}%
\def\XINT@split@fromright@three@andend #1\fi {\fi\expandafter
      \XINT@split@fromright@checkiftoofar\XINT@split@fromright@three }%
\def\XINT@split@fromright@three #1#2#3#4{#4{#4#3#2#1}}%
\def\XINT@split@fromright@four@andend #1\fi {\fi\expandafter
      \XINT@split@fromright@checkiftoofar\XINT@split@fromright@four }%
\def\XINT@split@fromright@four #1#2#3#4#5{#5{#5#4#3#2#1}}%
\def\XINT@split@fromright@five@andend #1\fi {\fi\expandafter
      \XINT@split@fromright@checkiftoofar\XINT@split@fromright@five }%
\def\XINT@split@fromright@five #1#2#3#4#5#6{#6{#6#5#4#3#2#1}}%
\def\XINT@split@fromright@six@andend #1\fi {\fi\expandafter
      \XINT@split@fromright@checkiftoofar\XINT@split@fromright@six }%
\def\XINT@split@fromright@six #1#2#3#4#5#6#7{#7{#7#6#5#4#3#2#1}}%
\def\XINT@split@fromright@seven@andend #1\fi {\fi\expandafter
      \XINT@split@fromright@checkiftoofar\XINT@split@fromright@seven }%
\def\XINT@split@fromright@seven #1#2#3#4#5#6#7#8{#8{#8#7#6#5#4#3#2#1}}%
\def\XINT@split@fromright@checkiftoofar #1%
{%
    \xint@w #1\XINT@split@fromright@wenttoofar\W
    \XINT@split@fromright@endsplit
}%
\def\XINT@split@fromright@wenttoofar\W\XINT@split@fromright@endsplit #1\Z #2%
    { {}{#2}}%
\XINT@restorecatcodes@endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xint>\relax
%\def<*xintgcd>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xint>
%<*xintgcd>
% \section{Package \xintgcdname implementation}
% 
% The commenting is currently (\docdate) very sparse.
%
% \localtableofcontents
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
%
% The code for reload detection is copied from \textsc{Heiko
% Oberdiek}'s packages, and adapted here to check for previous
% loading of the master \xintname package.
%
% The method for catcodes is slightly different, but still
% directly inspired by these packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \def\space { }%
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xintgcd.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xint.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintgcd}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintgcd.sty
      \ifx\w\relax % but xint.sty not yet loaded.
         \y{xintgcd}{Package xint is required}%
         \y{xintgcd}{Will try \string\input\space xint.sty}%
         \def\z{\endgroup\input xint.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xint.sty not yet loaded.
            \y{xintgcd}{Package xint is required}%
            \y{xintgcd}{Will try \string\RequirePackage{xint}}%
            \def\z{\endgroup\RequirePackage{xint}}%
          \fi
      \else
        \y{xintgcd}{I was already loaded, aborting input}%
        \aftergroup\endinput
      \fi
    \fi
  \fi
\z%
%    \end{macrocode}
% \subsection{Confirmation of \xintname loading}
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \def\empty {}%
  \expandafter\let\expandafter\w\csname ver@xint.sty\endcsname
  \ifx\w\relax % Plain TeX, user gave a file name at the prompt
      \y{xintgcd}{Loading of package xint failed, aborting input}%
      \aftergroup\endinput
  \fi
  \ifx\w\empty % LaTeX, user gave a file name at the prompt
      \y{xintgcd}{Loading of package xint failed, aborting input}%
      \aftergroup\endinput
  \fi
\endgroup%
%    \end{macrocode}
% \subsection{Catcodes}
%
% Perhaps catcodes have changed after the loading of \xintname
% and prior to the current loading of \xintgcdname, so we can not employ
% the |\XINT@restorecatcodes@endinput| in this style file. But
% there is no problem using |\XINT@setcatcodes|.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \def\x
  {%
      \endgroup
      \edef\XINT@gcd@restorecatcodes@endinput
      {%
        \catcode36=\the\catcode36   % $
        \catcode47=\the\catcode47   % /
        \catcode41=\the\catcode41   % )
        \catcode40=\the\catcode40   % (
        \catcode42=\the\catcode42   % *
        \catcode43=\the\catcode43   % +
        \catcode62=\the\catcode62   % >
        \catcode60=\the\catcode60   % <
        \catcode58=\the\catcode58   % :
        \catcode46=\the\catcode46   % .
        \catcode45=\the\catcode45   % -
        \catcode44=\the\catcode44   % ,
        \catcode35=\the\catcode35   % #
        \catcode64=\the\catcode64   % @
        \catcode125=\the\catcode125 % }
        \catcode123=\the\catcode123 % {
        \endlinechar=\the\endlinechar
        \catcode13=\the\catcode13   % ^^M
        \catcode32=\the\catcode32   % 
        \catcode61=\the\catcode61\relax   % =
        \noexpand\endinput
      }%
      \XINT@setcatcodes
      \catcode36=3  % $
  }%
\x
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\begingroup
  \catcode91=12 % [
  \catcode93=12 % ]
  \catcode58=12 % :
  \expandafter\ifx\csname ProvidesPackage\endcsname\relax
    \def\x#1#2#3[#4]{\endgroup
      \immediate\write-1{Package: #3 #4}%
      \xdef#1{#4}%
    }%
  \else
    \def\x#1#2[#3]{\endgroup
      #2[{#3}]%
      \ifx#1\@undefined
        \xdef#1{#3}%
      \fi
      \ifx#1\relax
        \xdef#1{#3}%
      \fi
    }%
  \fi
\expandafter\x\csname ver@xintgcd.sty\endcsname
\ProvidesPackage{xintgcd}%
  [2013/05/02 v1.05a Euclide algorithm with xint package (jfB)]%
%    \end{macrocode}
% \subsection{\csh{xintGCD}}
%    \begin{macrocode}
\def\xintGCD {\romannumeral0\xintgcd }%
\def\xintgcd #1%
{%
    \expandafter\XINT@gcd\expandafter{\romannumeral0\xintiabs {#1}}%
}%
\def\XINT@gcd #1#2%
{%
    \expandafter\XINT@gcd@fork\romannumeral0\xintiabs {#2}\Z #1\Z
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Ici #3#4=A, #1#2=B
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@gcd@fork #1#2\Z #3#4\Z
{%
    \xint@UDzerofork
      #1\dummy \XINT@gcd@BisZero
      #3\dummy \XINT@gcd@AisZero
       0\dummy \XINT@gcd@loop
    \xint@UDkrof
    {#1#2}{#3#4}%
}%
\def\XINT@gcd@AisZero #1#2{ #1}%
\def\XINT@gcd@BisZero #1#2{ #2}%
\def\XINT@gcd@CheckRem #1#2\Z
{%
    \xint@zero #1\xint@gcd@end0\XINT@gcd@loop {#1#2}%
}%
\def\xint@gcd@end0\XINT@gcd@loop #1#2{ #2}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1=B, #2=A
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@gcd@loop #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@gcd@CheckRem
    \expandafter\xint@secondoftwo
    \romannumeral0\XINT@div@prepare {#1}{#2}\Z 
    {#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintBezout}}
%    \begin{macrocode}
\def\xintBezout {\romannumeral0\xintbezout }%
\def\xintbezout #1%
{%
    \expandafter\expandafter\expandafter
      \xint@bezout
    \expandafter\expandafter\expandafter
      {#1}%
}%
\def\xint@bezout #1#2%
{%
    \expandafter\expandafter\expandafter\XINT@bezout@fork #2\Z #1\Z
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #3#4 = A, #1#2=B
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@fork #1#2\Z #3#4\Z
{%
    \xint@UDzerosfork
     #1#3\dummy \XINT@bezout@botharezero
      #10\dummy \XINT@bezout@secondiszero
      #30\dummy \XINT@bezout@firstiszero
       00\dummy 
        {\xint@UDsignsfork
          #1#3\dummy \XINT@bezout@minusminus % A < 0, B < 0
           #1-\dummy \XINT@bezout@minusplus  % A > 0, B < 0
           #3-\dummy \XINT@bezout@plusminus  % A < 0, B > 0
            --\dummy \XINT@bezout@plusplus   % A > 0, B > 0
         \xint@UDkrof }%
    \xint@UDkrof
    {#2}{#4}#1#3{#3#4}{#1#2}% #1#2=B, #3#4=A
}%
\def\XINT@bezout@botharezero #1#2#3#4#5#6%
{%
    \xintError:NoBezoutForZeros
    \space {0}{0}{0}{0}{0}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% attention première entrée doit être ici (-1)^n donc 1
% #4#2=0 = A, B = #3#1
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@firstiszero #1#2#3#4#5#6%
{%
    \xint@UDsignfork
      #3\dummy { {0}{#3#1}{0}{1}{#1}}%
       -\dummy { {0}{#3#1}{0}{-1}{#1}}%
    \xint@UDkrof
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #4#2= A, B = #3#1 = 0
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@secondiszero #1#2#3#4#5#6%
{%
    \xint@UDsignfork
       #4\dummy{ {#4#2}{0}{-1}{0}{#2}}%
        -\dummy{ {#4#2}{0}{1}{0}{#2}}%
    \xint@UDkrof
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #4#2= A < 0, #3#1 = B < 0
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@minusminus #1#2#3#4%
{%
    \expandafter\XINT@bezout@mm@post
    \romannumeral0\XINT@bezout@loop@a 1{#1}{#2}1001%
}%
\def\XINT@bezout@mm@post #1#2%
{%
    \expandafter\XINT@bezout@mm@postb\expandafter
    {\romannumeral0\xintiopp{#2}}{\romannumeral0\xintiopp{#1}}%
}%
\def\XINT@bezout@mm@postb #1#2%
{%
    \expandafter\XINT@bezout@mm@postc\expandafter {#2}{#1}%
}%
\def\XINT@bezout@mm@postc #1#2#3#4#5%
{%
    \space {#4}{#5}{#1}{#2}{#3}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% minusplus  #4#2= A > 0, B < 0
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@minusplus #1#2#3#4%
{%
    \expandafter\XINT@bezout@mp@post
    \romannumeral0\XINT@bezout@loop@a 1{#1}{#4#2}1001%
}%
\def\XINT@bezout@mp@post #1#2%
{%
    \expandafter\XINT@bezout@mp@postb\expandafter
      {\romannumeral0\xintiopp {#2}}{#1}%
}%
\def\XINT@bezout@mp@postb #1#2#3#4#5%
{%
    \space {#4}{#5}{#2}{#1}{#3}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% plusminus  A < 0, B > 0
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@plusminus #1#2#3#4%
{%
    \expandafter\XINT@bezout@pm@post
    \romannumeral0\XINT@bezout@loop@a 1{#3#1}{#2}1001%
}%
\def\XINT@bezout@pm@post #1%
{%
    \expandafter \XINT@bezout@pm@postb \expandafter
        {\romannumeral0\xintiopp{#1}}%
}%
\def\XINT@bezout@pm@postb #1#2#3#4#5%
{%
    \space {#4}{#5}{#1}{#2}{#3}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% plusplus
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@plusplus #1#2#3#4%
{%
    \expandafter\XINT@bezout@pp@post
    \romannumeral0\XINT@bezout@loop@a 1{#3#1}{#4#2}1001%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% la parité (-1)^N est en #1, et on la jette ici.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@pp@post #1#2#3#4#5%
{%
    \space {#4}{#5}{#1}{#2}{#3}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% n = 0: 1BAalpha(0)beta(0)alpha(-1)beta(-1)
% n général:
% {(-1)^n}{r(n-1)}{r(n-2)}{alpha(n-1)}{beta(n-1)}{alpha(n-2)}{beta(n-2)}
% #2 = B, #3 = A
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@loop@a #1#2#3%
{%
    \expandafter\XINT@bezout@loop@b
    \expandafter{\the\numexpr -#1\expandafter }%
    \romannumeral0\XINT@div@prepare {#2}{#3}{#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Le q(n) a ici une existence éphémère, dans le version Bezout Algorithm
% il faudra le conserver. On voudra à la fin
% {{q(n)}{r(n)}{alpha(n)}{beta(n)}}
% De plus ce n'est plus (-1)^n que l'on veut mais n. (ou dans un autre ordre)
% {-(-1)^n}{q(n)}{r(n)}{r(n-1)}{alpha(n-1)}{beta(n-1)}{alpha(n-2)}{beta(n-2)}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@loop@b #1#2#3#4#5#6#7#8%
{%
    \expandafter \XINT@bezout@loop@c \expandafter
        {\romannumeral0\xintiadd{\XINT@Mul{#5}{#2}}{#7}}%
        {\romannumeral0\xintiadd{\XINT@Mul{#6}{#2}}{#8}}%
    {#1}{#3}{#4}{#5}{#6}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {alpha(n)}{->beta(n)}{-(-1)^n}{r(n)}{r(n-1)}{alpha(n-1)}{beta(n-1)}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@loop@c #1#2%
{%
    \expandafter \XINT@bezout@loop@d \expandafter
        {#2}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {beta(n)}{alpha(n)}{(-1)^(n+1)}{r(n)}{r(n-1)}{alpha(n-1)}{beta(n-1)}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@loop@d #1#2#3#4#5%
{%
    \XINT@bezout@loop@e #4\Z {#3}{#5}{#2}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% r(n)\Z {(-1)^(n+1)}{r(n-1)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@loop@e #1#2\Z 
{%
    \xint@zero #1\xint@bezout@loop@exit0\XINT@bezout@loop@f
    {#1#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {r(n)}{(-1)^(n+1)}{r(n-1)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@loop@f #1#2%
{%
    \XINT@bezout@loop@a {#2}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {(-1)^(n+1)}{r(n)}{r(n-1)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}
% et itération
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xint@bezout@loop@exit0\XINT@bezout@loop@f #1#2%
{%
    \ifcase #2
    \or  \expandafter\XINT@bezout@exiteven
    \else\expandafter\XINT@bezout@exitodd
    \fi
}%
\def\XINT@bezout@exiteven #1#2#3#4#5%
{%
    \space {#5}{#4}{#1}%
}%
\def\XINT@bezout@exitodd #1#2#3#4#5%
{%
    \space {-#5}{-#4}{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintEuclideAlgorithm}}
% \begin{verbatim}
% Pour Euclide: 
% {N}{A}{D=r(n)}{B}{q1}{r1}{q2}{r2}{q3}{r3}....{qN}{rN=0}
% u<2n> = u<2n+3>u<2n+2> + u<2n+4> à la n ième étape
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintEuclideAlgorithm {\romannumeral0\xinteuclidealgorithm }%
\def\xinteuclidealgorithm #1%
{%
    \expandafter \XINT@euc \expandafter{\romannumeral0\xintiabs {#1}}%
}%
\def\XINT@euc #1#2%
{%
    \expandafter\XINT@euc@fork
    \romannumeral0\xintiabs {#2}\Z #1\Z
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Ici #3#4=A, #1#2=B
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@euc@fork #1#2\Z #3#4\Z
{%
    \xint@UDzerofork
      #1\dummy \XINT@euc@BisZero
      #3\dummy \XINT@euc@AisZero
       0\dummy \XINT@euc@a
    \xint@UDkrof
    {0}{#1#2}{#3#4}{{#3#4}{#1#2}}{}\Z
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Le {} pour protéger {{A}{B}} si on s'arrête après une étape (B divise A)
% On va renvoyer:
% {N}{A}{D=r(n)}{B}{q1}{r1}{q2}{r2}{q3}{r3}....{qN}{rN=0}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@euc@AisZero #1#2#3#4#5#6{ {1}{0}{#2}{#2}{0}{0}}%
\def\XINT@euc@BisZero #1#2#3#4#5#6{ {1}{0}{#3}{#3}{0}{0}}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {n}{rn}{an}{{qn}{rn}}...{{A}{B}}{}\Z
%  an = r(n-1)
% Pour n=0 on a juste {0}{B}{A}{{A}{B}}{}\Z
% \XINT@div@prepare {u}{v} divise v par u
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@euc@a #1#2#3%
{%
    \expandafter\XINT@euc@b
    \expandafter {\the\numexpr #1+1\expandafter }%
    \romannumeral0\XINT@div@prepare {#2}{#3}{#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {n+1}{q(n+1)}{r(n+1)}{rn}{{qn}{rn}}...
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@euc@b #1#2#3#4%
{%
    \XINT@euc@c #3\Z {#1}{#3}{#4}{{#2}{#3}}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% r(n+1)\Z {n+1}{r(n+1)}{r(n)}{{q(n+1)}{r(n+1)}}{{qn}{rn}}...
% Test si r(n+1) est nul.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@euc@c #1#2\Z 
{%
    \xint@zero #1\xint@euc@end0\XINT@euc@a
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {n+1}{r(n+1)}{r(n)}{{q(n+1)}{r(n+1)}}...{}\Z
% Ici r(n+1) = 0. On arrête on se prépare à inverser.
% {n+1}{0}{r(n)}{{q(n+1)}{r(n+1)}}.....{{q1}{r1}}{{A}{B}}{}\Z
% On veut renvoyer:
% {N=n+1}{A}{D=r(n)}{B}{q1}{r1}{q2}{r2}{q3}{r3}....{qN}{rN=0}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xint@euc@end0\XINT@euc@a #1#2#3#4\Z%
{%
    \expandafter\xint@euc@end@
    \romannumeral0%
    \XINT@rord@main {}#4{{#1}{#3}}%
    \xint@UNDEF
      \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@undef\xint@undef\xint@undef\xint@undef
    \xint@UNDEF
}%
\def\xint@euc@end@ #1#2#3%
{%
    \space {#1}{#3}{#2}%
}%
%    \end{macrocode}
% \subsection{\csh{xintBezoutAlgorithm}}
% \begin{verbatim}
% Pour Bezout: objectif, renvoyer
% alpha0=1, beta0=0
% alpha(-1)=0, beta(-1)=1
% {N}{A}{0}{1}{D=r(n)}{B}{1}{0}{q1}{r1}{alpha1=q1}{beta1=1}
%       {q2}{r2}{alpha2}{beta2}....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintBezoutAlgorithm {\romannumeral0\xintbezoutalgorithm }%
\def\xintbezoutalgorithm #1%
{%
    \expandafter \XINT@bezalg \expandafter{\romannumeral0\xintiabs {#1}}%
}%
\def\XINT@bezalg #1#2%
{%
    \expandafter\XINT@bezalg@fork
    \romannumeral0\xintiabs {#2}\Z #1\Z
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Ici #3#4=A, #1#2=B
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezalg@fork #1#2\Z #3#4\Z
{%
    \xint@UDzerofork
      #1\dummy \XINT@bezalg@BisZero
      #3\dummy \XINT@bezalg@AisZero
       0\dummy \XINT@bezalg@a
    \xint@UDkrof
    0{#1#2}{#3#4}1001{{#3#4}{#1#2}}{}\Z
}%
\def\XINT@bezalg@AisZero #1#2#3\Z{ {1}{0}{0}{1}{#2}{#2}{1}{0}{0}{0}{0}{1}}%
\def\XINT@bezalg@BisZero #1#2#3#4\Z{ {1}{0}{0}{1}{#3}{#3}{1}{0}{0}{0}{0}{1}}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% pour préparer l'étape n+1 il faut
% {n}{r(n)}{r(n-1)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}
%                    {{q(n)}{r(n)}{alpha(n)}{beta(n)}}...
% division de #3 par #2
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezalg@a #1#2#3%
{%
    \expandafter\XINT@bezalg@b
    \expandafter {\the\numexpr #1+1\expandafter }%
    \romannumeral0\XINT@div@prepare {#2}{#3}{#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {n+1}{q(n+1)}{r(n+1)}{r(n)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}...
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezalg@b #1#2#3#4#5#6#7#8%
{%
    \expandafter\XINT@bezalg@c\expandafter
     {\romannumeral0\xintiadd {\xintiMul {#6}{#2}}{#8}}%
     {\romannumeral0\xintiadd {\xintiMul {#5}{#2}}{#7}}%
     {#1}{#2}{#3}{#4}{#5}{#6}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {beta(n+1)}{alpha(n+1)}{n+1}{q(n+1)}{r(n+1)}{r(n)}{alpha(n)}{beta(n}}%
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezalg@c #1#2#3#4#5#6%
{%
    \expandafter\XINT@bezalg@d\expandafter {#2}{#3}{#4}{#5}{#6}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {alpha(n+1)}{n+1}{q(n+1)}{r(n+1)}{r(n)}{beta(n+1)}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezalg@d #1#2#3#4#5#6#7#8%
{%
    \XINT@bezalg@e #4\Z {#2}{#4}{#5}{#1}{#6}{#7}{#8}{{#3}{#4}{#1}{#6}}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% r(n+1)\Z {n+1}{r(n+1)}{r(n)}{alpha(n+1)}{beta(n+1)}
%                             {alpha(n)}{beta(n)}{q,r,alpha,beta(n+1)}
% Test si r(n+1) est nul.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezalg@e #1#2\Z
{%
    \xint@zero #1\xint@bezalg@end0\XINT@bezalg@a
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Ici r(n+1) = 0. On arrête on se prépare à inverser.
% {n+1}{r(n+1)}{r(n)}{alpha(n+1)}{beta(n+1)}%
%                    {alpha(n)}{beta(n)}%
%                     {q,r,alpha,beta(n+1)}...{{A}{B}}{}\Z
% On veut renvoyer
% {N}{A}{0}{1}{D=r(n)}{B}{1}{0}{q1}{r1}{alpha1=q1}{beta1=1}
%       {q2}{r2}{alpha2}{beta2}....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xint@bezalg@end0\XINT@bezalg@a #1#2#3#4#5#6#7#8\Z 
{%
    \expandafter\xint@bezalg@end@
    \romannumeral0%
    \XINT@rord@main {}#8{{#1}{#3}}%
    \xint@UNDEF
      \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@undef\xint@undef\xint@undef\xint@undef
    \xint@UNDEF
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {N}{D}{A}{B}{q1}{r1}{alpha1=q1}{beta1=1}{q2}{r2}{alpha2}{beta2}
%      ....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}
% On veut renvoyer
% {N}{A}{0}{1}{D=r(n)}{B}{1}{0}{q1}{r1}{alpha1=q1}{beta1=1}
%        {q2}{r2}{alpha2}{beta2}....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xint@bezalg@end@ #1#2#3#4%
{%
    \space {#1}{#3}{0}{1}{#2}{#4}{1}{0}%
}%
%    \end{macrocode}
% \subsection{\csh{xintTypesetEuclideAlgorithm}}
% \begin{verbatim}
% TYPESETTING
% Organisation: 
% {N}{A}{D}{B}{q1}{r1}{q2}{r2}{q3}{r3}....{qN}{rN=0}
% \U1 = N = nombre d'étapes, \U3 = PGCD, \U2 = A, \U4=B
% q1 = \U5, q2 = \U7 --> qn = \U<2n+3>, rn = \U<2n+4>
% bn = rn. B = r0. A=r(-1)
% r(n-2) = q(n)r(n-1)+r(n) (n e étape) (n au moins 1)
% \U{2n} = \U{2n+3} \times \U{2n+2} + \U{2n+4}, n e étape.
% avec n entre 1 et N.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintTypesetEuclideAlgorithm #1#2%
{% l'algo remplace #1 et #2 par |#1| et |#2|
  \par
  \begingroup
    \xintAssignArray\xintEuclideAlgorithm {#1}{#2}\to\U
    \edef\A{\U2}\edef\B{\U4}\edef\N{\U1}%
    \setbox 0 \vbox{\halign {$##$\cr \A\cr \B \cr}}%
    \noindent
    \count 255 1
    \loop
      \hbox to \wd 0 {\hfil$\U{\the\numexpr 2*\count 255\relax}$}%
      ${} =  \U{\the\numexpr 2*\count 255 + 3\relax}
      \times \U{\the\numexpr 2*\count 255 + 2\relax}
          +  \U{\the\numexpr 2*\count 255 + 4\relax}$%
    \ifnum \count 255 < \N
      \hfill\break
      \advance \count 255 1
    \repeat
  \par
  \endgroup
}%
%    \end{macrocode}
% \subsection{\csh{xintTypesetBezoutAlgorithm}}
% \begin{verbatim}
% Pour Bezout on a: 
% {N}{A}{0}{1}{D=r(n)}{B}{1}{0}{q1}{r1}{alpha1=q1}{beta1=1}
%             {q2}{r2}{alpha2}{beta2}....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}%
% Donc 4N+8 termes
% U1 = N, U2= A, U5=D, U6=B, 
% q1 = U9, qn = U{4n+5}, n au moins 1
% rn = U{4n+6}    , n au moins -1
% alpha(n) = U{4n+7}, n au moins -1
% beta(n)  = U{4n+8}, n au moins -1
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintTypesetBezoutAlgorithm #1#2%
{%
  \par
  \begingroup
    \parindent0pt
    \xintAssignArray\xintBezoutAlgorithm {#1}{#2}\to\BEZ
    \edef\A{\BEZ2}\edef\B{\BEZ6}\edef\N{\BEZ1}% A = |#1|, B = |#2|
    \setbox 0 \vbox{\halign {$##$\cr \A\cr \B \cr}}%
    \count 255 1
    \loop
      \noindent
      \hbox to \wd 0 {\hfil$\BEZ{\the\numexpr 4*\count 255 - 2\relax}$}%
      ${} =  \BEZ{\the\numexpr 4*\count 255 + 5\relax}
      \times \BEZ{\the\numexpr 4*\count 255 + 2\relax}
          +  \BEZ{\the\numexpr 4*\count 255 + 6\relax}$\hfill\break
      \hbox to \wd 0 {\hfil$\BEZ{\the\numexpr 4*\count 255 +7\relax}$}%
      ${} = \BEZ{\the\numexpr 4*\count 255 + 5\relax}
      \times \BEZ{\the\numexpr 4*\count 255 + 3\relax}
          +  \BEZ{\the\numexpr 4*\count 255 - 1\relax}$\hfill\break
      \hbox to \wd 0 {\hfil$\BEZ{\the\numexpr 4*\count 255 +8\relax}$}% 
      ${} =  \BEZ{\the\numexpr 4*\count 255 + 5\relax}
      \times \BEZ{\the\numexpr 4*\count 255 + 4\relax}
          +  \BEZ{\the\numexpr 4*\count 255 \relax}$
      \endgraf
    \ifnum \count 255 < \N
    \advance \count 255 1
  \repeat
  \par
    \edef\U{\BEZ{\the\numexpr 4*\N + 4\relax}}%
    \edef\V{\BEZ{\the\numexpr 4*\N + 3\relax}}%
    \edef\D{\BEZ5}%
    \ifodd\N
       $\U\times\A  - \V\times \B = -\D$%
    \else
       $\U\times\A - \V\times\B = \D$%
    \fi
  \par
  \endgroup
}%
\XINT@gcd@restorecatcodes@endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xintgcd>\relax
%\def<*xintfrac>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xintgcd>
%<*xintfrac>
% \section{Package \xintfracname implementation}
% 
% The commenting is currently (\docdate) very sparse.
%
% \localtableofcontents
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
%
% The code for reload detection is copied from \textsc{Heiko
% Oberdiek}'s packages, and adapted here to check for previous
% loading of the master \xintname package.
%
% The method for catcodes is slightly different, but still
% directly inspired by these packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \def\space { }%
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xintfrac.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xint.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintfrac}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintfrac.sty
      \ifx\w\relax % but xint.sty not yet loaded.
         \y{xintfrac}{Package xint is required}%
         \y{xintfrac}{Will try \string\input\space xint.sty}%
         \def\z{\endgroup\input xint.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xint.sty not yet loaded.
            \y{xintfrac}{Package xint is required}%
            \y{xintfrac}{Will try \string\RequirePackage{xint}}%
            \def\z{\endgroup\RequirePackage{xint}}%
          \fi
      \else
        \y{xintfrac}{I was already loaded, aborting input}%
        \aftergroup\endinput
      \fi
    \fi
  \fi
\z%
%    \end{macrocode}
% \subsection{Confirmation of \xintname loading}
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \def\empty {}%
  \expandafter\let\expandafter\w\csname ver@xint.sty\endcsname
  \ifx\w\relax % Plain TeX, user gave a file name at the prompt
      \y{xintfrac}{Loading of package xint failed, aborting input}%
      \aftergroup\endinput
  \fi
  \ifx\w\empty % LaTeX, user gave a file name at the prompt
      \y{xintfrac}{Loading of package xint failed, aborting input}%
      \aftergroup\endinput
  \fi
\endgroup%
%    \end{macrocode}
% \subsection{Catcodes}
%
% Perhaps catcodes have changed after the loading of \xintname
% and prior to the current loading of \xintfracname, so we can not employ
% the |\XINT@restorecatcodes@endinput| in this style file. But
% there is no problem using |\XINT@setcatcodes|.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \def\x
  {%
      \endgroup
      \edef\XINT@frac@restorecatcodes@endinput
      {%
        \catcode94=\the\catcode94   % ^
        \catcode93=\the\catcode93   % ]
        \catcode91=\the\catcode91   % [
        \catcode47=\the\catcode47   % /
        \catcode41=\the\catcode41   % )
        \catcode40=\the\catcode40   % (
        \catcode42=\the\catcode42   % *
        \catcode43=\the\catcode43   % +
        \catcode62=\the\catcode62   % >
        \catcode60=\the\catcode60   % <
        \catcode58=\the\catcode58   % :
        \catcode46=\the\catcode46   % .
        \catcode45=\the\catcode45   % -
        \catcode44=\the\catcode44   % ,
        \catcode35=\the\catcode35   % #
        \catcode64=\the\catcode64   % @
        \catcode125=\the\catcode125 % }
        \catcode123=\the\catcode123 % {
        \endlinechar=\the\endlinechar
        \catcode13=\the\catcode13   % ^^M
        \catcode32=\the\catcode32   % 
        \catcode61=\the\catcode61\relax   % =
        \noexpand\endinput
      }%
      \XINT@setcatcodes
      \catcode91=12 % [
      \catcode93=12 % ]
      \catcode94=7  % ^
  }%
\x
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\begingroup
  \catcode58=12 % :
  \expandafter\ifx\csname ProvidesPackage\endcsname\relax
    \def\x#1#2#3[#4]{\endgroup
      \immediate\write-1{Package: #3 #4}%
      \xdef#1{#4}%
    }%
  \else
    \def\x#1#2[#3]{\endgroup
      #2[{#3}]%
      \ifx#1\@undefined
        \xdef#1{#3}%
      \fi
      \ifx#1\relax
        \xdef#1{#3}%
      \fi
    }%
  \fi
\expandafter\x\csname ver@xintfrac.sty\endcsname
\ProvidesPackage{xintfrac}%
  [2013/05/02 v1.05a Expandable operations on fractions (jfB)]%
%    \end{macrocode}
% \subsection{\csh{xintLen}}
%    \begin{macrocode}
\def\xintLen {\romannumeral0\xintlen }%
\def\xintlen #1%
{%
    \expandafter\XINT@flen\romannumeral0\XINT@infrac {#1}%
}%
\def\XINT@flen #1#2#3%
{%
    \expandafter\space
    \the\numexpr -1+\XINT@Abs {#1}+\XINT@Len {#2}+\XINT@Len {#3}\relax
}%
%    \end{macrocode}
% \subsection{\csh{XINT@outfrac}}
%    \begin{macrocode}
\def\XINT@outfrac #1#2#3%
{%
    \ifcase\XINT@Sgn{#3}
        \expandafter \XINT@outfrac@divisionbyzero
    \or
        \expandafter \XINT@outfrac@P
    \else
        \expandafter \XINT@outfrac@N 
    \fi
    {#2}{#3}[#1]%
}%
\def\XINT@outfrac@divisionbyzero #1#2{\xintError:DivisionByZero\space #1/0}%
\def\XINT@outfrac@P #1#2%
{%
    \ifcase\XINT@Sgn{#1}
        \expandafter\XINT@outfrac@Zero
    \fi
    \space #1/#2%
}%
\def\XINT@outfrac@Zero #1[#2]{ 0[0]}%
\def\XINT@outfrac@N #1#2%
{%
    \expandafter\XINT@outfrac@N@a\expandafter
    {\romannumeral0\XINT@opp #2}{\romannumeral0\XINT@opp #1}%
}%
\def\XINT@outfrac@N@a #1#2%
{%
    \expandafter\XINT@outfrac@P\expandafter {#2}{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{XINT@inFrac}}
%    \begin{macrocode}
\def\XINT@inFrac {\romannumeral0\XINT@infrac }%
\def\XINT@infrac #1%
{%
    \expandafter\expandafter\expandafter\XINT@infrac@ #1[\W]\Z\T
}%
\def\XINT@infrac@ #1[#2#3]#4\Z
{%
    \xint@UDwfork
      #2\dummy \XINT@infrac@A
      \W\dummy \XINT@infrac@B
    \xint@UDkrof
    #1[#2#3]#4%
}%
\def\XINT@infrac@A #1[\W]\T 
{%
    \XINT@frac #1/\W\Z 
}%
\def\XINT@infrac@B #1%
{%
    \xint@zero #1\XINT@infrac@Zero0\XINT@infrac@BB #1%
}%
\def\XINT@infrac@BB #1[\W]\T {\XINT@infrac@BC #1/\W\Z }%
\def\XINT@infrac@BC #1/#2#3\Z 
{%
    \xint@UDwfork
     #2\dummy \XINT@infrac@BCa
     \W\dummy {\expandafter\expandafter\expandafter\XINT@infrac@BCb #2}%
    \xint@UDkrof
    #3\Z #1\Z
}%
\def\XINT@infrac@BCa \Z #1[#2]#3\Z { {#2}{#1}{1}}%
\def\XINT@infrac@BCb #1[#2]/\W\Z #3\Z { {#2}{#3}{#1}}%
\def\XINT@infrac@Zero #1\T { {0}{0}{1}}%
%    \end{macrocode}
% \subsection{\csh{XINT@frac}}
%    \begin{macrocode}
\def\XINT@frac #1/#2#3\Z
{%
    \xint@UDwfork
     #2\dummy \XINT@frac@A
     \W\dummy {\expandafter\expandafter\expandafter\XINT@frac@B #2}%
    \xint@UDkrof
    #3.\W\Z #1.\W\Z
}%
\def\XINT@frac@B #1.#2#3\Z
{%
    \xint@UDwfork
      #2\dummy \XINT@frac@Ba
      \W\dummy {\XINT@frac@Bb #2}%
    \xint@UDkrof
    #3\Z #1\Z
}%
\def\XINT@frac@Bb #1/\W.\W\Z #2\Z
{%
    \expandafter \XINT@frac@C \expandafter
    {\romannumeral0\XINT@length {#1}}{#2#1}%
}%
\def\XINT@frac@Ba \Z #1/\W\Z {\XINT@frac@C {0}{#1}}%
\def\XINT@frac@A .\W\Z {\XINT@frac@C {0}{1}}%
\def\XINT@frac@C #1#2#3.#4#5\Z
{%
    \xint@UDwfork
      #4\dummy \XINT@frac@Ca
      \W\dummy {\XINT@frac@Cb #4}%
    \xint@UDkrof
    #5\Z #3\Z {#1}{#2}%
}%
\def\XINT@frac@Ca \Z #1\Z {\XINT@frac@D {0}{#1}}%
\def\XINT@frac@Cb #1.\W\Z #2\Z 
{%
    \expandafter\XINT@frac@D\expandafter
    {\romannumeral0\XINT@length {#1}}{#2#1}%
}%
\def\XINT@frac@D #1#2#3#4%
{%
    \expandafter \XINT@frac@E \expandafter
    {\the\numexpr -#1+#3\expandafter}\expandafter
    {\romannumeral0\XINT@num@loop #2\R\R\R\R\R\R\R\R\Z }%
    {\romannumeral0\XINT@num@loop #4\R\R\R\R\R\R\R\R\Z }%
}%
\def\XINT@frac@E #1#2#3%
{%
   \expandafter \XINT@frac@F  #3\Z {#2}{#1}%
}%
\def\XINT@frac@F #1%
{%
    \xint@UDzerominusfork
      #1-\dummy  \XINT@frac@Gdivisionbyzero
      0#1\dummy  \XINT@frac@Gneg
       0-\dummy  {\XINT@frac@Gpos #1}%
    \xint@UDkrof
}%
\def\XINT@frac@Gdivisionbyzero #1\Z #2#3%
{%
   \xintError:DivisionByZero\space {0}{#2}{0}%
}%
\def\XINT@frac@Gneg #1\Z #2#3%
{%
    \expandafter\XINT@frac@H \expandafter{\romannumeral0\XINT@opp #2}{#3}{#1}%
}%
\def\XINT@frac@H #1#2{ {#2}{#1}}%
\def\XINT@frac@Gpos #1\Z #2#3{ {#3}{#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{XINT@factortens},~\csh{XINT@cuz@cnt}}
%    \begin{macrocode}
\def\XINT@factortens #1%
{%
    \expandafter\XINT@cuz@cnt@loop\expandafter
    {\expandafter}\romannumeral0\XINT@rord@main {}#1%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
    \R\R\R\R\R\R\R\R\Z
}%
\def\XINT@cuz@cnt #1%
{%
    \XINT@cuz@cnt@loop {}#1\R\R\R\R\R\R\R\R\Z
}%
\def\XINT@cuz@cnt@loop #1#2#3#4#5#6#7#8#9%
{%
    \xint@r #9\XINT@cuz@cnt@toofara \R
    \expandafter\XINT@cuz@cnt@checka\expandafter
    {\the\numexpr #1+8\relax}{#2#3#4#5#6#7#8#9}%
}%
\def\XINT@cuz@cnt@toofara\R
    \expandafter\XINT@cuz@cnt@checka\expandafter #1#2%
{%
    \XINT@cuz@cnt@toofarb {#1}#2%
}%
\def\XINT@cuz@cnt@toofarb #1#2\Z {\XINT@cuz@cnt@toofarc #2\Z {#1}}%
\def\XINT@cuz@cnt@toofarc #1#2#3#4#5#6#7#8%
{%
    \xint@r #2\XINT@cuz@cnt@toofard 7%
            #3\XINT@cuz@cnt@toofard 6%
            #4\XINT@cuz@cnt@toofard 5%
            #5\XINT@cuz@cnt@toofard 4%
            #6\XINT@cuz@cnt@toofard 3%
            #7\XINT@cuz@cnt@toofard 2%
            #8\XINT@cuz@cnt@toofard 1%
            \Z #1#2#3#4#5#6#7#8%
}%
\def\XINT@cuz@cnt@toofard #1#2\Z #3\R #4\Z #5%
{%
    \expandafter\XINT@cuz@cnt@toofare
    \the\numexpr #3\relax \R\R\R\R\R\R\R\R\Z
    {\the\numexpr #5-#1\relax}\R\Z
}%
\def\XINT@cuz@cnt@toofare #1#2#3#4#5#6#7#8%
{%
    \xint@r #2\XINT@cuz@cnt@stopc 1%
            #3\XINT@cuz@cnt@stopc 2%
            #4\XINT@cuz@cnt@stopc 3%
            #5\XINT@cuz@cnt@stopc 4%
            #6\XINT@cuz@cnt@stopc 5%
            #7\XINT@cuz@cnt@stopc 6%
            #8\XINT@cuz@cnt@stopc 7%
            \Z #1#2#3#4#5#6#7#8%
}%
\def\XINT@cuz@cnt@checka #1#2%
{%
    \expandafter\XINT@cuz@cnt@checkb\the\numexpr #2\relax \Z {#1}%
}%
\def\XINT@cuz@cnt@checkb #1%
{%
    \xint@zero #1\expandafter\XINT@cuz@cnt@loop\xint@z
    0\XINT@cuz@cnt@stopa #1%
}%
\def\XINT@cuz@cnt@stopa #1\Z 
{%
    \XINT@cuz@cnt@stopb #1\R\R\R\R\R\R\R\R\Z %
}%
\def\XINT@cuz@cnt@stopb #1#2#3#4#5#6#7#8#9%
{%
    \xint@r #2\XINT@cuz@cnt@stopc 1%
            #3\XINT@cuz@cnt@stopc 2%
            #4\XINT@cuz@cnt@stopc 3%
            #5\XINT@cuz@cnt@stopc 4%
            #6\XINT@cuz@cnt@stopc 5%
            #7\XINT@cuz@cnt@stopc 6%
            #8\XINT@cuz@cnt@stopc 7%
            #9\XINT@cuz@cnt@stopc 8%
            \Z #1#2#3#4#5#6#7#8#9%
}%
\def\XINT@cuz@cnt@stopc #1#2\Z #3\R #4\Z #5%
{%
    \expandafter\XINT@cuz@cnt@stopd\expandafter
    {\the\numexpr #5-#1}#3%
}%
\def\XINT@cuz@cnt@stopd #1#2\R #3\Z
{%
    \expandafter\space\expandafter
     {\romannumeral0\XINT@rord@main {}#2%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF }{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintRaw}}
%    \begin{macrocode}
\def\xintRaw {\romannumeral0\xintraw }%
\def\xintraw 
{%
    \expandafter\XINT@raw\romannumeral0\XINT@infrac
}%
\def\XINT@raw #1%
{%
    \ifcase\XINT@Sgn {#1}
      \expandafter\XINT@raw@Ba
    \or
      \expandafter\XINT@raw@A
    \else
      \expandafter\XINT@raw@Ba
    \fi 
    {#1}%
}%
\def\XINT@raw@A  #1#2#3{\xint@dsh {#2}{-#1}/#3}%
\def\XINT@raw@Ba #1#2#3{\expandafter\XINT@raw@Bb
                        \expandafter{\romannumeral0\xint@dsh {#3}{#1}}{#2}}%
\def\XINT@raw@Bb #1#2{ #2/#1}%
%    \end{macrocode}
% \subsection{\csh{xintNumerator}}
%    \begin{macrocode}
\def\xintNumerator {\romannumeral0\xintnumerator }%
\def\xintnumerator 
{%
    \expandafter\XINT@numer\romannumeral0\XINT@infrac
}%
\def\XINT@numer #1%
{%
    \ifcase\XINT@Sgn {#1}
      \expandafter\XINT@numer@B
    \or
      \expandafter\XINT@numer@A
    \else
      \expandafter\XINT@numer@B
    \fi 
    {#1}%
}%
\def\XINT@numer@A #1#2#3{\xint@dsh {#2}{-#1}}%
\def\XINT@numer@B #1#2#3{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintDenominator}}
%    \begin{macrocode}
\def\xintDenominator {\romannumeral0\xintdenominator }%
\def\xintdenominator 
{%
    \expandafter\XINT@denom\romannumeral0\XINT@infrac
}%
\def\XINT@denom #1%
{%
    \ifcase\XINT@Sgn {#1}
      \expandafter\XINT@denom@B
    \or
      \expandafter\XINT@denom@A
    \else
      \expandafter\XINT@denom@B
    \fi 
    {#1}%
}%
\def\XINT@denom@A #1#2#3{ #3}%
\def\XINT@denom@B #1#2#3{\xint@dsh {#3}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintFrac}}
%    \begin{macrocode}
\def\xintFrac {\romannumeral0\xintfrac }%
\def\xintfrac #1%
{%
    \expandafter\XINT@@frac@A\romannumeral0\XINT@infrac {#1}%
}%
\def\XINT@@frac@A #1{\XINT@@frac@B #1\Z }%
\def\XINT@@frac@B #1#2\Z 
{%
    \xint@zero #1\XINT@@frac@C 0\XINT@@frac@D {10^{#1#2}}%
}%
\def\XINT@@frac@C #1#2#3#4#5% 
{%
    \ifcase\XINT@isOne {#5}
    \or \xint@afterfi {\expandafter\xint@firstoftwo@andstop\xint@gobble@two }%
    \fi
    \space
    \frac {#4}{#5}%
}%
\def\XINT@@frac@D #1#2#3%
{%
    \ifcase\XINT@isOne {#3}
    \or \XINT@@frac@E
    \fi
    \space
    \frac {#2}{#3}#1%
}%
\def\XINT@@frac@E \fi #1#2#3#4{\fi \space #3\cdot }%
%    \end{macrocode}
% \subsection{\csh{xintSignedFrac}}
%    \begin{macrocode}
\def\xintSignedFrac {\romannumeral0\xintsignedfrac }%
\def\xintsignedfrac #1%
{%
    \expandafter\XINT@sgnfrac@a\romannumeral0\XINT@infrac {#1}%
}%
\def\XINT@sgnfrac@a #1#2%
{%
    \XINT@sgnfrac@b #2\Z {#1}%
}%
\def\XINT@sgnfrac@b #1%
{%
    \xint@UDsignfork
      #1\dummy \XINT@sgnfrac@N
       -\dummy {\XINT@sgnfrac@P #1}%
    \xint@UDkrof
}%
\def\XINT@sgnfrac@P #1\Z #2%
{%
    \XINT@@frac@A {#2}{#1}%
}%
\def\XINT@sgnfrac@N
{%
    \expandafter\xint@minus@andstop\romannumeral0\XINT@sgnfrac@P 
}%
%    \end{macrocode}
% \subsection{\csh{xintFwOver}}
%    \begin{macrocode}
\def\xintFwOver {\romannumeral0\xintfwover }%
\def\xintfwover #1%
{%
    \expandafter\XINT@fwover@A\romannumeral0\XINT@infrac {#1}%
}%
\def\XINT@fwover@A #1{\XINT@fwover@B #1\Z }%
\def\XINT@fwover@B #1#2\Z 
{%
    \xint@zero #1\XINT@fwover@C 0\XINT@fwover@D {10^{#1#2}}%
}%
\def\XINT@fwover@C #1#2#3#4#5% 
{%
    \ifcase\XINT@isOne {#5}
       \xint@afterfi { {#4\over #5}}%
    \or 
       \xint@afterfi { #4}%
    \fi
}%
\def\XINT@fwover@D #1#2#3%
{%
    \ifcase\XINT@isOne {#3}
      \xint@afterfi { {#2\over #3}}%
    \or 
      \xint@afterfi { #2\cdot }%
    \fi
    #1%
}%
%    \end{macrocode}
% \subsection{\csh{xintSignedFwOver}}
%    \begin{macrocode}
\def\xintSignedFwOver {\romannumeral0\xintsignedfwover }%
\def\xintsignedfwover #1%
{%
    \expandafter\XINT@sgnfwover@a\romannumeral0\XINT@infrac {#1}%
}%
\def\XINT@sgnfwover@a #1#2%
{%
    \XINT@sgnfwover@b #2\Z {#1}%
}%
\def\XINT@sgnfwover@b #1%
{%
    \xint@UDsignfork
      #1\dummy \XINT@sgnfwover@N
       -\dummy {\XINT@sgnfwover@P #1}%
    \xint@UDkrof
}%
\def\XINT@sgnfwover@P #1\Z #2%
{%
    \XINT@fwover@A {#2}{#1}%
}%
\def\XINT@sgnfwover@N
{%
    \expandafter\xint@minus@andstop\romannumeral0\XINT@sgnfwover@P 
}%
%    \end{macrocode}
% \subsection{\csh{xintREZ}}
%    \begin{macrocode}
\def\xintREZ {\romannumeral0\xintrez }%
\def\xintrez
{%
    \expandafter\XINT@rez@A\romannumeral0\XINT@infrac
}%
\def\XINT@rez@A #1#2%
{%
    \XINT@rez@AB #2\Z {#1}%
}%
\def\XINT@rez@AB #1%
{%
    \xint@UDzerominusfork
      #1-\dummy \XINT@rez@zero
      0#1\dummy \XINT@rez@neg
       0-\dummy {\XINT@rez@B #1}%
    \xint@UDkrof
}%
\def\XINT@rez@zero #1\Z #2#3{ 0/1[0]}%
\def\XINT@rez@neg {\expandafter\xint@minus@andstop\romannumeral0\XINT@rez@B }%
\def\XINT@rez@B #1\Z 
{%
    \expandafter\XINT@rez@C\romannumeral0\XINT@factortens {#1}%
}%
\def\XINT@rez@C #1#2#3#4%
{%
    \expandafter\XINT@rez@D\romannumeral0\XINT@factortens {#4}{#3}{#2}{#1}%
}%
\def\XINT@rez@D #1#2#3#4#5%
{%
    \expandafter\XINT@rez@E\expandafter
    {\the\numexpr #3+#4-#2}{#1}{#5}%
}%
\def\XINT@rez@E #1#2#3{ #3/#2[#1]}%
%    \end{macrocode}
% \subsection{\csh{xintIrr}}
% \begin{verbatim}
% 1.04 fixes a buggy \xintIrr {0}. 
% 1.05 modifies the initial parsing and post-processing to use \xintraw and to
% more quickly deal with an input denominator equal to 1.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintIrr {\romannumeral0\xintirr }%
\def\xintirr #1%
{%
    \expandafter\XINT@irr@start\romannumeral0\xintraw {#1}\Z
}%
\def\XINT@irr@start #1#2/#3\Z
{%
    \ifcase\XINT@isOne {#3}
      \xint@afterfi
          {\xint@UDsignfork
               #1\dummy \XINT@irr@negative    
                -\dummy {\XINT@irr@nonneg #1}%       
           \xint@UDkrof}%
    \or
      \xint@afterfi{\XINT@irr@denomisone #1}%
    \fi 
    #2\Z {#3}%
}%
\def\XINT@irr@denomisone #1\Z #2{ #1}%
\def\XINT@irr@negative   #1\Z #2{\XINT@irr@D #1\Z #2\Z \XINT@opp}%
\def\XINT@irr@nonneg     #1\Z #2{\XINT@irr@D #1\Z #2\Z \space}%
\def\XINT@irr@D #1#2\Z #3#4\Z
{%
    \xint@UDzerosfork
       #3#1\dummy \XINT@irr@indeterminate      
       #30\dummy  \XINT@irr@divisionbyzero        
       #10\dummy  \XINT@irr@zero        
        00\dummy  \XINT@irr@loop@a
    \xint@UDkrof      
    {#3#4}{#1#2}{#3#4}{#1#2}%
}%
\def\XINT@irr@indeterminate #1#2#3#4#5{\xintError:NaN\space 0/0}%
\def\XINT@irr@divisionbyzero #1#2#3#4#5{\xintError:DivisionByZero #5#2/0}%
\def\XINT@irr@zero #1#2#3#4#5{ 0}%
\def\XINT@irr@loop@a #1#2%
{%
    \expandafter\XINT@irr@loop@d
    \romannumeral0\XINT@div@prepare {#1}{#2}{#1}%
}%
\def\XINT@irr@loop@d #1#2%
{%
    \XINT@irr@loop@e #2\Z 
}%
\def\XINT@irr@loop@e #1#2\Z
{%
    \xint@zero #1\xint@irr@loop@exit0\XINT@irr@loop@a {#1#2}%
}%
\def\xint@irr@loop@exit0\XINT@irr@loop@a #1#2#3#4%
{%
    \expandafter\XINT@irr@loop@exitb\expandafter
    {\romannumeral0\xintiquo {#3}{#2}}%
    {\romannumeral0\xintiquo {#4}{#2}}%
}%
\def\XINT@irr@loop@exitb #1#2%
{%
   \expandafter\XINT@irr@finish\expandafter {#2}{#1}%
}%
\def\XINT@irr@finish #1#2#3%
{%
    \ifcase\XINT@isOne {#2}
      \xint@afterfi {#3#1/#2}%
    \or
      \xint@afterfi {#3#1}%
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintNum}}
% \begin{verbatim}
% this extension of the xint original xintNum is added in 1.05, as a synonym to
% \xintIrr, but raising an error when the input does not evaluate to an integer.
% Usable with not too much overhead on integer input as \xintIrr 
% checks quickly for a denominator equal to 1 (which will be put there by the
% \XINT@infrac called by \xintraw). This way, macros such as \xintQuo can be
% modified with minimal overhead to accept fractional input as long as it
% evaluates to an integer. 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintNum {\romannumeral0\xintnum }%
\def\xintnum #1{\expandafter\XINT@intcheck\romannumeral0\xintirr {#1}/\W\Z }%
\def\XINT@intcheck #1/#2#3\Z
{%
    \xint@w #2\xint@gobble@two\W\xintError:NotAnInteger
    \space #1%
}%
%    \end{macrocode}
% \subsection{\csh{xintJrr}}
% \begin{verbatim}
% Modified similarly as \xintIrr in release 1.05
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintJrr {\romannumeral0\xintjrr }%
\def\xintjrr #1%
{%
    \expandafter\XINT@jrr@start\romannumeral0\xintraw {#1}\Z
}%
\def\XINT@jrr@start #1#2/#3\Z
{%
    \ifcase\XINT@isOne {#3}
      \xint@afterfi
          {\xint@UDsignfork
               #1\dummy \XINT@jrr@negative    
                -\dummy {\XINT@jrr@nonneg #1}%       
           \xint@UDkrof}%
    \or
      \xint@afterfi{\XINT@jrr@denomisone #1}%
    \fi 
    #2\Z {#3}%
}%
\def\XINT@jrr@denomisone #1\Z #2{ #1}%
\def\XINT@jrr@negative   #1\Z #2{\XINT@jrr@D #1\Z #2\Z \XINT@opp}%
\def\XINT@jrr@nonneg     #1\Z #2{\XINT@jrr@D #1\Z #2\Z \space}%
\def\XINT@jrr@D #1#2\Z #3#4\Z
{%
    \xint@UDzerosfork
       #3#1\dummy \XINT@jrr@indeterminate      
       #30\dummy  \XINT@jrr@divisionbyzero        
       #10\dummy  \XINT@jrr@zero        
        00\dummy  \XINT@jrr@loop@a
    \xint@UDkrof      
    {#3#4}{#1#2}1001%
}%
\def\XINT@jrr@indeterminate #1#2#3#4#5#6#7{\xintError:NaN\space 0/0}%
\def\XINT@jrr@divisionbyzero #1#2#3#4#5#6#7{\xintError:DivisionByZero #7#2/0}%
\def\XINT@jrr@zero #1#2#3#4#5#6#7{ 0}%
\def\XINT@jrr@loop@a #1#2%
{%
    \expandafter\XINT@jrr@loop@b
    \romannumeral0\XINT@div@prepare {#1}{#2}{#1}%
}%
\def\XINT@jrr@loop@b #1#2#3#4#5#6#7%
{%
    \expandafter \XINT@jrr@loop@c \expandafter
        {\romannumeral0\xintiadd{\XINT@Mul{#4}{#1}}{#6}}%
        {\romannumeral0\xintiadd{\XINT@Mul{#5}{#1}}{#7}}%
    {#2}{#3}{#4}{#5}%
}%
\def\XINT@jrr@loop@c #1#2%
{%
    \expandafter \XINT@jrr@loop@d \expandafter{#2}{#1}%
}%
\def\XINT@jrr@loop@d #1#2#3#4%
{%
    \XINT@jrr@loop@e #3\Z {#4}{#2}{#1}%
}%
\def\XINT@jrr@loop@e #1#2\Z
{%
    \xint@zero #1\xint@jrr@loop@exit0\XINT@jrr@loop@a {#1#2}%
}%
\def\xint@jrr@loop@exit0\XINT@jrr@loop@a #1#2#3#4#5#6%
{%
    \XINT@irr@finish {#3}{#4}%
}%
%    \end{macrocode}
% \subsection{\csh{xintTrunc}, \csh{xintiTrunc}}
%    \begin{macrocode}
\def\xintTrunc {\romannumeral0\xinttrunc }%
\def\xintiTrunc {\romannumeral0\xintitrunc }%
\def\xinttrunc #1%
{%
    \expandafter\expandafter\expandafter
       \XINT@trunc
    \expandafter\expandafter\expandafter
       {#1}%
}%
\def\XINT@trunc #1#2%
{%
    \expandafter\XINT@trunc@G
    \romannumeral0\expandafter\XINT@trunc@A
    \romannumeral0\XINT@infrac {#2}{#1}{#1}%
}%
\def\xintitrunc #1%
{%
    \expandafter\expandafter\expandafter
       \XINT@itrunc
    \expandafter\expandafter\expandafter
       {#1}%
}%
\def\XINT@itrunc #1#2%
{%
    \expandafter\XINT@itrunc@G
    \romannumeral0\expandafter\XINT@trunc@A
    \romannumeral0\XINT@infrac {#2}{#1}{#1}%
}%
\def\XINT@trunc@A #1#2#3#4%
{%
    \expandafter\XINT@trunc@checkifzero
    \expandafter{\the\numexpr #1+#4}#2\Z {#3}%
}%
\def\XINT@trunc@checkifzero #1#2#3\Z 
{%
    \xint@zero #2\XINT@trunc@iszero0\XINT@trunc@B {#1}{#2#3}%
}%
\def\XINT@trunc@iszero #1#2#3#4#5{ 0\Z 0}%
\def\XINT@trunc@B #1%
{%
    \ifcase\XINT@Sgn {#1}
      \expandafter\XINT@trunc@D
    \or
      \expandafter\XINT@trunc@D
    \else
      \expandafter\XINT@trunc@C
    \fi 
    {#1}%
}%
\def\XINT@trunc@C #1#2#3%
{%
    \expandafter \XINT@trunc@E
    \romannumeral0\xint@dsh {#3}{#1}\Z #2\Z
}%
\def\XINT@trunc@D #1#2%
{%
    \expandafter \XINT@trunc@DE \expandafter
    {\romannumeral0\xint@dsh {#2}{-#1}}%
}%
\def\XINT@trunc@DE #1#2{\XINT@trunc@E #2\Z #1\Z }%
\def\XINT@trunc@E #1#2\Z #3#4\Z
{%
    \xint@UDsignsfork
          #1#3\dummy \XINT@trunc@minusminus          
           #1-\dummy {\XINT@trunc@minusplus #3}%
           #3-\dummy {\XINT@trunc@plusminus #1}%
            --\dummy {\XINT@trunc@plusplus  #3#1}%
    \xint@UDkrof
    {#4}{#2}%
}%
\def\XINT@trunc@minusminus #1#2{\xintiquo {#1}{#2}\Z \space}%
\def\XINT@trunc@minusplus #1#2#3{\xintiquo {#1#2}{#3}\Z \xint@minus@andstop}%
\def\XINT@trunc@plusminus #1#2#3{\xintiquo {#2}{#1#3}\Z \xint@minus@andstop}%
\def\XINT@trunc@plusplus  #1#2#3#4{\xintiquo {#1#3}{#2#4}\Z \space}%
\def\XINT@itrunc@G #1#2\Z #3#4%
{%
    \xint@zero #1\XINT@trunc@zero 0\xint@firstoftwo {#3#1#2}0%
}%
\def\XINT@trunc@G #1\Z #2#3%
{%
    \xint@zero #2\XINT@trunc@zero 0%
    \expandafter\XINT@trunc@H\expandafter
    {\the\numexpr\romannumeral0\XINT@length {#1}-#3}{#3}{#1}#2%
}%
\def\XINT@trunc@zero 0#10{ 0}%
\def\XINT@trunc@H #1#2%
{%
    \ifnum #1 > 0
        \xint@afterfi {\XINT@trunc@Ha {#2}}%
    \else
        \xint@afterfi {\XINT@trunc@Hb {-#1}}%
    \fi
}%
\def\XINT@trunc@Ha
{%
  \expandafter\XINT@trunc@Haa\romannumeral0\xintdecsplit
}%
\def\XINT@trunc@Haa #1#2#3%
{%
    #3#1.#2%
}%
\def\XINT@trunc@Hb #1#2#3%
{%
    \expandafter #3\expandafter0\expandafter.%
    \romannumeral0\XINT@dsx@zeroloop {#1}\Z {}#2%
}%
%    \end{macrocode}
% \subsection{\csh{xintRound}, \csh{xintiRound}}
%    \begin{macrocode}
\def\xintRound {\romannumeral0\xintround }%
\def\xintiRound {\romannumeral0\xintiround }%
\def\xintround #1%
{%
    \expandafter\expandafter\expandafter
       \XINT@round
    \expandafter\expandafter\expandafter
       {#1}%
}%
\def\XINT@round
{%
    \expandafter\XINT@trunc@G\romannumeral0\XINT@round@A
}%
\def\xintiround #1%
{%
    \expandafter\expandafter\expandafter
       \XINT@iround
    \expandafter\expandafter\expandafter
       {#1}%
}%
\def\XINT@iround
{%
    \expandafter\XINT@itrunc@G\romannumeral0\XINT@round@A
}%
\def\XINT@round@A #1#2%
{%
    \expandafter\XINT@round@B
    \romannumeral0\expandafter\XINT@trunc@A
    \romannumeral0\XINT@infrac {#2}{\the\numexpr #1+1\relax}{#1}%
}%
\def\XINT@round@B #1\Z
{%
    \expandafter\XINT@round@C
    \romannumeral0\XINT@rord@main {}#1%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF 
    \Z 
}%
\def\XINT@round@C #1%
{%
    \ifnum #1<5
        \expandafter\XINT@round@Daa
    \else
        \expandafter\XINT@round@Dba
    \fi
}%
\def\XINT@round@Daa #1%
{%
    \xint@z #1\XINT@round@Daz\Z \XINT@round@Da #1%
}%
\def\XINT@round@Daz\Z \XINT@round@Da \Z { 0\Z }%
\def\XINT@round@Da #1\Z 
{%
    \XINT@rord@main {}#1%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF  \Z  
}%
\def\XINT@round@Dba #1%
{%
    \xint@z #1\XINT@round@Dbz\Z \XINT@round@Db #1%
}%
\def\XINT@round@Dbz\Z \XINT@round@Db \Z { 1\Z }%
\def\XINT@round@Db #1\Z
{%
    \XINT@addm@A 0{}1000\W\X\Y\Z #1000\W\X\Y\Z \Z
}%
%    \end{macrocode}
% \subsection{\csh{xintAdd}}
%    \begin{macrocode}
\def\xintAdd {\romannumeral0\xintadd }%
\def\xintadd #1%
{%
    \expandafter\xint@fadd\expandafter {\romannumeral0\XINT@infrac {#1}}%
}%
\def\xint@fadd #1#2{\expandafter\XINT@fadd@A\romannumeral0\XINT@infrac{#2}#1}%
\def\XINT@fadd@A #1#2#3#4%
{%
    \ifnum #4 > #1
       \xint@afterfi {\XINT@fadd@B {#1}}%
    \else
       \xint@afterfi {\XINT@fadd@B {#4}}%
    \fi
    {#1}{#4}{#2}{#3}%
}%
\def\XINT@fadd@B #1#2#3#4#5#6#7%
{%
    \expandafter\XINT@fadd@C\expandafter
    {\romannumeral0\xintimul {#7}{#5}}%
    {\romannumeral0\xintiadd
    {\romannumeral0\xintimul {\xintDSH {\the\numexpr -#3+#1\relax}{#6}}{#5}}%
    {\romannumeral0\xintimul {#7}{\xintDSH {\the\numexpr -#2+#1\relax}{#4}}}%
    }%
    {#1}%
}%
\def\XINT@fadd@C #1#2#3%
{%
    \expandafter\XINT@fadd@D\expandafter {#2}{#3}{#1}%
}%
\def\XINT@fadd@D #1#2{\XINT@outfrac {#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintSub}}
%    \begin{macrocode}
\def\xintSub {\romannumeral0\xintsub }%
\def\xintsub #1%
{%
    \expandafter\xint@fsub\expandafter {\romannumeral0\XINT@infrac {#1}}%
}%
\def\xint@fsub #1#2%
   {\expandafter\XINT@fsub@A\romannumeral0\XINT@infrac {#2}#1}%
\def\XINT@fsub@A #1#2#3#4%
{%
    \ifnum #4 > #1
       \xint@afterfi {\XINT@fsub@B {#1}}%
    \else
       \xint@afterfi {\XINT@fsub@B {#4}}%
    \fi
    {#1}{#4}{#2}{#3}%
}%
\def\XINT@fsub@B #1#2#3#4#5#6#7%
{%
    \expandafter\XINT@fsub@C\expandafter
    {\romannumeral0\xintimul {#7}{#5}}%
    {\romannumeral0\xintisub
    {\romannumeral0\xintimul {\xintDSH {\the\numexpr -#3+#1\relax}{#6}}{#5}}%
    {\romannumeral0\xintimul {#7}{\xintDSH {\the\numexpr -#2+#1\relax}{#4}}}%
    }%
    {#1}%
}%
\def\XINT@fsub@C #1#2#3%
{%
    \expandafter\XINT@fsub@D\expandafter {#2}{#3}{#1}%
}%
\def\XINT@fsub@D #1#2{\XINT@outfrac {#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintSum}, \csh{xintSumExpr}}
%    \begin{macrocode}
\def\xintSum {\romannumeral0\xintsum }%
\def\xintsum #1{\xintsumexpr #1\relax }%
\def\xintSumExpr {\romannumeral0\xintsumexpr }%
\def\xintsumexpr {\expandafter\expandafter\expandafter\XINT@fsumexpr }%
\def\XINT@fsumexpr {\XINT@fsum@loop@a {0[0]}}%
\def\XINT@fsum@loop@a #1#2%
{%
    \expandafter\expandafter\expandafter\XINT@fsum@loop@b #2\Z {#1}%
}%
\def\XINT@fsum@loop@b #1%
{%
    \xint@relax #1\XINT@fsum@finished\relax
    \XINT@fsum@loop@c #1%
}%
\def\XINT@fsum@loop@c #1\Z #2%
{%
    \expandafter\XINT@fsum@loop@a\expandafter{\romannumeral0\xintadd {#2}{#1}}%
}%
\def\XINT@fsum@finished #1\Z #2{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintMul}}
%    \begin{macrocode}
\def\xintMul {\romannumeral0\xintmul }%
\def\xintmul #1%
{%
    \expandafter\xint@fmul\expandafter {\romannumeral0\XINT@infrac {#1}}%
}%
\def\xint@fmul #1#2%
   {\expandafter\XINT@fmul@A\romannumeral0\XINT@infrac {#2}#1}%
\def\XINT@fmul@A #1#2#3#4#5#6%
{%
    \expandafter\XINT@fmul@B
    \expandafter{\the\numexpr #1+#4\expandafter}%
    \expandafter{\romannumeral0\xintimul {#6}{#3}}%
    {\romannumeral0\xintimul {#5}{#2}}%
}%
\def\XINT@fmul@B #1#2#3%
{%
    \expandafter \XINT@fmul@C \expandafter{#3}{#1}{#2}%
}%
\def\XINT@fmul@C #1#2{\XINT@outfrac {#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintSqr}}
%    \begin{macrocode}
\def\xintSqr {\romannumeral0\xintsqr }%
\def\xintsqr #1%
{%
    \expandafter\xint@fsqr\expandafter{\romannumeral0\XINT@infrac {#1}}%
}%
\def\xint@fsqr #1{\XINT@fmul@A #1#1}%
%    \end{macrocode}
% \subsection{\csh{xintPow}}
%    \begin{macrocode}
\def\xintPow {\romannumeral0\xintpow }%
\def\xintpow #1%
{%
    \expandafter\xint@fpow\expandafter {\romannumeral0\XINT@infrac {#1}}%
}%
\def\xint@fpow #1#2%
{%
    \expandafter\expandafter\expandafter
    \XINT@fpow@fork #2\Z #1%
}%
\def\XINT@fpow@fork #1#2\Z
{%
    \xint@UDzerominusfork
      #1-\dummy  \XINT@fpow@zero
      0#1\dummy  \XINT@fpow@neg
       0-\dummy  {\XINT@fpow@pos #1}%
    \xint@UDkrof
    {#2}%
}%
\def\XINT@fpow@zero #1#2#3#4%
{%
    \space 1[0]%
}%
\def\XINT@fpow@pos #1#2#3#4#5%
{%
    \expandafter\XINT@fpow@pos@A\expandafter
    {\the\numexpr #1#2*#3\expandafter}\expandafter
    {\romannumeral0\xintipow {#5}{#1#2}}%
    {\romannumeral0\xintipow {#4}{#1#2}}%
}%
\def\XINT@fpow@neg #1#2#3#4%
{%
    \expandafter\XINT@fpow@pos@A\expandafter
    {\the\numexpr -#1*#2\expandafter}\expandafter
    {\romannumeral0\xintipow {#3}{#1}}%
    {\romannumeral0\xintipow {#4}{#1}}%
}%
\def\XINT@fpow@pos@A #1#2#3%
{%
    \expandafter\XINT@fpow@pos@B\expandafter {#3}{#1}{#2}%
}%
\def\XINT@fpow@pos@B #1#2{\XINT@outfrac {#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintPrd}, \csh{xintProductExpr}}
%    \begin{macrocode}
\def\xintPrd {\romannumeral0\xintprd }%
\def\xintprd #1{\xintproductexpr #1\relax }%
\def\xintProductExpr {\romannumeral0\xintproductexpr }%
\def\xintproductexpr{\expandafter\expandafter\expandafter\XINT@fproductexpr }%
\def\XINT@fproductexpr {\XINT@fprod@loop@a {1[0]}}%
\def\XINT@fprod@loop@a #1#2%
{%
    \expandafter\expandafter\expandafter\XINT@fprod@loop@b #2\Z {#1}%
}%
\def\XINT@fprod@loop@b #1%
{%
    \xint@relax #1\XINT@fprod@finished\relax
    \XINT@fprod@loop@c #1%
}%
\def\XINT@fprod@loop@c #1\Z #2%
{%
    \expandafter\XINT@fprod@loop@a\expandafter{\romannumeral0\xintmul {#1}{#2}}%
}%
\def\XINT@fprod@finished #1\Z #2{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintDiv}}
%    \begin{macrocode}
\def\xintDiv {\romannumeral0\xintdiv }%
\def\xintdiv #1%
{%
    \expandafter\xint@fdiv\expandafter {\romannumeral0\XINT@infrac {#1}}%
}%
\def\xint@fdiv #1#2%
   {\expandafter\XINT@fdiv@A\romannumeral0\XINT@infrac {#2}#1}%
\def\XINT@fdiv@A #1#2#3#4#5#6%
{%
    \expandafter\XINT@fdiv@B
    \expandafter{\the\numexpr #4-#1\expandafter}%
    \expandafter{\romannumeral0\xintimul {#2}{#6}}%
    {\romannumeral0\xintimul {#3}{#5}}%
}%
\def\XINT@fdiv@B #1#2#3%
{%
    \expandafter\XINT@fdiv@C
    \expandafter{#3}{#1}{#2}%
}%
\def\XINT@fdiv@C #1#2{\XINT@outfrac {#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintCmp}}
%    \begin{macrocode}
\def\xintCmp {\romannumeral0\xintcmp }%
\def\xintcmp #1%
{%
    \expandafter\xint@fcmp\expandafter {\romannumeral0\XINT@infrac {#1}}%
}%
\def\xint@fcmp #1#2{\expandafter\XINT@fcmp@A\romannumeral0\XINT@infrac {#2}#1}%
\def\XINT@fcmp@A #1#2#3#4%
{%
    \ifnum #4 > #1
       \xint@afterfi {\XINT@fcmp@B {#1}}%
    \else
       \xint@afterfi {\XINT@fcmp@B {#4}}%
    \fi
    {#1}{#4}{#2}{#3}%
}%
\def\XINT@fcmp@B #1#2#3#4#5#6#7%
{%
    \xinticmp
    {\romannumeral0\xintimul {\xintDSH {\the\numexpr -#3+#1\relax}{#6}}{#5}}%
    {\romannumeral0\xintimul {#7}{\xintDSH {\the\numexpr -#2+#1\relax}{#4}}}%
}%
%    \end{macrocode}
% \subsection{\csh{xintMax}}
%    \begin{macrocode}
\def\xintMax {\romannumeral0\xintmax }%
\def\xintmax #1%
{%
    \expandafter\xint@fmax\expandafter {\romannumeral0\XINT@infrac {#1}}%
}%
\def\xint@fmax #1#2{\expandafter\XINT@outfrac
                    \romannumeral0\expandafter\XINT@fmax@A
                    \romannumeral0\XINT@infrac {#2}#1}%
\def\XINT@fmax@A #1#2#3#4#5#6%
{%
    \ifnum #4 > #1
       \xint@afterfi {\XINT@fmax@B {#1}}%
    \else
       \xint@afterfi {\XINT@fmax@B {#4}}%
    \fi
    {#1}{#4}{#2}{#3}{#5}{#6}{{#4}{#5}{#6}}{{#1}{#2}{#3}}%
}%
\def\XINT@fmax@B #1#2#3#4#5#6#7%
{%
    \expandafter\XINT@fmax@C\expandafter
    {\romannumeral0\xintimul {\xintDSH {\the\numexpr -#3+#1\relax}{#6}}{#5}}%
    {\romannumeral0\xintimul {#7}{\xintDSH {\the\numexpr -#2+#1\relax}{#4}}}%
}%
\def\XINT@fmax@C #1#2%
{%
    \expandafter\XINT@max@fork #2\Z #1\Z 
}%
%    \end{macrocode}
% \subsection{\csh{xintMin}}
%    \begin{macrocode}
\def\xintMin {\romannumeral0\xintmin }%
\def\xintmin #1%
{%
    \expandafter\xint@fmin\expandafter {\romannumeral0\XINT@infrac {#1}}%
}%
\def\xint@fmin #1#2%
{%
    \expandafter\XINT@outfrac
    \romannumeral0\expandafter\XINT@fmin@A
    \romannumeral0\XINT@infrac {#2}#1%
}%
\def\XINT@fmin@A #1#2#3#4#5#6%
{%
    \ifnum #4 > #1
       \xint@afterfi {\XINT@fmin@B {#1}}%
    \else
       \xint@afterfi {\XINT@fmin@B {#4}}%
    \fi
    {#1}{#4}{#2}{#3}{#5}{#6}{{#4}{#5}{#6}}{{#1}{#2}{#3}}%
}%
\def\XINT@fmin@B #1#2#3#4#5#6#7%
{%
    \expandafter\XINT@fmin@C\expandafter
    {\romannumeral0\xintimul {\xintDSH {\the\numexpr -#3+#1\relax}{#6}}{#5}}%
    {\romannumeral0\xintimul {#7}{\xintDSH {\the\numexpr -#2+#1\relax}{#4}}}%
}%
\def\XINT@fmin@C #1#2%
{%
    \expandafter\XINT@min@fork #2\Z #1\Z 
}%
%    \end{macrocode}
% \subsection{\csh{xintAbs}}
%    \begin{macrocode}
\def\xintAbs {\romannumeral0\xintabs }%
\def\xintabs #1%
{%
    \expandafter\xint@fabs\romannumeral0\XINT@infrac {#1}%
}%
\def\xint@fabs #1#2%
{%
    \expandafter\XINT@outfrac\expandafter 
    {\the\numexpr #1\expandafter}\expandafter
    {\romannumeral0\XINT@abs #2}%
}%
%    \end{macrocode}
% \subsection{\csh{xintOpp}}
%    \begin{macrocode}
\def\xintOpp {\romannumeral0\xintopp }%
\def\xintopp #1%
{%
    \expandafter\xint@fopp\romannumeral0\XINT@infrac {#1}%
}%
\def\xint@fopp #1#2%
{%
    \expandafter\XINT@outfrac\expandafter 
    {\the\numexpr #1\expandafter}\expandafter
    {\romannumeral0\XINT@opp #2}%
}%
%    \end{macrocode}
% \subsection{\csh{xintSgn}}
%    \begin{macrocode}
\def\xintSgn {\romannumeral0\xintsgn }%
\def\xintsgn #1%
{%
    \expandafter\xint@fsgn\romannumeral0\XINT@infrac {#1}%
}%
\def\xint@fsgn #1#2#3{\xintisgn {#2}}%
%    \end{macrocode}
% \subsection{\csh{xintGeq}}
%    \begin{macrocode}
\def\xintGeq {\romannumeral0\xintgeq }%
\def\xintgeq #1%
{%
    \expandafter\xint@xgeq\expandafter{\romannumeral0\xintnum {#1}}%
}%
\def\xint@xgeq #1#2%
{%
    \expandafter\XINT@geq@fork\romannumeral0\xintnum {#2}\Z #1\Z 
}%
%    \end{macrocode}
% \subsection{\csh{xintDivision},~\csh{xintQuo},~\csh{xintRem}}
%    \begin{macrocode}
\def\xintDivision {\romannumeral0\xintdivision }%
\def\xintdivision #1%
{%
    \expandafter\xint@xdivision\expandafter{\romannumeral0\xintnum {#1}}%
}%
\def\xint@xdivision #1#2%
{%
    \expandafter\XINT@div@fork\romannumeral0\xintnum {#2}\Z #1\Z 
}%
\def\xintQuo {\romannumeral0\xintquo }%
\def\xintRem {\romannumeral0\xintrem }%
\def\xintquo {\expandafter\xint@firstoftwo@andstop
               \romannumeral0\xintdivision }%
\def\xintrem {\expandafter\xint@secondoftwo@andstop
               \romannumeral0\xintdivision }%
%    \end{macrocode}
% \subsection{\csh{xintFDg},~\csh{xintLDg},~\csh{xintMON},~\csh{xintMMON},~\csh{xintOdd}}
%    \begin{macrocode}
\def\xintFDg {\romannumeral0\xintfdg }%
\def\xintfdg #1%
{%
    \expandafter\XINT@fdg\romannumeral0\xintnum {#1}\W\Z
}%
\def\xintLDg {\romannumeral0\xintldg }%
\def\xintldg #1%
{%
    \expandafter\XINT@ldg\expandafter{\romannumeral0\xintnum {#1}}%
}%
\def\xintMON {\romannumeral0\xintmon }%
\def\xintmon #1%
{%
    \ifodd\xintLDg {#1}
        \xint@afterfi{ -1}%
    \else
        \xint@afterfi{ 1}%
    \fi
}%
\def\xintMMON {\romannumeral0\xintmmon }%
\def\xintmmon #1%
{%
    \ifodd\xintLDg {#1}
        \xint@afterfi{ 1}%
    \else
        \xint@afterfi{ -1}%
    \fi
}%
\def\xintOdd {\romannumeral0\xintodd }%
\def\xintodd #1%
{%
    \ifodd\xintLDg{#1}
        \xint@afterfi{ 1}%
    \else
        \xint@afterfi{ 0}%
    \fi
}%
\XINT@frac@restorecatcodes@endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xintfrac>\relax
%\def<*xintseries>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xintfrac>
%<*xintseries>
% \section{Package \xintseriesname implementation}
% 
% The commenting is currently (\docdate) very sparse.
%
% \localtableofcontents
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
%
% The code for reload detection is copied from \textsc{Heiko
% Oberdiek}'s packages, and adapted here to check for previous
% loading of the \xintfracname package.
%
% The method for catcodes is slightly different, but still
% directly inspired by these packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \def\space { }%
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xintseries.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xintfrac.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintseries}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintseries.sty
      \ifx\w\relax % but xintfrac.sty not yet loaded.
         \y{xintseries}{Package xintfrac is required}%
         \y{xintseries}{Will try \string\input\space xintfrac.sty}%
         \def\z{\endgroup\input xintfrac.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xintfrac.sty not yet loaded.
            \y{xintseries}{Package xintfrac is required}%
            \y{xintseries}{Will try \string\RequirePackage{xintfrac}}%
            \def\z{\endgroup\RequirePackage{xintfrac}}%
          \fi
      \else
        \y{xintseries}{I was already loaded, aborting input}%
        \aftergroup\endinput
      \fi
    \fi
  \fi
\z%
%    \end{macrocode}
% \subsection{Confirmation of \xintfracname loading}
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \def\empty {}%
  \expandafter\let\expandafter\w\csname ver@xintfrac.sty\endcsname
  \ifx\w\relax % Plain TeX, user gave a file name at the prompt
      \y{xintseries}{Loading of package xintfrac failed, aborting input}%
      \aftergroup\endinput
  \fi
  \ifx\w\empty % LaTeX, user gave a file name at the prompt
      \y{xintseries}{Loading of package xintfrac failed, aborting input}%
      \aftergroup\endinput
  \fi
\endgroup%
%    \end{macrocode}
% \subsection{Catcodes}
%
% Perhaps catcodes have changed after the loading of \xintname and
% \xintfracname and prior to the current loading of \xintseriesname, 
% so we can not employ the |\XINT@restorecatcodes@endinput| in this style 
% file. But there is no problem using |\XINT@setcatcodes|.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \def\x
  {%
      \endgroup
      \edef\XINT@series@restorecatcodes@endinput
      {%
        \catcode93=\the\catcode93   % ]
        \catcode91=\the\catcode91   % [
        \catcode47=\the\catcode47   % /
        \catcode41=\the\catcode41   % )
        \catcode40=\the\catcode40   % (
        \catcode42=\the\catcode42   % *
        \catcode43=\the\catcode43   % +
        \catcode62=\the\catcode62   % >
        \catcode60=\the\catcode60   % <
        \catcode58=\the\catcode58   % :
        \catcode46=\the\catcode46   % .
        \catcode45=\the\catcode45   % -
        \catcode44=\the\catcode44   % ,
        \catcode35=\the\catcode35   % #
        \catcode64=\the\catcode64   % @
        \catcode125=\the\catcode125 % }
        \catcode123=\the\catcode123 % {
        \endlinechar=\the\endlinechar
        \catcode13=\the\catcode13   % ^^M
        \catcode32=\the\catcode32   % 
        \catcode61=\the\catcode61\relax   % =
        \noexpand\endinput
      }%
      \XINT@setcatcodes
      \catcode91=12 % [
      \catcode93=12 % ]
  }%
\x
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\begingroup
  \catcode58=12 % :
  \expandafter\ifx\csname ProvidesPackage\endcsname\relax
    \def\x#1#2#3[#4]{\endgroup
      \immediate\write-1{Package: #3 #4}%
      \xdef#1{#4}%
    }%
  \else
    \def\x#1#2[#3]{\endgroup
      #2[{#3}]%
      \ifx#1\@undefined
        \xdef#1{#3}%
      \fi
      \ifx#1\relax
        \xdef#1{#3}%
      \fi
    }%
  \fi
\expandafter\x\csname ver@xintseries.sty\endcsname
\ProvidesPackage{xintseries}%
  [2013/05/02 v1.05a Expandable partial sums with xint package (jfB)]%
%    \end{macrocode}
% \subsection{\csh{xintSeries}}
%    \begin{macrocode}
\def\xintSeries {\romannumeral0\xintseries }%
\def\xintseries #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@series@i
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@series@i #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@series@ii
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@series@ii #1#2#3%
{%
   \ifnum #2<#1
      \xint@afterfi { 0[0]}%
   \else
      \xint@afterfi {\XINT@series@loop {#1}{0}{#2}{#3}}%
   \fi
}%
\def\XINT@series@loop #1#2#3#4%
{%
    \ifnum #3>#1 \else \XINT@series@exit \fi
    \expandafter\XINT@series@loop\expandafter
    {\the\numexpr #1+1\expandafter }\expandafter
    {\romannumeral0\xintadd {#2}{#4{#1}}}%
    {#3}{#4}%
}%
\def\XINT@series@exit \fi #1#2#3#4#5#6#7#8%
{%
    \fi\xint@gobble@two #6%
}%
%    \end{macrocode}
% \subsection{\csh{xintiSeries}}
%    \begin{macrocode}
\def\xintiSeries {\romannumeral0\xintiseries }%
\def\xintiseries #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@iseries@i
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@iseries@i #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@iseries@ii
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@iseries@ii #1#2#3%
{%
   \ifnum #2<#1
      \xint@afterfi { 0}%
   \else
      \xint@afterfi {\XINT@iseries@loop {#1}{0}{#2}{#3}}%
   \fi
}%
\def\XINT@iseries@loop #1#2#3#4%
{%
    \ifnum #3>#1 \else \XINT@iseries@exit \fi
    \expandafter\XINT@iseries@loop\expandafter
    {\the\numexpr #1+1\expandafter }\expandafter
    {\romannumeral0\xintiadd {#2}{#4{#1}}}%
    {#3}{#4}%
}%
\def\XINT@iseries@exit \fi #1#2#3#4#5#6#7#8%
{%
    \fi\xint@gobble@two #6%
}%
%    \end{macrocode}
% \subsection{\csh{xintPowerSeries}}
% \begin{verbatim}
% The 1.03 version was very lame and created a build-up of denominators.
% The Horner scheme for polynomial evaluation is used in 1.04, this
% cures the denominator problem and drastically improves the efficiency
% of the macro.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintPowerSeries {\romannumeral0\xintpowerseries }%
\def\xintpowerseries #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@powseries@i
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@powseries@i #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@powseries@ii
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@powseries@ii #1#2#3#4%
{%
   \ifnum #2<#1
      \xint@afterfi { 0[0]}%
   \else
      \xint@afterfi
      {\XINT@powseries@loop@i {#3{#2}}{#1}{#2}{#3}{#4}}%
   \fi
}%
\def\XINT@powseries@loop@i #1#2#3#4#5%
{%
    \ifnum #3>#2 \else\XINT@powseries@exit@i\fi
    \expandafter\XINT@powseries@loop@ii\expandafter
    {\the\numexpr #3-1\expandafter}\expandafter
    {\romannumeral0\xintmul {#1}{#5}}{#2}{#4}{#5}%
}%
\def\XINT@powseries@loop@ii #1#2#3#4%
{%
   \expandafter\XINT@powseries@loop@i\expandafter
   {\romannumeral0\xintadd {#4{#1}}{#2}}{#3}{#1}{#4}%
}%
\def\XINT@powseries@exit@i\fi #1#2#3#4#5#6#7#8#9%
{%
    \fi \XINT@powseries@exit@ii  #6{#7}%
}%
\def\XINT@powseries@exit@ii #1#2#3#4#5#6%
{%
    \xintmul{\xintPow {#5}{#6}}{#4}%
}%
%    \end{macrocode}
% \subsection{\csh{xintPowerSeriesX}}
% \begin{verbatim}
% Same as \xintPowerSeries except for the initial expansion of the x parameter.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintPowerSeriesX {\romannumeral0\xintpowerseriesx }%
\def\xintpowerseriesx #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@powseriesx@i
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@powseriesx@i #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@powseriesx@ii
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@powseriesx@ii #1#2#3#4%
{%
   \ifnum #2<#1
      \xint@afterfi { 0[0]}%
   \else
      \xint@afterfi
      {\expandafter\expandafter\expandafter\XINT@powseriesx@pre 
       \expandafter\expandafter\expandafter {#4}{#1}{#2}{#3}}%
   \fi
}%
\def\XINT@powseriesx@pre #1#2#3#4%
{%
    \XINT@powseries@loop@i {#4{#3}}{#2}{#3}{#4}{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintRationalSeries}}
% \begin{verbatim}
% This computes F(a)+...+F(b) on the basis of the value of F(a) and the
% ratios F(n)/F(n-1). As in \xintPowerSeries we use an iterative scheme which
% has the great advantage to avoid denominator build-up. This makes exact
% computations possible with exponential type series, which would be completely
% inaccessible to \xintSeries. 
% #1=a, #2=b, #3=F(a), #4=ratio function
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintRationalSeries {\romannumeral0\xintratseries }%
\def\xintratseries #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@ratseries@i
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@ratseries@i #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@ratseries@ii
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@ratseries@ii #1#2#3#4%
{%
   \ifnum #2<#1
      \xint@afterfi { 0[0]}%
   \else
      \xint@afterfi
      {\XINT@ratseries@loop {#2}{1}{#1}{#4}{#3}}%
   \fi
}%
\def\XINT@ratseries@loop #1#2#3#4%
{%
    \ifnum #1>#3 \else\XINT@ratseries@exit@i\fi
    \expandafter\XINT@ratseries@loop\expandafter
    {\the\numexpr #1-1\expandafter}\expandafter
    {\romannumeral0\xintadd {1}{\xintMul {#2}{#4{#1}}}}{#3}{#4}%
}%
\def\XINT@ratseries@exit@i\fi #1#2#3#4#5#6#7#8%
{%
    \fi \XINT@ratseries@exit@ii  #6%
}%
\def\XINT@ratseries@exit@ii #1#2#3#4#5%
{%
    \XINT@ratseries@exit@iii #5%
}%
\def\XINT@ratseries@exit@iii #1#2#3#4%
{%
    \xintmul{#2}{#4}%
}%
%    \end{macrocode}
% \subsection{\csh{xintRationalSeriesX}}
% \begin{verbatim}
% a,b,initial,ratiofunction,x
% This computes F(a,x)+...+F(b,x) on the basis of the value of F(a,x) and the
% ratios F(n,x)/F(n-1,x). The argument x is first expanded and it is the value
% resulting from this which is used then throughout. The initial term F(a,x)
% must be defined as one-parameter macro which will be given x. 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintRationalSeriesX {\romannumeral0\xintratseriesx }%
\def\xintratseriesx #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@ratseriesx@i
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@ratseriesx@i #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@ratseriesx@ii
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@ratseriesx@ii #1#2#3#4#5%
{%
   \ifnum #2<#1
      \xint@afterfi { 0[0]}%
   \else
      \xint@afterfi
      {\expandafter\expandafter\expandafter\XINT@ratseriesx@pre 
       \expandafter\expandafter\expandafter {#5}{#2}{#1}{#4}{#3}}%
   \fi
}%
\def\XINT@ratseriesx@pre #1#2#3#4#5%
{%
    \XINT@ratseries@loop {#2}{1}{#3}{#4{#1}}{#5{#1}}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFxPtPowerSeries}}
% \begin{verbatim}
% I am not two happy with this piece of code. Will make it more economical
% another day. 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintFxPtPowerSeries {\romannumeral0\xintfxptpowerseries }%
\def\xintfxptpowerseries #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@fppowseries@i
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@fppowseries@i #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@fppowseries@ii
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@fppowseries@ii #1#2#3#4#5%
{%
   \ifnum #2<#1
      \xint@afterfi { 0}%
   \else
      \xint@afterfi
        {\expandafter\XINT@fppowseries@loop@pre\expandafter
           {\romannumeral0\xinttrunc {#5}{\xintPow {#4}{#1}}}%
          {#1}{#4}{#2}{#3}{#5}%
        }%
   \fi
}%
\def\XINT@fppowseries@loop@pre #1#2#3#4#5#6%
{%
    \ifnum #4>#2 \else\XINT@fppowseries@dont@i \fi
    \expandafter\XINT@fppowseries@loop@i\expandafter 
    {\the\numexpr #2+1\expandafter}\expandafter
    {\romannumeral0\xintitrunc {#6}{\xintMul {#5{#2}}{#1}}}%
    {#1}{#3}{#4}{#5}{#6}%
}%
\def\XINT@fppowseries@dont@i \fi\expandafter\XINT@fppowseries@loop@i
    {\fi \expandafter\XINT@fppowseries@dont@ii }%
\def\XINT@fppowseries@dont@ii #1#2#3#4#5#6#7{\xinttrunc {#7}{#2[-#7]}}%
\def\XINT@fppowseries@loop@i #1#2#3#4#5#6#7%
{%
    \ifnum #5>#1 \else \XINT@fppowseries@exit@i \fi
    \expandafter\XINT@fppowseries@loop@ii\expandafter
    {\romannumeral0\xinttrunc {#7}{\xintMul {#3}{#4}}}%
    {#1}{#4}{#2}{#5}{#6}{#7}%
}%
\def\XINT@fppowseries@loop@ii #1#2#3#4#5#6#7%
{%
    \expandafter\XINT@fppowseries@loop@i\expandafter
    {\the\numexpr #2+1\expandafter}\expandafter
    {\romannumeral0\xintiadd {#4}{\xintiTrunc {#7}{\xintMul {#6{#2}}{#1}}}}%
    {#1}{#3}{#5}{#6}{#7}%
}%
\def\XINT@fppowseries@exit@i\fi\expandafter\XINT@fppowseries@loop@ii
    {\fi \expandafter\XINT@fppowseries@exit@ii }%
\def\XINT@fppowseries@exit@ii #1#2#3#4#5#6#7%
{%
    \xinttrunc {#7}
    {\xintiAdd {#4}{\xintiTrunc {#7}{\xintMul {#6{#2}}{#1}}}[-#7]}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFxPtPowerSeriesX}}
% \begin{verbatim}
% a,b,coeff,x,D
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintFxPtPowerSeriesX {\romannumeral0\xintfxptpowerseriesx }%
\def\xintfxptpowerseriesx #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@fppowseriesx@i
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@fppowseriesx@i #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@fppowseriesx@ii
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@fppowseriesx@ii #1#2#3#4#5%
{%
   \ifnum #2<#1
      \xint@afterfi { 0}%
   \else
      \xint@afterfi
        {\expandafter\expandafter\expandafter
         \XINT@fppowseriesx@pre
         \expandafter\expandafter\expandafter
         {#4}{#1}{#2}{#3}{#5}%
        }%
   \fi
}%
\def\XINT@fppowseriesx@pre #1#2#3#4#5%
{%
    \expandafter\XINT@fppowseries@loop@pre\expandafter
       {\romannumeral0\xinttrunc {#5}{\xintPow {#1}{#2}}}%
       {#2}{#1}{#3}{#4}{#5}%
}%
\XINT@series@restorecatcodes@endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xintseries>\relax
%\def<*xintcfrac>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xintseries>
%<*xintcfrac>
% \section{Package \xintcfracname implementation}
% 
% The commenting is currently (\docdate) very sparse.
%
% \localtableofcontents
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
%
% The code for reload detection is copied from \textsc{Heiko
% Oberdiek}'s packages, and adapted here to check for previous
% loading of the \xintfracname package.
%
% The method for catcodes is slightly different, but still
% directly inspired by these packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \def\space { }%
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xintcfrac.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xintfrac.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintcfrac}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintcfrac.sty
      \ifx\w\relax % but xintfrac.sty not yet loaded.
         \y{xintcfrac}{Package xintfrac is required}%
         \y{xintcfrac}{Will try \string\input\space xintfrac.sty}%
         \def\z{\endgroup\input xintfrac.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xintfrac.sty not yet loaded.
            \y{xintcfrac}{Package xintfrac is required}%
            \y{xintcfrac}{Will try \string\RequirePackage{xintfrac}}%
            \def\z{\endgroup\RequirePackage{xintfrac}}%
          \fi
      \else
        \y{xintcfrac}{I was already loaded, aborting input}%
        \aftergroup\endinput
      \fi
    \fi
  \fi
\z%
%    \end{macrocode}
% \subsection{Confirmation of \xintfracname loading}
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \def\empty {}%
  \expandafter\let\expandafter\w\csname ver@xintfrac.sty\endcsname
  \ifx\w\relax % Plain TeX, user gave a file name at the prompt
      \y{xintcfrac}{Loading of package xintfrac failed, aborting input}%
      \aftergroup\endinput
  \fi
  \ifx\w\empty % LaTeX, user gave a file name at the prompt
      \y{xintcfrac}{Loading of package xintfrac failed, aborting input}%
      \aftergroup\endinput
  \fi
\endgroup%
%    \end{macrocode}
% \subsection{Catcodes}
%
% Perhaps catcodes have changed after the loading of \xintname and
% \xintfracname and prior to the current loading of \xintcfracname, 
% so we can not employ the |\XINT@restorecatcodes@endinput| in this style 
% file. But there is no problem using |\XINT@setcatcodes|.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \def\x
  {%
      \endgroup
      \edef\XINT@cfrac@restorecatcodes@endinput
      {%
        \catcode93=\the\catcode93   % ]
        \catcode91=\the\catcode91   % [
        \catcode47=\the\catcode47   % /
        \catcode41=\the\catcode41   % )
        \catcode40=\the\catcode40   % (
        \catcode42=\the\catcode42   % *
        \catcode43=\the\catcode43   % +
        \catcode62=\the\catcode62   % >
        \catcode60=\the\catcode60   % <
        \catcode58=\the\catcode58   % :
        \catcode46=\the\catcode46   % .
        \catcode45=\the\catcode45   % -
        \catcode44=\the\catcode44   % ,
        \catcode35=\the\catcode35   % #
        \catcode64=\the\catcode64   % @
        \catcode125=\the\catcode125 % }
        \catcode123=\the\catcode123 % {
        \endlinechar=\the\endlinechar
        \catcode13=\the\catcode13   % ^^M
        \catcode32=\the\catcode32   % 
        \catcode61=\the\catcode61\relax   % =
        \noexpand\endinput
      }%
      \XINT@setcatcodes
      \catcode91=12 % [
      \catcode93=12 % ]
  }%
\x
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\begingroup
  \catcode58=12 % :
  \expandafter\ifx\csname ProvidesPackage\endcsname\relax
    \def\x#1#2#3[#4]{\endgroup
      \immediate\write-1{Package: #3 #4}%
      \xdef#1{#4}%
    }%
  \else
    \def\x#1#2[#3]{\endgroup
      #2[{#3}]%
      \ifx#1\@undefined
        \xdef#1{#3}%
      \fi
      \ifx#1\relax
        \xdef#1{#3}%
      \fi
    }%
  \fi
\expandafter\x\csname ver@xintcfrac.sty\endcsname
\ProvidesPackage{xintcfrac}%
  [2013/05/02 v1.05a Expandable continued fractions with xint package (jfB)]%
%    \end{macrocode}
% \subsection{\csh{xintCFrac}}
%    \begin{macrocode}
\def\xintCFrac {\romannumeral0\xintcfrac }%
\def\xintcfrac #1%
{%
    \XINT@cfrac@opt@a #1\Z
}%
\def\XINT@cfrac@opt@a #1%
{% 
    \ifx#1[\XINT@cfrac@opt@b\fi \XINT@cfrac@noopt #1%
}%
\def\XINT@cfrac@noopt #1\Z
{%
    \expandafter\XINT@cfrac@A\romannumeral0\xintraw {#1}\Z
    \relax\relax
}%
\def\XINT@cfrac@opt@b\fi\XINT@cfrac@noopt [\Z #1]%
{%
    \fi\csname XINT@cfrac@opt#1\endcsname
}%
\def\XINT@cfrac@optl #1%
{%
    \expandafter\XINT@cfrac@A\romannumeral0\xintraw {#1}\Z
    \relax\hfill
}%
\def\XINT@cfrac@optc #1%
{%
    \expandafter\XINT@cfrac@A\romannumeral0\xintraw {#1}\Z
    \relax\relax
}%
\def\XINT@cfrac@optr #1%
{%
    \expandafter\XINT@cfrac@A\romannumeral0\xintraw {#1}\Z
    \hfill\relax
}%
\def\XINT@cfrac@A #1/#2\Z
{%
    \expandafter\XINT@cfrac@B\romannumeral0\xintidivision {#1}{#2}{#2}%
}%
\def\XINT@cfrac@B #1#2%
{%
    \XINT@cfrac@C #2\Z {#1}%
}%
\def\XINT@cfrac@C #1%
{%
    \xint@zero #1\XINT@cfrac@integer 0\XINT@cfrac@D #1%
}%
\def\XINT@cfrac@integer 0\XINT@cfrac@D 0#1\Z #2#3#4#5{ #2}%
\def\XINT@cfrac@D #1\Z #2#3{\XINT@cfrac@loop@a {#1}{#3}{#1}{{#2}}}%  
\def\XINT@cfrac@loop@a 
{%
    \expandafter\XINT@cfrac@loop@d\romannumeral0\XINT@div@prepare
}%
\def\XINT@cfrac@loop@d #1#2%
{%
    \XINT@cfrac@loop@e #2.{#1}%
}%
\def\XINT@cfrac@loop@e #1%
{%
    \xint@zero #1\xint@cfrac@loop@exit0\XINT@cfrac@loop@f #1%
}%
\def\XINT@cfrac@loop@f #1.#2#3#4%
{%
    \XINT@cfrac@loop@a {#1}{#3}{#1}{{#2}#4}%
}%
\def\xint@cfrac@loop@exit0\XINT@cfrac@loop@f #1.#2#3#4#5#6%
   {\XINT@cfrac@T #5#6{#2}#4\Z }%
\def\XINT@cfrac@T #1#2#3#4%
{%
    \xint@z #4\XINT@cfrac@end\Z\XINT@cfrac@T #1#2{#4+\cfrac{#11#2}{#3}}%
}%
\def\XINT@cfrac@end\Z\XINT@cfrac@T #1#2#3%
{%
    \XINT@cfrac@@end #3%
}%
\def\XINT@cfrac@@end \Z+\cfrac#1#2{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintGCFrac}}
%    \begin{macrocode}
\def\xintGCFrac {\romannumeral0\xintgcfrac }%
\def\xintgcfrac #1%
{%
    \XINT@gcfrac@opt@a #1\Z
}%
\def\XINT@gcfrac@opt@a #1%
{% 
    \ifx#1[\XINT@gcfrac@opt@b\fi \XINT@gcfrac@noopt #1%
}%
\def\XINT@gcfrac@noopt #1\Z
{%
    \XINT@gcfrac #1+\W/\relax\relax
}%
\def\XINT@gcfrac@opt@b\fi\XINT@gcfrac@noopt [\Z #1]%
{%
    \fi\csname XINT@gcfrac@opt#1\endcsname
}%
\def\XINT@gcfrac@optl #1%
{%
    \XINT@gcfrac #1+\W/\relax\hfill
}%
\def\XINT@gcfrac@optc #1%
{%
    \XINT@gcfrac #1+\W/\relax\relax
}%
\def\XINT@gcfrac@optr #1%
{%
    \XINT@gcfrac #1+\W/\hfill\relax
}%
\def\XINT@gcfrac 
{%
    \expandafter\expandafter\expandafter\XINT@gcfrac@enter
}%
\def\XINT@gcfrac@enter {\XINT@gcfrac@loop {}}%
\def\XINT@gcfrac@loop #1#2+#3/%
{%
    \xint@w #3\XINT@gcfrac@endloop\W\XINT@gcfrac@loop {{#3}{#2}#1}%
}%
\def\XINT@gcfrac@endloop\W\XINT@gcfrac@loop #1#2#3%
{%
    \XINT@gcfrac@T #2#3#1\Z\Z
}%
\def\XINT@gcfrac@T #1#2#3#4{\XINT@gcfrac@U #1#2{\xintFrac{#4}}}%
\def\XINT@gcfrac@U #1#2#3#4#5%
{%
    \xint@z #5\XINT@gcfrac@end\Z\XINT@gcfrac@U 
              #1#2{\xintFrac{#5}%
               \ifcase\xintSgn{#4}
               +\or+\else-\fi
               \cfrac{#1\xintFrac{\xintAbs{#4}}#2}{#3}}%
}%
\def\XINT@gcfrac@end\Z\XINT@gcfrac@U #1#2#3%
{%
    \XINT@gcfrac@@end #3%
}%
\def\XINT@gcfrac@@end #1\cfrac#2#3{ #3}%
%    \end{macrocode}
% \subsection{\csh{xintGCtoGCx}}
%    \begin{macrocode}
\def\xintGCtoGCx {\romannumeral0\xintgctogcx }%
\def\xintgctogcx #1#2#3%
{%
    \expandafter\expandafter\expandafter\XINT@gctgcx@start
    \expandafter\expandafter\expandafter {#3}{#1}{#2}%
}%
\def\XINT@gctgcx@start #1#2#3{\XINT@gctgcx@loop@a {}{#2}{#3}#1+\W/}%
\def\XINT@gctgcx@loop@a #1#2#3#4+#5/%
{%
    \xint@w #5\XINT@gctgcx@end\W
    \XINT@gctgcx@loop@b {#1{#4}}{#2{#5}#3}{#2}{#3}%
}%
\def\XINT@gctgcx@loop@b #1#2%
{%
    \XINT@gctgcx@loop@a {#1#2}%
}%  
\def\XINT@gctgcx@end\W\XINT@gctgcx@loop@b #1#2#3#4{ #1}%
%    \end{macrocode}
% \subsection{\csh{xintFtoCs}}
%    \begin{macrocode}
\def\xintFtoCs {\romannumeral0\xintftocs }%
\def\xintftocs #1%
{%
    \expandafter\XINT@ftc@A\romannumeral0\xintraw {#1}\Z
}%
\def\XINT@ftc@A #1/#2\Z
{%
    \expandafter\XINT@ftc@B\romannumeral0\xintidivision {#1}{#2}{#2}%
}%
\def\XINT@ftc@B #1#2%
{%
    \XINT@ftc@C #2.{#1}%
}%
\def\XINT@ftc@C #1%
{%
    \xint@zero #1\XINT@ftc@integer 0\XINT@ftc@D #1%
}%
\def\XINT@ftc@integer 0\XINT@ftc@D 0#1.#2#3{ #2}%
\def\XINT@ftc@D #1.#2#3{\XINT@ftc@loop@a {#1}{#3}{#1}{#2,}}%  
\def\XINT@ftc@loop@a 
{%
    \expandafter\XINT@ftc@loop@d\romannumeral0\XINT@div@prepare
}%
\def\XINT@ftc@loop@d #1#2%
{%
    \XINT@ftc@loop@e #2.{#1}%
}%
\def\XINT@ftc@loop@e #1%
{%
    \xint@zero #1\xint@ftc@loop@exit0\XINT@ftc@loop@f #1%
}%
\def\XINT@ftc@loop@f #1.#2#3#4%
{%
    \XINT@ftc@loop@a {#1}{#3}{#1}{#4#2,}%
}%
\def\xint@ftc@loop@exit0\XINT@ftc@loop@f #1.#2#3#4{ #4#2}%
%    \end{macrocode}
% \subsection{\csh{xintFtoCx}}
%    \begin{macrocode}
\def\xintFtoCx {\romannumeral0\xintftocx }%
\def\xintftocx #1#2%
{%
    \expandafter\XINT@ftcx@A\romannumeral0\xintraw {#2}\Z {#1}%
}%
\def\XINT@ftcx@A #1/#2\Z
{%
    \expandafter\XINT@ftcx@B\romannumeral0\xintidivision {#1}{#2}{#2}%
}%
\def\XINT@ftcx@B #1#2%
{%
    \XINT@ftcx@C #2.{#1}%
}%
\def\XINT@ftcx@C #1%
{%
    \xint@zero #1\XINT@ftcx@integer 0\XINT@ftcx@D #1%
}%
\def\XINT@ftcx@integer 0\XINT@ftcx@D 0#1.#2#3#4{ #2}%
\def\XINT@ftcx@D #1.#2#3#4{\XINT@ftcx@loop@a {#1}{#3}{#1}{#2#4}{#4}}%  
\def\XINT@ftcx@loop@a 
{%
    \expandafter\XINT@ftcx@loop@d\romannumeral0\XINT@div@prepare
}%
\def\XINT@ftcx@loop@d #1#2%
{%
    \XINT@ftcx@loop@e #2.{#1}%
}%
\def\XINT@ftcx@loop@e #1%
{%
    \xint@zero #1\xint@ftcx@loop@exit0\XINT@ftcx@loop@f #1%
}%
\def\XINT@ftcx@loop@f #1.#2#3#4#5%
{%
    \XINT@ftcx@loop@a {#1}{#3}{#1}{#4{#2}#5}{#5}%
}%
\def\xint@ftcx@loop@exit0\XINT@ftcx@loop@f #1.#2#3#4#5{ #4{#2}}%
%    \end{macrocode}
% \subsection{\csh{xintFtoGC}}
%    \begin{macrocode}
\def\xintFtoGC {\romannumeral0\xintftogc }%
\def\xintftogc {\xintftocx {+1/}}%
%    \end{macrocode}
% \subsection{\csh{xintFtoCC}}
%    \begin{macrocode}
\def\xintFtoCC {\romannumeral0\xintftocc }%
\def\xintftocc #1%
{%
    \expandafter\XINT@ftcc@A\expandafter {\romannumeral0\xintraw {#1}}%
}%
\def\XINT@ftcc@A #1%
{%
    \expandafter\XINT@ftcc@B
    \romannumeral0\xintraw {\xintAdd {1/2[0]}{#1[0]}}\Z {#1[0]}%
}%
\def\XINT@ftcc@B #1/#2\Z 
{%
    \expandafter\XINT@ftcc@C\expandafter {\romannumeral0\xintiquo {#1}{#2}}%
}%
\def\XINT@ftcc@C #1#2%
{%
    \expandafter\XINT@ftcc@D\romannumeral0\xintsub {#2}{#1}\Z {#1}%
}%
\def\XINT@ftcc@D #1%
{%
    \xint@UDzerominusfork
      #1-\dummy \XINT@ftcc@integer
      0#1\dummy \XINT@ftcc@En
       0-\dummy {\XINT@ftcc@Ep #1}%
    \xint@UDkrof
}%
\def\XINT@ftcc@Ep #1\Z #2%
{%
    \expandafter\XINT@ftcc@loop@a\expandafter
    {\romannumeral0\xintdiv {1[0]}{#1}}{#2+1/}%
}%
\def\XINT@ftcc@En #1\Z #2%
{%
    \expandafter\XINT@ftcc@loop@a\expandafter
    {\romannumeral0\xintdiv {1[0]}{#1}}{#2+-1/}%
}%
\def\XINT@ftcc@integer #1\Z #2{ #2}%
\def\XINT@ftcc@loop@a #1%
{%
    \expandafter\XINT@ftcc@loop@b
    \romannumeral0\xintraw {\xintAdd {1/2[0]}{#1}}\Z {#1}%
}%
\def\XINT@ftcc@loop@b #1/#2\Z
{%
    \expandafter\XINT@ftcc@loop@c\expandafter 
    {\romannumeral0\xintiquo {#1}{#2}}%
}%
\def\XINT@ftcc@loop@c #1#2%
{%
    \expandafter\XINT@ftcc@loop@d
    \romannumeral0\xintsub {#2}{#1[0]}\Z {#1}%
}%
\def\XINT@ftcc@loop@d #1%
{%
    \xint@UDzerominusfork
      #1-\dummy \XINT@ftcc@end
      0#1\dummy \XINT@ftcc@loop@N
       0-\dummy {\XINT@ftcc@loop@P #1}%
    \xint@UDkrof
}%
\def\XINT@ftcc@end #1\Z #2#3{ #3#2}%
\def\XINT@ftcc@loop@P #1\Z #2#3%
{%
    \expandafter\XINT@ftcc@loop@a\expandafter
    {\romannumeral0\xintdiv {1[0]}{#1}}{#3#2+1/}%
}%
\def\XINT@ftcc@loop@N #1\Z #2#3%
{%
    \expandafter\XINT@ftcc@loop@a\expandafter
    {\romannumeral0\xintdiv {1[0]}{#1}}{#3#2+-1/}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFtoCv}}
%    \begin{macrocode}
\def\xintFtoCv {\romannumeral0\xintftocv }%
\def\xintftocv #1%
{%
    \xinticstocv {\xintFtoCs {#1}}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFtoCCv}}
%    \begin{macrocode}
\def\xintFtoCCv {\romannumeral0\xintftoccv }%
\def\xintftoccv #1%
{%
    \xintigctocv {\xintFtoCC {#1}}%
}%
%    \end{macrocode}
% \subsection{\csh{xintCstoF}}
%    \begin{macrocode}
\def\xintCstoF {\romannumeral0\xintcstof }%
\def\xintcstof #1%
{%
    \expandafter\expandafter\expandafter\XINT@cstf@prep #1,\W,%
}%
\def\XINT@cstf@prep
{%
    \XINT@cstf@loop@a 1001%
}%
\def\XINT@cstf@loop@a #1#2#3#4#5,%
{%
    \xint@w #5\XINT@cstf@end\W\expandafter\XINT@cstf@loop@b
    \romannumeral0\xintraw {#5}.{#1}{#2}{#3}{#4}%
}%
\def\XINT@cstf@loop@b #1/#2.#3#4#5#6%
{%
    \expandafter\XINT@cstf@loop@c\expandafter
    {\romannumeral0\XINT@mul@fork #2\Z #4\Z }%
    {\romannumeral0\XINT@mul@fork #2\Z #3\Z }%
    {\romannumeral0\xintiadd {\XINT@Mul {#2}{#6}}{\XINT@Mul {#1}{#4}}}%
    {\romannumeral0\xintiadd {\XINT@Mul {#2}{#5}}{\XINT@Mul {#1}{#3}}}%
}%
\def\XINT@cstf@loop@c #1#2%
{%
    \expandafter\XINT@cstf@loop@d\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT@cstf@loop@d #1#2%
{%
    \expandafter\XINT@cstf@loop@e\expandafter {\expandafter{#2}#1}%
}%
\def\XINT@cstf@loop@e #1#2%
{%
    \expandafter\XINT@cstf@loop@a\expandafter{#2}#1%
}%
\def\XINT@cstf@end #1.#2#3#4#5{\xintraw {#2/#3}[0]}%
%    \end{macrocode}
% \subsection{\csh{xintiCstoF}}
%    \begin{macrocode}
\def\xintiCstoF {\romannumeral0\xinticstof }%
\def\xinticstof #1%
{%
    \expandafter\expandafter\expandafter\XINT@icstf@prep #1,\W,%
}%
\def\XINT@icstf@prep
{%
    \XINT@icstf@loop@a 1001%
}%
\def\XINT@icstf@loop@a #1#2#3#4#5,%
{%
    \xint@w #5\XINT@icstf@end\W
    \expandafter\expandafter\expandafter
    \XINT@icstf@loop@b #5.{#1}{#2}{#3}{#4}%
}%
\def\XINT@icstf@loop@b #1.#2#3#4#5%
{%
    \expandafter\XINT@icstf@loop@c\expandafter
    {\romannumeral0\xintiadd {#5}{\XINT@Mul {#1}{#3}}}%
    {\romannumeral0\xintiadd {#4}{\XINT@Mul {#1}{#2}}}%
    {#2}{#3}%
}%
\def\XINT@icstf@loop@c #1#2%
{%
    \expandafter\XINT@icstf@loop@a\expandafter {#2}{#1}%
}%
\def\XINT@icstf@end#1.#2#3#4#5{\xintraw {#2/#3}[0]}%
%    \end{macrocode}
% \subsection{\csh{xintGCtoF}}
%    \begin{macrocode}
\def\xintGCtoF {\romannumeral0\xintgctof }%
\def\xintgctof #1%
{%
    \expandafter\expandafter\expandafter\XINT@gctf@prep #1+\W/%
}%
\def\XINT@gctf@prep
{%
    \XINT@gctf@loop@a 1001%
}%
\def\XINT@gctf@loop@a #1#2#3#4#5+%
{%
    \expandafter\XINT@gctf@loop@b
    \romannumeral0\xintraw {#5}.{#1}{#2}{#3}{#4}%
}%
\def\XINT@gctf@loop@b #1/#2.#3#4#5#6%
{%
    \expandafter\XINT@gctf@loop@c\expandafter
    {\romannumeral0\XINT@mul@fork #2\Z #4\Z }%
    {\romannumeral0\XINT@mul@fork #2\Z #3\Z }%
    {\romannumeral0\xintiadd {\XINT@Mul {#2}{#6}}{\XINT@Mul {#1}{#4}}}%
    {\romannumeral0\xintiadd {\XINT@Mul {#2}{#5}}{\XINT@Mul {#1}{#3}}}%
}%
\def\XINT@gctf@loop@c #1#2%
{%
    \expandafter\XINT@gctf@loop@d\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT@gctf@loop@d #1#2%
{%
    \expandafter\XINT@gctf@loop@e\expandafter {\expandafter{#2}#1}%
}%
\def\XINT@gctf@loop@e #1#2%
{%
    \expandafter\XINT@gctf@loop@f\expandafter {\expandafter{#2}#1}%
}%
\def\XINT@gctf@loop@f #1#2/%
{%
    \xint@w #2\XINT@gctf@end\W\expandafter\XINT@gctf@loop@g 
    \romannumeral0\xintraw {#2}.#1%
}%
\def\XINT@gctf@loop@g #1/#2.#3#4#5#6%
{%
    \expandafter\XINT@gctf@loop@h\expandafter
    {\romannumeral0\XINT@mul@fork #1\Z #6\Z }%
    {\romannumeral0\XINT@mul@fork #1\Z #5\Z }%
    {\romannumeral0\XINT@mul@fork #2\Z #4\Z }%
    {\romannumeral0\XINT@mul@fork #2\Z #3\Z }%
}%
\def\XINT@gctf@loop@h #1#2%
{%
    \expandafter\XINT@gctf@loop@i\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT@gctf@loop@i #1#2%
{%
    \expandafter\XINT@gctf@loop@j\expandafter {\expandafter{#2}#1}%
}%
\def\XINT@gctf@loop@j #1#2%
{%
    \expandafter\XINT@gctf@loop@a\expandafter {#2}#1%
}%
\def\XINT@gctf@end #1.#2#3#4#5{\xintraw {#2/#3}[0]}%
%    \end{macrocode}
% \subsection{\csh{xintiGCtoF}}
%    \begin{macrocode}
\def\xintiGCtoF {\romannumeral0\xintigctof }%
\def\xintigctof #1%
{%
    \expandafter\expandafter\expandafter\XINT@igctf@prep #1+\W/%
}%
\def\XINT@igctf@prep
{%
    \XINT@igctf@loop@a 1001%
}%
\def\XINT@igctf@loop@a #1#2#3#4#5+%
{%
    \expandafter\expandafter\expandafter\XINT@igctf@loop@b
    #5.{#1}{#2}{#3}{#4}%
}%
\def\XINT@igctf@loop@b #1.#2#3#4#5%
{%
    \expandafter\XINT@igctf@loop@c\expandafter
    {\romannumeral0\xintiadd {#5}{\XINT@Mul {#1}{#3}}}%
    {\romannumeral0\xintiadd {#4}{\XINT@Mul {#1}{#2}}}%
    {#2}{#3}%
}%
\def\XINT@igctf@loop@c #1#2%
{%
    \expandafter\XINT@igctf@loop@f\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT@igctf@loop@f #1#2#3#4/%
{%
    \xint@w #4\XINT@igctf@end\W
    \expandafter\expandafter\expandafter\XINT@igctf@loop@g 
    #4.{#2}{#3}#1%
}%
\def\XINT@igctf@loop@g #1.#2#3%
{%
    \expandafter\XINT@igctf@loop@h\expandafter
    {\romannumeral0\XINT@mul@fork #1\Z #3\Z }%
    {\romannumeral0\XINT@mul@fork #1\Z #2\Z }%
}%
\def\XINT@igctf@loop@h #1#2%
{%
    \expandafter\XINT@igctf@loop@i\expandafter {#2}{#1}%
}%
\def\XINT@igctf@loop@i #1#2#3#4%
{%
    \XINT@igctf@loop@a {#3}{#4}{#1}{#2}%
}%
\def\XINT@igctf@end #1.#2#3#4#5{\xintraw {#4/#5}[0]}%
%    \end{macrocode}
% \subsection{\csh{xintCstoCv}}
%    \begin{macrocode}
\def\xintCstoCv {\romannumeral0\xintcstocv }%
\def\xintcstocv #1%
{%
    \expandafter\expandafter\expandafter\XINT@cstcv@prep #1,\W,%
}%
\def\XINT@cstcv@prep
{%
    \XINT@cstcv@loop@a {}1001%
}%
\def\XINT@cstcv@loop@a #1#2#3#4#5#6,%
{%
    \xint@w #6\XINT@cstcv@end\W
    \expandafter\XINT@cstcv@loop@b
    \romannumeral0\xintraw {#6}.{#2}{#3}{#4}{#5}{#1}%
}%
\def\XINT@cstcv@loop@b #1/#2.#3#4#5#6%
{%
    \expandafter\XINT@cstcv@loop@c\expandafter
    {\romannumeral0\XINT@mul@fork #2\Z #4\Z }%
    {\romannumeral0\XINT@mul@fork #2\Z #3\Z }%
    {\romannumeral0\xintiadd {\XINT@Mul {#2}{#6}}{\XINT@Mul {#1}{#4}}}%
    {\romannumeral0\xintiadd {\XINT@Mul {#2}{#5}}{\XINT@Mul {#1}{#3}}}%
}%
\def\XINT@cstcv@loop@c #1#2%
{%
    \expandafter\XINT@cstcv@loop@d\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT@cstcv@loop@d #1#2%
{%
    \expandafter\XINT@cstcv@loop@e\expandafter {\expandafter{#2}#1}%
}%
\def\XINT@cstcv@loop@e #1#2%
{%
    \expandafter\XINT@cstcv@loop@f\expandafter{#2}#1%
}%
\def\XINT@cstcv@loop@f #1#2#3#4#5%
{%
    \expandafter\XINT@cstcv@loop@g\expandafter 
    {\romannumeral0\xintraw {#1/#2}}{#5}{#1}{#2}{#3}{#4}%
}%
\def\XINT@cstcv@loop@g #1#2{\XINT@cstcv@loop@a {#2{#1[0]}}}%
\def\XINT@cstcv@end #1.#2#3#4#5#6{ #6}%
%    \end{macrocode}
% \subsection{\csh{xintiCstoCv}}
%    \begin{macrocode}
\def\xintiCstoCv {\romannumeral0\xinticstocv }%
\def\xinticstocv #1%
{%
    \expandafter\expandafter\expandafter\XINT@icstcv@prep #1,\W,%
}%
\def\XINT@icstcv@prep
{%
    \XINT@icstcv@loop@a {}1001%
}%
\def\XINT@icstcv@loop@a #1#2#3#4#5#6,%
{%
    \xint@w #6\XINT@icstcv@end\W
    \expandafter\expandafter\expandafter
    \XINT@icstcv@loop@b #6.{#2}{#3}{#4}{#5}{#1}%
}%
\def\XINT@icstcv@loop@b #1.#2#3#4#5%
{%
    \expandafter\XINT@icstcv@loop@c\expandafter
    {\romannumeral0\xintiadd {#5}{\XINT@Mul {#1}{#3}}}%
    {\romannumeral0\xintiadd {#4}{\XINT@Mul {#1}{#2}}}%
    {{#2}{#3}}%
}%
\def\XINT@icstcv@loop@c #1#2%
{%
    \expandafter\XINT@icstcv@loop@d\expandafter {#2}{#1}%
}%
\def\XINT@icstcv@loop@d #1#2%
{%
    \expandafter\XINT@icstcv@loop@e\expandafter
    {\romannumeral0\xintraw {#1/#2}}{{#1}{#2}}%
}%
\def\XINT@icstcv@loop@e #1#2#3#4{\XINT@icstcv@loop@a {#4{#1[0]}}#2#3}%
\def\XINT@icstcv@end #1.#2#3#4#5#6{ #6}%
%    \end{macrocode}
% \subsection{\csh{xintGCtoCv}}
%    \begin{macrocode}
\def\xintGCtoCv {\romannumeral0\xintgctocv }%
\def\xintgctocv #1%
{%
    \expandafter\expandafter\expandafter\XINT@gctcv@prep #1+\W/%
}%
\def\XINT@gctcv@prep
{%
    \XINT@gctcv@loop@a {}1001%
}%
\def\XINT@gctcv@loop@a #1#2#3#4#5#6+%
{%
    \expandafter\XINT@gctcv@loop@b
    \romannumeral0\xintraw {#6}.{#2}{#3}{#4}{#5}{#1}%
}%
\def\XINT@gctcv@loop@b #1/#2.#3#4#5#6%
{%
    \expandafter\XINT@gctcv@loop@c\expandafter
    {\romannumeral0\XINT@mul@fork #2\Z #4\Z }%
    {\romannumeral0\XINT@mul@fork #2\Z #3\Z }%
    {\romannumeral0\xintiadd {\XINT@Mul {#2}{#6}}{\XINT@Mul {#1}{#4}}}%
    {\romannumeral0\xintiadd {\XINT@Mul {#2}{#5}}{\XINT@Mul {#1}{#3}}}%
}%
\def\XINT@gctcv@loop@c #1#2%
{%
    \expandafter\XINT@gctcv@loop@d\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT@gctcv@loop@d #1#2%
{%
    \expandafter\XINT@gctcv@loop@e\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT@gctcv@loop@e #1#2%
{%
    \expandafter\XINT@gctcv@loop@f\expandafter {#2}#1%
}%
\def\XINT@gctcv@loop@f #1#2%
{%
    \expandafter\XINT@gctcv@loop@g\expandafter
    {\romannumeral0\xintraw {#1/#2}}{{#1}{#2}}%
}%
\def\XINT@gctcv@loop@g #1#2#3#4%
{%
    \XINT@gctcv@loop@h {#4{#1[0]}}{#2#3}%
}%
\def\XINT@gctcv@loop@h #1#2#3/%
{%
    \xint@w #3\XINT@gctcv@end\W\expandafter\XINT@gctcv@loop@i
    \romannumeral0\xintraw {#3}.#2{#1}%
}%
\def\XINT@gctcv@loop@i #1/#2.#3#4#5#6%
{%
    \expandafter\XINT@gctcv@loop@j\expandafter
    {\romannumeral0\XINT@mul@fork #1\Z #6\Z }%
    {\romannumeral0\XINT@mul@fork #1\Z #5\Z }%
    {\romannumeral0\XINT@mul@fork #2\Z #4\Z }%
    {\romannumeral0\XINT@mul@fork #2\Z #3\Z }%
}%
\def\XINT@gctcv@loop@j #1#2%
{%
    \expandafter\XINT@gctcv@loop@k\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT@gctcv@loop@k #1#2%
{%
    \expandafter\XINT@gctcv@loop@l\expandafter {\expandafter{#2}#1}%
}%
\def\XINT@gctcv@loop@l #1#2%
{%
    \expandafter\XINT@gctcv@loop@m\expandafter {\expandafter{#2}#1}%
}%
\def\XINT@gctcv@loop@m #1#2{\XINT@gctcv@loop@a {#2}#1}%
\def\XINT@gctcv@end #1.#2#3#4#5#6{ #6}%
%    \end{macrocode}
% \subsection{\csh{xintiGCtoCv}}
%    \begin{macrocode}
\def\xintiGCtoCv {\romannumeral0\xintigctocv }%
\def\xintigctocv #1%
{%
    \expandafter\expandafter\expandafter\XINT@igctcv@prep #1+\W/%
}%
\def\XINT@igctcv@prep
{%
    \XINT@igctcv@loop@a {}1001%
}%
\def\XINT@igctcv@loop@a #1#2#3#4#5#6+%
{%
    \expandafter\expandafter\expandafter\XINT@igctcv@loop@b
    #6.{#2}{#3}{#4}{#5}{#1}%
}%
\def\XINT@igctcv@loop@b #1.#2#3#4#5%
{%
    \expandafter\XINT@igctcv@loop@c\expandafter
    {\romannumeral0\xintiadd {#5}{\XINT@Mul {#1}{#3}}}%
    {\romannumeral0\xintiadd {#4}{\XINT@Mul {#1}{#2}}}%
    {{#2}{#3}}%
}%
\def\XINT@igctcv@loop@c #1#2%
{%
    \expandafter\XINT@igctcv@loop@f\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT@igctcv@loop@f #1#2#3#4/%
{%
    \xint@w #4\XINT@igctcv@end@a\W
    \expandafter\expandafter\expandafter\XINT@igctcv@loop@g 
    #4.#1#2{#3}%
}%
\def\XINT@igctcv@loop@g #1.#2#3#4#5%
{%
    \expandafter\XINT@igctcv@loop@h\expandafter
    {\romannumeral0\XINT@mul@fork #1\Z #5\Z }%
    {\romannumeral0\XINT@mul@fork #1\Z #4\Z }%
    {{#2}{#3}}%
}%
\def\XINT@igctcv@loop@h #1#2%
{%
    \expandafter\XINT@igctcv@loop@i\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT@igctcv@loop@i #1#2{\XINT@igctcv@loop@k #2{#2#1}}%
\def\XINT@igctcv@loop@k #1#2%
{%
    \expandafter\XINT@igctcv@loop@l\expandafter
    {\romannumeral0\xintraw {#1/#2}}%
}%
\def\XINT@igctcv@loop@l #1#2#3{\XINT@igctcv@loop@a {#3{#1[0]}}#2}%
\def\XINT@igctcv@end@a #1.#2#3#4#5%
{%
    \expandafter\XINT@igctcv@end@b\expandafter
    {\romannumeral0\xintraw {#2/#3}}%
}%
\def\XINT@igctcv@end@b #1#2{ #2{#1[0]}}%
%    \end{macrocode}
% \subsection{\csh{xintCntoF}}
%    \begin{macrocode}
\def\xintCntoF {\romannumeral0\xintcntof }%
\def\xintcntof #1%
{%
    \expandafter\expandafter\expandafter
        \XINT@cntf
    \expandafter\expandafter\expandafter
        {#1}%
}%
\def\XINT@cntf #1#2%
{%
   \ifnum #1>0
      \xint@afterfi {\expandafter\XINT@cntf@loop\expandafter 
                     {\the\numexpr
                     #1-1\expandafter\expandafter\expandafter}%
                     \expandafter\expandafter\expandafter
                     {#2{#1}}{#2}}%
   \else
      \xint@afterfi 
         {\ifnum #1=0
              \xint@afterfi {\expandafter\expandafter\expandafter
                             \space #2{0}}%
          \else \xint@afterfi { 0[0]}%
          \fi}%
   \fi
}%
\def\XINT@cntf@loop #1#2#3%
{%
    \ifnum #1>0 \else \XINT@cntf@exit \fi
    \expandafter\XINT@cntf@loop\expandafter
    {\the\numexpr #1-1\expandafter }\expandafter
    {\romannumeral0\xintadd {\xintDiv {1[0]}{#2}}{#3{#1}}}%
    {#3}%
}%
\def\XINT@cntf@exit \fi 
    \expandafter\XINT@cntf@loop\expandafter
    #1\expandafter #2#3%
{%
    \fi\xint@gobble@two #2%
}%
%    \end{macrocode}
% \subsection{\csh{xintGCntoF}}
%    \begin{macrocode}
\def\xintGCntoF {\romannumeral0\xintgcntof }%
\def\xintgcntof #1%
{%
    \expandafter\expandafter\expandafter
        \XINT@gcntf
    \expandafter\expandafter\expandafter
        {#1}%
}%
\def\XINT@gcntf #1#2#3%
{%
   \ifnum #1>0
      \xint@afterfi {\expandafter\XINT@gcntf@loop\expandafter 
                     {\the\numexpr
                     #1-1\expandafter\expandafter\expandafter}%
                     \expandafter\expandafter\expandafter
                     {#2{#1}}{#2}{#3}}%
   \else
      \xint@afterfi 
         {\ifnum #1=0
              \xint@afterfi {\expandafter\expandafter\expandafter
                             \space #2{0}}%
          \else \xint@afterfi { 0[0]}%
          \fi}%
   \fi
}%
\def\XINT@gcntf@loop #1#2#3#4%
{%
    \ifnum #1>0 \else \XINT@gcntf@exit \fi
    \expandafter\XINT@gcntf@loop\expandafter
    {\the\numexpr #1-1\expandafter }\expandafter
    {\romannumeral0\xintadd {\xintDiv {#4{#1}}{#2}}{#3{#1}}}%
    {#3}{#4}%
}%
\def\XINT@gcntf@exit \fi 
    \expandafter\XINT@gcntf@loop\expandafter
    #1\expandafter #2#3#4%
{%
    \fi\xint@gobble@two #2%
}%
%    \end{macrocode}
% \subsection{\csh{xintCntoCs}}
%    \begin{macrocode}
\def\xintCntoCs {\romannumeral0\xintcntocs }%
\def\xintcntocs #1%
{%
    \expandafter\expandafter\expandafter
        \XINT@cntcs
    \expandafter\expandafter\expandafter
        {#1}%
}%
\def\XINT@cntcs #1#2%
{%
   \ifnum #1<0
      \xint@afterfi { 0[0]}%
   \else       
      \xint@afterfi {\expandafter\XINT@cntcs@loop\expandafter 
                     {\the\numexpr
                     #1-1\expandafter\expandafter\expandafter}%
                     \expandafter\expandafter\expandafter
                     {\expandafter\expandafter\expandafter
                      {#2{#1}}}{#2}}%
   \fi
}%
\def\XINT@cntcs@loop #1#2#3%
{%
    \ifnum #1>-1 \else \XINT@cntcs@exit \fi
    \expandafter\XINT@cntcs@loop\expandafter
    {\the\numexpr #1-1\expandafter\expandafter\expandafter }%
    \expandafter\expandafter\expandafter 
    {\expandafter\expandafter\expandafter{#3{#1}},#2}{#3}%
}%
\def\XINT@cntcs@exit \fi 
    \expandafter\XINT@cntcs@loop\expandafter
    #1\expandafter\expandafter\expandafter #2#3%
{%
    \fi\XINT@cntcs@@exit #2%
}%
\def\XINT@cntcs@@exit #1,{ }%
%    \end{macrocode}
% \subsection{\csh{xintCntoGC}}
%    \begin{macrocode}
\def\xintCntoGC {\romannumeral0\xintcntogc }%
\def\xintcntogc #1%
{%
    \expandafter\expandafter\expandafter
        \XINT@cntgc
    \expandafter\expandafter\expandafter
        {#1}%
}%
\def\XINT@cntgc #1#2%
{%
   \ifnum #1<0
      \xint@afterfi { 0[0]}%
   \else       
      \xint@afterfi {\expandafter\XINT@cntgc@loop\expandafter 
                     {\the\numexpr
                     #1-1\expandafter\expandafter\expandafter}%
                     \expandafter\expandafter\expandafter
                     {\expandafter\expandafter\expandafter
                      {#2{#1}}}{#2}}%
   \fi
}%
\def\XINT@cntgc@loop #1#2#3%
{%
    \ifnum #1>-1 \else \XINT@cntgc@exit \fi
    \expandafter\XINT@cntgc@loop\expandafter
    {\the\numexpr #1-1\expandafter\expandafter\expandafter }%
    \expandafter\expandafter\expandafter 
    {\expandafter\expandafter\expandafter{#3{#1}}+1/#2}{#3}%
}%
\def\XINT@cntgc@exit \fi 
    \expandafter\XINT@cntgc@loop\expandafter
    #1\expandafter\expandafter\expandafter #2#3%
{%
    \fi\XINT@cntgc@@exit #2%
}%
\def\XINT@cntgc@@exit #1+1/{ }%
%    \end{macrocode}
% \subsection{\csh{xintGCntoGC}}
%    \begin{macrocode}
\def\xintGCntoGC {\romannumeral0\xintgcntogc }%
\def\xintgcntogc #1%
{%
    \expandafter\expandafter\expandafter
        \XINT@gcntgc
    \expandafter\expandafter\expandafter
        {#1}%
}%
\def\XINT@gcntgc #1#2#3%
{%
   \ifnum #1<0
      \xint@afterfi { {0[0]}}%
   \else       
      \xint@afterfi {\expandafter\XINT@gcntgc@loop\expandafter 
                     {\the\numexpr
                     #1-1\expandafter\expandafter\expandafter}%
                     \expandafter\expandafter\expandafter
                     {\expandafter\expandafter\expandafter
                      {#2{#1}}}{#2}{#3}}%
   \fi
}%
\def\XINT@gcntgc@loop #1#2#3#4%
{%
    \ifnum #1>-1 \else \XINT@gcntgc@exit \fi
    \expandafter\expandafter\expandafter
        \XINT@gcntgc@loop@b
    \expandafter\expandafter\expandafter
    {\expandafter\expandafter\expandafter
     {#4{#1}}/#2}{#3{#1}}{#1}{#3}{#4}%
}%
\def\XINT@gcntgc@loop@b #1#2#3%
{%
    \expandafter\XINT@gcntgc@loop\expandafter
    {\the\numexpr #3-1\expandafter\expandafter\expandafter}%
    \expandafter\expandafter\expandafter
    {\expandafter\expandafter\expandafter{#2}+#1}%
}%
\def\XINT@gcntgc@exit \fi
    \expandafter\expandafter\expandafter
        \XINT@gcntgc@loop@b
    \expandafter\expandafter\expandafter #1#2#3#4#5%
{%
    \fi\XINT@gcntgc@@exit #1%
}%
\def\XINT@gcntgc@@exit #1/{ }%
%    \end{macrocode}
% \subsection{\csh{xintCstoGC}}
%    \begin{macrocode}
\def\xintCstoGC {\romannumeral0\xintcstogc }%
\def\xintcstogc #1%
{%
    \expandafter\expandafter\expandafter\XINT@cstc@prep #1,\W,%
}%
\def\XINT@cstc@prep #1,{\XINT@cstc@loop@a {{#1}}}%
\def\XINT@cstc@loop@a #1#2,%
{%
    \xint@w #2\XINT@cstc@end\W\XINT@cstc@loop@b {#1}{#2}%
}%
\def\XINT@cstc@loop@b #1#2{\XINT@cstc@loop@a {#1+1/{#2}}}%
\def\XINT@cstc@end\W\XINT@cstc@loop@b #1#2{ #1}%
%    \end{macrocode}
% \subsection{\csh{xintGCtoGC}}
%    \begin{macrocode}
\def\xintGCtoGC {\romannumeral0\xintgctogc }%
\def\xintgctogc #1%
{%
    \expandafter\expandafter\expandafter\XINT@gctgc@start #1+\W/%
}%
\def\XINT@gctgc@start {\XINT@gctgc@loop@a {}}%
\def\XINT@gctgc@loop@a #1#2+#3/%
{%
    \xint@w #3\XINT@gctgc@end\W
    \expandafter\expandafter\expandafter
    \XINT@gctgc@loop@b
    \expandafter\expandafter\expandafter
    {#2}{#3}{#1}%
}%
\def\XINT@gctgc@loop@b #1#2%
{%
    \expandafter\expandafter\expandafter
    \XINT@gctgc@loop@c
    \expandafter\expandafter\expandafter
    {#2}{#1}%
}%
\def\XINT@gctgc@loop@c #1#2#3%
{%
    \XINT@gctgc@loop@a {#3{#2}+{#1}/}%
}%
\def\XINT@gctgc@end\W
    \expandafter\expandafter\expandafter\XINT@gctgc@loop@b
{%
    \expandafter\expandafter\expandafter\XINT@gctgc@@end
}%
\def\XINT@gctgc@@end #1#2#3{ #3{#1}}%
\XINT@cfrac@restorecatcodes@endinput%
%    \end{macrocode}
% \DeleteShortVerb{\|}
% \MakePercentComment
%</xintcfrac>
%<*none>
\CharacterTable
 {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
  Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
  Digits        \0\1\2\3\4\5\6\7\8\9
  Exclamation   \!     Double quote  \"     Hash (number) \#
  Dollar        \$     Percent       \%     Ampersand     \&
  Acute accent  \'     Left paren    \(     Right paren   \)
  Asterisk      \*     Plus          \+     Comma         \,
  Minus         \-     Point         \.     Solidus       \/
  Colon         \:     Semicolon     \;     Less than     \<
  Equals        \=     Greater than  \>     Question mark \?
  Commercial at \@     Left bracket  \[     Backslash     \\
  Right bracket \]     Circumflex    \^     Underscore    \_
  Grave accent  \`     Left brace    \{     Vertical bar  \|
  Right brace   \}     Tilde         \~}

\CheckSum{11712}
\makeatletter\check@checksum\makeatother
\Finale
%%
%% End of file `xint.dtx'.

