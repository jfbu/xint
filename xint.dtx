% -*- coding: iso-latin-1; -*-
% xint.dtx, 1.08b (2013/06/14)
% Copyright (C) 2013 by Jean-François B.
% Style files which will self-extract from xint.dtx:
% (base) xint.sty       Expandable operations on long numbers
%        xintfrac.sty   Expandable operations on fractions
%        xintexpr.sty   Expandable expression parser
%        xintbinhex.sty Expandable binary and hexadecimal conversions
%        xintgcd.sty    Euclidean algorithm with xint package
%        xintseries.sty Expandable partial sums with xint package
%        xintcfrac.sty  Expandable continued fractions with xint package
% To be used with Plain TeX (\input) or LaTeX (\usepackage)
%<*doc>
\def\lasttimestamp{Time-stamp: <16-06-2013 08:53:40 CEST *>}
%</doc>
%  License
%  =======
%
%  This work consists of the source file xint.dtx and of its derived files:
%  xint.sty, xintfrac.sty, xintexpr.sty,
%  xintbinhex.sty, xintgcd.sty, xintseries.sty, xintcfrac.sty, 
%  as well as xint.ins and the documentation xint.pdf (or xint.dvi).
%
%     This work may be distributed and/or modified under the
%     conditions of the LaTeX Project Public License, either
%     version 1.3c of this license or (at your option) any later
%     version. This version of this license is in 
%          http://www.latex-project.org/lppl/lppl-1-3c.txt
%     and the latest version of this license is in
%          http://www.latex-project.org/lppl.txt
%     and version 1.3 or later is part of all distributions of
%     LaTeX version 2005/12/01 or later. 
% 
%  The author of this work is Jean-Francois B. <2589111+jfbu@users.noreply.github.com>. 
%  This work has the LPPL maintenance status `author-maintained'.
% 
%  Installation and Usage:
%  =======================
%
%  Run tex or latex on xint.dtx.
% 
%  This will extract the style files xint.sty, xintfrac.sty, xintexpr.sty,
%  xintbinhex.sty, xintgcd.sty, xintseries.sty, xintcfrac.sty (and xint.ins).
%
%  Files with the same names and in the same repertory will be overwritten.
%  The tex (not latex) run will stop with the complaint that it does not
%  understand \NeedsTeXFormat, but the style files will already have been
%  extracted by that time.
%
%  Alternatively, run tex or latex on xint.ins if available.
%
%  To get xint.pdf run pdflatex thrice on xint.dtx
%  
%             xint.sty |
%         xintfrac.sty |
%         xintexpr.sty | 
%       xintbinhex.sty | --> TDS:tex/generic/xint/
%          xintgcd.sty |
%       xintseries.sty |
%        xintcfrac.sty |
%             xint.dtx   --> TDS:source/generic/xint/
%             xint.pdf   --> TDS:doc/generic/xint/
% 
%  It may be necessary to then refresh the TeX installation filename
%  database.
%
%  Usage with LaTeX: \usepackage{xint}
%                    \usepackage{xintfrac}   % (loads xint)
%                    \usepackage{xintexpr}   % (loads xintfrac)
%
%                    \usepackage{xintbinhex} % (loads xint)
%                    \usepackage{xintgcd}    % (loads xint)
%                    \usepackage{xintseries} % (loads xintfrac)
%                    \usepackage{xintcfrac}  % (loads xintfrac)
%
%  Usage with TeX:   \input xint.sty\relax   
%                    \input xintfrac.sty\relax   % (loads xint)
%                    \input xintexpr.sty\relax   % (loads xintfrac)
%
%                    \input xintbinhex.sty\relax % (loads xint)
%                    \input xintgcd.sty\relax    % (loads xint)
%                    \input xintseries.sty\relax % (loads xintfrac)
%                    \input xintcfrac.sty\relax  % (loads xintfrac)
%
%%
%%----------------------------------------------------------------
%% The xint bundle (version 1.08b of June 14, 2013)
%<xint>%% xint: Expandable operations on long numbers
%<xintfrac>%% xintfrac: Expandable operations on fractions  
%<xintexpr>%% xintexpr: Expandable expression parser
%<xintbinhex>%% xintbinhex: Expandable binary and hexadecimal conversions
%<xintgcd>%% xintgcd: Euclidean algorithm with xint package 
%<xintseries>%% xintseries: Expandable partial sums with xint package
%<xintcfrac>%% xintcfrac: Expandable continued fractions with xint package
%% Copyright (C) 2013 by Jean-Francois B. 
%%----------------------------------------------------------------
%%
%<*doc>
\def\pkgversion{1.08b}
\def\pkgdate{2013/06/14}
\def\striptimestamp #1 <#2 #3 #4 #5>{#2 at #3 #4}
\def\getdocdate #1 <#2-#3-#4 #5>{#4/#3/#2}
\edef\docdate{\expandafter\getdocdate\lasttimestamp}
\edef\dtxtimestamp{\expandafter\striptimestamp\lasttimestamp}
\begingroup
\input docstrip.tex
\askforoverwritefalse
\generate{\nopreamble
\file{xint.ins}{\from{xint.dtx}{ins}}
\usepreamble\defaultpreamble
\file{xint.sty}{\from{xint.dtx}{xint}}
\file{xintbinhex.sty}{\from{xint.dtx}{xintbinhex}}
\file{xintgcd.sty}{\from{xint.dtx}{xintgcd}}
\file{xintfrac.sty}{\from{xint.dtx}{xintfrac}}
\file{xintseries.sty}{\from{xint.dtx}{xintseries}}
\file{xintcfrac.sty}{\from{xint.dtx}{xintcfrac}}
\file{xintexpr.sty}{\from{xint.dtx}{xintexpr}}}
\endgroup
\iffalse
%</doc>
%<*ins>
%----------- to .ins file ----------------------------------------
%%
%% This is a generated file. Run tex or latex on this file to
%% extract xint.sty, xintfrac.sty, xintexpr.sty, xintbinhex.sty,
%% xintgcd.sty, xintseries.sty and xintcfrac.sty from xint.dtx
%%
%% See xint.dtx for the copyright and the conditions for
%% distribution and/or modification of this work.
%%
\input docstrip.tex
\askforoverwritefalse
\generate{\usepreamble\defaultpreamble
\file{xint.sty}{\from{xint.dtx}{xint}}
\file{xintbinhex.sty}{\from{xint.dtx}{xintbinhex}}
\file{xintgcd.sty}{\from{xint.dtx}{xintgcd}}
\file{xintfrac.sty}{\from{xint.dtx}{xintfrac}}
\file{xintseries.sty}{\from{xint.dtx}{xintseries}}
\file{xintcfrac.sty}{\from{xint.dtx}{xintcfrac}}
\file{xintexpr.sty}{\from{xint.dtx}{xintexpr}}}
\endbatchfile
%----------- end of .ins file ------------------------------------
%</ins>
%<*doc>
\fi
\NeedsTeXFormat{LaTeX2e}
\ProvidesFile{xint.dtx}[bundle source and documentation (\dtxtimestamp)]

\documentclass[a4paper,11pt,abstract]{scrdoc}

\pagestyle{headings}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{multicol}

%---- GEOMETRY WILL BE CHANGED FOR SOURCE CODE SECTIONS
\usepackage[hscale=0.66,vscale=0.75]{geometry}

\usepackage{xintexpr}

\usepackage{xintbinhex}
\usepackage{xintgcd}
\usepackage{xintseries}
\usepackage{xintcfrac}

\usepackage{amsmath} % for \cfrac in the documentation 

\usepackage{etoc}

%---- CHANGING TOCDEPTH MIDWAY THROUGH THE MAIN TOC (1.04, 18 avril 2013)
% je modifie le 27 mai car finalement j'ajoute des \localtableofcontents aux
% chapitres décrivant les commandes des packages, et je supprime ces
% sous-sections de la Table principale. OK, ça marche. Ok aussi pour les
% bookmarks du pdf.

\makeatletter
\def\resettocdepthto #1{\c@tocdepth #1\relax }%
% ainsi on modifie localement seulement puisque cela sera vu seulement dans le
% scope du group de la (local) tableofcontents faite par etoc et hyperref ne me
% jouera pas de tour avec les bookmarks

\def\SetInnerTocdepthTo #1{%
    \addtocontents {toc}{\protect\resettocdepthto {#1}}%
}%

\def\FutureTOCsDoNotObeyInnerTocdepth{%
    \let\resettocdepthto\@gobble 
    \etocmulticolstyle [1]{\subsection *{Contents}}%
}%
% parfait, modifs du 27 mai ok.

% ---- USING ETOC FOR CUSTOM SUBSECTION STYLE (pour 1.04, 21 avril 2013)
% attention comme je crée un groupe pour le typesetting dans les TOCs des
% sous-sections, je dois donc faire  attention de positionner \toctransition
% juste après le début de la section "implémentation de xint", sinon il est dans
% le scope de la précédente sous-section et l'action sur \c@tocdepth sera
% annulée aussitôt.
 
% 27 mai: la position, et la nature, de \toctransition modifiés car je ne mets
% plus les sous-sections des sections de «Commands» dans la Toc.

% 8 juin: je change à nouveau le nom de \toctransition (cf au-dessus)

\def\gobbletodot #1.{}

\let\savedsectionline\l@section
\etocsetstyle{section}{}{}
     {\savedsectionline{\numberline{\etocnumber}\etocname}{\etocpage}}{}%

% choix de style plus sophistiqué à partir de 1.08a
\etocsetstyle{subsection}
    {\begingroup
     \setlength{\premulticols}{0pt}
     \setlength{\multicolsep}{0pt}
     \setlength{\columnsep}{1em}
     \setlength{\columnseprule}{.4pt}
     \raggedcolumns % only added for 1.08a, I should have done it long time ago!
     \begin{multicols}{2}%
     \leftskip 2.3em\rightskip 0em\parfillskip 0em\relax
    }
    {}
    {\noindent
        \llap{\makebox[2.3em][l]
              {\ttfamily\bfseries\etoclink
                         {.\expandafter\gobbletodot\etocthenumber}}}%
        \strut 
        \etocname\leaders\etoctoclineleaders
        \hfill \strut\makebox[1.5em][r]{\normalfont\small\etocpage}\endgraf }
    {\end{multicols}\endgroup }%

\makeatother

% 4 juin 2013

% je me décide à utiliser les couleurs des liens via hyperref, mais je n'en veux
% pas (des couleurs) dans les TOCs (par contre je veux les liens évidemment).
% Idéalement j'aurais aimé pouvoir avoir pour les TOCs les liens sous la forme
% de rectangles mais je n'ai pas le temps de regarder si on peut dire à hyperref
% de faire cela. J'ai déterminé empiriquement qu'on peut tout-à-fait mettre
% \hypersetup{hidelinks} dans un groupe 

% à propos il faudrait une interface plus commode pour ce hook
% Mais c'est déjà bien qu'on ait ça!

\def\etocaftertitlehook {\hypersetup{hidelinks}}

%--- TXFONTS: TXTT WILL BE MADE SMALLER AND WILL ALLOW HYPHENATION
\usepackage{txfonts}

% malheureusement, comme j'utilise des diacritiques dans mes
% parties commentées, imprimées verbatim, je ne pourrai pas
% utiliser dvipdfmx qui a un problème avec txtt

\DeclareFontFamily{T1}{txtt}{}
\DeclareFontShape{T1}{txtt}{m}{n}{	%medium
     <->s*[.96] t1xtt%
}{}
\DeclareFontShape{T1}{txtt}{m}{sc}{	%cap & small cap
     <->s*[.96] t1xttsc%
}{}
\DeclareFontShape{T1}{txtt}{m}{sl}{	%slanted
     <->s*[.96] t1xttsl%
}{}
\DeclareFontShape{T1}{txtt}{m}{it}{	%italic
     <->ssub * txtt/m/sl%
}{}
\DeclareFontShape{T1}{txtt}{m}{ui}{   	%unslanted italic
     <->ssub * txtt/m/sl%
}{}
\DeclareFontShape{T1}{txtt}{bx}{n}{	%bold extended
     <->t1xbtt%
}{}
\DeclareFontShape{T1}{txtt}{bx}{sc}{	%bold extended cap & small cap
     <->t1xbttsc%
}{}
\DeclareFontShape{T1}{txtt}{bx}{sl}{	%bold extended slanted
     <->t1xbttsl%
}{}
\DeclareFontShape{T1}{txtt}{bx}{it}{	%bold extended italic
     <->ssub * txtt/bx/sl%
}{}
\DeclareFontShape{T1}{txtt}{bx}{ui}{  	%bold extended unslanted italic
     <->ssub * txtt/bx/sl%
}{}
\DeclareFontShape{T1}{txtt}{b}{n}{	%bold
     <->ssub * txtt/bx/n%
}{}
\DeclareFontShape{T1}{txtt}{b}{sc}{	%bold cap & small cap
     <->ssub * txtt/bx/sc%
}{}
\DeclareFontShape{T1}{txtt}{b}{sl}{	%bold slanted
     <->ssub * txtt/bx/sl%
}{}
\DeclareFontShape{T1}{txtt}{b}{it}{   	%bold italic
     <->ssub * txtt/bx/it%
}{}
\DeclareFontShape{T1}{txtt}{b}{ui}{   	%bold unslanted italic
     <->ssub * txtt/bx/ui%
}{}

% au bout d'un moment j'ai fini par être mal à l'aise avec le 0 de txtt, pour
% afficher les résultats des calculs faits pas xint. 
% 
% ***** Attention le - de cmtt est ÉPOUVANTABLE!***** bon, ça le disqualifie.
% le - de lmtt lui n'a PAS ce problème. Et lmtt, à sa taille naturelle,
% correspond bien à mon txtt réduit à 96%. Donc c'est très simple:

\def\digitstt {\bgroup\fontfamily {lmtt}\selectfont\let\next=}
 
% le nom de \digitstt n'est pas très bien choisi, mais bon il est en effet
% utilisé ici dans 95% des cas pour des nombres uniquement. 

\usepackage{xspace}
\usepackage{color}
\usepackage{framed}

\definecolor{joli}{RGB}{225,95,0}
\definecolor{JOLI}{RGB}{225,95,0}
\definecolor{BLUE}{RGB}{0,0,255}
\definecolor{niceone}{RGB}{38,128,192}
\definecolor{PineGreen}{cmyk}{0.92,0,0.59,0.25}% cf color.pro
\definecolor{Purple}{cmyk}{0.45,0.86,0,0}

\usepackage[english]{babel}
\usepackage[autolanguage,np]{numprint}
\AtBeginDocument{\npthousandsep{,\hskip .05em plus .01em minus .01em}}

\usepackage[pdfencoding=pdfdoc,bookmarks=true]{hyperref}
\hypersetup{%
linktoc=all,%
breaklinks=true,%
colorlinks=true,%
urlcolor=niceone,%
linkcolor=blue,%
pdfauthor={Jean-Fran\c cois B.},%
pdftitle={The xint bundle},%
pdfsubject={Arithmetic with TeX},%
pdfkeywords={Expansion, arithmetic, TeX},%
pdfstartview=FitH,%
pdfpagemode=UseOutlines}


%---- \MyMarginNote: a simple macro for some margin notes with no fuss
\makeatletter
\def\MyMarginNote {\@ifnextchar[\@MyMarginNote{\@MyMarginNote[]}}%
\def\@MyMarginNote [#1]#2{%
    \vadjust{\vskip-\dp\strutbox
             \smash{\hbox to 0pt
                       {\color{PineGreen}\normalfont\small
                        \hsize 1.5cm\rightskip.5cm minus.5cm
                        \hss\vtop{\noindent #2}\ $\to$#1\ }}%
             \vskip\dp\strutbox }\strut{}} 
\def\MyMarginNoteWithBrace #1{%
    \vadjust{\vskip-\dp\strutbox
             \smash{\hbox to 0pt
                       {\color{PineGreen}\normalfont\small
                        \hss #1\ $\Bigg\{$\ }}%
             \vskip\dp\strutbox }\strut{}} 
\def\IMPORTANT {\MyMarginNoteWithBrace {IMPORTANT!}}
\makeatother

%---- \centeredeline: OUR OWN LITTLE MACRO FOR CENTERING LINES

% 7 mars 2013
% This macro allows to conveniently center a line inside a paragraph and still
% use therein \verb or other commands changing catcodes.
% A proposito, the \LaTeX \centerline uses \hsize and not \linewidth ! 
% (which in my humble opinion is bad)

% \ignorespaces ajouté le 9 juin. Cela m'aurait évité des dizaines de % lorsque
% plusieurs \centeredline se suivent (car on reste en mode horizontal si on y
% est au début).

\makeatletter
\newcommand*\centeredline {%
      \ifhmode \\\relax
        \def\centeredline@{\hss\egroup\hskip\z@skip\ignorespaces }%
      \else 
        \def\centeredline@{\hss\egroup }%
      \fi
      \afterassignment\@centeredline
      \let\next=}
\def\@centeredline 
    {\hbox to \linewidth \bgroup \hss \bgroup \aftergroup\centeredline@ }
\makeatother

%---- MODIFIED \verb, and verbatim like `environments' FITS BETTER OUR USE OF IT
% le \verb de doc.sty est très chiant car il a retiré \verbatim@font pour mettre
% un \ttfamily hard-coded à la place. [en fin de compte j'utilise dorénavant le
% vocable \MicroFont plutôt que \verbatim@font]
% 
% Par ailleurs j'en ai marre des erreurs dues au fait que mes
% paragraphes reformatés dans emacs passent à la ligne au milieu
% d'un \verb. Je décide donc d'annuler l'effet du \dospecials sur les
% espaces dans la source. Et donc je retire le \verb@eol@error et
% il n'y a donc plus lieu d'un comportement différent pour
% l'impression des blancs, donné par la version étoilée.
% 
% Et il n'y avait donc pas de \obeylines puisque la fin de ligne
% devenait un message d'erreur dans \verb@eol@error 
%
% à propos \do@noligs:
% macro:#1->\catcode `#1\active \begingroup \lccode `\~=`#1\relax \lowercase
% {\endgroup \def ~{\leavevmode \kern \z@ \char `#1}} 
% ne manque-t-il pas un espace après le \char `#1? En effet! ça me pose des
% problèmes lorsque l'espace a catcode 10!!
% 
% attention au signe - par contre, on ne veut vraiment *pas* de ligatures avec
% lui, donc pour lui et seulement pour lui je fais le boulot de \do@noligs. OK,
% je pense que la raison pour laquelle je ne le faisais que pour - est celle du
% paragraphe précédent que je viens d'ajouter, donc finalement je fais le
% \do@noligs entier 
%  \catcode`\-\active \def-{\kern \z@ \char`\- }
%
% 12 et 13 mai 2013. Je dois m'occuper des verbatim, et comme je n'ai (pas ou
% plus) envie de perdre du temps à aller re-regarder verbatim et en particulier
% son emploi  de trivlist, avec les conséquences *lamentables* sur les
% espacements verticaux je décide de tester une variante de \verb spécialement
% pour remplacer mes blocs verbatim, particulièrement dans le code commenté. Et
% voilà \lverb! bye bye \begin{verbatim} 
%
% bref, pour \lverb: d'abord il est \long. Ensuite j'utilise $ si j'ai besoin de
% control sequences. En fait j'ai juste eu besoin pour \%. Car le % lui je le
% mets (maintiens, donc la partie implémentation) à ignore. Ah, et finalement
% j'utilise aussi $\. Les espaces sont normaux. 
% Enfin, je fais de & un caractère de  commentaires. Tout cela c'est pour 
% la partie Implémentation. 
%
% Pour les verbatim dans la partie user manual, je fais une variante \dverb, qui
% elle respecte les lignes, en utilisant \obeylines. 
% 
% 8 juin: dans \dverb et aussi dans les shortverb, & est commentaire et *
% est actif et fait \lowast (\makestarlowast). J'utilisais avant ~ comme
% caractère actif dans les shortverbs mais je n'en ai pas besoin finalement,
% c'est plus simple avec un * actif.
% 
\def\MicroFont {\ttfamily }
\def\MacroFont {\ttfamily\baselineskip12pt\relax}
\makeatletter

% modif de \do@noligs: \char`#1} --> \char`#1 } 
\def\do@noligs #1%
{%
    \catcode `#1\active 
    \begingroup \lccode `\~=`#1\relax 
    \lowercase {\endgroup \def ~{\leavevmode \kern \z@ \char `#1 }}%
} 
% \makestarlowast ajouté le 8 juin
\def\verb 
{%
  \relax \ifmmode\hbox\else\leavevmode\null\fi
  \bgroup \MicroFont
  \let\do\do@noligs  \verbatim@nolig@list
  \let\do\@makeother \dospecials
  \catcode32 10 \makestarlowast \catcode`\& 14 \@jfverb 
}
\def\@jfverb #1{\catcode`#1\active\lccode`\~`#1\lowercase{\let~\egroup}}
% ATTENTION!
% \def~{\\\relax} cause des problèmes infinis. Donc je vais simplement utiliser
% dans les parties commentées du code $\ puisque $ a catcode 0. 
% attention à [, donc $\$relax en un endroit. 
% Le choix de $ est ok, car comme c'est dans des parties commentées, le mode
% docTeX de emacs ne fait pas de choses pénibles au-niveau de la coloration
% syntaxique. 
\long\def\lverb % pour utilisation dans la partie implémentation
{%
  \relax\par\smallskip\noindent\null
  \begingroup
  \let\par\@@par\hbadness 100 \hfuzz 100pt\relax
  \hsize .85\hsize 
  \MacroFont
  \bgroup
    \aftergroup\@@par \aftergroup\endgroup \aftergroup\medskip
    \let\do\do@noligs  \verbatim@nolig@list
    \let\do\@makeother \dospecials 
    \catcode32 10 \catcode`\% 9 \catcode`\& 14 \catcode`\$ 0
    \@jfverb 
}
% et voilà. Comme quoi, on peut aussi faire sans \trivlist si on veut.
\long\def\dverb % pour utilisation dans le manuel de l'utilisateur
% contrairement à \lverb, ici, on fait \obeylines 
% à utiliser sous la forme: (ou avec un autre à la place de |)(on aurait pu
% imaginer aussi prendre ^^A ou dans le genre
% \dverb|&
% blahblah
% |
% pour qu'il y ait bien un dernier end of line, qui est compensé a posteriori
{%
   \relax\par\smallskip
   \bgroup
     \parindent0pt 
     % \parskip0pt 
     \def\par{\@@par\leavevmode\null}%
     \let\do\do@noligs \verbatim@nolig@list
     \let\do\@makeother \dospecials 
     \catcode`\& 14 \makestarlowast
     \aftergroup\vskip\aftergroup-\aftergroup\baselineskip
     \aftergroup\smallskip
     \aftergroup\noindent\aftergroup\ignorespaces
     \MacroFont \obeylines \@vobeyspaces 
   \@jfverb 
}
% Mais j'ai besoin d'un mode verbatim différent pour les nombres car je
% ne veux pas passer en mode mathématique (que j'aime de moins en moins) et je
% ne veux pas les 0 du txtt pour cela. Comme je n'utilise pas de tabulation, je
% vais prendre &.
% Hmm, finalement je supporte de moins en moins les chiffres du roman. J'ai un
% peu de mal à me mettre d'accord sur un style uni de présentation.
% Update 8 juin: finalement je me décide ici aussi pour utiliser lmtt
% Donc dans &..& c'est comme dans \digitstt. Très bien.
\catcode`\& 13
\def&{\begingroup\fontfamily{lmtt}\selectfont
           \let\do\@makeother\dospecials
           \catcode`\& 13 
      \@jfendshrtverb }
\def\@jfendshrtverb #1&{#1\endgroup }
\makeatother

% Note: il n'y a plus de \hyphenchar-1 dans le \DeclareFontFamily de t1txtt
% MAIS ATTENTION CEPENDANT À CE QUI SE PASSE EN CAS DE CHANGEMENT DE TAILLE

% 11 mai 2013: j'utilise dorénavant _ là où avant c'était @
\catcode`\_=11

\def\csa_aux #1{\ttfamily\hyphenchar\font45 \char`\\#1\endgroup }
\def\csb_aux #1{\hyperref[#1]{\ttfamily
                              \hyphenchar\font45 \char`\\#1}\endgroup }

\DeclareRobustCommand\csa     {\begingroup\catcode`\_=11 \csa_aux }
\DeclareRobustCommand\csb     {\begingroup\catcode`\_=11 \csb_aux }
\DeclareRobustCommand\csbnolk {\begingroup\catcode`\_=11 \color{blue}\csa_aux }

\newcommand\csh[1]{\texorpdfstring{\csa{#1}}{\textbackslash #1}}
\newcommand\csbh[1]{\texorpdfstring{\csbnolk{#1}}{\textbackslash #1}}

\def\XINT_tmp_def #1%
{%
    \expandafter\def\csname #1name\endcsname
   {\texorpdfstring
                  {{\color{joli}\ttfamily\hyphenchar\font45 \bfseries #1}}
                  {#1}%
    \xspace }%
}%
\xintApplyUnbraced\XINT_tmp_def
    {{xint}{xintbinhex}{xintgcd}{xintfrac}{xintseries}{xintcfrac}{xintexpr}}

\let\XINT_tmp_def\empty
\catcode`\_=8

\frenchspacing
\renewcommand\familydefault\sfdefault

%---- QUICK WAY TO PRINT LONG THINGS, IN PARTICULAR, BUT NOT EXCLUSIVELY, LONG
%     NUMBERS 
\def\allowsplits #1%
{%
    \ifx #1\relax \else #1\hskip 0pt plus 1pt\relax
    \expandafter\allowsplits\fi
}%
\def\printnumber #1%
{\expandafter\expandafter\expandafter
    \allowsplits #1\relax }% Expands twice before printing.

%--- counts used in particular in the samples from the documentation of the
%    xintseries.sty package
\newcount\cnta
\newcount\cntb
\newcount\cntc

%--- printing (systematically) * in a lowered position in the various verbatim
%    blocks using txtt.

\def\lowast{\raisebox{-.25\height}{*}}
\begingroup
   \catcode`* 13
   \gdef\makestarlowast {\let*\lowast\catcode`\*\active}%
\endgroup

\begin{document}\thispagestyle{empty}\rmfamily
\pdfbookmark[1]{Title page}{TOP}

{\normalfont\Large\parindent0pt \parfillskip 0pt\relax 
 \leftskip 2cm plus 1fil \rightskip 2cm plus 1fil
 The \xintname bundle: \xintname, \xintfracname, \xintexprname,
    \xintbinhexname, \xintgcdname, \xintseriesname and \xintcfracname.\par}%
{\centering
  \textsc{Jean-François B.}\par
  \footnotesize \ttfamily
  2589111+jfbu@users.noreply.github.com\\
  Package version: \pkgversion\ (\pkgdate)\\
  Documentation generated from the source file\\
  with timestamp ``\dtxtimestamp''\par
}

\begin{abstract}
  The \xintname package implements with expandable \TeX{} macros the basic
  arithmetic operations of addition, subtraction, multiplication and division,
  applied to arbitrarily long numbers represented as chains of digits with an
  optional minus sign. The \xintfracname package extends the scope of \xintname
  to fractional numbers with arbitrarily long numerators and denominators.

  \xintexprname provides an expandable parser |\xintexpr . . . \relax| of
  expressions constructed with decimal numbers, fractions, numbers in
  scientific notation, the basic operations as infix operators, parentheses,
  sign prefixes, factorial symbol, and sub-expressions or macros expanding
  to the previous items.

  The \xintbinhexname package is for conversions to and from binary and
  hexadecimal bases, \xintseriesname provides some basic functionality for
  computing in an expandable manner partial sums of series and power series with
  fractional coefficients, \xintgcdname implements the Euclidean algorithm and
  its typesetting, and \xintcfracname deals with the computation of continued
  fractions.

  Most macros, and all of those doing computations, work purely by expansion
  without assignments, and may thus be used almost everywhere in \TeX{}.

  The packages may be used with any flavor of \TeX{} supporting the \eTeX{}
  extensions. \LaTeX{} users will use |\usepackage| and others |\input| to
  load the package components.
\end{abstract}

\setcounter{tocdepth}{2}

\tableofcontents

\FutureTOCsDoNotObeyInnerTocdepth   

\clearpage

\section{Presentation}

\subsection{Recent changes}

Release |1.08b|:
\begin{itemize}
\item Correction of a problem with spaces inside |\xintexpr|-essions.
\item Additional improvements to the handling of floating point numbers.
\item The macros of \xintfracname allow to use count registers in their
  arguments in ways which were not previously documented. See
  \hyperlink{useofcount}{Use of count registers}.  
\end{itemize}

\noindent Release |1.08a|:
\begin{itemize}
\item Improved efficiency of the basic conversion from exact
  fractions to floating point numbers,
  with ensuing speed gains especially for the power function macros
  \csb{xintFloatPow} and \csb{xintFloatPower},
\item Better management by the \xintfracname macros \csb{xintCmp},
  \csb{xintMax}, \csb{xintMin} and \csb{xintGeq} of inputs having big powers
  of ten in them.
\item Macros for floating point numbers added to the \xintseriesname package.
\end{itemize}

\noindent Release |1.08|:
\begin{itemize}
\item Extraction of square roots, for floating point numbers
  (\csb{xintFloatSqrt}), and also in 
  a version adapted to integers (\csb{xintiSqrt}).
\item New package \xintbinhexname providing \hyperref[sec:combinhex]{conversion
    routines} to and from binary and hexadecimal bases.
\end{itemize}
 
\noindent Release |1.07|:
\begin{itemize}
\item The \xintfracname macros accept numbers written in scientific notation,
  the \csb{xintFloat} command serves to output its argument with a given number
  |D| of significant figures. The value of |D| is either given as optional
  argument to \csb{xintFloat} or set with |\xintDigits := D;|. The default value
  is |16|.
\item The \xintexprname package is a new core constituent (which loads
  automatically \xintfracname and \xintname) and implements the expandable
  expanding parsers \centeredline{{\color{blue}|\xintexpr . . . \relax|},
    and  its variant 
  {\color{blue}|\xintfloatexpr . . 
  . \relax|}} allowing on input formulas using the standard form with infix
  operators |+|, |-|, |*|, |/|, and |^|, and arbitrary levels of
  parenthesizing. Within a float expression the operations are executed
  according to the current value of \csb{xintDigits}. Within an
  |\xintexpr|-ession the binary operators are computed exactly.
\end{itemize}

% The |\xintexpr..\relax| and |\xintfloatexpr..\relax| are usable as
% sub-expressions but not directly printable; for this one has |\xinttheexpr|
% and 
% |\xintthefloatexpr|, or equivalently |\xintthe\xintexpr| and
% |\xintthe\xintfloatexpr|. 
The floating point precision |D| is set (this is a
local assignment to a |\mathchar| variable) with |\xintDigits := D;| and queried
with |\xinttheDigits|. It may be set to anything up to |32767|.\footnote{but
  values higher than 100 or 200 will presumably give too slow evaluations.} The
macro incarnations of the binary operations admit an optional argument which
will replace pointwise |D|; this argument may exceed the |32767| bound.

To write the |\xintexpr| parser I benefited from the commented source of the
\LaTeX3 parser; the |\xintexpr| parser has its own features and peculiarities.
See \hyperref[sec:comexpr]{its documentation}.

\subsection{Overview}

The main characteristics are:
\begin{enumerate}
\item exact algebra on arbitrarily big numbers, integers as well as fractions,
\item floating point variants with user-chosen precision,
\item implemented via macros compatible with expansion-only
  context.
\end{enumerate}

`Arbitrarily big': this means with less than
    |2^31-1|\digitstt{=\number"7FFFFFFF} digits, as most of the macros will
    have to compute the length of the inputs and these lengths must be treatable
    as \TeX{} integers, which are at most \digitstt{\number "7FFFFFFF} 
    in absolute value.
    This is a distant theoretical upper bound, 
the true limitation is from the \emph{time} taken by the
expansion-compatible algorithms, this will be commented upon soon.

As just recalled, ten-digits numbers starting with a &3& already exceed the
\TeX{} bound on integers; and \TeX{} does not have a native processing of
floating point numbers (multiplication by a decimal number of a dimension
register is allowed --- this is used for example by the
\href{http://www.ctan.org/tex-archive/graphics/pgf/base}{pgf} basic math
engine.)

\TeX{} elementary operations on numbers are done via the non-expandable
\emph{advance, multiply, \emph{and} divide} assignments. This was changed with
\eTeX{}'s |\numexpr| which does expandable computations using standard infix
notations with \TeX{} integers. But \eTeX{} did not modify the \TeX{} bound on
acceptable integers, and did not add floating point support.

The \href{http://www.ctan.org/pkg/bigintcalc}{bigintcalc} package by
\textsc{Heiko Oberdiek} provided expandable operations (using some of |\numexpr|
possibilities, when available) on arbitrarily big integers, beyond the \TeX{}
bound. The present package does this again, using more of |\numexpr| (\xintname
requires the \eTeX{} extensions) for higher speed, and also on fractions, not
only integers. Arbitrary precision floating points operations are a derivative,
and not the initial design goal.\footnote{currently (|v1.08|), the only
  non-elementary operation implemented for floating point numbers is the
  square-root extraction; furthermore no |NaN|'s nor error traps has been
  implemented, only the notion of `scientific notation with a given number of
  significant figures'.}${}^{\text{,\,}}$\footnote{multiplication of two floats
  with |P=\string\xinttheDigits| digits is first done exactly then rounded to
  |P| digits, rather than using a specially tailored multiplication for floating
  point numbers which would be more efficient (it is a waste to evaluate fully
  the multiplication result with |2P| or |2P-1| digits.)}

The \LaTeX3 project has implemented
expandably floating-point computations with 16 significant figures
(\href{http://www.ctan.org/tex-archive/macros/latex/contrib/l3kernel}{l3fp}), 
including special functions such as exp, log, sine and cosine.

The \xintname package can be used for 24, 40, etc... significant figures but one
rather quickly (not much beyond 100 figures perhaps) hits against a `wall'
created by the constraint of expandability: currently, multiplying out two
one-hundred digits numbers takes circa 80 or 90 times longer than for two
ten-digits numbers, which is reasonable, but multiplying out two one-thousand
digits numbers takes more than 500 times longer than for two one hundred-digits
numbers. This shows that the algorithm is drifting from quadratic to cubic in
that range. On my laptop multiplication of two 1000-digits numbers takes some
seconds, so it can not be done routinely in a document.\footnote{without
  entering 
  into too much technical details, the 
  source of this `wall' is that when dealing with two long operands, when one
  wants to pick some digits from the second one, one has to jump above all
  digits constituting the first one, which can not be stored away: expandability
  forbids assignments to memory storage. One may envision some sophisticated
  schemes, dealing with this problem in less naive ways, trying to move big
  chunks of data higher up in the input stream and come back to it later,
  etc...; but each `better' algorithm adds overhead for the smaller inputs. For
  example, I have another version of addition which is twice faster on inputs
  with 500 digits or more, but it is slightly less efficient for 50 digits or
  less. This `wall' dissuaded me to look into implementing `intelligent'
  multiplication which would be sub-quadratic in a model where storing and
  retrieving from memory do not cost much.}

The conclusion perhaps could be that it is in the end lucky that the speed gains
brought by \xintname for expandable operations on big numbers do open some
non-empty range of applicability in terms of the number of kept digits for
routine floating point operations.

The second conclusion, somewhat depressing after all the hard work, is
that if one really wants to do computations with \emph{hundreds} of digits, one
should drop the expandability requirement. And indeed, as clearly
demonstrated long ago by the \href{http://www.ctan.org/pkg/pi}{pi
  computing file} by \textsc{D. Roegel} one can program \TeX{} to
compute with many digits at a much higher speed than what \xintname
achieves: but, direct access to memory storage in one form or another
seems a necessity for this kind of speed and one has to renounce at the
complete expandability.\footnote{I could, naturally, be proven
  wrong!}\,\footnote{The Lua\TeX{} project possibly makes endeavours
  such as \xintname appear even more insane that they are, in truth.}


\subsection{Missing things}


`Arbitrary-precision' floating-point
operations are currently limited to the basic four operations, the power
function with integer exponent, and the extraction of square-roots.

\subsection{Some examples}

The main initial goal is to allow computations with integers and fractions of
arbitrary sizes.

Here are some examples. The first one uses only the base module \xintname, the
next two require the \xintfracname package, which deals with fractions. Then two
examples with the \xintgcdname package, one with the \xintseriesname package,
and finally a computation with a float. Some inputs are simplified by the use
of the \xintexprname package.

% There is also \xintcfracname for continued fractions computations.

{\color{magenta}&123456^99&: }\\
{\color{Purple}\csa{xintiPow}|{123456}{99}|}: \digitstt{\printnumber{\xintiPow {123456}{99}}}

{\color{magenta}1234/56789 with 1500 digits after the decimal point: }\\
{\color{Purple}\csa{xintTrunc}|{1500}{1234/56789}\dots|}: 
\digitstt{\printnumber {\xintTrunc {1500}{1234/56789}}\dots }

{\color{magenta}&0.99^{-100}& with 200 digits after the decimal point:}\\
{\color{Purple}\csa{xintTrunc}|{200}{\xinttheexpr .99^-100\relax}\dots|}:
\digitstt{\printnumber{\xintTrunc {200}{\xinttheexpr .99^-100\relax}}\dots }


{\color{magenta}Computation of a Bezout identity with  |7^200-3^200| and |2^200-1|:}\\
{\color{Purple}|\xintAssign\xintBezout|\\
\hspace*{2cm}|{\xintNum{\xinttheexpr 7^200-3^200\relax}}|\\
\hspace*{2cm}|{\xintNum{\xinttheexpr 2^200-1\relax}}\to\A\B\U\V\D|%
\centeredline{|\U$\times$(7^200-3^200)+\xintiOpp\V$\times$(2^200-1)=\D|}}%
\xintAssign\xintBezout {\xintNum{\xinttheexpr 7^200-3^200\relax}}{\xintNum{\xinttheexpr 2^200-1\relax}}\to\A\B\U\V\D
\digitstt{\printnumber\U$\times$(&7^200-3^200&)+\printnumber{\xintiOpp\V}$\times$(&2^200-1&)=\printnumber\D }

{\color{magenta}The Euclide algorithm applied to \np{179876541573} and
  \np{66172838904}:}\footnote{this example is computed tremendously faster than
  the
  other ones, but we had to limit the space taken by the output.}\\
{\color{Purple}|\xintTypesetEuclideAlgorithm {179876541573}{66172838904}|}
\xintTypesetEuclideAlgorithm {179876541573}{66172838904} \smallskip

{\color{magenta}$\sum_{n=1}^{500} (4n^2 - 9)^{-2}$ with each term rounded to
  twelve digits, and the sum to nine digits:} {\color{Purple}%
  |\def\coeff #1%|\\
  |   {\xintiRound {12}{1/\xintiSqr{\the\numexpr 4*#1*#1-9\relax }[0]}}|\\
  |\xintRound {9}{\xintiSeries {1}{500}{\coeff}[-12]}|:} \def\coeff #1%
{\xintiRound {12}{1/\xintiSqr{\the\numexpr 4*#1*#1-9\relax }[0]}} 
\digitstt{\xintRound {9}{\xintiSeries {1}{500}{\coeff}[-12]}}\endgraf 

The complete series, extended to
infinity, has value
$\frac{\pi^2}{144}-\frac1{162}={}$%
\digitstt{\np{0.06236607994583659534684445}\dots}\,%
\footnote{\label{fn:np}This number is typeset using the
  \href{http://www.ctan.org/pkg/numprint}{numprint} package, with
  \texttt{\detokenize{\npthousandsep{,\hskip .05em plus .01em minus .01em}}}.
  But the breaking accross 
  lines works only in text mode. The number itself was (of course...) computed
  initially with \xintname, with 30 digits of  $\pi$ as input.
  See 
  \hyperref[ssec:Machin]{{how \xintname may compute $\pi$
    from scratch}}.} I also used (this is a lengthier computation
than the one above) \xintseriesname to evaluate the sum with \np{100000} terms,
obtaining 16 
correct decimal digits for the complete sum. The
coefficient macro must be redefined to avoid a |\numexpr| overflow, as
|\numexpr| inputs must not exceed &2^31-1&; my choice
was: 
{\color{Purple}\dverb|& 
\def\coeff #1%
{\xintiRound {22}{1/\xintiSqr{\xintiMul{\the\numexpr 2*#1-3\relax}
                                       {\the\numexpr 2*#1+3\relax}}[0]}}
|}%


{\color{magenta}Computation of $2^{\np{999999999}}$ with |24| significant
  figures:}\\ 
{\color{Purple}|\xintFloatPow[24] {2}{999999999}|:}
\digitstt{\xintFloatPow[24] {2}{999999999}}


To see more of \xintname in action, jump to the
{\autoref{sec:series}} describing the commands of the
\xintseriesname{} package, especially as illustrated with the
\hyperref[ssec:Machin]{{traditional computations of $\pi$
    and $\log 2$}}, or also see the
{\hyperlink{e-convergents}{computation of the convergents
    of $e$}} made with the \xintcfracname package. 

Note that almost all of the computational results interspersed through the
documentation are not hard-coded in the source of the document but just written
there using the package macros, and were selected to not impact too much the
compilation time.

\subsection{Origins of the package}

Package |bigintcalc| by \textsc{Heiko Oberdiek} already
provides expandable arithmetic operations on ``big integers'',
exceeding the \TeX{} limits (of &2^{31}-1&), so why another\footnote{this section was written before the 
  \xintfracname package; the author is not aware of another package allowing
  expandable computations with arbitrarily big fractions.}
one?

I got started on this in early March 2013, via a thread on the
|c.t.tex| usenet group, where \textsc{Ulrich D\,i\,e\,z} used the
previously cited package together with a macro (|\ReverseOrder|)
which I had contributed to another thread.\footnote{the
  \csa{ReverseOrder} could be avoided in that circumstance, but it
  does play a crucial r\^ole here.} What I had learned in this
other thread thanks to interaction with \textsc{Ulrich D\,i\,e\,z} and
\textsc{GL} on expandable manipulations of tokens motivated me to
try my hands at addition and multiplication.

I wrote macros \csa{bigMul} and \csa{bigAdd} which I posted to the
newsgroup; they appeared to work comparatively fast. These first
versions did not use the \eTeX{} \csa{numexpr} primitive, they worked
one digit at a time, having previously stored carry-arithmetic in
1200 macros.

I noticed that the |bigintcalc| package used\csa{numexpr}
if available, but (as far as I could tell) not
to do computations many digits at a time. Using \csa{numexpr} for
one digit at a time for \csa{bigAdd} and \csa{bigMul} slowed them
a tiny bit but avoided cluttering \TeX{} memory with the 1200
macros storing pre-computed digit arithmetic. I wondered if some speed
could be gained by using \csa{numexpr} to do four digits at a time
for elementary multiplications (as the maximal admissible number
for \csa{numexpr} has ten digits).

The present package is the result of this initial questioning. 

\begin{framed}\centering
  \xintname requires the \eTeX{} extensions.
\end{framed}



\section{Expansions}

\SetInnerTocdepthTo {1}

Except for some specific macros dealing with assignments or typesetting, the
bundle macros all work in expansion-only context. For example, with the
following code snippet within |myfile.tex|:
\dverb|&
\newwrite\outfile
\immediate\openout\outfile \jobname-out\relax
\immediate\write\outfile {\xintQuo{\xintPow{2}{1000}}{\xintFac{100}}}
% \immediate\closeout\outfile
|
the tex run creates a file |myfile-out.tex|
containing the decimal representation of the integer quotient &2^{1000}/100!&.
Such macros can also be used inside a |\csname...\endcsname|, and
of course in an |\edef|.

\edef\x{\xintQuo{\xintPow {2}{1000}}{\xintFac{100}}}
\edef\y{\xintLen{\x}}

Furthermore the package macros give their final results in two expansion steps.
They expand `fully' (the first token of) their arguments so that they can be
arbitrarily chained. Hence \centeredline{%
  |\xintLen{\xintQuo{\xintPow{2}{1000}}{\xintFac{100}}}|} expands in two steps
and tells us that &[2^{1000}/100!]& has {\y} digits. This is not so many, let us
print them here: \digitstt{\printnumber\x}.

For the sake of typesetting this documentation and not have big numbers
extend into the margin and go beyond the page physical limits, I use
these commands (not provided by the package):
\dverb|&
\def\allowsplits #1{\ifx #1\relax \else #1\hskip 0pt plus 1pt \relax
                     \expandafter\allowsplits\fi}%
\def\printnumber #1{\expandafter\expandafter\expandafter
                    \allowsplits #1\relax }% 
% Expands twice before printing.
|

The |\printnumber| macro is not part of the package and would need additional
thinking for more general use.\footnote{as explained in
  \hyperref[fn:np]{a previous footnote},
  the |numprint| package may also be used, in text mode only (as the thousand
  separator seemingly ends up typeset in a |\string\hbox| when in math
  mode).} It may be used as |\printnumber 
{\xintQuo{\xintPow {2}{1000}}{\xintFac{100}}}|, or as |\printnumber\mynumber| if
the macro |\mynumber| was previously defined via an |\edef|, as for
example:\centeredline{ |\edef\mynumber {\xintQuo {\xintPow
      {2}{1000}}{\xintFac{100}}}|}% 
or as
  |\expandafter\printnumber\expandafter{\mynumber}|, if the macro |\mynumber| is
  defined by a |\newcommand| or a |\def| (see below {\autoref{item:xpxp}} for the
  underlying expansion issue; adding four |\expandafter|'s to |\printnumber|
  would allow to use it directly as |\printnumber\mynumber| with a |\mynumber|
  itself defined via a |\def| or |\newcommand|).


Just to show off, let's print 300 digits (after the decimal point) of
the decimal expansion of &0.7^{-25}&:\footnote{the |\string\np| typesetting
  macro 
  is from the |numprint| package.}
\centeredline{|\np {\xintTrunc {300}{\xinttheexpr .7^-25\relax}}\dots|}
\digitstt{\np {\xintTrunc {300}{\xinttheexpr .7^-25\relax}}\dots }

This computation uses the macro \csb{xintTrunc} from package \xintfracname
wich extends to fractions the basic arithmetic operations defined for
integers by \xintname. It also uses \csb{xinttheexpr} from package
\xintexprname, which allows to use standard notations. Note that the
fraction |.7^-25| is first evaluated exactly; for some more complex inputs,
such as |.7123045678952^-243|, the exact evaluation before truncation would
be expensive, and (assuming one needs twenty digits) one
would rather use floating mode:
\centeredline{|\xintDigits:=20;
               \np{\xintthefloatexpr .7123045678952^-243\relax}|}%
\xintDigits:=20;%
\centeredline{|.7123045678952^-243|${}\approx{}$%
\digitstt{\np{\xintthefloatexpr .7123045678952^-243\relax }}}

% 6.342,022,117,488,416,127,3  10^35
% maple n'aime pas ^-243 il veut les parenthèses, bon et il donne, en Digits
% = 24: 0.634202211748841612732270 10^36

\xintDigits:=16;

Important points, to be noted, related to the expansion of arguments:
\begin{enumerate}
\item the macros expand `fully' their arguments, this means that they expand
  the first token seen (for each argument), then expand
  \MyMarginNote{Changed in |1.06|}, etc..., until something un-expandable
  such as a\strut{} digit or a brace is hit against.\footnote{the
    knowledgeable people will have recognized
    \texttt{\string\romannumeral-\string`0}} This example
  \centeredline{|\def\x{98765}\def\y{43210}|%
    |\xintAdd {\x}{\x\y}|} is \emph{not} a legal construct, as the |\y| will
  remain untouched by expansion and not get converted into the digits which
  are expected by the sub-routines of |\xintAdd|. It is a |\numexpr|
  which will expand it and an arithmetic overflow will arise as |9876543210|
  exceeds the \TeX{} bounds.

  \begingroup\slshape
  The |1.07| novelty\MyMarginNote{New with |1.07|} \csb{xinttheexpr} has brought
  a solution: here one would write |\xinttheexpr \x+\x\y\relax|, or
  |\xintAdd\x{\xinttheexpr\x\y\relax}|.\hfill
  \endgroup

\item Unfortunately, after |\def\x {12}|, one can not use just
  {\color{blue}|-\x|} as input to one of the package macros: the rules above
  explain that the expansion will act only on the minus sign,
  hence do nothing. The only way is to use the \csb{xintOpp}
  macro, which replaces a number with its opposite.

  \begingroup\slshape
  Again, this is otherwise inside an \csb{xinttheexpr}-ession or
  \csb{xintthefloatexpr}-ession. There,\MyMarginNote{New with |1.07|} the
  minus sign may prefix macros which will expand to numbers (or parentheses
  etc...)
  \endgroup

\def\x {12}%
\def\AplusBC #1#2#3{\xintAdd {#1}{\xintMul {#2}{#3}}}%


\item \label{item:xpxp} With the definition \centeredline{%
    |\def\AplusBC #1#2#3{\xintAdd {#1}{\xintMul {#2}{#3}}}|} one
  obtains an expandable macro producing the expected result, not
  in two, but rather in three steps: a first expansion is consumed
  by the macro expanding to its definition. The new expansion policy starting
  with the package
  release |1.06| allows to use this inside other 
  package `primitives' or also similar macros: {|\xintAdd
    {\AplusBC {1}{2}{3}}{4}|} does work and returns \digitstt{\xintAdd
    {\AplusBC {1}{2}{3}}{4}}.\footnote{this strange thing is because this
    document uses \xintfracname, and we have printed the raw output of addition
    which is automatically a fraction.}

  If, for some reason, it is important to create a macro expanding in two steps
  to its final value, the solution is to use the \emph{lowercase} form of
  \csa{xintAdd}: \smallskip\centeredline {|\def\AplusBC
    #1#2#3{|{\color{blue}|\romannumeral0\xintadd |}|{#1}{\xintMul {#2}{#3}}}|}
  
  and then \csa{AplusBC} will share the same properties as do the
  other \xintname `primitive' macros.


  The lowercase form is \emph{only} for the external highest level of chained
  commands. All \xintname provided public macros have such a lowercase form. To
  more fully imitate the \xintname standard habits, the example above should
  thus be treated via the creation of two macros:\par\parskip0pt
  \hspace*{1cm}|\def\aplusbc #1#2#3{\xintadd {#1}{\xintMul {#2}{#3}}}|\par
  \hspace*{1cm}|\def\AplusBC {\romannumeral0\aplusbc}|\par
  Or, for people using the \LaTeX{} vocabulary:\par
  \hspace*{1cm}|\newcommand*{\aplusbc}[3]{\xintadd {#1}{\xintMul
      {#2}{#3}}}|\par 
  \hspace*{1cm}|\newcommand*{\AplusBC}{\romannumeral0\aplusbc}|\par

  This then allows further definitions of macros expanding in two steps only,
  such as:\par
  |\def\aplusbcsquared #1#2#3{\aplusbc {#1}{#2}{\xintSqr{#3}}}|\par
  |\def\AplusBCSquared {\romannumeral0\aplusbcsquared}|\par
  |\newcommand*\myalgebra [6]{\xintmul {\AplusBC {#1}{#2}{#3}}{\AplusBC
      {#4}{#5}{#6}}}|\par
  |\newcommand*\MyAlgebra {\romannumeral0\myalgebra}|\par
\end{enumerate}

The |\romannumeral0| things above look like an invitation to hacker's
territory; if it is not important that the macro expands in two steps only,
there is no reason to follow these guidelines. Just chain arbitrarily the
package macros, and the new ones will be completely expandable and usable one
within the other.

Release |1.07| has the \csb{xintNewExpr} command\MyMarginNote{New with
  |1.07|} which automatizes the creation of such expandable macros:
\centeredline{|\xintNewExpr\AplusBC[3]{_1+_2*_3}|} creates the |\AplusBC|
macro doing the above and expanding in two expansion steps.


\section {Inputs and outputs}\label{sec:inputs}

The core bundle constituents are \xintname, \xintfracname, \xintexprname,
each one loading its predecessor. The base constituent \xintname only deals
with integers, of arbitrary sizes, and apart from its macro \csb{xintNum},
the input format is rather strict. Then \xintfracname extends the scope to
fractions: numerators and
denominators are separated by a forward slash and may contain each an
optional fractional part after the decimal mark (which has to be a dot) and a
scientific part\MyMarginNote{New with |1.07|} (with a lower case |e|).


The numeric arguments to the bundle macros may be of various types,
extending in generality:

\begin{enumerate}
\item `short' integers, \emph{i.e.} less than (or equal to) in absolute value
  \np{\xintiSub{\xintiPow {2}{31}}1}. I will refer to this as the `\TeX{}' or
  `|\numexpr|' limit. This is the case for arguments which serve to count or
  index something. It is also the case for the exponent in the power function
  and for the argument to the factorial function. The bounds have been
  (arbitrarily) lowered to \np{999999999} and \np{999999} respectively for the
  latter cases.\footnote{the float power function limits the exponent to the
    \TeX{} bound, not |999999999|, and it has a variant with no imposed limit on
    the exponent; but the result of the computation must in all cases be
    representable with a power of ten exponent obeying the \TeX{} bound.} When
  the argument exceeds the \TeX{} bound (either positively or negatively), an
  error will originate from a \csa{numexpr} expression and it may sometimes be
  followed by a more specific error `message' from a package macro.
\item `long' integers, which are the bread and butter of the package commands.
  They are signed integers with an illimited number of digits.
  Theoretically though, most of the macros require that the number of digits
  itself be less than the \TeX-\csa{numexpr} bound.\footnote{and to be very
    precise, less than the \TeX{} bound minus eight, due to the way the length
    is evaluated.}
  Some macros, such as addition when \xintfracname has not been loaded, do not
  measure first the length of their arguments and could theoretically be used
  with `gigantic' integers with a larger number of digits. However memory
  constraints from the \TeX{} implementation probably exclude such inputs.
  Concretely though, multiplying out two 1000 digits numbers is already a
  longish operation.
\item `fractions': they become available after having loaded the \xintfracname
  package. Their format on input will be described next, a fraction has a
  numerator, a forward slash and then a denominator.\MyMarginNote{New with
    |1.07|} It is now possible to use scientific notation, with a lowercase
  |e| on input (an uppercase |E| is accepted inside the |\xintexpr|-essions).
  The decimal mark must be a dot and not a comma. No separator for thousands
  should be used on inputs, and except within |\xintexpr|-essions, spaces
  should be avoided.
\end{enumerate}

\begin{framed}
  With only package \xintname loaded \TeX{}'s count registers must be prefixed
  by |\the| or |\number| inside the arguments to the package macros, except in
  places (argument of the factorial, exponent of the power function, ...) where
  the documentation of the macro says otherwise. 

  With the macros\MyMarginNote[\kern\FrameSep\kern\FrameRule]{Not previously
    documented} of \xintfracname (including those of \xintname extended to 
  fractions) a count register is \emph{accepted} on input, with no need to be
  prefixed by |\the| or |\number|.

  Inside |\xinttheexpr...\relax|, count registers must again be prefixed by
  |\the| or 
  |\number| (if they are not arguments to macros of \xintfracname).
\end{framed}


\edef\z {\xintAdd
    {+--0367.8920280/-++278.289287}{-109.2882/+270.12898}}

  The package macros first operate a `full' expansion\MyMarginNote{New with
    |1.06|} of their \strut{} arguments, as explained above: only the first
  token is repeatedly expanded until no more is possible.

  On the other hand, this expansion is a\MyMarginNote{New with |1.06|} complete
  one for those arguments which are constrained to obey the \TeX{} bounds on
  numbers, as they are systematically inserted inside a |\numexpr...\relax|
  expression.


The allowed input formats for `long numbers' and `fractions' are:
\begin{enumerate}
\item the strict format is when \xintfracname is not loaded. The number should
  be a string of digits, optionally preceded by a unique minus sign. The first
  digit can be zero only if the number is zero. A plus sign is not accepted.
  There is a macro \csb{xintNum} which normalizes to this form an input having
  arbitrarily many minus and plus signs, followed by a string of zeros, then
  digits:\centeredline{|\xintNum
  {+-+-+----++-++----00000000009876543210}|\digitstt{=\xintNum
    {+-+-+----++-++----0000000009876543210}}}%
  Note that |-0| is not legal input and will confuse \xintname (but not
  \csa{xintNum} which even accepts an  empty input).
\item the extended format is with \xintfracname is loaded: the macros are
  extended from operating on integers to operating on fractions, which are input
  as (or expand to) |A/B| (or just an integer |A|), where |A| and |B| will be
  automatically given to the sign and zeros normalizing macro \csb{xintNum}.
  Each of |A| and |B| may be decimal numbers: with a decimal point and 
  digits following it. Here is an example: \centeredline{|\xintAdd
    {+--0367.8920280/-++278.289287}{-109.2882/+270.12898}|}%
  Incidentally this evaluates to \centeredline{\digitstt{=\z}}%
  \centeredline{\digitstt{=\xintIrr\z{} (irreducible)}}%
  \centeredline{\digitstt{=\xintTrunc {50}{\z}\dots}}%
  where the second line was produced with |\xintIrr| and the next with
  |\xintTrunc {50}| to get fifty digits of the decimal expansion following the
  decimal mark. Scientific notation\MyMarginNote{New with |1.07|} is accepted on
  input both for the numerators and denominators of fractions, and is produced
  on output by \csb{xintFloat}: \centeredline{|\xintAdd{10.1e1}{101.010e3}|%
    \digitstt{=\xintAdd{10.1e1}{101.010e3}}}%

  \centeredline{|\xintRaw{1.234e5/6.789e3}|\digitstt{=\xintRaw{1.234e5/6.789e3}}}%
  \centeredline{|\xintFloat[24]{1/66049}|\digitstt{=\xintFloat[24]{1/66049}}}
\end{enumerate}
Of course, even when \xintfracname is loaded, some macros can not treat
fractions on input. Starting with release |1.05| most of them have also been
extended to accept the relaxed format on input as long as the fraction actually
represents an integer. For example it used to be the case with the earlier
releases that |\xintQuo {100/2}{12/3}| would not work (the macro \csb{xintQuo}
computes a euclidean quotient). It now does, because its arguments are in truth
integers.

A number can start directly with a decimal point:
\centeredline{|\xintPow{-.3/.7}{11}|\digitstt{=\xintPow{-.3/+.7}{11}}}%
\centeredline{|\xinttheexpr (-.3/.7)^11\relax|%
               \digitstt{=\xinttheexpr (-.3/.7)^11\relax}}
It is also licit to use |\A/\B| as input if each of |\A| and |\B| expands (in
the sense previously described) to a ``decimal number'' as examplified above by
the numerators and denominators (thus, possibly with a `scientific' exponent
part, with a lowercase `e'). Or one may have just one macro |\C| which
expands to such a ``fraction with optional decimal points'', or mixed things
such as |\A 245/7.77|, where the numerator will be the concatenation of the
expansion of |\A| and |245|. But, as explained already |123\A| is a no-go,
\emph{except inside an |\string\xintexpr|-ession}!

Finally, after the decimal point there may be |eN| where |N| is a positive
or negative number (obeying the \TeX{} bounds on
integers).\MyMarginNote{New with |1.07|} This `|e|' part (which must be in
lowercase, except inside |\xintexpr|-essions) may appear both at the numerator
and at the denominator. \centeredline{|\xintRaw
  {+--+1253.2782e++--3/---0087.123e---5}|\digitstt{=\xintRaw
    {+--+1253.2782e++--3/---0087.123e---5}}}

\hypertarget{useofcount}{\paragraph{Use of count registers:}} when\MyMarginNote{New
  documentation section (|1.08b|)} an argument
to a macro is said in the documentation to have to obey the \TeX{} bound, this
means that it is fed to a |\numexpr...\relax|, hence it is subjected to a
complete expansion which must delivers an integer, and count registers and even
algebraic expressions with them like
|\mycountA+\mycountB*17-\mycountC/12+\mycountD| are admissible arguments (the
slash stands here for the integer (rounded) division done by |\numexpr|). This
applies in particular to the number of digits to truncate or round with, to the
indices of a series partial sum, \dots

With \xintfracname.sty loaded and for arguments of macros accepting fractions on
inputs, use\MyMarginNote{Not previously documented} of count
registers and even direct algebra with them is possible: a count register
|\mycountA| or |\count 255| is admissible as numerator or also as denominator,
with no need to be prefixed by |\the| or |\number|. It is even possible to have
algebraic expressions, with the limitation (how to overcome it in complete
generality will be explained later) that each of the numerator and
denominator should be expressed with at most \emph{eight} tokens, and the
forward slash symbol must be protected by braces to be used inside the
|\numexpr| and not be interpreted as the fraction slash. Note that |\mycountA|
is 
one token but |\count 255| is four tokens. Example:
|\mycountA+\mycountB{/}17/1+\mycountA*\mycountB|, or |\count 0+\count
2{/}17/1+\count 0*\count 2|, but in the latter case the numerator has
the maximal allowed number of tokens (the braced slash counts for only one).
\centeredline{|\cnta 10 \cntb 35 \xintRaw
  {\cnta+\cntb{/}17/1+\cnta*\cntb}|\digitstt{->\cnta 10 \cntb 35 \xintRaw
    {\cnta+\cntb{/}17/1+\cnta*\cntb}}}

This possibility of using directly count registers and even algebraic expression
is only for arguments to macros of \xintfracname: inside |\xintexpr...\relax|
one can not use directly a count register, it must be prefixed by |\the| or
|\number|. And with only \xintname.sty is loaded, the \emph{only} macro allowing
the
above is \csb{xintNum}:  
\centeredline{|\cnta 10 \cntb 100 \xintNum
  {\cnta+\cntb+\cnta*\cntb}|\digitstt{->\cnta 10 \cntb 100 \xintNum
    {\cnta+\cntb+\cnta*\cntb}}} 
Note that |\cnta+\cntb+2*\cnta*\cntb| would be too long (it has nine tokens).
Using braces works:
\centeredline{|\cnta 10 \cntb 100 \xintNum
  {\cnta+\cntb+{2*\cnta*\cntb}}|\digitstt{->\cnta 10 \cntb 100 \xintNum
    {\cnta+\cntb+{2*\cnta*\cntb}}}} 
The braces should be used for some sub-part of the expression, not for the
entire thing; alternatively, one can always use |\numexpr {arbitrarily long
  expression}\relax| as input:
\dverb|&
\cnta 100 \cntb 10 \cntc 1 
\xintRaw {\numexpr {\cnta*\cnta+\cntb*\cntb+\cntc*\cntc+
                    2*\cnta*\cntb+2*\cnta*\cntc+2*\cntb*\cntc}\relax/%
          \numexpr {\cnta*\cnta+\cntb*\cntb+\cntc*\cntc}\relax }|
\cnta 100 \cntb 10 \cntc 1 
\centeredline{\digitstt{\xintRaw {\numexpr {\cnta*\cnta+\cntb*\cntb+\cntc*\cntc+
                    2*\cnta*\cntb+2*\cnta*\cntc+2*\cntb*\cntc}\relax/%
          \numexpr {\cnta*\cnta+\cntb*\cntb+\cntc*\cntc}\relax }}}
    \begin{framed}
      Macros expecting fractions may be fed with arbitrarily long
      |\numexpr|-expressions by the trick of using 
      |\numexpr {long_expression}\relax| as numerator and/or denominator of the
      argument to the macro. 

      Macros expecting an
      integer obeying the \TeX{} bound must to the contrary receive directly
      |long_expression| as argument (or |\numexpr long_expression\relax|, but
      this is redundant as it will be done by the macro itself.)
    \end{framed}
This is a trick as the braces would not be accepted as regular
|\numexpr|-syntax: and indeed, they
        are removed at some point in the processing.

\paragraph {Outputs: } loading \xintfracname not only relaxes the format of the
inputs; it also modifies the format of the outputs: except when a fraction is
filtered on output by \csb{xintIrr} (and \csb{xintJrr}) or
\csb{xintRawWithZeros}, or by the truncation or rounding macros, it will always
be in the \fbox{|A/B[n]|} form (which stands for |(A/B)|$\times$|10^n|). The |A| and
|B| may end in zeros (\emph{i.e}, |n| does not represent all powers of ten), and
will generally have a common factor. The denominator |B| is always strictly
positive.

A macro \csb{xintFrac} is provided
for the typesetting (math-mode only) of such a `raw' output. Of course, the
\csb{xintFrac} itself is not accepted as input to the package macros.

Direct user input of things such as |16000/289072[17]| or |3[-4]| is authorized.
It is even possible to use |\A/\B[17]| if |\A| expands to |16000| and |\B| to
|289072|, or |\A| if |\A| expands to |3[-4]|. However,%\IMPORTANT{}
\MyMarginNote{Important! }
NEITHER the numerator NOR 
the denominator may then have a decimal
point. And, for this format, ONLY the numerator may carry
a UNIQUE minus sign (and no superfluous leading zeros; and NO plus sign).
This format with a power of ten represented by a number within
  square brackets is the output format used by (almost all) \xintfracname
  macros dealing with fractions.
  It is allowed for user input but the parsing is minimal and it
  is very important to follow the above rules. This reduced
  flexibility, compared to the format without the square brackets,
  allows chaining package macros without too much speed impact, as
  they always output computation results in the |A/B[n]| form. 

  \begin{framed}
    All computations done by \xintfracname on fractions are exact. Inputs
    containing decimal points or scientific parts do not make the package switch
    to a `floating-point' mode. The inputs, however long, are always converted
    into exact internal representations.

    Floating point evaluations are done with special macros containing
    `Float' in their names, or inside |\xintthefloatexpr|-essions.
  \end{framed}

Generally speaking, there should be no spaces among the digits in the inputs
(in arguments to the package macros).
Although most would be harmless in most macros, there are some cases
where spaces could break havoc. So the best is to avoid them entirely.

This is entirely otherwise inside an |\xintexpr|-ession, where spaces are
expected to, as a general rule (with possible exceptions related to the
allowed use of braces, see the
\hyperref[sec:comexpr]{documentation}) be completely
harmless, and even recommended for making the source more legible.

Syntax such as |\xintMul\A\B|
is accepted and equivalent\footnote{see however near the end of
  \hyperref[sec:ifcase]{this later section} for the important
  difference when used in contexts where \TeX{} expects a number, such as
  following an \csa{ifcase} or an \csa{ifnum}.} to |\xintMul {\A}{\B}|. Or
course |\xintAdd\xintMul\A\B\C| does not work, the product operation must be put
within braces: |\xintAdd{\xintMul\A\B}\C|.
It would be nice to have a functional form |\add(x,\mul(y,z))| but
this is not provided by the package. Arguments must be either
within braces or a single control sequence.

Note that |-| and |+| may serve only as unary operators, on \emph{explicit}
numbers. They can not serve to prefix macros evaluating to such numbers,
\emph{except inside an |\string\xintexpr|-ession.}

\section{More on fractions}

With package \xintfracname loaded, the routines \csb{xintAdd}, \csb{xintSub},
\csb{xintMul}, \csb{xintPow}, \csb{xintSum}, \csb{xintPrd} are modified to allow
fractions on input,\footnote{of course, the power function does not accept a
  fractional exponent. Or rather, does not expect, and errors will result if one
  is provided.}\,\footnote{macros \csb{xintiAdd}, \csb{xintiSub},
  \csb{xintiMul}, \csb{xintiPow}, \csb{xintiSum}, \csb{xintiPrd} are the
  original ones dealing only with integers. They are available as synonyms, also
  when \xintfracname is not loaded. }\,\footnote{also \csb{xintCmp},
  \csb{xintSgn}, \csb{xintOpp}, \csb{xintAbs}, \csb{xintMax}, \csb{xintMin} are
  extended to fractions and have their integer-only initial
  synonyms.}\,\footnote{and \csb{xintQuo}, \csb{xintRem}, \csb{xintDivision},
  \csb{xintGeq}, \csb{xintFDg}, \csb{xintLDg}, \csb{xintOdd}, \csb{xintMON},
  \csb{xintMMON} all accept a fractional input as long as it reduces to an
  integer.} and produce on output a
fractional number |f=A/B[n]| where |A| and |B| are integers, with |B| positive,
and |n| is a signed ``small'' integer (\emph{i.e} less in absolute value than
|2^{31}-9|). This represents |(A/B)| times |10^n|. The fraction |f| may be, and
generally is, reducible, and |A| and |B| may well end up with zeros (\emph{i.e.}
|n| does not contain all powers of 10). Conversely, this format is accepted on
input (and is parsed more quickly than fractions containing decimal points; the
input may be a number without denominator).\footnote{at each stage of the
  computations, the sum of |n| and the length of |A|, or of the absolute value
  of |n| and the length of |B|, must be kept less than
  |2\string^\string{31\string}-9|.}

The \csb{xintiAdd}, \csb{xintiSub}, \csb{xintiMul}, \csb{xintiPow},
\csb{xintiSum}, \csb{xintiPrd}, etc... are the original un-modified integer-only
versions. They have less parsing overhead.



The macro \csb{xintRaw} prints\MyMarginNote{Changed in |1.07|} the fraction 
directly from its internal representation in |A/B[n]| form. To convert
the trailing |[n]| into explicit zeros either at the numerator or the
denominator, use \csb{xintRawWithZeros}. In both cases the |B| is printed
even if it has value |1|.

Conversely (sort of), the macro \csb{xintREZ}
 puts all powers of ten into the |[n]| (REZ stands for remove zeros).
Here also, the |B| is printed even if it has value |1|.

The macro \csb{xintIrr} reduces the fraction to its irreducible form |C/D|
(without a trailing |[0]|), and\MyMarginNote{Changed in |1.08|} it prints
the |D| even if |D=1|. 

The macro \csb{xintNum} from package \xintname is extended: it now does like
\csa{xintIrr}, raises an error if the fraction did not reduce to an integer, and
outputs the numerator. This macro
should be used when one knows that necessarily the result of a computation is an
integer, and one wants to get rid of its denominator |/1| which would be left by
\csa{xintIrr}.


The macro \csb{xintTrunc}|{N}{f}| prints\footnote{`prints' does not at all mean
  that this macro is designed for typesetting; I am just using the verb here in
  analogy to the effect of the functioning of a computing software in console
  mode. The package does not provide any `printing' facility, besides its
  rudimentary \csb{xintFrac} and \csb{xintFwOver} math-mode only macros. To deal
  with really long numbers, some macros are necessary as \TeX{} by default will
  print a long number on a single line extending beyond the page limits. The
  \csa{printnumber} command used in this documentation is just one way to
  address this problem, some other method should be used if it is important that
  digits occupy the same width always.} the decimal expansion of |f| with |N|
digits after the decimal point.\footnote{the current release does not provide a
  macro to get the period of the decimal expansion.} Currently, it does not
verify that |N| is non-negative and strange things could happen with a negative
|N|. Of course a negative |f| is no problem, needless to say. When the original
fraction is negative and its truncation has only zeros, it is printed as
|-0.0...0|, with |N| zeros following the decimal point:
\centeredline{|\xintTrunc {5}{\xintPow {-13}{-9}}|\digitstt{=\xintTrunc
    {5}{\xintPow {-13}{-9}}}}%
\centeredline{|\xintTrunc {20}{\xintPow {-13}{-9}}|\digitstt{=\xintTrunc
    {20}{\xintPow {-13}{-9}}}} The output always contains a decimal point (even
for |N=0|) followed by |N| digits, except when the original fraction was zero.
In that case the output is |0|, with no decimal point. \centeredline{|\xintTrunc
  {10}{\xintSum {{1/2}{1/3}{1/5}{-31/30}}}|%
  \digitstt{=\xintTrunc {10}{\xintSum {{1/2}{1/3}{1/5}{-31/30}}}}}

% The output of \csb{xintTrunc} may of course serve as input to the other
% macros. And this is almost necessary when summing hundreds of
% terms of a series with fractional coefficients, as the exact
% rational number quickly becomes quite big (when doing the sum from
% |n=|1 to |n=|1000 of |1/n|, the raw denominator is &1000!&, which
% has 2568 digits) ; but for less than fifty terms with small
% denominators it is often possible to work with the exact
% value without too much toll on the compilation time. 

% The macro \csb{xintiTrunc}|{N}{f}| is like \csa{xintTrunc}|{N}{f}|
% followed by multiplication by |10^N|. Thus, it outputs an integer
% in a format acceptable by the integer-only macros. This is also
% convenient when computing partial sums of series, with a fixed number of
% digits after the decimal point: it is a bit
% faster to sum with \csb{xintiSeries} the integers produced by
% \csa{xintiTrunc}|{N}| than it is to use the general
% \csb{xintSeries} on the decimal numbers produced by
% \csa{xintTrunc}|{N}|. These latter macros belong to the \xintseriesname
% package.

% Needless to say when using \csa{xintTrunc} or \csa{xintiTrunc} on
% intermediate computations the ending digits of the final result
% are, pending further analysis, only indications of those of the
% fraction an exact computation would have produced.

\edef\z {\xintPow {1.01}{100}}

The macro \csb{xintiTrunc}|{N}{f}| is like \csa{xintTrunc}|{N}{f}|
followed by multiplication by |10^N|. Thus, it outputs an integer
in a format acceptable by the integer-only macros. 
To get the integer part of the decimal expansion of |f|, use
|\xintiTrunc{0}{f}|: \centeredline{|\xintiTrunc {0}{\xintPow
    {1.01}{100}}|\digitstt{=\xintiTrunc {0}\z}}%
\centeredline{|\xintiTrunc {0}{\xintPow{0.123}{-10}}|\digitstt{=\xintiTrunc
    {0}{\xintPow{0.123}{-10}}}}

See also the documentations of \csb{xintRound}, \csb{xintiRound} and
\csb{xintFloat}.

\section{\csh{ifcase}, \csh{ifnum}, ... constructs}\label{sec:ifcase}

When using things such as |\ifcase \xintSgn{\A}| one has to leave
a space after the closing brace for \TeX{} to
stop its scanning for a number: once \TeX{} has finished expanding
|\xintSgn{\A}| and has so far obtained either |1|, |0|, or |-1|, a
space (or something `unexpandable') must stop it looking for more
digits. Using |\ifcase\xintSgn\A| without the braces is very dangerous,
because the blanks (including the end of line) following |\A| will be
skipped and not serve to stop the number which |\ifcase| is looking for.
With |\def\A{1}|:
\dverb|&
\ifcase \xintSgn\A   0\or OK\else ERROR\fi   ---> gives ERROR
\ifcase \xintSgn{\A} 0\or OK\else ERROR\fi   ---> gives OK
|
% \def\A{1}
% \ifcase \xintSgn\A   0\or OK\else ERROR\fi\ 
% \ifcase \xintSgn{\A} 0\or OK\else ERROR\fi

Release |1.07| provides the expandable\MyMarginNote{New with |1.07|}
\csb{xintSgnFork} which chooses one of three branches according to whether its
argument expand to |-1|, |0| or |1|. This, rather than the corresponding
|\ifcase|, should be used when such a fork is needed as argument to one of the
package macros.


\section{Multiple outputs}\label{sec:multout}

Some macros have an output consisting of more than one number, each one is then
within braces. Examples of multiple-output macros are \csb{xintDivision} which
gives first the quotient and then the remainder of euclidean division,
\csb{xintBezout} from the \xintgcdname package which outputs five numbers,
\csb{xintFtoCv} from the \xintcfracname package which returns the list of the
convergents of a fraction, ... the next two sections explain ways to deal,
expandably or not, with such outputs.

See the \autoref{xintDecSplit} for a rare example of a bundle macro which may
return an empty string, or a number prefixed by a chain of zeros. This is the
only situation where a macro from the package \xintname may output something
which could require parsing through \csa{xintNum} before further processing by
the other (integer-only) package macros from \xintname.


\section{Assignments}

\xintAssign\xintBezout{357}{323}\to\tmpA\tmpB\tmpU\tmpV\tmpD

It might not be necessary to maintain at all times complete
expandability. For example why not allow oneself the two definitions
|\edef\A {\xintQuo{100}{3}}| and |\edef\B {\xintRem {100}{3}}|. A special
  syntax is provided to make these things more efficient, as the package
  provides 
 \csa{xintDivision} which computes both quotient and
  remainder at the same time:
  \centeredline{\csb{xintAssign}\csa{xintDivision}|{100}{3}|\csbnolk{to}|\A\B|}
  \centeredline{\csb{xintAssign}\csa{xintDivision}%
|{\xintiPow {2}{1000}}{\xintFac{100}}|\csbnolk{to}|\A\B|} gives
\xintAssign\xintDivision{\xintiPow {2}{1000}}{\xintFac{100}}\to\A\B
|\meaning\A|\digitstt{: \expandafter\allowsplits\meaning\A\relax} and
|\meaning\B|\digitstt{: \expandafter\allowsplits\meaning\B\relax}. 


  Another example (which uses a macro from the \xintgcdname
  package):
  \centeredline{\csb{xintAssign}\csa{xintBezout}|{357}{323}|%
    \csbnolk{to}|\A\B\U\V\D|} is equivalent to setting |\A| to
  \digitstt{\tmpA}, |\B| to \digitstt{\tmpB}, |\U| to \digitstt{\tmpU},
  |\V| to \digitstt{\tmpV}, and |\D| to \digitstt{\tmpD}. And indeed
  \digitstt{(\tmpU)$\times$\tmpA-(\tmpV)$\times$\tmpB$=$%
   \xintiSub{\xintiMul\tmpU\tmpA}{\xintiMul\tmpV\tmpB}}
  is a Bezout Identity.

\xintAssign\xintBezout{3570902836026}{200467139463}\to\tmpA\tmpB\tmpU\tmpV\tmpD
\centeredline{\csb{xintAssign}\csa{xintBezout}|{3570902836026}{200467139463}|%
    \csbnolk{to}|\A\B\U\V\D|} gives then |\U|\digitstt{:
    \expandafter\allowsplits\meaning\tmpU\relax},
  |\V|\digitstt{: 
    \expandafter\allowsplits\meaning\tmpV\relax} and |\D|\digitstt{=\tmpD}.

  When one does not know in advance the number of tokens, one can use
  \csa{xintAssignArray} or its synonym \csa{xintDigitsOf}:
  \centeredline{\csb{xintDigitsOf}\csa{xintiPow}|{2}{100}|\csbnolk{to}\csa{Out}}
  This defines \csa{Out} to be macro with one parameter, \csa{Out}|{0}| gives
  the size |N| of the array and \csa{Out}|{n}|, for |n| from |1| to |N| then
  gives the |n|th element of the array, here the |n|th digit of &2^{100}&, from
  the most significant to the least significant. As usual, the generated macro
  \csa{Out} is completely expandable (in two steps). As it wouldn't make much
  sense to allow indices exceeding the \TeX{} bounds, the macros created by
  \csb{xintAssignArray} put their argument inside a
  \csa{numexpr},\MyMarginNoteWithBrace{Changed in |1.06|}
   so it is completely expanded and
may be a count register, not necessarily prefixed by |\the| or |\number|.
Consider the following code snippet:
\dverb+&
\newcount\cnta
\newcount\cntb
\begingroup
\xintDigitsOf\xintiPow{2}{100}\to\Out
\cnta = 1
\cntb = 0
\loop
\advance \cntb \xintiSqr{\Out{\cnta}}
\ifnum \cnta < \Out{0}
\advance\cnta 1
\repeat

|2^{100}| (=\xintiPow {2}{100}) has \Out{0} digits and the sum of
their squares is \the\cntb. These digits are, from the least to
the most significant: \cnta = \Out{0} 
\loop \Out{\cnta}\ifnum \cnta > 1 \advance\cnta -1 , \repeat.
\endgroup
+

\edef\z{\xintiPow {2}{100}}

\begingroup
\xintDigitsOf\z\to\Out
\cnta = 1
\cntb = 0
\loop
\advance \cntb \xintiSqr{\Out{\cnta}}
\ifnum \cnta < \Out{0}
\advance\cnta 1
\repeat

&2^{100}& (=\z) has \Out{0} digits and the sum of
their squares is \the\cntb. These digits are, from the least to
the most significant: \cnta = \Out{0} 
\loop \Out{\cnta}\ifnum \cnta > 1 \advance\cnta -1 , \repeat.
\endgroup

We used a group in order to release the memory taken by the
\csa{Out} array: indeed internally, besides \csa{Out} itself,
additional macros are defined which are \csa{Out0}, \csa{Out00},
\csa{Out1}, \csa{Out2}, ..., \csa{OutN}, where |N| is the size of
the array (which is the value returned by |\Out{0}|; the digits
are parts of the names not arguments). 

The command \csb{xintRelaxArray}\csa{Out} sets all these macros to
\csa{relax}, but it was simpler to put everything withing a group.

Needless to say \csb{xintAssign}, \csb{xintAssignArray} and
\csb{xintDigitsOf} do not do any check on whether the macros they
define are already defined.

In the example above, we deliberately broke all rules of complete
expandability, but had we wanted to compute the sum of the digits,
not the sum of the squares, we could just have written:
\centeredline{\csb{xintiSum}|{\xintiPow{2}{100}}|\digitstt{=%
    \xintiSum\z}} Indeed, \csa{xintiSum} is usually
used as in \centeredline{%
  \csb{xintiSum}|{{123}{-345}{\xintFac{7}}{\xintiOpp{\xintRem{3347}{591}}}}|%
                 \digitstt{=%
    \xintiSum{{123}{-345}{\xintFac{7}}{\xintiOpp{\xintRem{3347}{591}}}}}}
but in the example above each digit of &2^{100}& is treated as
would have been a summand enclosed within braces, due to the rules
of \TeX{} for parsing macro arguments.

Note that |{-\xintRem{3347}{591}}| is not a valid input, because
the expansion will apply only to the minus sign and leave
unaffected the |\xintRem|. So we used \csa{xint}\-|iOpp| which replaces
a number with its opposite.


As a last example with \csa{xintAssignArray} here is one line
extracted from the source code of the \xintgcdname macro
\csb{xintTypesetEuclideAlgorithm}:
\centeredline{|\xintAssignArray\xintEuclideAlgorithm
  {#1}{#2}\to\U|}
This is done inside a group. After this command |\U{1}| contains
the number |N| of steps of the algorithm (not to be confused with
|\U{0}=2N+4| which is the number of elements in the |\U| array),
and the GCD is to be found in |\U{3}|, a convenient location
between |\U{2}| and |\U{4}| which are (absolute values of the
expansion of) the
initial inputs. Then follow |N| quotients and remainders
from the first to the last step of the algorithm. The
\csa{xintTypesetEuclideAlgorithm} macro organizes this data
for typesetting: this is just an example of one way to do it. 

\section{Utilities for expandable manipulations}

The\MyMarginNote{Extended in |1.06|} package now has more utilities to deal
expandably with `lists of things', which were treated un-expandably in the
previous section with \csa{xintAssign} and \csa{xintAssignArray}: \csb{xintRev},
\csb{xintReverseOrder}, \csb{xintLen} and \csb{xintLength} since the first
release, \csb{xintApply} and \csb{xintListWithSep} since |1.04|,
\csb{xintRevWithBraces}, \csb{xintCSVtoList}, \csb{xintNthElt} with |1.06|, and
\csb{xintApplyUnbraced}, new with |1.06b|.

\edef\z{\xintiPow {2}{100}}

As an example the following code uses only expandable operations:
\dverb+&
|2^{100}| (=\xintiPow {2}{100}) has \xintLen{\xintiPow {2}{100}}} digits 
and the sum of their squares is  
\xintiSum{\xintApply {\xintiSqr}{\xintiPow {2}{100}}}. 
These digits are, from the least to the most significant: 
\xintListWithSep {, }{\xintRev{\xintiPow {2}{100}}}. The thirteenth most
significant digit is \xintNthElt{13}{\xintiPow {2}{100}}. The seventh 
least significant one is \xintNthElt{7}{\xintRev{\xintiPow {2}{100}}}.
+
|2^{100}| (=\z) has \xintLen{\z} digits and the sum of
their squares is \xintiSum{\xintApply\xintiSqr\z}. These digits are, from the
least to the most significant: \xintListWithSep {, }{\xintRev\z}.  The
thirteenth most 
significant digit is \xintNthElt{13}{\z}. The seventh 
least significant one is \xintNthElt{7}{\xintRev\z}. 

% The
% thirteenth most 
% significant digit is \xintNthElt{13}{\xintiPow {2}{100}}. The seventh least
% significant one is \xintNthElt{7}{\xintRev{\xintiPow {2}{100}}}.

Of course, it would be nicer to do
|\edef\z{\xintiPow {2}{100}}|, and then use |\z| in place of 
  |\xintiPow {2}{100}| everywhere as this would  spare the CPU some repetitions.

\section{Exceptions (error messages)}

In situations such as division by zero, the package will insert in the
\TeX{} processing an undefined control sequence (we copy this method
from the |bigintcalc| package). This will trigger the writing to the log
of a message signaling an undefined control sequence. The name of the
control sequence is the message. The error is raised \emph{before} the
end of the expansion so as to not disturb further processing of the
token stream, after completion of the operation. Generally the problematic
operation will output a zero. Possible such error message control
sequences: 
\dverb|&
\xintError:ArrayIndexIsNegative
\xintError:ArrayIndexBeyondLimit
\xintError:FactorialOfNegativeNumber
\xintError:FactorialOfTooBigNumber
\xintError:DivisionByZero
\xintError:NaN
\xintError:FractionRoundedToZero
\xintError:NotAnInteger
\xintError:ExponentTooBig
\xintError:TooBigDecimalShift
\xintError:TooBigDecimalSplit
\xintError:RootOfNegative
\xintError:NoBezoutForZeros
\xintError:ignored
\xintError:removed
\xintError:use_xintthe!
\xintError:inserted
|

\section{Common input errors when using the package macros}

\edef\x{\xintMul {3}{5}/\xintMul{7}{9}}

Here is a list of  common input errors. Some will cause compilation errors,
others are more annoying as they may pass through unsignaled.
\begin{itemize}
\item using |-| to prefix some macro: |-\xintiSqr{35}/271|.\footnote{to the
    contrary, this \emph{is} 
    allowed inside an |\string\xintexpr|-ession.}  
\item using one pair of braces too many |\xintIrr{{\xintiPow {3}{13}}/243}| (the
  computation goes through with no error signaled, but the result is completely
  wrong). 
\item using |[]| and decimal points at the same time |1.5/3.5[2]|, or with a
  sign in the denominator |3/-5[7]|. The scientific notation has no such
  restriction, the two inputs |1.5/-3.5e-2| and |-1.5e2/3.5| are equivalent:
  |\xintRaw{1.5/-3.5e-2}|\digitstt{=\xintRaw{1.5/-3.5e-2}},
  |\xintRaw{-1.5e2/3.5}|\digitstt{=\xintRaw{-1.5e2/3.5}}. 
\item specifying numerators and
  denominators with macros producing fractions when \xintfracname is loaded:
  |\edef\x{|\allowbreak|\xintMul {3}{5}/\xintMul{7}{9}}|. This expands to
  \texttt{\x} which is 
  invalid on input. Using this |\x| in a fraction macro will most certainly
  cause a compilation error, with its usual arcane and undecipherable
  accompanying message. The fix here would be to use |\xintiMul|. The simpler
  alternative with package \xintexprname:
  |\xinttheexpr 3*5/(7*9)\relax|.
\item generally speaking, using in a context expecting an integer (possibly
  restricted to the \TeX{} bound) a macro or expression which returns a
  fraction: |\xinttheexpr 4/2\relax| outputs \digitstt{\xinttheexpr 4/2\relax},
  not &2&. Use |\xintNum {\xinttheexpr 4/2\relax}|. 
\end{itemize}


\section{Package namespace}

Inner macros of \xintname, \xintfracname, \xintexprname,
\xintbinhexname, \xintgcdname, \xintseriesname, and \xintcfracname{} all
begin either with |\XINT_| or with |\xint_|.\footnote{starting with
  release |1.06b| the style files use for macro names a more modern
  underscore |\_| rather than the |@| sign. Probability of a name clash
  with \LaTeX2e packages is now even closer to nil, and with \LaTeX3
  packages it is also close to nil as our control sequences are all
  lacking the argument specifier part of \LaTeX3 function names. A few
  macros starting with |\string\XINT| do not have the underscore.} The
package public commands all start with |\xint|. The major forms have
their initials capitalized, and lowercase forms, prefixed with
|\romannumeral0|, allow definitions of further macros expanding in only
two steps to their final outputs. Some other control sequences are used
only as delimiters, and left undefined, they may have been defined
elsewhere, their meaning doesn't matter and is not touched.

\section{Loading and usage}

\dverb|&
Usage with LaTeX: \usepackage{xint}
                  \usepackage{xintfrac}   % (loads xint)
                  \usepackage{xintexpr}   % (loads xintfrac)

                  \usepackage{xintbinhex} % (loads xint)
                  \usepackage{xintgcd}    % (loads xint)
                  \usepackage{xintseries} % (loads xintfrac)
                  \usepackage{xintcfrac}  % (loads xintfrac)

Usage with TeX:   \input xint.sty\relax   
                  \input xintfrac.sty\relax   % (loads xint)
                  \input xintexpr.sty\relax   % (loads xintfrac)

                  \input xintbinhex.sty\relax % (loads xint)
                  \input xintgcd.sty\relax    % (loads xint)
                  \input xintseries.sty\relax % (loads xintfrac)
                  \input xintcfrac.sty\relax  % (loads xintfrac)
|

We have added, directly copied from packages by \textsc{Heiko
 Oberdiek}, a mecanism of re-load and \eTeX{} detection,
especially for Plain \TeX{}. As \eTeX{} is required, the
executable |tex| can not be used, |etex| or |pdftex| (version
|1.40| or later) or ..., must
be invoked.

Furthermore, \xintfracname, \xintbinhexname, and \xintgcdname check for the
previous loading of \xintname, and will try to load it if this was not
already done. Similarly \xintseriesname, \xintcfracname and \xintexprname do
the necessary loading of \xintfracname. Each package will refuse to be
loaded twice.

Also inspired from the \textsc{Heiko Oberdiek} packages we have included
a complete catcode protection mecanism. The packages may be loaded in
any catcode configuration satisfying these requirements: the percent is
of category code comment character, the backslash is of category code
escape character, digits have category code other and letters have
category code letter. Nothing else is assumed, and the previous
configuration is restored after the loading of each one of the packages.

This is for the loading of the packages. 

For the actual use of the
macros, note that when feeding them with negative numbers the
minus sign must have category code other, as is standard. Similarly the
slash used for inputting fractions must be of category other, as usual.
And the square brackets also must be of category code other, if used on
input. The `e' of the scientific notation must be of category code letter.
All of that is relaxed when inside an 
|\xintexpr|-ession (but arguments to macros which have been inserted in
the expression must obey the rules, as it is the macro and not the parser which
will get the tokens). In an |\xintexpr|-ession, the scientific `e' may be `E'.

The components of the \xintname bundle presuppose that the usual
\csa{space} and \csa{empty} macros are pre-defined, which is the case in
Plain \TeX{} as well as in \LaTeX.

Lastly, the macros \csa{xintRelaxArray} (of \xintname) and
\csa{xintTypesetEuclideAlgorithm} and
\csa{xintTypesetBezoutAlgorithm} (of \xintgcdname) use 
\csa{loop}, both Plain and \LaTeX{} incarnations are
compatible. \csa{xintTypesetBezoutAlgorithm} also uses the
\csa{endgraf} macro.
 

\section{Installation}

\dverb+&
Run tex or latex on xint.dtx.

This will extract the style files xint.sty, xintfrac.sty, xintexpr.sty,
xintbinhex.sty, xintgcd.sty, xintseries.sty, xintcfrac.sty (and xint.ins).

Files with the same names and in the same repertory will be overwritten.
The tex (not latex) run will stop with the complaint that it does not
understand \NeedsTeXFormat, but the style files will already have been
extracted by that time.

Alternatively, run tex or latex on xint.ins if available.

To get xint.pdf run pdflatex thrice on xint.dtx

           xint.sty |
       xintfrac.sty |
       xintexpr.sty | 
     xintbinhex.sty | --> TDS:tex/generic/xint/
        xintgcd.sty |
     xintseries.sty |
      xintcfrac.sty |
           xint.dtx   --> TDS:source/generic/xint/
           xint.pdf   --> TDS:doc/generic/xint/

It may be necessary to then refresh the TeX installation filename
database.
+


\section{Commands of the \xintname package}\label{sec:comxint}

\def\n{\string{N\string}}
\def\m{\string{M\string}}
\def\x{\string{x\string}}

\texttt{\n} (or also \texttt{\m}) stands for a (long) number within braces with
one optional minus sign and no leading zeros, or for a control sequence possibly
within braces and expanding to such a number (without the braces!), or for
material within braces which expands to such a number after repeated expansions
of the first token.

The letter \texttt{x} stands for something which will be inserted in-between a
|\numexpr| and a |\relax|. It will thus be completely expanded and must give an
integer obeying the \TeX{} bounds. Thus, it may be for example a count register,
or itself a \csa{numexpr} expression, or just a number written explicitely with
digits or something like |4*\count 255 + 17|, etc...

A count register or \csa{numexpr} expression, used as an argument to a macro
dealing with long integers, must be prefixed by |\the| or
|\number|.

Some of these macros are extended by \xintfracname to accept fractions
on input, and, generally, to output a fraction. This will be mentioned
and the original macro \csa{xintAbc} remains then available under the
name \csa{xintiAbc}. 

\begin{framed}
  For the macros extended by the loading of \xintfracname.sty, it is not
  necessary anymore to prefix a count register with |\the|. See the previous
  `\hyperlink{useofcount}{Use of count registers}' section.
\end{framed}
Some macros such as \csa{xintQuo} or \csa{xintNum} (which are among those made
to accept fractions on input when \xintfracname.sty is loaded) check that the
fraction is an integer in disguise. They still produce on output integers
without any forward slash mark nor trailing |[n]|. Again the original is still
available with an additional `i' in the name, in case it is important to skip
the parsing, but here the output format is the same. See the \xintfracname
\hyperref[sec:comfrac]{documentation} for more information.

The integer-only macros are a bit more efficient, even for simple things such as
determining the sign of a (long) number, as there is always some overhead due to
the parsing the fraction format on input. This overhead, when package
\xintfracname has been loaded and has modified the \xintname routines, usually
will not matter much, but there are contexts where obtaining\strut{} an integer
without 
a forward slash nor trailing |[n]| is mandatory:\IMPORTANT{}
for example after an |\ifnum| or inside a
|\numexpr| (for `short' integers) or when used as argument to one of the package
macros which are stricly integer-only on input such as \csb{xintiSqrt}, or
\csb{xintDouble} or \csb{xintDecSplit}. A fraction which in disguise is an
integer can be stripped of the slash and trailing |[n]| using \csb{xintNum}.


\localtableofcontents

\subsection{\csbh{xintRev}} \label{xintRev}

\csa{xintRev\n} will revert the order of the digits of the number,
keeping the optional sign. Leading zeros
resulting from the operation are not removed (see the
\csa{xintNum} macro for this). As described early, this macro and all other
macros dealing with numbers first expand `fully' their arguments. 
\centeredline{|\xintRev{-123000}|\digitstt{=\xintRev{-123000}}}
\centeredline{|\xintNum{\xintRev{-123000}}|%
               \digitstt{=\xintNum{\xintRev{-123000}}}}

\subsection{\csbh{xintReverseOrder}}\label{xintReverseOrder}

\csa{xintReverseOrder}\marg{list} does not do any
expansion of its argument and just reverses the order of the
tokens in the \meta{list}.\footnote{the argument is not a token list variable,
  just a 
  \meta{list} of tokens.} Brace pairs encountered are removed once and the
enclosed 
material does not get reverted. Spaces are gobbled.
\centeredline{|\xintReverseOrder{\xintDigitsOf\xintiPow {2}{100}\to\Stuff}|}
\centeredline{gives: 
   \ttfamily{\string\Stuff\string\to1002\string\xintiPow\string\xintDigitsOf}}

\subsection{\csbh{xintRevWithBraces}}\label{xintRevWithBraces}

{\small New in release |1.06|.\par}
\edef\X{\xintRevWithBraces{12345}}
\edef\y{\xintRevWithBraces\X}
\expandafter\def\expandafter\w\expandafter
     {\romannumeral0\xintrevwithbraces{{\A}{\B}{\C}{\D}{\E}}}


\csa{xintRevWithBraces}\marg{list} first does the expansion of its argument
(which thus may be macro), then it reverses the order of the tokens, or braced
material, it encounters, adding a pair of braces to each (thus, maintaining
brace pairs already existing). Spaces (in-between external brace pairs) are
gobbled. This macro is mainly thought out for use on a \meta{list} of such
braced 
material; with such a list as argument the expansion will only hit against the
first opening brace, hence do nothing, and the braced stuff may thus be macros
one does not want to expand. \centeredline{|\edef\x{\xintRevWithBraces{12345}}|}
\centeredline{|\meaning\x:|\ttfamily{\meaning\X}}
\centeredline{|\edef\y{\xintRevWithBraces\x}|}%
\centeredline{|\meaning\y:|\ttfamily{\meaning\y}} The examples above could be
defined with |\edef|'s because the braced material did not contain macros.
Alternatively: \centeredline{|\expandafter\def\expandafter\w\expandafter|}%
\centeredline{|{\romannumeral0\xintrevwithbraces{{\A}{\B}{\C}{\D}{\E}}}|}
\centeredline{|\meaning\w:|\ttfamily{\meaning\w}} The macro
\csa{xintReverseWithBracesNoExpand} 
does the same job without the initial expansion of its argument.

\subsection{\csbh{xintLen}}\label{xintiLen}

\csa{xintLen\n} returns the length of the number, not counting the sign.
\centeredline{|\xintLen{-12345678901234567890123456789}|\digitstt
  {=\xintLen{-12345678901234567890123456789}}} Extended by \xintfracname to
fractions: the length of |A/B[n]| is the length of |A| plus the length of |B|
plus the absolute value of |n| and minus one (an integer input as |N| is
internally |N/1[0]| so the minus one means that the extended \csa{xintLen}
behaves the same as the original for integers). The whole thing should sum up to
less than circa &2^{31}&. 

\subsection{\csbh{xintLength}}\label{xintLength}

\csa{xintLength}\marg{list} does not do any expansion of its argument and just
counts how many tokens there are (possibly none). Things enclosed in braces
count as one. \centeredline{|\xintLength {\xintiPow
    {2}{100}}|\digitstt{=\xintLength {\xintiPow{2}{100}}}}
\centeredline{${}\neq{}$|\xintLen {\xintiPow {2}{100}}|\digitstt{=\xintLen
    {\xintiPow{2}{100}}}}

\subsection{\csbh{xintCSVtoList}}\label{xintCSVtoList}

{\small New with release |1.06|.\par}

\edef\X{\xintCSVtoList {1,2,a , b   ,c  d,x,y }}
\def\y {a,b,c,d,e}
\edef\z{\xintCSVtoList \y}

\csa{xintCSVtoList}|{a,b,c...,z}| returns |{a}{b}{c}...{z}|. The argument may be
a macro. It is first expanded: this means that if the argument is |a,b,..|, then
|a|, if a macro, will be expanded which may or may not be a good thing (starting
the replacement text of the macro with |\space| stops the expansion at the first
level and gobbles
the space; prefixing a macro with |\space| stops preemptively the expansion and
gobbles the space). Chains of
contiguous spaces are collapsed by the \TeX{} scanning into single spaces.
\centeredline{|\xintCSVtoList {1,2,a , b ,c d,x,y
  }->|\makeatletter\digitstt{\expandafter\strip@prefix\meaning\X}\makeatother}
\centeredline{|\def\y{a,b,c,d,e}\xintCSVtoList\y->|%
      \makeatletter\digitstt{\expandafter\strip@prefix\meaning\z}\makeatother} 

The macro \csa{xintCSVtoListNoExpand} does the same job without the initial
expansion.

\subsection{\csbh{xintNthElt}}\label{xintNthElt}

{\small New in release |1.06| and modified in |1.06a|.\par}

\def\macro #1{\the\numexpr 9-#1\relax}

\csa{xintNthElt\x}\marg{list} gets (expandably) the |x|th element of the
\meta{list}, which may be a macro: it is first expanded (fully for the first
tokens). The seeked element is returned with
one pair of braces removed (if initially present). \centeredline{|\xintNthElt
  {37}{\xintFac {100}}|\digitstt{=\xintNthElt {37}{\xintFac {100}}}} is the
thirty-seventh digit of &100!&. \centeredline{|\xintNthElt {10}{\xintFtoCv
    {566827/208524}}|\digitstt{=\xintNthElt {10}{\xintFtoCv {566827/208524}}}}
is 
the tenth convergent of &566827/208524& (uses \xintcfracname package). 

If |x=0| or |x<0|, the macro returns the length of the expanded list: this is
not equivalent to \csb{xintLength} due to the initial full expansion of the
first token, and differs from \csb{xintLen} which is to be used on numbers or
fractions only. The situation with |x| larger than the length of the list is
kept silent, the macro then returns nothing; this will perhaps be modified in
future versions. \centeredline{|\xintNthElt {7}{\xintCSVtoList
    {1,2,3,4,5,6,7,8,9}}|%
  \digitstt{=\xintNthElt {7}{\xintCSVtoList {1,2,3,4,5,6,7,8,9}}}}%
\centeredline{|\xintNthElt {0}{\xintCSVtoList {1,2,3,4,5,6,7,8,9}}|%
  \digitstt{=\xintNthElt {0}{\xintCSVtoList {1,2,3,4,5,6,7,8,9}}}} 

The macro
\csa{xintNthEltNoExpand} does the same job without first expanding its 
second argument.

\subsection{\csbh{xintListWithSep}}\label{xintListWithSep}

{\small New with release |1.04|.\par}

\def\macro #1{\the\numexpr 9-#1\relax}

\csa{xintListWithSep}|{sep}|\marg{list} just inserts the given separator |sep|
in-between all elements of the given list: this separator may be a macro but
will not be expanded. The second argument also may be itself a macro: it is
expanded as usual, \emph{i.e.} fully for what comes first. Applying
\csa{xintListWithSep} removes one level of top braces to each list constituent.
An empty input gives an empty output, a singleton gives a singleton, the
separator is used starting with at least two elements. Using an empty separator
has the net effect of removing one-level of brace pairs from each ot the
top-level braced material constituting the \meta{list}.
\centeredline{|\xintListWithSep{:}{\xintFac
    {20}}|\digitstt{=\xintListWithSep{:}{\xintFac {20}}}}

The  macro \csa{xintListWithSepNoExpand} does the same
job without the initial expansion.

\subsection{\csbh{xintApply}}\label{xintApply}

{\small New with release |1.04|.\par}

\def\macro #1{\the\numexpr 9-#1\relax}

\csa{xintApply}|{\macro}|\marg{list} applies the one parameter command |\macro|
to 
each item in the \meta{list} (no separator) given as second argument. Each item
is 
given in turn as parameter to |\macro| which is expanded (as usual, \emph{i.e.}
fully for what comes first), and 
the result is braced. On output, a new list with these braced results. The
\meta{list} may itself be some macro expanding (in the previously described way)
to 
the list of tokens to which the command |\macro| will be applied. For example,
if the \meta{list} expands to some positive number, then each digit will be
replaced 
by the result of applying |\macro| on it. \centeredline{|\def\macro
  #1{\the\numexpr 9-#1\relax}|} \centeredline{|\xintApply\macro{\xintFac
    {20}}|\digitstt{=\xintApply\macro{\xintFac {20}}}} 

The macro 
\csa{xintApplyNoExpand} does the same job without the first initial expansion
which gave the \meta{list}  of braced tokens to which |\macro| is applied.

\subsection{\csbh{xintApplyUnbraced}}\label{xintApplyUnbraced}

{\small New in release |1.06b|.\par}

\def\macro #1{\expandafter\def\csname myself#1\endcsname {#1}}
\xintApplyUnbraced\macro{{elta}{eltb}{eltc}}

\csa{xintApplyUnbraced}|{\macro}|\marg{list} is like \csb{xintApply} except that
the 
various outputs are not again braced. The net effect is the same as doing 
\centeredline{|\xintListWithSep {}{\xintApply {\macro}|\marg{list}|}|}
This command is useful for non-expandable
things like doing macro definitions, for which braces are an inconvenience.
(sorry for the silly example: )
% sorry also for the silly coding of the following verbatim block
\lverb|&
$ $ $ $ \def\macro #1{\expandafter\def\csname myself#1\endcsname {#1}}$\
$null$ $ $ $ \xintApplyUnbraced\macro{{elta}{eltb}{eltc}}$\
$null$ $ $ $ \meaning\myselfelta:$ $ $meaning$myselfelta
| 
The macro \csa{xintApplyUnbracedNoExpand} does the same job without the first
initial expansion which gave the \meta{list} of braced tokens to which
|\macro| 
is applied.

\subsection{\csbh{xintAssign}}\label{xintAssign}


\csa{xintAssign}\meta{braced things}\csa{to}%
\meta{as many cs as they are things} defines (without checking if
something gets overwritten) the control sequences on the right of
\csa{to} to be the complete expansions of the successive things on
the left of \csa{to} enclosed within braces. 

Important: a `full' expansion (as previously described) is applied first to the
material in front of \csa{xintAssign}.

\xintAssign\xintiPow {7}{13}\to\SevenToThePowerThirteen
\xintAssign\xintDivision{1000000000000}{133333333}\to\Q\R

As a special exception, if after this initial expansion a
brace does not immediately follows \csa{xintAssign}, it is assumed
that there is only one control sequence to define and it is then
defined to be the complete expansion of the entire material between
\csa{xintAssign} and \csa{to}.
\centeredline{|\xintAssign\xintDivision{1000000000000}{133333333}\to\Q\R|}
\centeredline{|\meaning\Q: |\digitstt{\meaning\Q}, |\meaning\R:
  |\digitstt{\meaning\R}} \centeredline{|\xintAssign\xintiPow
  {7}{13}\to\SevenToThePowerThirteen|}
\centeredline{|\SevenToThePowerThirteen|\digitstt{=\SevenToThePowerThirteen}}

Of course this macro and its cousins completely break usage in
pure expansion contexts, as assignments are made via the
\csa{edef} primitive.

\subsection{\csbh{xintAssignArray}}\label{xintAssignArray}

{\small Changed in release |1.06| to let the defined macro pass its
  argument through a |\numexpr...\relax|.\par}

\xintAssignArray\xintBezout {1000}{113}\to\Bez

\csa{xintAssignArray}\meta{braced things}\csa{to}\csa{myArray} first 
expands fully the first token then defines \csa{myArray} to be a macro with one
parameter, such that \csa{myArray\x} expands in two steps (which provoke the
full expansion of the `short' number \texttt{\x}, given to a
|\numexpr|)  to give the |x|th braced
thing, itself completely expanded. \csa{myArray}|{0}| returns the number |M| of
elements of the array so that the successive elements are \csa{myArray}|{1}|,
\dots, \csa{myArray}|{M}|. \centeredline{|\xintAssignArray\xintBezout
  {1000}{113}\to\Bez|} will set |\Bez{0}| to \digitstt{\Bez0}, |\Bez{1}| to
\digitstt{\Bez1}, |\Bez{2}| to \digitstt{\Bez2}, |\Bez{3}| to \digitstt{\Bez3},
|\Bez{4}| to \digitstt{\Bez4}, and |\Bez{5}| to \digitstt{\Bez5}:
\digitstt{(\Bez3)${}\times{}$\Bez1${}-{}$(\Bez4)${}\times{}$\Bez2${}={}$\Bez5.}

\subsection{\csbh{xintRelaxArray}}\label{xintRelaxArray}

\csa{xintRelaxArray}\csa{myArray} sets to \csa{relax} all 
macros which were defined by the previous \csa{xintAssignArray}
with \csa{myArray} as array name. 

\subsection{\csbh{xintDigitsOf}}\label{xintDigitsOf}

This is a synonym for \csa{xintAssignArray}, to be used to define
an array giving all the digits of a given number.
\begingroup\xintDigitsOf\xintiPow {7}{500}\to\digits
\centeredline{|\xintDigitsOf\xintiPow {7}{500}\to\digits|}
\noindent &7^500& has |\digits{0}=|\digits{0} digits, and the 123rd among them
(starting from the most significant) is
|\digits{123}=|\digits{123}.
\endgroup 

\subsection{\csbh{xintNum}}\label{xintiNum}

\csa{xintNum\n} removes chains of plus or minus signs, followed by zeros.
\centeredline{|\xintNum{+---++----+--000000000367941789479}|\digitstt
  {=\xintNum{+---++----+--000000000367941789479}}} Extended by \xintfracname to
accept also a fraction on input, as long as it reduces to an integer after
division of the numerator by the denominator.
\centeredline{|\xintNum{123.48/-0.03}|\digitstt{=\xintNum{123.48/-0.03}}}


\subsection{\csbh{xintSgn}}\label{xintiSgn}

\csa{xintSgn\n} returns 1 if the number is positive, 0 if it is
zero and -1 if it is negative. Extended by \xintfracname to fractions.

\subsection{\csbh{xintSgnFork}}\label{xintSgnFork}
{\small New with release |1.07|.\par}

\csa{xintSgnFork}\verb+{-1|0|1}+\marg{A}\marg{B}\marg{C} expandably
chooses to execute either the \meta{A}, \meta{B} or \meta{C} code,
depending on its first argument. This first argument should be anything
expanding to either |-1|, |0| or |1| (a count register should be
prefixed by |\the| and a |\numexpr...\relax| also should be prefixed by
|\the|). This utility is provided to help construct expandable macros
choosing depending on a condition which one of the package macros to
use, or which values to confer to their arguments. 
\dverb(&
\def\myfunction #1% 
% expands to |x+1| if x < -1, x-1 if x > 1, else 1 - x^2
% rounded to two decimal places
   {\xintRound {2}{\xintSgnFork 
       {\xintSgnFork{\xintGeq{#1}{1}}{}{0}{\xintSgn{#1}}}
       {\xintSub{-1}{#1}}{\xintSub{1}{\xintSqr{#1}}}{\xintSub{#1}{1}}}}%
\xintListWithSep{,\,}{\xintApply\myfunction
                 {{-5/2}{-2}{-3/2}{-1}{-1/2}{0}{1/2}{1}{3/2}{2}{5/2}}}
(

\def\myfunction #1%
   {\xintRound {2}{\xintSgnFork 
       {\xintSgnFork{\xintGeq{#1}{1}}{}{0}{\xintSgn{#1}}}
       {\xintSub{-1}{#1}}{\xintSub{1}{\xintSqr{#1}}}{\xintSub{#1}{1}}}}%
\digitstt{\xintListWithSep{,\,}{\xintApply\myfunction
                 {{-5/2}{-2}{-3/2}{-1}{-1/2}{0}{1/2}{1}{3/2}{2}{5/2}}}}

Using an \xintexprname-ession, one may simplify the coding:
\dverb*&
\def\myfunction #1% expands to |x+1| if x < -1, x-1 if x > 1, else 1 - x^2
   {\xintRound {2}{\xinttheexpr\xintSgnFork 
       {\xintSgnFork{\xintGeq{#1}{1}}{}{0}{\xintSgn{#1}}}
       { -#1 - 1 }{ 1 - (#1)^2 }{ #1 - 1 } \relax }}%
*

\def\myfunction #1% expands to |x+1| if x < -1, x-1 if x > 1, else 1 - x^2
   {\xintRound {2}{\xinttheexpr\xintSgnFork 
       {\xintSgnFork{\xintGeq{#1}{1}}{}{0}{\xintSgn{#1}}}
       { -#1 - 1 }{ 1 - (#1)^2 }{ #1 - 1 } \relax }}%

\digitstt{\xintListWithSep{,\,}{\xintApply\myfunction
                 {{-5/2}{-2}{-3/2}{-1}{-1/2}{0}{1/2}{1}{3/2}{2}{5/2}}}}

Notice the use of parentheses, with |#1=-1|, |1-#1^2| would give |1--1^2| which
evaluates to |2|. Or with |#1=3/2|, |1-#1^2| gives |1-3/2^2| which evaluates
inside an \xintexprname-ession to |1-3/4=1/4| not |1-9/4=-5/4|.

\subsection{\csbh{xintOpp}}\label{xintiOpp}

\csa{xintOpp\n} returns the opposite |-N| of the number |N|.
Extended by \xintfracname to fractions.


\subsection{\csbh{xintAbs}}\label{xintiAbs}

\csa{xintAbs\n} returns the absolute value of the number. Extended
by \xintfracname to fractions. 

\subsection{\csbh{xintAdd}}\label{xintiAdd}

\csa{xintAdd\n\m} returns the sum of the two numbers. Extended by
\xintfracname to fractions.

\subsection{\csbh{xintSub}}\label{xintiSub}

\csa{xintSub\n\m} returns the difference |N-M|. Extended by
\xintfracname to fractions.

\subsection{\csbh{xintCmp}}\label{xintiCmp}

\csa{xintCmp\n\m} returns 1 if |N>M|, 0 if |N=M|, and -1 if |N<M|.
Extended by \xintfracname to fractions.

\subsection{\csbh{xintGeq}}\label{xintiGeq}

\csa{xintGeq\n\m} returns 1 if the \emph{absolute value} of the first number is
at least equal to the absolute value of the second number. If \verb+|N|<|M|+ it
returns 0. Extended by \xintfracname to fractions (starting with relaease
|1.07|). Please note that the macro compares \emph{absolute values}.

\subsection{\csbh{xintMax}}\label{xintiMax}

\csa{xintMax\n\m} returns the largest of the two in the sense of the order
structure on the relative integers (\emph{i.e.} the right-most number if they
are put on a line with positive numbers on the right): |\xintiMax
{-5}{-6}|\digitstt{=\xintiMax{-5}{-6}}. Extended by \xintfracname to fractions.

\subsection{\csbh{xintMin}}\label{xintiMin}

\csa{xintMin\n\m} returns the smallest of the two in the sense of the order
structure on the relative integers (\emph{i.e.} the left-most number if they are
put on a line with positive numbers on the right): |\xintiMin
{-5}{-6}|\digitstt{=\xintiMin{-5}{-6}}. Extended by \xintfracname to fractions.

\subsection{\csbh{xintSum}}\label{xintiSum}

\csa{xintSum}\marg{braced things} after expanding its argument
expects to find a sequence of tokens (or braced material).
Each is expanded (with the usual meaning), and the sum of all these numbers is
returned. 
\centeredline{%
  \csa{xintiSum}|{{123}{-98763450}{\xintFac{7}}{\xintiMul{3347}{591}}}|%
    \digitstt{=\xintiSum{{123}{-98763450}{\xintFac{7}}{\xintiMul{3347}{591}}}}}
\centeredline{\csa{xintiSum}|{1234567890}|\digitstt{=\xintiSum{1234567890}}}
An empty sum is no error and returns zero: |\xintiSum
{}|\digitstt{=\xintiSum {}}. A sum with only one
term returns that number: |\xintiSum {{-1234}}|\digitstt{=\xintiSum
  {{-1234}}}. Attention that |\xintiSum {-1234}| is not legal input
and will make the \TeX{} run fail. On the other hand  |\xintiSum
{1234}|\digitstt{=\xintiSum{1234}}. Extended by \xintfracname
to fractions.

\subsection{\csbh{xintSumExpr}}\label{xintiSumExpr}

\csa{xintSumExpr}\meta{braced things}\csa{relax} is to what \csa{xintSum}
expands. The argument is then expanded (with the usual meaning) and should give
a list of braced quantities or macros, each one will be expanded in turn.
\centeredline{%
  \csa{xintiSumExpr}| {123}{-98763450}|%
  |{\xintFac{7}}{\xintiMul{3347}{591}}\relax|\digitstt{=%
    \xintiSumExpr {123}{-98763450}{\xintFac{7}}{\xintiMul{3347}{591}}\relax}}

Note: I am not so happy with the name which seems to suggest that the
|+| sign should be used instead of braces. Perhaps this will change
in the future.

Extended by \xintfracname to fractions.

\subsection{\csbh{xintMul}}\label{xintiMul}
{\small Modified in release |1.03|.\par}

\csa{xintMul\n\m} returns the product of the two numbers. Starting
with release |1.03| of \xintname, the macro checks the lengths of
the two numbers and then activates its algorithm with the best (or
at least, hoped-so) choice of which one to put first. This makes
the macro a bit slower for numbers up to 50 digits, but may give
substantial speed gain when one of the number has 100 digits or more.
Extended by \xintfracname to fractions.

\subsection{\csbh{xintSqr}}\label{xintiSqr}

\csa{xintSqr\n} returns the square. Extended by \xintfracname to fractions.

\subsection{\csbh{xintPrd}}\label{xintiPrd}

\csa{xintPrd}\marg{braced things} after expanding its argument expects to find a
sequence of tokens (or braced material). Each is expanded (with the usual
meaning), and the product of all these numbers is returned. 
\centeredline{%
  \csa{xintiPrd}|{{-9876}{\xintFac{7}}{\xintiMul{3347}{591}}}|%
  \digitstt{=%
    \xintiPrd{{-9876}{\xintFac{7}}{\xintiMul{3347}{591}}}}}
\centeredline{\csa{xintiPrd}|{123456789123456789}|\digitstt{=%
    \xintiPrd{123456789123456789}}} An empty product is no error and returns 1:
|\xintiPrd {}|\digitstt{=\xintiPrd {}}. A product reduced to a single term returns
this number: |\xintiPrd {{-1234}}|\digitstt{=\xintiPrd {{-1234}}}. Attention that
|\xintiPrd {-1234}| is not legal input and will make the \TeX{} compilation
fail. On the other hand |\xintiPrd {1234}|\digitstt{=\xintiPrd {1234}}.
\centeredline{$\displaystyle 2^{200}3^{100}7^{100}$} \centeredline{|=\xintiPrd
  {{\xintiPow {2}{200}}{\xintiPow {3}{100}}{\xintiPow {7}{100}}}|}
% \digitstt{=\expandafter\expandafter\expandafter\allowsplits \xintiPrd
%   {{\xintiPow {2}{200}}{\xintiPow {3}{100}}{\xintiPow {7}{100}}}\relax }
\digitstt{=\printnumber{\xintNum {\xinttheexpr 2^200*3^100*7^100\relax }}}
%\centeredline{|=\xintiPow {\xintiMul {\xintiPow {42}{9}}{43008}}{10}|} 

Extended by \xintfracname to fractions.

With \xintexprname, the above would be coded simply as \centeredline{|\xintNum
  {\xinttheexpr 2^200*3^100*7^100\relax }|} (\csa{xintNum} to print an integer, not a fraction).

% \printnumber{%
%    \xintPow {\xintMul {\xintPow {42}{9}}{43008}}{10}}

\subsection{\csbh{xintPrdExpr}}\label{xintiPrdExpr}

{\small Name change in |1.06a|! I apologize, but I suddenly decided that
  \csa{xintProductExpr} was a bad choice; so I just replaced it by the current
  name. \par}

\csa{xintPrdExpr}\marg{argument}\csa{relax} is to what \csa{xintPrd} expands
; its argument is expanded (with the usual meaning) and should give a list of
braced numbers or macros. Each will be expanded when it is its turn.
\centeredline{\csa{xintiPrdExpr}| 123456789123456789\relax|\digitstt{=%
    \xintiPrdExpr 123456789123456789\relax}}

Note: I am not so happy with the name which seems to suggest that the
|*| sign should be used instead of braces. Perhaps this will change
in the future.

Extended by \xintfracname to fractions.

\subsection{\csbh{xintPow}}\label{xintiPow}

\csa{xintPow\n\x} returns |N^x|. When |x| is zero, this is 1. If |N| is zero and
|x<0|, if \verb+|N|>1+ and |x<0| negative, or if \verb+|N|>1+ and |x>999999999|,
then an error is raised. |2^999999999| has \np{301029996} digits; each exact
multiplication of two one thousand digits numbers already takes a few seconds,
so needless to say this bound is completely irrealistic. Already |2^9999| has
\np{3010} digits,\footnote{on my laptop |\string\xintiPow \{2\}\{9999\}|
  obtains all |3010| digits in about ten or eleven seconds. In contrast, the
  float versions for 
  |8|, |16|, |24|, or even more significant figures, do their jobs in circa one
  hundredth of a second (|1.08b|). This is done without |log|/|exp| which are
  not (yet?) implemented in \xintfracname. The \LaTeX3
  \href{http://www.ctan.org/tex-archive/macros/latex/contrib/l3kernel}{l3fp}
  does this with |log|/|exp| and is ten times faster (|16| figures only).} so I
should perhaps lower the bound to |99999|.

Extended by \xintfracname to fractions (\csb{xintPow}) and also to floats
(\csb{xintFloatPow}). Of course, negative
exponents do not then cause errors anymore. The float version is able to deal
with things such as  
|2^999999999| without any problem. For example
|\xintFloatPow[4]{2}{9999}|\digitstt{=\xintFloatPow[4]{2}{9999}} and 
|\xintFloatPow[4]{2}{999999999}|
\digitstt{=\xintFloatPow[4]{2}{999999999}}.

\begin{framed}
  The macros described next are all integer-only on input. With \xintfracname
  loaded their argument is filtered through \csb{xintNum} and may thus be
  a fraction, as long as it is an integer in disguise.
\end{framed}

\subsection{\csbh{xintFac}}\label{xintiFac}

\csa{xintFac\x} returns the factorial. It is an error if the
argument is negative or at least &10^6&. It is not recommended to
launch the computation of things such as &100000!&, if you need
your computer for other tasks. Note that the argument is of the |x| type, it
must obey the \TeX{} bounds, but on the other hand may involve count registers
and even arithmetic operations as it will be completely expanded inside a
|\numexpr|.

With \xintfracname loaded, the macro also\MyMarginNote{Modified in |1.08b|}
accepts a fraction as argument, as long as this fraction turns out to be an
integer: |\xintFac {66/3}|\digitstt{=\xintFac {66/3}}.

% the construct |\xintFac{\xintAdd {2}{3}}| will fail,
% use either |\xintFac{\xintiAdd {2}{3}}| or |\xintFac{\xintNum{\xintAdd
%     {2}{3}}}|.

% temps obsolètes, mettre à jour
% On my laptop &1000!& (2568 digits)
% is computed in a little less than ten seconds, &2000!& (5736
% digits) is computed in a little less than one hundred seconds, and
% &3000!& (which has 9131 digits) needs close to seven minutes\dots
% I have no idea how much time &10000!& would need (do rather
% &9999!& if you can, the algorithm has some overhead at the
% transition from &N=9999& to &10000& and higher; &10000!& has 35660
% digits). Not to mention &100000!& which, from the Stirling formula,
% should have 456574 digits.

\subsection{\csbh{xintDivision}}\label{xintDivision}

\csa{xintDivision\n\m} returns |{quotient Q}{remainder R}|. This
is euclidean division: |N = QM + R|, |0|${}\leq{}$\verb+R < |M|+. So the
remainder is always non-negative and the formula |N = QM + R|
always holds independently of the signs of |N| or |M|. Division by
zero is of course an error (even if |N| vanishes) and returns |{0}{0}|.

This macro is integer only (with \xintfracname loaded it accepts
fractions on input, but they must be integers in disguise) and not to be
confused with the \xintfracname macro \csb{xintDiv} which divides one
fraction by another.

\subsection{\csbh{xintQuo}}\label{xintQuo}

\csa{xintQuo\n\m} returns the quotient from the euclidean division. When
both |N| and |M| are positive one has \csa{xintQuo\n\m}|=\xintiTrunc
{0}{N/M}| (using package \xintfracname). With \xintfracname loaded it
accepts fractions on input, but they must be integers in disguise.

\subsection{\csbh{xintRem}}\label{xintRem}

\csa{xintRem\n\m} returns the remainder from the euclidean division.
With \xintfracname loaded it accepts fractions on input, but they must
be integers in disguise.



\subsection{\csbh{xintFDg}}\label{xintFDg}

\csa{xintFDg\n} returns the first digit (most significant) of the
decimal expansion.

\subsection{\csbh{xintLDg}}\label{xintLDg}

\csa{xintLDg\n} returns the least significant digit. When the
number is positive, this is the same as the remainder in the
euclidean division by ten.

\subsection{\csbh{xintMON}, \csbh{xintMMON}}\label{xintiMON}%
\label{xintiMMON}\label{xintMON}\label{xintMMON}
{\small New in version |1.03|.\par}

\csa{xintMON\n} returns |(-1)^N| and \csa{xintMMON\n} returns
|(-1)^{N-1}|. \centeredline{|\xintMON {-280914019374101929}|\digitstt{=\xintMON
  {280914019374101929}}, |\xintMMON
{-280914019374101929}|\digitstt{=\xintMMON {280914019374101929}}}

\subsection{\csbh{xintOdd}}\label{xintOdd}

\csa{xintOdd\n} is 1 if the number is odd and 0 otherwise. 

\begin{framed}
The macros described next are strictly for integer-only arguments. If
\xintfracname is loaded, use \csb{xintNum} if necessary.
\end{framed}


\subsection{\csbh{xintiSqrt}, \csbh{xintiSquareRoot}}\label{xintiSqrt}
\label{xintiSquareRoot}
{\small New with |1.08|.\par}
\xintAssign\xintiSquareRoot {17000000000000000000000000}\to\A\B

\noindent\csa{xintiSqrt\n} returns the largest integer whose square is
at most equal to |N|. 
\centeredline{|\xintiSqrt {2000000000000000000000000000000000000}=|%
\digitstt{\xintiSqrt{2000000000000000000000000000000000000}}}
\centeredline{|\xintiSqrt {3000000000000000000000000000000000000}=|%
\digitstt{\xintiSqrt{3000000000000000000000000000000000000}}}
\centeredline{|\xintiSqrt {\xintDSH {-120}{2}}=|}%
\centeredline{\digitstt{\xintiSqrt {\xintDSH {-120}{2}}}}
\csa{xintiSquareRoot\n} returns |{M}{d}| with |d>0|, |M^2-d=N| and |M|
smallest (hence |=1+|\csa{xint\-iSqrt}|{N}|). 
\centeredline{|\xintAssign\xintiSquareRoot
  {17000000000000000000000000}\to\A\B|}% 
\centeredline{|\xintiSub{\xintiSqr\A}\B=\A^2-\B|}%
\centeredline{\digitstt{\xintiSub{\xintiSqr\A}\B=\A\string^2-\B}}
A rational approximation to
$\sqrt{|N|}$ is $|M|-\frac{|d|}{|2M|}$ (this is a majorant and the error is at
most |1/2M|; if |N| is a perfect square |k^2| then |M=k+1| and this gives
|k+1/(2k+2)|, not |k|). 

Package \xintfracname has \csb{xintFloatSqrt} for square
roots of floating point numbers. 

\subsection{\csbh{xintInc}, \csbh{xintDec}}
\label{xintInc}
\label{xintDec}
{\small New with |1.08|.\par}

\csa{xintInc\n} is |N+1| and \csa{xintDec\n} is |N-1|. These macros remain
integer-only, even with \xintfracname loaded.

\subsection{\csbh{xintDouble}, \csbh{xintHalf}}
\label{xintDouble}
\label{xintHalf}
{\small New with |1.08|.\par}

\csa{xintDouble\n} returns |2N| and \csa{xintHalf\n} is |N/2| rounded
towards zero. These macros remain integer-only, even with \xintfracname loaded.

\subsection{\csbh{xintDSL}}\label{xintDSL}

\csa{xintDSL\n} is decimal shift left, \emph{i.e.} multiplication
by ten.

\subsection{\csbh{xintDSR}}\label{xintDSR}

\csa{xintDSR\n} is decimal shift right, \emph{i.e.} it removes the last digit
(keeping the sign), equivalently it is the closest integer to |N/10| when
starting at zero.

\subsection{\csbh{xintDSH}}\label{xintDSH}

\csa{xintDSH\x\n} is parametrized decimal shift. When |x| is
negative, it is like iterating \csa{xintDSL} \verb+|x|+ times
(\emph{i.e.} multiplication by &10^{-&|x|&}&). When |x| positive,
it is like iterating \csa{DSR} |x| times (and is more efficient of
course), and for a non-negative |N| this is thus the same as the
quotient from the euclidean division by |10^x|. 

\subsection{\csbh{xintDSHr}, \csbh{xintDSx}}\label{xintDSHr}\label{xintDSx}
{\small New in release |1.01|.\par}

\csa{xintDSHr\x\n} expects |x| to be zero or positive and it returns
then a value |R| which is correlated to the value |Q| returned by
\csa{xintDSH\x\n} in the following manner:
\begin{itemize}
\item if |N| is
  positive or zero, |Q| and |R| are the quotient and remainder in
  the euclidean division by |10^x| (obtained in a more efficient
  manner than using \csa{xintDivision}),
\item if |N| is negative let
  |Q1| and |R1| be the quotient and remainder in the euclidean
  division by |10^x| of the absolute value of |N|. If |Q1|
  does not vanish, then |Q=-Q1| and |R=R1|. If |Q1| vanishes, then
  |Q=0| and |R=-R1|.
\item for |x=0|, |Q=N| and |R=0|.
\end{itemize}
So one has |N = 10^x Q + R| if |Q| turns out to be zero or
positive, and |N = 10^x Q - R| if |Q| turns out to be negative,
which is exactly the case when |N| is at most |-10^x|.


\csa{xintDSx\x\n} for |x| negative is exactly as
\csa{xintDSH\x\n}, \emph{i.e.} multiplication by &10^{-&|x|&}&.
For |x| zero or positive it returns the two numbers |{Q}{R}|
described above, each one within braces. So |Q| is
\csa{xintDSH\x\n}, and |R| is \csa{xintDSHr\x\n}, but computed
simultaneously.

\begin{flushleft}
  \xintAssign\xintDSx {-1}{-123456789}\to\M 
  \noindent{|\xintAssign\xintDSx {-1}{-123456789}\to\M|}\\
  |\meaning\M: |\digitstt{\meaning\M}.\\
  \xintAssign\xintDSx {-20}{1234567689}\to\M 
  {|\xintAssign\xintDSx {-20}{123456789}\to\M|}\\ 
  |\meaning\M: |\digitstt{\meaning\M}.\\
  \xintAssign\xintDSx{0}{-123004321}\to\Q\R 
  {|\xintAssign\xintDSx {0}{-123004321}\to\Q\R|}\\
  \noindent|\meaning\Q: |\digitstt{\meaning\Q}, |\meaning\R:
  |\digitstt{\meaning\R.}\\
  |\xintDSH {0}{-123004321}|\digitstt{=\xintDSH {0}{-123004321}},
  |\xintDSHr {0}{-123004321}|\digitstt{=\xintDSHr {0}{-123004321}}\\
  \xintAssign\xintDSx {6}{-123004321}\to\Q\R 
  {|\xintAssign\xintDSx {6}{-123004321}\to\Q\R|}\\ 
  |\meaning\Q: |\digitstt{\meaning\Q},
  |\meaning\R: |\digitstt{\meaning\R.}\\
  |\xintDSH {6}{-123004321}|\digitstt{=\xintDSH {6}{-123004321}},
  |\xintDSHr {6}{-123004321}|\digitstt{=\xintDSHr {6}{-123004321}}\\
  \xintAssign\xintDSx {8}{-123004321}\to\Q\R 
  {|\xintAssign\xintDSx {8}{-123004321}\to\Q\R|}\\ 
  |\meaning\Q: |\digitstt{\meaning\Q},
  |\meaning\R: |\digitstt{\meaning\R.} \\
  |\xintDSH {8}{-123004321}|\digitstt{=\xintDSH {8}{-123004321}},
  |\xintDSHr {8}{-123004321}|\digitstt{=\xintDSHr {8}{-123004321}}\\
  \xintAssign\xintDSx {9}{-123004321}\to\Q\R 
  {|\xintAssign\xintDSx {9}{-123004321}\to\Q\R|}\\ 
  |\meaning\Q: |\digitstt{\meaning\Q},
  |\meaning\R: |\digitstt{\meaning\R.}\\
  |\xintDSH {9}{-123004321}|\digitstt{=\xintDSH {9}{-123004321}},
  |\xintDSHr {9}{-123004321}|\digitstt{=\xintDSHr {9}{-123004321}}\\
\end{flushleft}

\subsection{\csbh{xintDecSplit}}\label{xintDecSplit}

{\small This has been modified in release |1.01|.\par}

\csa{xintDecSplit\x\n} cuts the number into two pieces (each one within a
pair of enclosing braces). First the sign if present is \emph{removed}.
Then, for |x| positive or null, the second piece contains the |x| least
significant digits (\emph{empty} if |x=0|) and the first piece the remaining
digits (\emph{empty} when |x| equals or exceeds the length of |N|).
Leading zeros in the second piece are not removed. When |x| is negative
the first piece contains the \verb+|x|+ most significant digits and the
second piece the remaining digits (\emph{empty} if &|x|& equals or exceeds
the length of |N|). Leading zeros in this second piece are not removed.
So the absolute value of the original number is always the concatenation
of the first and second piece.

{\footnotesize This macro's behavior for |N| non-negative is final and will not
  change. I am still hesitant about what to do with the sign of a
  negative |N|.\par}


\xintAssign\xintDecSplit {0}{-123004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {0}{-123004321}\to\L\R|}
\noindent|\meaning\L: |\digitstt{\meaning\L}, |\meaning\R: |\digitstt{\meaning\R.}
\xintAssign\xintDecSplit {5}{-123004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {5}{-123004321}\to\L\R|}
|\meaning\L: |\digitstt{\meaning\L}, |\meaning\R: |\digitstt{\meaning\R.}
\xintAssign\xintDecSplit {9}{-123004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {9}{-123004321}\to\L\R|}
|\meaning\L: |\digitstt{\meaning\L}, |\meaning\R: |\digitstt{\meaning\R.}
\xintAssign\xintDecSplit {10}{-123004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {10}{-123004321}\to\L\R|}
|\meaning\L: |\digitstt{\meaning\L}, |\meaning\R: |\digitstt{\meaning\R.}
\xintAssign\xintDecSplit {-5}{-12300004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {-5}{-12300004321}\to\L\R|}
|\meaning\L: |\digitstt{\meaning\L}, |\meaning\R: |\digitstt{\meaning\R.}
\xintAssign\xintDecSplit {-11}{-12300004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {-11}{-12300004321}\to\L\R|}
|\meaning\L: |\digitstt{\meaning\L}, |\meaning\R: |\digitstt{\meaning\R.}
\xintAssign\xintDecSplit {-15}{-12300004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {-15}{-12300004321}\to\L\R|}
|\meaning\L: |\digitstt{\meaning\L}, |\meaning\R: |\digitstt{\meaning\R.}

\subsection{\csbh{xintDecSplitL}}\label{xintDecSplitL}

\csa{xintDecSplitL\x\n} returns the first piece after the action
of \csa{xintDecSplit}.

\subsection{\csbh{xintDecSplitR}}\label{xintDecSplitR}

\csa{xintDecSplitR\x\n} returns the second piece after the action
of \csa{xintDecSplit}.



\section{Commands of the \xintfracname package}\label{sec:comfrac}

\def\x{\string{x\string}}

This package was first included in release |1.03| of the \xintname bundle. The
general rule of the bundle that each macro first expands (what comes first,
fully) each one of its arguments applies. 


|f| stands for an integer or a fraction (see \autoref{sec:inputs} for the
accepted input formats) or something which expands to an integer or fraction. It
is possible to use in the numerator or the denominator of |f| count
registers\MyMarginNote{Not previously documented} and even expressions with
infix arithmetic operators, under some rules which are explained in the previous
\hyperlink{useofcount}{Use of count registers} section.

As in the \hyperref[sec:comxint]{xint.sty} documentation, |x|
stands for something which will internally be embedded in a \csa{numexpr}.
It 
may thus be a count register or something like |4*\count 255 + 17|, etc..., but
must expand to an integer obeying the \TeX{} bound.

The fraction format on output is the scientific notation for the `float' macros,
and the |A/B[n]| format for all other fraction macros, with the exception of
\csb{xintTrunc}, {\color{blue}\string\xint\-Round} (which produce decimal
numbers) 
and \csb{xintIrr}, \csb{xintJrr}, \csb{xintRawWithZeros} (which return an |A/B|
with no trailing |[n]|, even if |B| turns out to be |1|). Use \csb{xintNum} for
fractions a priori known to simplify to integers: |\xintNum {\xintAdd {2}{3}}|
gives \digitstt{\xintNum {\xintAdd {2}{3}}} whereas |\xintAdd {2}{3}| returns
\digitstt{\xintAdd {2}{3}}. Some macros (among them \csb{xintiTrunc},
\csb{xintiRound}, and \csb{xintFac}) already produce integers on output.


\localtableofcontents

\subsection{\csbh{xintLen}}\label{xintLen}

The original macro is extended to accept a fraction on input.
\centeredline {|\xintLen {201710/298219}|\digitstt{=\xintLen {201710/298219}},
|\xintLen {1234/1}|\digitstt{=\xintLen {1234/1}}, |\xintLen {1234}|%
                    \digitstt{=\xintLen {1234}}}


\subsection{\csbh{xintRaw}}\label{xintRaw}

{\small New with release |1.04|.\par}
{\small \color{red}MODIFIED IN |1.07|.\par}

This macro `prints' the 
fraction |f| as it is received by the package after its parsing and
expansion, in a printable form |A/B[n]| equivalent to the internal
representation: the denominator |B| is always strictly positive and is
printed even if it has value |1|. 
\centeredline{|\xintRaw{\the\numexpr 571*987\relax.123e-10/\the\numexpr
    -201+59\relax e-7}=|}%
\centeredline{\digitstt{\xintRaw{\the\numexpr
      571*987\relax.123e-10/\the\numexpr -201+59\relax e-7}}}


\subsection{\csbh{xintRawWithZeros}}\label{xintRawWithZeros}

{\small New name in |1.07| (former name |\xintRaw|).\par}

This macro `prints' the 
fraction |f| (after its parsing and expansion) in |A/B| form, with |A|
as returned by \csa{xintNumerator}|{f}| and |B| as returned by
\csa{xintDenominator}|{f}|.
\centeredline{|\xintRawWithZeros{\the\numexpr 571*987\relax.123e-10/\the\numexpr
    -201+59\relax e-7}=|}%
\centeredline{\digitstt{\xintRawWithZeros{\the\numexpr
      571*987\relax.123e-10/\the\numexpr -201+59\relax e-7}}} 

\subsection{\csbh{xintNumerator}}\label{xintNumerator}

This returns the numerator corresponding to the internal representation of a
fraction, with positive powers of ten converted into zeros of this numerator:
\centeredline{|\xintNumerator
  {178000/25600000[17]}|\digitstt{=\xintNumerator {178000/25600000[17]}}}
\centeredline{|\xintNumerator {312.289001/20198.27}|%
      \digitstt{=\xintNumerator {312.289001/20198.27}}}
\centeredline{|\xintNumerator {178000e-3/256e5}|\digitstt{=\xintNumerator
    {178000e-3/256e5}}} 
\centeredline{|\xintNumerator {178.000/25600000}|\digitstt{=\xintNumerator
    {178.000/25600000}}} As shown by the examples, no simplification of the
input is done. For a result uniquely associated to the value of the fraction
first apply \csa{xintIrr}.

\subsection{\csbh{xintDenominator}}\label{xintDenominator}

This returns the denominator corresponding to the internal representation of the
fraction:\footnote{recall that the |[]| construct excludes presence of a decimal
  point.} \centeredline{|\xintDenominator
  {178000/25600000[17]}|\digitstt{=\xintDenominator {178000/25600000[17]}}}%
\centeredline{|\xintDenominator {312.289001/20198.27}|%
               \digitstt{=\xintDenominator {312.289001/20198.27}}}
\centeredline{|\xintDenominator {178000e-3/256e5}|\digitstt{=\xintDenominator
    {178000e-3/256e5}}} 
\centeredline{|\xintDenominator {178.000/25600000}|\digitstt{=\xintDenominator
    {178.000/25600000}}} As shown by the examples, no simplification of the
input is done. The denominator looks wrong in the last example, but the
numerator was tacitly multiplied by &1000& through the removal of the decimal
point.   For a result uniquely associated to the value of the fraction
first apply \csa{xintIrr}.


\subsection{\csbh{xintFrac}}\label{xintFrac}

This is a \LaTeX{} only command, to be used in math mode only. It will print a
fraction, internally represented as something equivalent to |A/B[n]| as |\frac
{A}{B}10^n|. The power of ten is omitted when |n=0|, the denominator is omitted
when it has value one, the number being separated from the power of ten by a
|\cdot|. |$\xintFrac {178.000/25600000}$| gives $\xintFrac {178.000/25600000}$,
|$\xintFrac {178.000/1}$| gives $\xintFrac {178.000/1}$,  |$\xintFrac
{3.5/5.7}$| gives $\xintFrac {3.5/5.7}$, and |$\xintFrac {\xintNum
  {\xintFac{10}/|\allowbreak|\xintiSqr{\xintFac {5}}}}$| gives
 $\xintFrac {\xintNum {\xintFac{10}/\xintiSqr{\xintFac {5}}}}$. 
As shown by the examples, 
simplification of the input (apart from removing the decimal points and
moving the minus sign to the numerator) is not done automatically and must be
the result of macros such as |\xintIrr|, |\xintREZ|, or |\xintNum| (for
fractions being in fact integers.)

\subsection{\csbh{xintSignedFrac}}\label{xintSignedFrac}

{\small New with release |1.04|.\par}

This is as \csb{xintFrac} except that a negative fraction has the sign put in
front, not in the numerator.
\centeredline{|\[\xintFrac {-355/113}=\xintSignedFrac {-355/113}\]|}
\[\xintFrac {-355/113}=\xintSignedFrac {-355/113}\]

\subsection{\csbh{xintFwOver}}\label{xintFwOver}

This does the same as \csa{xintFrac} except that the \csa{over} primitive is
used for the fraction (in case the denominator is not one; and a pair of braces
contains the |A\over B| part). |$\xintFwOver {178.000/25600000}$| gives
$\xintFwOver {178.000/25600000}$, |$\xintFwOver {178.000/1}$| gives $\xintFwOver
{178.000/1}$, |$\xintFwOver {3.5/5.7}$| gives $\xintFwOver {3.5/5.7}$, and
|$\xintFwOver {\xintNum {\xintFac{10}/\xintiSqr{\xintFac {5}}}}$| gives
$\xintFwOver {\xintNum {\xintFac{10}/\xintiSqr{\xintFac {5}}}}$.

\subsection{\csbh{xintSignedFwOver}}\label{xintSignedFwOver}

{\small New with release |1.04|.\par}

This is as \csb{xintFwOver} except that a negative fraction has the sign put in
front, not in the numerator.
\centeredline{|\[\xintFwOver {-355/113}=\xintSignedFwOver {-355/113}\]|}
\[\xintFwOver {-355/113}=\xintSignedFwOver {-355/113}\]


\subsection{\csbh{xintREZ}}\label{xintREZ}

This command normalizes a fraction by removing the powers of ten from its
numerator and denominator: |\xintREZ {178000/25600000[17]}|\digitstt{=\xintREZ
  {178000/25600000[17]}}, |\xintREZ
{1780000000000e30/2560000000000e15}|\digitstt{=\xintREZ 
{1780000000000e30/2560000000000e15}}. As shown by the example, it does not
otherwise simplify the fraction.

\subsection{\csbh{xintE}}\label{xintE}
{\small New with |1.07|.}

|\xintE {f}{x}| multiplies the fraction |f| by &10^x&. The \emph{second}
argument |x| must obey the \TeX{} bounds. It may be a count register: |\count
255 123456789 \xintE {10}{\count 255}|\digitstt{->\count
255 123456789 \xintE {10}{\count 255}}. Be careful that for obvious reasons such
gigantic numbers should not be given to \csb{xintNum}, or added to something
with a widely different order of magnitude, as the package always works to get
the \emph{exact} result. There is \emph{no problem} using them for
\emph{float} operations:\centeredline{|\xintFloatAdd
  {1e1234567890}{1}|\digitstt{=\xintFloatAdd {1e1234567890}{1}}}

\subsection{\csbh{xintIrr}}\label{xintIrr}
{\small \color{red}MODIFIED IN |1.08|.\par}

This puts the fraction into its unique irreducible form: \centeredline{|\xintIrr
  {178.256/256.178}|%
  \digitstt{=\xintIrr {178.256/256.178}}${}=\xintFrac{\xintIrr
    {178.256/256.178}[0]}$}%
Note that the current implementation does not cleverly first factor powers of 2
and 5, so input such as |\xintIrr {2/3[100]}| will make \xintfracname do the
Euclidean division of |2|\raisebox{.5ex}{|.|}|10^{100}| by |3|, which is a bit
stupid.

Starting with release |1.08|, \csa{xintIrr} does not remove the trailing |/1|
when the output is an integer. This makes things easier for post-treatment by
user defined macros. So the output format is now \emph{always} |A/B| with |B>0|.
Use \csb{xintNum} rather than \csa{xintIrr} if it is known that the output is an
integer and the trailing |/1| is a nuisance.

\subsection{\csbh{xintJrr}}\label{xintJrr}
{\small \color{red}MODIFIED IN |1.08|.\par}

This also puts the fraction into its unique irreducible form:
\centeredline{|\xintJrr {178.256/256.178}|%
  \digitstt{=\xintJrr {178.256/256.178}}}%
This is faster than \csa{xintIrr} for fractions having some big common
factor in the numerator and the denominator.\par
{\centering |\xintJrr {\xintiPow{\xintFac {15}}{3}/\xintiPrdExpr
{\xintFac{10}}{\xintFac{30}}{\xintFac{5}}\relax }|\digitstt{=%
 \xintJrr {\xintiPow{\xintFac {15}}{3}/\xintiPrdExpr
{\xintFac{10}}{\xintFac{30}}{\xintFac{5}}\relax }}\par} But to notice the
difference one would need computations with much bigger numbers than in this
example.
Starting with release |1.08|, \csa{xintJrr} does not remove the trailing |/1|
when the output is an integer. 


\subsection{\csbh{xintTrunc}}\label{xintTrunc}

\csa{xintTrunc}|{x}{f}| returns the start of the decimal expansion of the
fraction |f|, with |x| digits after the decimal point. The argument |x| should
be non-negative. When |x=0|, the integer part of |f| results, with an ending
decimal point. Only when |f| evaluates to zero does \csa{xintTrunc} not print a
decimal point. When |f| is not zero, the sign is maintained in the output, also
when the digits are all zero. \centeredline{|\xintTrunc
  {16}{-803.2028/20905.298}|\digitstt{=\xintTrunc {16}{-803.2028/20905.298}}}%
\centeredline{|\xintTrunc {20}{-803.2028/20905.298}|\digitstt{=\xintTrunc
    {20}{-803.2028/20905.298}}}%
\centeredline{|\xintTrunc {10}{\xintPow {-11}{-11}}|\digitstt{=\xintTrunc
    {10}{\xintPow {-11}{-11}}}}%
\centeredline{|\xintTrunc {12}{\xintPow {-11}{-11}}|\digitstt{=\xintTrunc
    {12}{\xintPow {-11}{-11}}}}%
\centeredline{|\xintTrunc {12}{\xintAdd {-1/3}{3/9}}|\digitstt{=\xintTrunc
    {12}{\xintAdd {-1/3}{3/9}}}} The digits printed are exact up to and
including the last one. The identity |\xintTrunc {x}{-f}=-\xintTrunc {x}{f}|
holds.\footnote{Recall that |-\string\macro| is not valid as argument to any
  package macro, one must use |\string\xintOpp\string{\string\macro\string}| or
  |\string\xintiOpp\string{\string\macro\string}|, except inside
  |\string\xinttheexpr...\string\relax|.}

\subsection{\csbh{xintiTrunc}}\label{xintiTrunc}

\csa{xintiTrunc}|{x}{f}| returns the integer equal to |10^x| times what
\csa{xintTrunc}|{x}{f}| would return. \centeredline{|\xintiTrunc
  {16}{-803.2028/20905.298}|\digitstt{=\xintiTrunc {16}{-803.2028/20905.298}}}%
 \centeredline{|\xintiTrunc
  {10}{\xintPow {-11}{-11}}|\digitstt{=\xintiTrunc
  {10}{\xintPow {-11}{-11}}}}%
 \centeredline{|\xintiTrunc
  {12}{\xintPow {-11}{-11}}|\digitstt{=\xintiTrunc
  {12}{\xintPow {-11}{-11}}}}%
Differences between \csa{xintTrunc}|{0}{f}| and \csa{xintiTrunc}|{0}{f}|:
the former cannot be used inside integer-only macros, and the latter
removes the decimal point, and never returns |-0| (and of course removes
all superfluous leading zeros.)

\subsection{\csbh{xintRound}}\label{xintRound}

{\small New with release |1.04|.\par}

\csa{xintRound}|{x}{f}| returns the start of the decimal expansion of the
fraction |f|, rounded to |x| digits precision after the decimal point. The
argument |x| should be non-negative. Only when |f| evaluates exactly to zero
does \csa{xintRound} return |0| without decimal point. When |f| is not zero, its
sign is given in the output, also when the digits printed are all zero.
\centeredline{|\xintRound {16}{-803.2028/20905.298}|\digitstt{=\xintRound
    {16}{-803.2028/20905.298}}}% 
 \centeredline{|\xintRound
  {20}{-803.2028/20905.298}|\digitstt{=\xintRound {20}{-803.2028/20905.298}}}%
 \centeredline{|\xintRound
  {10}{\xintPow {-11}{-11}}|\digitstt{=\xintRound
  {10}{\xintPow {-11}{-11}}}}%
 \centeredline{|\xintRound
  {12}{\xintPow {-11}{-11}}|\digitstt{=\xintRound
  {12}{\xintPow {-11}{-11}}}}%
\centeredline{|\xintRound {12}{\xintAdd {-1/3}{3/9}}|\digitstt{=\xintRound
    {12}{\xintAdd {-1/3}{3/9}}}} 
The identity |\xintRound {x}{-f}=-\xintRound {x}{f}| holds. And regarding
$(-11)^{-11}$ here is some more of its expansion: 
\centeredline{\digitstt{\xintTrunc  {50}{\xintPow {-11}{-11}}\dots}}

\subsection{\csbh{xintiRound}}\label{xintiRound}

{\small New with release |1.04|.\par}

\csa{xintiRound}|{x}{f}| returns the integer equal to |10^x| times what
\csa{xintRound}|{x}{f}| would return. \centeredline{|\xintiRound
  {16}{-803.2028/20905.298}|\digitstt{=\xintiRound {16}{-803.2028/20905.298}}}%
\centeredline{|\xintiRound {10}{\xintPow {-11}{-11}}|\digitstt{=\xintiRound
    {10}{\xintPow {-11}{-11}}}}%
Differences between \csa{xintRound}|{0}{f}| and \csa{xintiRound}|{0}{f}|: 
the former cannot be used inside integer-only macros, and the 
latter removes the decimal point, and never returns |-0| (and of course removes
all superfluous leading zeros.)

\subsection{\csbh{xintDigits}, \csbh{xinttheDigits}}\label{xintDigits}

{\small New with release |1.07|.\par}

The syntax |\xintDigits := D;| (where spaces do not matter) assigns the
value of |D| to the number of digits to be used by floating point
operations. The default is |16|. The maximal value is |32767|. The macro
|\xinttheDigits| serves to print the current value.

\subsection{\csbh{xintFloat}}\label{xintFloat}

{\small New with release |1.07|.\par}

The macro |\xintFloat [P]{f}| has an optional argument |P| which replaces
the current value of |\xintDigits|. The (rounded truncation of the) fraction
|f| is then printed in scientific form, with |P| digits,
a lowercase |e| and an exponent |N|.  The first digit is from |1| to |9|, it is
preceded by an optional minus sign and 
is followed by a dot and |P-1| digits, the trailing zeros
are not trimmed. In the exceptional case where the
rounding went to the next power of ten, the output is |10.0...0eN|
(with a sign, perhaps). The sole exception is for a zero value, which then gets
output as |0.e0| (in an \csa{xintCmp} test it is the only possible output of
\csa{xintFloat} or one of the `Float' macros which will test positive for
equality with zero). 
\centeredline{|\xintFloat[32]{1234567/7654321}|%
               \digitstt{=\xintFloat[32]{1234567/7654321}}}
% \pdfresettimer
\centeredline{|\xintFloat[32]{1/\xintFac{100}}|%
               \digitstt{=\xintFloat[32]{1/\xintFac{100}}}}
% \the\pdfelapsedtime
% 992: plus rapide que ce que j'aurais cru..

The argument to \csa{xintFloat} may be an |\xinttheexpr|-ession, like the
other macros; only its final evaluation is submitted to \csa{xintFloat}: the
inner evaluations of chained arguments are not at all done in `floating'
mode. For this one must use |\xintthefloatexpr|.


\subsection{\csbh{xintAdd}}\label{xintAdd}

The original macro is extended to accept fractions on input. Its output will now
always be in the form |A/B[n]|. The original is available as \csb{xintiAdd}.

\subsection{\csbh{xintFloatAdd}}\label{xintFloatAdd}

{\small New with release |1.07|.\par}

|\xintFloatAdd [P]{f}{g}| first replaces |f| and |g| with their float
approximations, with 2 safety digits. It then adds exactly and outputs in
float format with precision |P| (which is optional) or |\xintDigits| if |P|
was absent, the result of this computation.


\subsection{\csbh{xintSub}}\label{xintSub}

The original macro is extended to accept fractions on input. Its output will now
always be in the form |A/B[n]|.
The original is available as \csb{xintiSub}.

\subsection{\csbh{xintFloatSub}}\label{xintFloatSub}

{\small New with release |1.07|.\par}

|\xintFloatSub [P]{f}{g}| first replaces |f| and |g| with their float
approximations, with 2 safety digits. It then subtracts exactly and outputs in
float format with precision |P| (which is optional), or |\xintDigits| if |P|
was absent, the result of this computation.


\subsection{\csbh{xintMul}}\label{xintMul}

The original macro is extended to accept fractions on input. Its output will now
always be in the form |A/B[n]|. 
The original is available as \csb{xintiMul}.

\subsection{\csbh{xintFloatMul}}\label{xintFloatMul}

{\small New with release |1.07|.\par}

|\xintFloatMul [P]{f}{g}| first replaces |f| and |g| with their float
approximations, with 2 safety digits. It then multiplies exactly and outputs in
float format with precision |P| (which is optional), or |\xintDigits| if |P|
was absent, the result of this computation.

\subsection{\csbh{xintSqr}}\label{xintSqr}

The original macro is extended to accept a fraction on input. Its output will
now always be in the form |A/B[n]|. The original is available as
\csb{xintiSqr}.

\subsection{\csbh{xintDiv}}\label{xintDiv}

\csa{xintDiv}|{f}{g}| computes the fraction |f/g|. As with all other computation
macros, no simplification is done on the output, which is in the form |A/B[n]|.

\subsection{\csbh{xintFloatDiv}}\label{xintFloatDiv}

{\small New with release |1.07|.\par}

|\xintFloatDiv [P]{f}{g}| first replaces |f| and |g| with their float
approximations, with 2 safety digits. It then divides exactly and outputs in
float format with precision |P| (which is optional), or |\xintDigits| if |P|
was absent, the result of this computation.


\subsection{\csbh{xintFac}}\label{xintFac}
{\small Modified in |1.08b| (to allow fractions on input).\par}

The original is extended to allow a fraction on input but this fraction |f| must
simplify to a integer |n| (non negative and at most |999999|, but already
|100000!| is prohibitively time-costly). On output |n!|
(no trailing |/1[0]|). The original macro
(which has less overhead) is still 
available as \csb{xintiFac}.

\subsection{\csbh{xintPow}}\label{xintPow}

\csa{xintPow}{|{f}{g}|}: the original macro is extended to accept fractions on
input. The output will now always be in the form
|A/B[n]| (even when the exponent vanishes: |\xintPow
{2/3}{0}|\digitstt{=\xintPow{2/3}{0}}). The original is available as
\csb{xintiPow}. 

% \xintDigits:= 3;

The exponent is allowed\MyMarginNote{Changed in |1.08b|} to be input as a
fraction but it must simplify to an integer: |\xintPow
{2/3}{10/2}|\digitstt{=\xintPow {2/3}{10/2}}. This integer will be checked to
not exceed |999999999|; future releases will presumably lower this limit as
even much much smaller values already create gigantic numerators and
denominators which can not be computed exactly in a reasonable time. Indeed
|2^999999999| has \digitstt{\xintLen {\xintFloatPow [1]{2}{999999999}}} digits. 



% \xintDigits:= 16;

\subsection{\csbh{xintFloatPow}}\label{xintFloatPow}
{\small New with |1.07|.\par}

|\xintFloatPow [P]{f}{x}| uses either the optional argument |P| or the value of
|\xintDigits|. It computes a floating approximation to |f^x|. 

The exponent |x| will be fed to a |\numexpr|, hence count registers are accepted
on input for this |x|. And the absolute value \verb+|x|+ must obey the \TeX{}
bound. For larger exponents use the slightly slower routine \csb{xintFloatPower}
which allows the exponent to be a fraction simplifying to an integer and does
not limit its size. This slightly slower routine is the one to which |^| is
mapped inside |\xintthefloatexpr...\relax|.


The macro |\xintFloatPow| chooses dynamically an appropriate number of
digits for the intermediate computations, large enough to achieve the desired
accuracy (hopefully).

\centeredline{|\xintFloatPow [8]{3.1415}{1234567890}|%
               \digitstt{=\xintFloatPow [8]{3.1415}{1234567890}}}



\subsection{\csbh{xintFloatPower}}\label{xintFloatPower}
{\small New with |1.07|.\par}

\csa{xintFloatPower}|{f}{g}| computes a floating point value |f^g| where the
exponent |g| is not constrained to be at most the \TeX{} bound
\texttt{\number "7FFFFFFF}. It may even be a
fraction |A/B| but must simplify to an integer.
\centeredline{|\xintFloatPower [8]{1.000000000001}{1e12}|%
               \digitstt{=\xintFloatPower [8]{1.000000000001}{1e12}}}
\centeredline{|\xintFloatPower [8]{3.1415}{3e9}|%
               \digitstt{=\xintFloatPower [8]{3.1415}{3e9}}}
Note that |3e9>2^31|. But  the number following |e| in the output must at any
rate obey the \TeX{}
\digitstt{\number"7FFFFFFF} bound.


Inside an |\xintfloatexpr|-ession, \csa{xintFloatPower} is the function to which
|^| is mapped. The exponent may then be something like |(144/3/(1.3-.5)-37)|
which is, in disguise, an integer.


The intermediate multiplications are done with a higher precision than
|\xintDigits| or the optional |P| argument, in order for the
final result to hopefully have the desired accuracy.

\subsection{\csbh{xintFloatSqrt}}\label{xintFloatSqrt}
{\small New with |1.08|.\par}

\csa{xintFloatSqrt}|[P]{f}| computes a floating point approximation of
$\sqrt{|f|}$, either using the optional precision |P| or the value of
|\xintDigits|. The computation is done for a precision of at least 17 figures
(and the output is rounded if the asked-for precision was smaller).
\centeredline{|\xintFloatSqrt [50]{12.3456789e12}|}%
\centeredline{${}\approx{}$\digitstt{\xintFloatSqrt [50]{12.3456789e12}}}%
\centeredline{|\xintDigits:=50;\xintFloatSqrt {\xintFloatSqrt {2}}|}%
\centeredline{%
  ${}\approx{}$\xintDigits:=50;\digitstt{\xintFloatSqrt {\xintFloatSqrt {2}}}}

% maple: 0.351364182864446216166582311675807703715914271812431919843183 1O^7
%         3.5136418286444621616658231167580770371591427181243e6
% maple: 1.18920711500272106671749997056047591529297209246381741301900
%        1.1892071150027210667174999705604759152929720924638e0


\xintDigits:=16;


\subsection{\csbh{xintSum}, \csbh{xintSumExpr}}\label{xintSum}% le % inutile
\label{xintSumExpr}

The original commands are extended to accept fractions on input and produce
fractions on output. Their outputs will now always be in the form |A/B[n]|. The
originals are available as \csa{xintiSum} and \csa{xintiSumExpr}.


\subsection{\csbh{xintPrd}, \csbh{xintPrdExpr}}\label{xintPrd}\label{xintPrdExpr}

The originals are extended to accept fractions on input and produce fractions on
output. Their outputs will now always be in the form |A/B[n]|. The originals are
available as \csa{xintiPrd} and \csa{xintiPrdExpr}.

\subsection{\csbh{xintCmp}}\label{xintCmp}
{\small Rewritten in |1.08a|.\par}

The macro is extended to fractions. Of course its output is still either
|-1|, |0|, or |1| with no forward slash nor trailing |[n]|. 
The original, which skips the overhead of
the fraction format parsing, is available as \csb{xintiCmp}.

For choosing branches according to the result of comparing |f| and |g|, the
following syntax is recommended: |\xintSgnFork{\xintCmp{f}{g}}{code for
  f<g}{code for f=g}{code for f>g}|.

Note that since release |1.08a| using this macro on inputs with large powers of
tens does not take a quasi-infinite time, contrarily to the earlier, somewhat
dumb version (the earlier version indirectly led to the creation of giant chains
of zeros in certain circumstances, causing a serious efficiency impact).

\subsection{\csbh{xintGeq}}\label{xintGeq}
{\small Rewritten in |1.08a|.\par}

The macro is extended to fractions. The original, which skips the overhead of
the fraction format parsing, is available as \csb{xintiGeq}. Beware that the
comparison is on 
the \emph{absolute values} of the fractions. Can be used as:
\verb+\xintSgnFork{\xintGeq{f}{g}}{}{code for |f|<|g|}{code for
  |f|+$\geqslant$\verb+|g|}+ 


Same improvements in |1.08a| as for
\csb{xintCmp}. 

\subsection{\csbh{xintMax}}\label{xintMax}
{\small Rewritten in |1.08a|.\par}

The macro is extended to fractions. But now |\xintMax {2}{3}| returns
\digitstt{\xintMax {2}{3}}. The original is available as
\csb{xintiMax}. 


\subsection{\csbh{xintMin}}\label{xintMin}
{\small Rewritten in |1.08a|.\par}

The macro is extended to fractions. The original is available as
\csb{xintiMin}.

\subsection{\csbh{xintAbs}}\label{xintAbs}

The macro is extended to fractions. The original is available as
\csb{xintiAbs}. Note that |\xintAbs {-2}|\digitstt{=\xintAbs {-2}} whereas
|\xintiAbs {-2}|\digitstt{=\xintiAbs {-2}}.

\subsection{\csbh{xintSgn}}\label{xintSgn}

The macro is extended to fractions. Of course its output is still either
|-1|, |0|, or |1| with no forward slash nor trailing |[n]|. The
original, which skips the overhead of the fraction format parsing, is
available as \csb{xintiSgn}.

\subsection{\csbh{xintOpp}}\label{xintOpp}

The macro is extended to fractions. The original is available as
\csb{xintiOpp}. Note that |\xintOpp {3}| now outputs \digitstt{\xintOpp {3}}.

\subsection{\csbh{xintDivision}, \csbh{xint\-Quo}, \csbh{xint\-Rem},
  \csbh{xintFDg}, \csbh{xintLDg}, \csbh{xintMON}, \csbh{xintMMON}, \csbh{xintOdd}}

These macros are extended to accept a fraction on input if this fraction
in fact reduces to an integer (if not an |\xintError:NotAnInteger| will
be raised). As usual, the `{\color{blue}i}' variants all exist, they
accept on input only integers in the strict format and have less
overhead. There is no difference in the output, the difference is only
in the accepted format for the inputs.

\subsection{\csbh{xintNum}}\label{xintNum}

The macro is extended to accept a fraction on input. But this fraction should
reduce to an integer. If not an error will be raised. The original is available
as \csb{xintiNum}. It is imprudent to apply \csa{xintNum} to numbers with a
large power of ten given either in scientific notation or with the |[n]|
notation, as the macro will add the necessary zeros to get an explicit
integer.\centeredline{|\xintNum {1e80}|}
\centeredline{\digitstt{\xintNum{1e80}}}


\section{Expandable expressions with the \xintexprname package}%
\label{sec:comexpr}

\SetInnerTocdepthTo {2}

The \xintexprname package was first released with version |1.07| of the
\xintname bundle. Loading this package automatically loads \xintfracname, hence
also \xintname.

\localtableofcontents

\subsection{The \csbh{xintexpr} expressions}\label{xintexpr}%
\label{xinttheexpr}\label{xintthe}


An \xintexprname{}ession is a construct
\csb{xintexpr}\meta{expandable\_expression}|\relax| where the expandable
expression is read and expanded from left to right, and whose constituents
should be (they are uncovered by iterated left to right expansion of the
contents during the scanning):
\begin{itemize}
\item integers or decimal numbers, such as |123.345|, or numbers in scientific
  notation |6.02e23| or |6.02E23| (or anything expanding to
  these things; a decimal number may start directly with a decimal point), 
\item fractions |A/B|, or |a.b/c.d| or |a.beN/c.deM|, if they are to be treated
  as one entity should then be parenthesized, \emph{e.g.} disambiguating |A/B^2|
  from |(A/B)^2|,
\item fractions |A/B[n]| as produced on output by the macros of the
  \xintfracname package; they \emph{must} be enclosed in one pair of braces, for
  example |{13/35[3]}| or |{\x\y\z}| with |\x| expanding to |13/|, |\y|
  expanding to |35[| and |\z| expanding to |3]|, (\emph{note that using
    parentheses does not suffice, braces are required: the parser can not digest
    directly square brackets. Material within braces \emph{must} after complete
    expansion give either an integer {\upshape|A|} or a fraction in
    {\upshape|A/B|} or {\upshape|A/B[n]|} form; it is only in the latter case
    that braces are mandatory. They should \emph{not} be used for material
    expanding to a fraction in scientific notation, or something else than an
    integer or fraction, etc... of course braces also appear in the completely
    other r\^ole of feeding macros with their parameters.}),
\item the standard binary operators, |+|, |-|, |*|, |/|, and |^| (the |**|
  notation for exponentiation is not recognized and will give an error),
\item opening and closing parentheses, with arbitrary level of nesting,
\item |+| and |-| as prefix operators,
\item |!| as postfix factorial operator (applied to a non-negative integer),
\item and sub-expressions |\xintexpr|\meta{stuff}|\relax| (they do not need
  to be put within parentheses).
\end{itemize}


Such an expression, like a |\numexpr| expression, is not directly printable, nor
can it be directly used as argument to the other package macros. For this one
uses one of the two equivalent forms:
\begin{itemize}
\item \csb{xinttheexpr}\meta{expandable\_expression}|\relax|, or
\item \csb{xintthe}|\xintexpr|\meta{expandable\_expression}|\relax|.
\end{itemize}

Both forms are equivalent and produce, always, a fraction in the standard
|A/B[n]| format (even when the result is an integer; as usual no automatic
simplification is done, and adding fractions multiplies all the denominators).
\centeredline{|\xinttheexpr
  1+1/2!+1/3!+1/4!+1/5!\relax|\digitstt{=\xinttheexpr1+1/2!+1/3!+1/4!+1/5!\relax}}

One will usually post-process with |\xintIrr|, |\xintTrunc| or |\xintRound|, or
|\xintFloat|, or |\xintNum| (when the output is known to be an integer) to get
the result in the desired form. One may imagine some future version where the
output format will be given as optional argument to |\xintexpr|.
\centeredline{|\xintIrr{\xinttheexpr
    1+1/2!+1/3!+1/4!+1/5!\relax}|%
    \digitstt{=\xintIrr{\xinttheexpr1+1/2!+1/3!+1/4!+1/5!\relax}}}
\centeredline{|\xinttheexpr 1.99^-2 - 2.01^-2 \relax|\digitstt{=\xinttheexpr
    1.99^-2 - 2.01^-2 \relax}} \centeredline{|\xintRound{10}{\xinttheexpr
    1.99^-2 - 2.01^-2 \relax}|\digitstt{=\xintRound{10}{\xinttheexpr 1.99^-2 -
      2.01^-2 \relax}}}

\smallskip
Again:
\begin{itemize}
\item \xintexprname{}essions evaluate through expansion to arbitrarily big
  fractions (in a non-directly printable form),
\item the standard operations of addition, subtraction,
  multiplication, division, power, are written in infix form,
\item recognized numbers on input are either integers, decimal numbers, or
  numbers written in scientific notation, (or anything expanding to the previous
  things), 
\item fractions on input which contain the |[n]| part, or macros expanding to
  some |A/B[n]| with the trailing |[n]| must be enclosed in 
  (precisely one) pair of braces to be parsable by the expression
  scanner,\footnote{the reason why the braced material should not be a number in
    scientific notation is that the `e' will become of catcode other and not be
    understood then by the package macros; this is different from an `e'
    directly seen by the parser, for which the catcode does not matter. Of
    course if the brace pair is for feeding an argument to a macro, then all of
    the above is irrelevant.}
\item the expression may contain arbitrarily many levels of nested parenthesized
  sub-expressions,  
\item sub-contents evaluating to fractions should be either
   \begin{enumerate}
   \item parenthesized,\footnote{recall that the parser does not produce
       explicit fractions |A/B[n]|, hence the bracing rule does not
       apply 
       to the result of the evaluation of the contents within parentheses;
       except of course if it was produced by some other means giving an
       explicit |A/B[n]|, but then braces should have been used, not
       parentheses.} 
   \item a sub-expression |\xintexpr...\relax|,
   \item or braced (use of infix operators inside the braced material will have
     to 
     be 
     understood by the enclosed macros, which may be external to the
     package, or explicitely enclosed in a sub |\xinttheexpr...\relax|). 
   \end{enumerate}
 \item an expression can not be given as argument to the other package macros,
   nor printed, for this one must use |\xinttheexpr...\relax| or
   |\xintthe\xintexpr...\relax|,
\item the output of these latter expressions is always in the |A/B[n]|
  form, and may serve as input to the other package macros accepting fractions,
\item |\xinttheexpr...\relax| as a sub-constituent of an |\xintexpr...\relax|
  must be within some braces, else it should be written directly as
  |\xintexpr...\relax|, 
\item as usual no simplification is done on the output and is the responsability
  of post-processing,
\item very long output will need special macros to break
  across lines, like the |\printnumber| macro used in this documentation,
\item everything is expanded along the way, the expression may contain
  macros, but of course use of |+|, |*|, ... within their arguments
  is only possible if
  these macros know how to deal with them,
\item finally each \xintexprname{}ession is completely expandable and obtains
  its result in two expansion steps.
\end{itemize}

\subsection{\texorpdfstring{\texttt{\protect\string\numexpr}}{\textbackslash numexpr} expressions, count and dimension registers}

They can not be used directly but must be prefixed by |\the| or |\number| for
the count registers and by |\number| for the dimension registers. The dimension
is then converted to its value in scalable points |sp|, which are |1/65536|th of
a point.

One may thus compute exactly and expandably with dimensions even exceeding
temporarily the \TeX{} limits and then convert back approximately to points by
division by |65536| and rounding to |4|,|5| or |6| decimal digits after the
decimal point.


\subsection{Catcodes and spaces}


Spaces inside an |\xinttheexpr...\relax| should mostly be
innocuous\footnote{release |1.08b| fixes a bug in this context.} (if the
expression contains macros, then it is the macro which is responsible for
grabbing its arguments, so spaces within the arguments are presumably to be
avoided, as a general rule.).

|\xintexpr| and |\xintthexpr| are very agnostic regarding catcodes: digits,
binary operators, minus and plus signs as prefixes, parentheses, decimal point,
may be indifferently of catcode letter or other or subscript or superscript,
..., it does not matter. Of course |+|, |-|, |*|, |/|, |^| or |!| should not be
active as everything is expanded along the way. If one of them (especially |!|
which is made active by Babel for certain languages) is active, it should be
prefixed with |\string|. In the case of the factorial, the macro |\xintFac| may
be used rather than the postfix |!|, preferably within braces as this will avoid
the subsequent slow scan digit by digit of its expansion (other macros from the
\xintfracname package generally \emph{must} be used within a brace pair, as they
expand to fractions |A/B[n]| with the trailing |[n]|; the |\xintFac| produces an
integer with no |[n]| and braces are only optional, but preferable, as the
scanner will get the job done faster.)

Sub-material within braces is treated technically in a different manner, and
depending on the macros used therein may be more sensitive to the catcode of the
five operations (the minus sign as prefix in particular). Digits, slash, square
brackets, sign, produced on output by an |\xinttheexpr| are all of catcode 12.
For the output of |\xintthefloatexpr| digits, decimal dot, signs are of catcode
12, and the `e' is of catcode 11. 

Note that if some macro is inserted in the expression it will expand and grab
its arguments before the parser may get a chance to see them, so the situation
with catcodes and spaces is not as flexible within the macro arguments.


\subsection{Expandability}

As is the case with all other package macros |\xintexpr| expands in two steps to
its final (non-printable) result; and similarly for |\xinttheexpr|. The
`lowercase' form are a bit unusual as these macros are already in lowercase... :
|\xinteval| for |\xintexpr| and |\xinttheeval| for |\xinttheexpr|. 

Similarly,
there are |\xintfloateval| and |\xintthefloateval|.

As explained above the expressions should contain only expandable material,
except that braces are allowed when they enclose either a fraction (or decimal
number) or something arbitrarily complicated but expanding (in a manner
compatible to an expansion only context) to such a fraction or decimal number.

\subsection{Memory considerations}

The parser creates an undefined control sequence for each intermediate
computation (this does not of course refer to the intermediate steps needed in
the evaluations of the \csb{xintAdd}, \csb{xintMul}, etc... macros corresponding
to the infix operators, but only to each conversion of such an infix operator
into a computation). So, a moderately sized expression might create 10, or 20
such control sequences. On my \TeX{} installation, the memory available for such
things is of circa \np{200000} multi-letter control words. So this means that a
document containing hundreds, perhaps even thousands of expressions will compile
with no problem. But, if the package is used for computing plots\footnote{this
  is not very probable as so far \xintname does not include a mathematical
  library with floating point calculations, but provides only the basic
  operations of algebra.}, this may cause a problem.

There is a solution.\footnote{which convinced me that I could stick with the
  parser implementation despite its potential impact on the hash-table.}

A
document can possibly do tens of thousands of evaluations only
if some formulas are being used repeatedly, for example inside loops, with
counters being incremented, or with data being fetched from a file. So it is the
same formula used again and again with varying numbers inside.

With the \csb{xintNewExpr} command, it is possible to convert once and for all
an expression containing parameters into an expandable macro with parameters.
Only this initial definition of this macro actually activates the \csb{xintexpr}
parser and will (very moderately) impact the hash-table: once this unique
parsing is done, a macro with parameters is produced which is built-up
recursively from the \csb{xintAdd}, \csb{xintMul}, etc... macros, exactly as it
was necessary to do before the availability of the \xintexprname package.

\subsection{The \csbh{xintNewExpr} command}\label{xintNewExpr}

This allows to define a completely expandable macro with parameters, expanding
in two steps to its final evaluation, and corresponding to the given
\xintname{}expression where the parameters are input using the underscore as
macro-parameter: |_1|, ..., |_9|.\footnote{using the character |\#| as in
  standard macros would have been more complicated to implement, the question
  mark |?| is sometimes made active for reasons of punctuation, the dollar sign
  was perfect but my text editor does some automatic font coloring and size
  change when visualizing a |.tex| file and encountering such a |\$|, there was
  also the tab character |\&| which could have been used. Perhaps a future
  release could leave the choice of the character to the user.}

The command is used
as:\centeredline{|\xintNewExpr{\myformula}[n]|\marg{stuff}}
\begin{itemize}
\item \meta{stuff} will be inserted inside |\xinttheexpr . . . \relax|,
\item |n| is an integer between zero and nine, inclusive, and tells how many
  parameters will |\myformula| have (it is mandatory even
  if the macro to be defined will have no parameters),
\item placeholders |_1|, |_2|, ..., |_n| are used inside \meta{stuff} to play
  the r\^ole of the macro parameters.  
\end{itemize}

The macro |\myformula| is defined without checking if it
already exists, \LaTeX{} users might prefer to do first |\newcommand*\myformula
{}| to get a reasonable error message in case |\myformula| already exists.

It will be a completely expandable macro entirely built-up using |\xintAdd|,
|\xintSub|, |\xintMul|, |\xintDiv|, |\xintPow|, |\xintOpp| and |\xintFac| and
corresponding to the formula as written with the infix operators.

The formula may of course contain besides the infix operators and macro
parameters some arbitrary decimal numbers, fractions (within braces) and also
macros. If these macros do not involve the parameters, nothing special needs to
be done, they will be expanded once during the construction of the formula. But
if the parameters are to be used within the macros themselves, this has to be
coded in a specific manner, which is to be explained after first examining a few
simpler examples:

\dverb|&
\xintNewExpr\myformA[4]{ _1 + _2 * _3^_4 }
\xintNewExpr\myformB[3]{ (_1 + 1.75)^_2 + _3*2.7 }
\xintNewExpr\myformC[3]{ _1*_1+_2*_2+_3*_3-(_1*_2+_2*_3+_3*_1) }
\xintNewExpr\myformD[2]{ (1+1.5*_1)^_2 - (1+1.5*_2)^_1 }
\xintNewExpr\myformE[2]{ -----((((((_1*10-5*_2)))))) }
\xintNewExpr\myformF[4]{ -_1^-_2*-_3-_4 }
\xintNewExpr\myformG[4]{ -_1*-_2^-_3-_4 }
\xintNewExpr\DET[9]{ _1*_5*_9+_2*_6*_7+_3*_4*_8-_1*_6*_8-_2*_4*_9-_3*_5*_7 }
|

\xintNewExpr\myformA[4]{ _1 + _2 * _3^_4 }
\xintNewExpr\myformB[3]{ (_1 + 1.75)^_2 + _3*2.7 }
\xintNewExpr\myformC[3]{ _1*_1+_2*_2+_3*_3-(_1*_2+_2*_3+_3*_1) }
\xintNewExpr\myformD[2]{ (1+1.5*_1)^_2 - (1+1.5*_2)^_1 }
\xintNewExpr\myformE[2]{ -----((((((_1*10-5*_2)))))) }
\xintNewExpr\myformF[4]{ -_1^-_2*-_3-_4 }
\xintNewExpr\myformG[4]{ -_1*-_2^-_3-_4 }
\xintNewExpr\DET[9]{ _1*_5*_9+_2*_6*_7+_3*_4*_8-_1*_6*_8-_2*_4*_9-_3*_5*_7 }

\ttfamily
|\meaning\myformA:|\printnumber{\meaning\myformA}\endgraf
|\meaning\myformB:|\printnumber{\meaning\myformB}\endgraf
|\meaning\myformC:|\printnumber{\meaning\myformC}\endgraf
|\meaning\myformD:|\printnumber{\meaning\myformD}\endgraf
|\meaning\myformE:|\printnumber{\meaning\myformE}\endgraf
|\meaning\myformF:|\printnumber{\meaning\myformF}\endgraf
|\meaning\myformG:|\printnumber{\meaning\myformG}\endgraf
|\meaning\DET:|\printnumber{\meaning\DET}\endgraf


\centeredline{|\xintNum{\DET {1}{1}{1}{10}{-10}{5}{11}{-9}{6}}|%
       \digitstt{=\xintNum{\DET {1}{1}{1}{10}{-10}{5}{11}{-9}{6}}}}%
\centeredline{|\xintNum{\DET {1}{2}{3}{10}{0}{-10}{21}{2}{-17}}|%
       \digitstt{=\xintNum{\DET {1}{2}{3}{10}{0}{-10}{21}{2}{-17}}}}

\rmfamily

\emph{Remark:} |\meaning| has been used within the argument to a |\printnumber|
command, to avoid going into the right margin, but this zaps all spaces
originally in the output from |\meaning|. Here is as an illustration the raw
output of 
|\meaning| on the last example:

\ttfamily
\meaning\DET
\rmfamily

This is why |\printnumber| was used, to have breaks across lines.

\smallskip

For macros to be inserted within such a created \xintname-formula command, there
are two cases:
\begin{enumerate}
\item the macro does not involve the numbered parameters in its arguments: it
  may then be left as is, and will be evaluated once during the construction of
  the formula,
\item it does involve some of the parameters withing its arguments: then the
  whole thing (macro + argument) should be
  braced (this is not necessary if it is already included into a braced group)
  and the macro should be coded with |:| replacing |\|.
\end{enumerate}

Here are some examples; they are rather silly but this is to
illustrate the general principles.

\dverb|&
\xintNewExpr\myformH[2]{ {:xintMax{_1}{_2}} }
\xintNewExpr\myformI[2]{ {:xintRound{_1}{_2}} - {:xintTrunc{_1}{_2}} }
\xintNewExpr\myformJ[3]{ {:xintSgnFork{:xintSgn{_1}}
                          {\xinttheexpr _2 + _3\relax }
                          {\xinttheexpr _2 - _3\relax }
                          {\xinttheexpr _2 * _3\relax }} }
|

\xintNewExpr\myformH[2]{ {:xintMax{_1}{_2}} }
\xintNewExpr\myformI[2]{ {:xintRound{_1}{_2}} - {:xintTrunc{_1}{_2}} }
\xintNewExpr\myformJ[3]{ {:xintSgnFork{:xintSgn{_1}}
                          {\xinttheexpr _2 + _3\relax }
                          {\xinttheexpr _2 - _3\relax }
                          {\xinttheexpr _2 * _3\relax }} }

\ttfamily
\noindent|\meaning\myformH:|\printnumber{\meaning\myformH}\endgraf
\noindent|\meaning\myformI:|\printnumber{\meaning\myformI}\endgraf
\noindent|\meaning\myformJ:|\printnumber{\meaning\myformJ}\endgraf

% |\myformJ {-13}{100}{10}=|\myformJ {-13}{100}{10}, and
% |\myformJ {0}{100}{10}=|\myformJ {0}{100}{10}, and
% |\myformJ {3}{100}{10}=|\myformJ {3}{100}{10}\endgraf

% |\myformI {12}{1/123}=|\myformI {12}{1/123}, |\myformI {13}{1/123}=|\myformI
% {13}{1/123}, |\xintTrunc {15}{1/123}=|\xintTrunc {15}{1/123}

\rmfamily

One more example:
\dverb(&
\xintNewExpr\myfunction[1]
   { {:xintSgnFork {:xintSgnFork {:xintGeq{_1}{1}} {}{0}{:xintSgn{_1}}}
     {\xinttheexpr -_1 - 1  \relax }
     {\xinttheexpr 1 - _1^2 \relax }
     {\xinttheexpr _1 - 1   \relax }} }
(

\xintNewExpr\myfunction[1]
   { {:xintSgnFork {:xintSgnFork {:xintGeq{_1}{1}} {}{0}{:xintSgn{_1}}}
     {\xinttheexpr -_1 - 1  \relax }
     {\xinttheexpr 1 - _1^2 \relax }
     {\xinttheexpr _1 - 1   \relax }} }% 

The principles were explained earlier:
\begin{enumerate}
\item parameters are denoted |_1|, |_2|, ... , |_9|,
\item anything which can not be immediately expanded, because the parameters
  appear within, must be enclosed, together
  with its arguments, in a brace pair (no need to add one if it already exists),
\item and the macros must be written with a |:| as control character, rather
  than a |\|. This rule applies only to the macros involved in the previous
  item.
\item Finally, if the infix operators |+|, |-|, |*|, |/|, |^| are to be used
  inside macro arguments, this should be done within an |\xinttheexpr...\relax|;
  but this rule applies in general also independently of the |\xintNewExpr|
  context. 
\end{enumerate}
The produced macro |\myfunction| turns out to have meaning in this last case:

\digitstt{\printnumber{\meaning\myfunction }}

The reason why these created macros are made to start with
|\romannumeral0\xintraw| is in order for them to expand in only two steps. Of
course in the last example their occurences in the three sub-branches is
redundant, but we had to use |\xinttheexpr| in each of the three sub-branch,
else the formal parsing done by |\xintNewExpr| would not have had a chance to
discover the binary infix operators and convert them to their macro form.

Things like a closing parenthesis only arising from the expansion of a macro
when the parser goes from left to right will be hard to make understandable to
\csb{xintNewExpr}, if the macro is to contain some of the parameters within its
arguments.

\dverb|&
\def\formula #1#2#3{\xinttheexpr #2\xintSgnFork{\xintSgn{#1}}+-*#3\relax }
|
is a perfectly valid macro definition, which will work to produce |#2+#3|,
|#2-#3|, or |#2*#3| depending on the sign of |#1|. But if we tried the
following: 
\dverb|&
\xintNewExpr\formula[3]{_2{:xintSgnFork{:xintSgn{_1}}+-*}_3}
|
we would discover that it would not compile, despite seemingly following the
enunciated rules. I recall:
\begin{enumerate}\setcounter{enumi}{4}
\item braced material, if not an argument to a macro, should correspond to the
  evaluation of a fraction, and in particular it can not be
  used to produce  an infix operator or an opening or closing
  parenthesis, etc...
\end{enumerate}
This rule was mentioned in the description of \xintexprname{}-ession, 
and it
has to be obeyed in the syntax of the expression argument to \csa{xintNewExpr}.
We could try then:
\dverb|&
\xintNewExpr\formula[3]{{_2:xintSgnFork{:xintSgn{_1}}+-*_3}}
|
This time, |\xintNewExpr| works but the produced |\formula| has meaning
\xintNewExpr\formula[3]{{_2:xintSgnFork{:xintSgn{_1}}+-*_3}}\endgraf
\noindent\digitstt{\printnumber{\meaning\formula}}\endgraf
Clearly this macro will not work. 

We may try
\dverb|&
\xintNewExpr\formula[3]{{:xinttheexpr 
                          _2:xintSgnFork{:xintSgn{_1}}+-*_3:relax}}
| 
but this gives \xintNewExpr\formula[3]{{:xinttheexpr
    _2:xintSgnFork{:xintSgn{_1}}+-*_3:relax}}\endgraf
\noindent\digitstt{\printnumber{\meaning\formula}}
and
there was no point whatsoever in it all, as what we want is to avoid the use of
|\xintexpr|\dots so we end up having to do:
\dverb|&
\xintNewExpr\formula[3]{{:xintSgnFork{:xintSgn{_1}}
                         {\xinttheexpr _2+_3\relax}
                         {\xinttheexpr _2-_3\relax}
                         {\xinttheexpr _2*_3\relax}}}
|
which is like what was done with |\myformJ|.

All of the previous examples may not be very convincing, because it is easier
for the user to define directly a macro with parameters not using |\xinttheexpr|
and achieving the wished-for computation, but |\xintNewExpr| would prove very
useful on more complicated cases with a high level of nesting of macros.

\subsection{\csbh{xintfloatexpr},
  \csbh{xintthefloatexpr}}\label{xintfloatexpr}\label{xintthefloatexpr}

\csb{xintfloatexpr}|...\relax| is exactly like |\xintexpr...\relax| but with the
four binary operations and the power function mapped to \csa{xintFloatAdd},
\csa{xintFloatSub}, \csa{xintFloatMul}, \csa{xintFloatDiv} and
\csa{xintFloatPower}. The precision is from the current setting of
|\xintDigits| (it can not be given as an optional parameter).

Currently, the factorial function hasn't yet a float version; so inside 
|\xintthefloatexpr . . . \relax|, |n!| will be computed exactly. Perhaps this
will 
be improved in a future release. 

\xintDigits:= 9;

Note that |1.000000001| and |(1+1e-9)| will not be equivalent for
|D=\xinttheDigits| set to nine or less. Indeed the addition implicit in |1+1e-9|
(and executed when the closing parenthesis is found) will provoke the rounding
to |1|. Whereas |1.000000001|, when found as operand of one of the four
elementary operations is kept with |D+2| digits, and even more for the power
function. \centeredline{|\xintDigits:= 9; \xintthefloatexpr
  (1+1e-9)-1\relax|\digitstt{=\xintthefloatexpr (1+1e-9)-1\relax}}
\centeredline{|\xintDigits:= 9; \xintthefloatexpr
  1.000000001-1\relax|\digitstt{=\xintthefloatexpr 1.000000001-1\relax}}

For the fun of it:\xintDigits:=20; |\xintDigits:=20;|%
\centeredline{|\xintthefloatexpr (1+1e-7)^1e7\relax|%
       \digitstt{=\xintthefloatexpr (1+1e-7)^1e7\relax}}

|\xintDigits:=36;|\xintDigits:=36;
\centeredline{|\xintthefloatexpr
  ((1/13+1/121)*(1/179-1/173))/(1/19-1/18)\relax|}
\centeredline{\digitstt{\xintthefloatexpr
  ((1/13+1/121)*(1/179-1/173))/(1/19-1/18)\relax}}
\centeredline{|\xintFloat{\xinttheexpr
  ((1/13+1/121)*(1/179-1/173))/(1/19-1/18)\relax}|}
\centeredline{\digitstt{\xintFloat
  {\xinttheexpr((1/13+1/121)*(1/179-1/173))/(1/19-1/18)\relax}}}

\xintDigits := 16; 

The latter result is the rounding of the exact result. The previous one has
rounding errors coming from the various roundings done for each
sub-expression. It was a bit funny  to discover that |maple|, configured with
|Digits:=36;| and with decimal dots everywhere to let it input the numbers as
floats, gives exactly the same result with the same rounding errors
as does |\xintthefloatexpr|!

Note that using |\xintthefloatexpr| only pays off compared to using
|\xinttheexpr| and then |\xintFloat| if the computations turn out to involve
hundreds of digits. For elementary calculations with hand written numbers
(not using the scientific notation with exponents differing greatly) it will
generally be more efficient to use |\xinttheexpr|. The situation is quickly
otherwise if one starts using the Power function. Then, |\xintthefloat| is
often useful; and sometimes indispensable to achieve the (approximate)
computation in reasonable time.

We can try some crazy things:\footnote{this evaluation takes a about a fifth of a second already on my laptop. Recall the constraints of expandability.}
\centeredline{|\xintDigits:=12;\xintthefloatexpr 1.000000000000001^1e15\relax|}
\centeredline{\xintDigits:=12;%
\digitstt{\xintthefloatexpr 1.000000000000001^1e15\relax}}
Note that contrarily to some professional computing sofware which are our
concurrents on this market, the \digitstt{1.000000000000001} wasn't rounded
to |1| despite the setting of \csa{xintDigits}; it would have been if we had
input it as 
|(1+1e-15)|. 

% \xintDigits:=12;
% \pdfresettimer
% \edef\z{\xintthefloatexpr 1.000000000000001^1e15\relax}%
% \edef\temps{\the\pdfelapsedtime}%
% \xintRound {5}{\temps/65536}s\endgraf


\xintDigits := 16; % mais en fait \centeredline crée un groupe.


\subsection{\csbh{xintNewFloatExpr}}\label{xintNewFloatExpr}

This is exactly like \csb{xintNewExpr} except that the created formulas are
set-up to use |\xintthefloatexpr|. The precision used for numbers fetched as
parameters will be the one
locally given by |\xintDigits| at the time of use of the created formulas,
not |\xintNewFloatExpr|. However, the numbers hard-wired in the original
expression will have been evaluated with the then current setting for
|\xintDigits|. 




\xintDigits:= 16;

\subsection{Technicalities and experimental status}

As already mentioned \csa{xintNewExpr}|\myformula[n]| does not check the
prior existence of a macro |\myformula|. And the number of parameters |n| given
as mandatory argument withing square brackets should of course be at least equal
to the actual maximal index following an underscore in the expression.

Obviously I should mention that \csa{xintNewExpr} itself can not be used in an
expansion-only context, as it creates a macro.

The format of the output of |\xintexpr|\meta{stuff}|\relax| is a |!| (with
catcode 11) followed by |\XINT_expr_illegaluse| which prints an error message in
the document and in the log file if it is executed, and next a token |\.A/B[n]|
(which is a single control sequence: these are the famous things which may
impact the hash-table). Using |\xinttheexpr| means zapping the first
two things, and opening up the third token to access its name and get the result
|A/B[n]| of the evaluation of the expression.

I decided to put all intermediate results (from each evaluation of an infix
operators, or of a parenthesized subpart of the expression, or from application
of the minus as prefix, or of the exclamation sign as postfix, or any
encountered braced material) inside |\csname...\endcsname|, as this can be done
expandably and encapsulates an arbitrarily long fraction in a single token (left
with undefined meaning), thus providing tremendous relief to the programmer in
his/her expansion control.

\begin{framed}
  This implementation and user interface are currently to be considered
  \emph{experimental}, they have not been yet extensively tested. Indeed the
  additions brought to the \xintname bundle with release |1.07| are rather
  extant and I just haven't had time to thoroughly validate them all.
\end{framed}

Some `error messages' will be issued by the scanner in case of problems, but
errors may also be issued from low-level \TeX{} processing, and are most of the
time unrecoverable. An attempt has been made to handle gracefully missing or
extraneous parentheses.  


\subsection{Acknowledgements}

I was greatly helped in my preparatory thinking, prior to producing such an
expandable parser, by the commented source of the
\href{http://www.ctan.org/tex-archive/macros/latex/contrib/l3kernel}{l3fp}
package, specifically the |l3fp-parse.dtx| file. Also the source of the |calc|
package was instructive, despite the fact that here for |\xintexpr| the
principles are necessarily different due to the aim of achieving expandability.

I apologize for not including
comments currently in my own code, the reason being that this a time-consuming
task which should wait until the code has a rather certain more-or-less final
form.

\section{Commands of the \xintbinhexname package}\label{sec:combinhex} 

\SetInnerTocdepthTo {1}

This package was first included in the |1.08| release of \xintname. It
provides expandable conversions of arbitrarily long numbers
to and from binary and hexadecimal.

The argument is first fully expanded. It then may start with an optional minus
sign (unique, of category code other), followed with optional leading zeros
(arbitrarily many, category code other) and then ``digits'' (hexadecimal
letters may be of category code letter or other, and must be
uppercased). The optional (unique) minus sign (plus sign is not allowed) is
kept in the output. Leading zeros are allowed, and stripped. The
hexadecimal letters on output are of category code letter, and
uppercased.

% \clearpage

\localtableofcontents



\subsection{\csbh{xintDecToHex}}\label{xintDecToHex}

Converts from decimal to hexadecimal.

\texttt{\string\xintDecToHex \string{\printnumber{2718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003}\string}}\endgraf\noindent\digitstt{->\printnumber{\xintDecToHex{2718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003}}} 

\subsection{\csbh{xintDecToBin}}\label{xintDecToBin}

Converts from decimal to binary.

\texttt{\string\xintDecToBin \string{\printnumber{2718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003}\string}}\endgraf\noindent\digitstt{->\printnumber{\xintDecToBin{2718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003}}} 

\subsection{\csbh{xintHexToDec}}\label{xintHexToDec}

Converts from hexadecimal to decimal.

\texttt{\string\xintHexToDec
  \string{\printnumber{11A9397C66949A97051F7D0A817914E3E0B17C41B11C48BAEF2B5760BB38D272F46DCE46C6032936BF37DAC918814C63}\string}}\endgraf\noindent
\digitstt{->\printnumber{\xintHexToDec{11A9397C66949A97051F7D0A817914E3E0B17C41B11C48BAEF2B5760BB38D272F46DCE46C6032936BF37DAC918814C63}}}
 
\subsection{\csbh{xintBinToDec}}\label{xintBinToDec}

Converts from binary to decimal.

\texttt{\string\xintBinToDec
  \string{\printnumber{100011010100100111001011111000110011010010100100110101001011100000101000111110111110100001010100000010111100100010100111000111110000010110001011111000100000110110001000111000100100010111010111011110010101101010111011000001011101100111000110100100111001011110100011011011100111001000110110001100000001100101001001101101011111100110111110110101100100100011000100000010100110001100011}\string}}\endgraf\noindent
\digitstt{->\printnumber{\xintBinToDec{100011010100100111001011111000110011010010100100110101001011100000101000111110111110100001010100000010111100100010100111000111110000010110001011111000100000110110001000111000100100010111010111011110010101101010111011000001011101100111000110100100111001011110100011011011100111001000110110001100000001100101001001101101011111100110111110110101100100100011000100000010100110001100011}}}

\subsection{\csbh{xintBinToHex}}\label{xintBinToHex}

Converts from binary to hexadecimal.

\texttt{\string\xintBinToHex
  \string{\printnumber{100011010100100111001011111000110011010010100100110101001011100000101000111110111110100001010100000010111100100010100111000111110000010110001011111000100000110110001000111000100100010111010111011110010101101010111011000001011101100111000110100100111001011110100011011011100111001000110110001100000001100101001001101101011111100110111110110101100100100011000100000010100110001100011}\string}}\endgraf\noindent
\digitstt{->\printnumber{\xintBinToHex{100011010100100111001011111000110011010010100100110101001011100000101000111110111110100001010100000010111100100010100111000111110000010110001011111000100000110110001000111000100100010111010111011110010101101010111011000001011101100111000110100100111001011110100011011011100111001000110110001100000001100101001001101101011111100110111110110101100100100011000100000010100110001100011}}}

\subsection{\csbh{xintHexToBin}}\label{xintHexToBin}

Converts from hexadecimal to binary.

\texttt{\string\xintHexToBin
  \string{\printnumber{11A9397C66949A97051F7D0A817914E3E0B17C41B11C48BAEF2B5760BB38D272F46DCE46C6032936BF37DAC918814C63}\string}}\endgraf\noindent
\digitstt{->\printnumber{\xintHexToBin{11A9397C66949A97051F7D0A817914E3E0B17C41B11C48BAEF2B5760BB38D272F46DCE46C6032936BF37DAC918814C63}}}


\subsection{\csbh{xintCHexToBin}}\label{xintCHexToBin}

Also converts from hexadecimal to binary. Faster on inputs with at least
one hundred hexadecimal digits.

\texttt{\string\xintCHexToBin
  \string{\printnumber{11A9397C66949A97051F7D0A817914E3E0B17C41B11C48BAEF2B5760BB38D272F46DCE46C6032936BF37DAC918814C63}\string}}\endgraf\noindent
\digitstt{->\printnumber{\xintCHexToBin{11A9397C66949A97051F7D0A817914E3E0B17C41B11C48BAEF2B5760BB38D272F46DCE46C6032936BF37DAC918814C63}}}



\section{Commands of the \xintgcdname package}



This package was included in the original release |1.0| of the \xintname bundle.
The numbers on input have only one optional minus sign and no leading zeros, as
is the rule with the macros of package \xintname. In case of need, macro
\csb{xintNum} can be used to normalize the inputs.

\localtableofcontents

\subsection{\csbh{xintGCD}}\label{xintGCD}

\csa{xintGCD\n\m} computes the greatest common divisor. It is
positive, except when both |N| and |M| vanish, in which case the macro
returns zero.
\centeredline{\csa{xintGCD}|{10000}{1113}|\digitstt{=\xintGCD{10000}{1113}}}
\centeredline{|\xintGCD{123456789012345}{9876543210321}=|\digitstt
              {\xintGCD{123456789012345}{9876543210321}}}

\subsection{\csbh{xintBezout}}\label{xintBezout}

\xintAssign{{\xintBezout {10000}{1113}}}\to\X
\xintAssign {\xintBezout {10000}{1113}}\to\A\B\U\V\D

\csa{xintBezout\n\m} returns five numbers |A|, |B|, |U|, |V|, |D| within
braces. |A| is the first (expanded, as usual) input number, |B| the
second, |D| is the GCD, and \digitstt{UA - VB = D}. 
\centeredline{|\xintAssign {{\xintBezout {10000}{1113}}}\to\X|}
\centeredline{|\meaning\X: |\digitstt{\meaning\X }.}
\noindent{|\xintAssign {\xintBezout {10000}{1113}}\to\A\B\U\V\D|}\\
|\A: |\digitstt{\A },
|\B: |\digitstt{\B },
|\U: |\digitstt{\U },
|\V: |\digitstt{\V },
|\D: |\digitstt{\D }.\\
\xintAssign {\xintBezout {123456789012345}{9876543210321}}\to\A\B\U\V\D
\noindent{|\xintAssign {\xintBezout {123456789012345}{9876543210321}}\to\A\B\U\V\D
|}\\
|\A: |\digitstt{\A },
|\B: |\digitstt{\B },
|\U: |\digitstt{\U },
|\V: |\digitstt{\V },
|\D: |\digitstt{\D }.


\subsection{\csbh{xintEuclideAlgorithm}}\label{xintEuclideAlgorithm}

\xintAssign {{\xintEuclideAlgorithm {10000}{1113}}}\to\X

\def\restorebracecatcodes
   {\catcode`\{=1 \catcode`\}=2 }

\def\allowlistsplit 
   {\catcode`\{=12 \catcode`\}=12 \allowlistsplita }

\def\allowlistsplitx {\futurelet\listnext\allowlistsplitxx }

\def\allowlistsplitxx {\ifx\listnext\relax \restorebracecatcodes
                        \else \expandafter\allowlistsplitxxx \fi }
\begingroup
\catcode`\[=1
\catcode`\]=2
\catcode`\{=12
\catcode`\}=12
\gdef\allowlistsplita #1{[#1\allowlistsplitx {]
\gdef\allowlistsplitxxx {#1}%
     [{#1}\hskip 0pt plus 1pt \allowlistsplitx ]
\endgroup

\csa{xintEuclideAlgorithm\n\m} applies the Euclide algorithm and
keeps a copy of all quotients and remainders. 
\centeredline{|\xintAssign {{\xintEuclideAlgorithm {10000}{1113}}}\to\X|}

|\meaning\X: |\digitstt{\expandafter\allowlistsplit
               \meaning\X\relax .}

The first token is the number of steps, the second is |N|, the
third is the GCD, the fourth is |M| then the first quotient and
remainder, the second quotient and remainder, \dots until the
final quotient and last (zero) remainder.

\subsection{\csbh{xintBezoutAlgorithm}}\label{xintBezoutAlgorithm}

\catcode`\& 4

\xintAssign {{\xintBezoutAlgorithm {10000}{1113}}}\to\X

\csa{xintBezoutAlgorithm\n\m} applies the Euclide algorithm and
keeps a copy of all quotients and remainders. Furthermore it
computes the entries of the successive products of the 2 by 2 matrices 
$\left(\vcenter{\halign {\,#&\,#\cr q & 1 \cr 1 & 0 \cr}}\right)$
formed from the quotients arising in the algorithm.
\centeredline{|\xintAssign {{\xintEuclideAlgorithm {10000}{1113}}}\to\X|}

|\meaning\X: |\digitstt{\expandafter\allowlistsplit\meaning\X \relax .}

The first token is the number of steps, the second is |N|, then
|0|, |1|, the GCD, |M|, |1|, |0|, the first quotient, the first
remainder, the top left entry of the first matrix, the bottom left
entry, and then these four things at each step until the end.

\catcode`\& 13

\subsection{\csbh{xintTypesetEuclideAlgorithm}\allowbreak\null\hspace*{.25cm}}%
\label{xintTypesetEuclideAlgorithm}

This macro is just an example of how to organize the data returned
by \csa{xintEuclideAlgorithm}. Copy the source code to a new macro
and modify it to what is needed.
\centeredline{|\xintTypesetEuclideAlgorithm
  {123456789012345}{9876543210321}|} \xintTypesetEuclideAlgorithm
{123456789012345}{9876543210321}


\subsection{\csbh{xintTypesetBezoutAlgorithm}}%
\label{xintTypesetBezoutAlgorithm}

This macro is just an example of how to organize the data returned
by \csa{xintBezoutAlgorithm}. Copy the source code to a new macro
and modify it to what is needed.
\centeredline{|\xintTypesetBezoutAlgorithm {10000}{1113}|}
\xintTypesetBezoutAlgorithm {10000}{1113}


\section{Commands of the \xintseriesname package}\label{sec:series}

Some arguments to the package commands are macros which are expanded only later,
when given their parameters. The arguments serving as indices are systematically
given to a |\numexpr| expressions (new with |1.06|!) , hence fully expanded,
they may be count registers, etc...

This package was
first released with version |1.03| of the \xintname bundle.

% \clearpage

\localtableofcontents

\subsection{\csbh{xintSeries}}\label{xintSeries}

\def\coeff #1{\xintiMON{#1}/#1.5} % (-1)^n/(n+1/2)
\edef\w {\xintSeries {0}{50}{\coeff}}
\edef\z {\xintJrr {\w}[0]}

\csa{xintSeries}|{A}{B}{\coeff}| computes
$\sum_{\text{|n=A|}}^{\text{|n=B|}}|\coeff{n}|$. The initial and final indices
must obey the |\numexpr| constraint of expanding to numbers at most |2^31-1|.
The |\coeff| macro must be a
one-parameter fully expandable command, taking on input an explicit number |n|
and producing some fraction |\coeff{n}|; it is expanded at the time it is
needed. 
\dverb|& 
\def\coeff #1{\xintiMON{#1}/#1.5} % (-1)^n/(n+1/2)
\edef\w {\xintSeries {0}{50}{\coeff}} % we want to re-use it
\edef\z {\xintJrr {\w}[0]} % the [0] for a microsecond gain.
% \xintJrr preferred to \xintIrr: a big common factor is suspected.
% But numbers much bigger would be needed to show the greater efficiency.
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} = \xintFrac\z \]
|
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} = \xintFrac\z \] For info,
before action by |\xintJrr| the inner representation of the result has a
denominator of |\xintLen {\xintDenominator\w}=|\xintLen
{\xintDenominator\w} digits. This troubled me as &101!!& has only 81
digits: |\xintLen {\xintQuo {\xintFac {101}}{\xintiMul {\xintiPow
      {2}{50}}{\xintFac{50}}}}|\digitstt{=\xintLen {\xintQuo {\xintFac
      {101}}{\xintiMul {\xintiPow {2}{50}}{\xintFac{50}}}}}. The
explanation lies in the too clever to be efficient |#1.5| trick. It
leads to a silly extra &5^{51}& (which has \xintLen {\xintPow {5}{51}}
digits) in the denominator. See the explanations in the next section.

\begin{framed}
  Note: as soon as the coefficients look like factorials, it is more
  efficient to use the \csb{xintRationalSeries} macro whose evaluation
  will avoid a denominator build-up; indeed the raw operations of
  addition and subtraction of fractions blindly multiply out
  denominators. So the raw evaluation of $\sum_{n=0}^{|N|}1/n!$ with
  \csa{xintSeries} will have a denominator equal to $\prod_{n=0}^{|N|}
  n!$. Needless to say this makes it more difficult to compute the exact
  value of this sum with |N=50|, for example, whereas with
  \csb{xintRationalSeries} the denominator does not
  get bigger than $50!$.

\footnotesize
  For info: by the way $\prod_{n=0}^{50} n!$ is easily computed by \xintname
  and is a number with 1394 digits. And $\prod_{n=0}^{100} n!$ is also
  computable by \xintname (24 seconds on my laptop for the brute force
  iterated multiplication of all factorials, a
  specialized routine would do it faster) and has 6941 digits (this
  means more than two pages if printed...). Whereas $100!$ only has
  158 digits.
\end{framed}

% \newcount\cntb
% \cnta 2
% \loop
% \advance\cntb by \xintLen{\xintFac{\the\cnta}}%
% \ifnum\cnta < 50
% \advance\cnta 1
% \repeat
% \the\cntb

% \cnta 2
% \def\z{1}
% \pdfresettimer
% \loop
% \edef\z {\xintiMul\z{\xintFac{\the\cnta}}}%
% \ifnum\cnta < 100
% \advance\cnta 1
% \repeat
% \edef\temps{\the\pdfelapsedtime}%

% \temps: \xintQuo\temps{\xintiMul{60}{65536}} minutes, 
% \xintQuo{\xintRem\temps{\xintiMul{60}{65536}}}{65536} secondes et 
% \xintiTrunc {2}{\xintRem\temps{65536}/65536} centièmes de secondes
% 1573518: 0 minutes, 24 secondes et 0 centièmes de secondes
% nota bene, marrant c'était 0,99 centièmes en fait.

% \xintLen\z

% \printnumber\z

\setlength{\columnsep}{0pt}
\dverb|&
\def\coeffleibnitz #1{\the\numexpr\ifodd #1 1\else-1\fi\relax/#1[0]}
\cnta 1
\loop  % in this loop we recompute from scratch each partial sum! 
% we can afford that, as \xintSeries is fast enough.
\noindent\hbox to 2em{\hfil\texttt{\the\cnta.} }%  
         \xintTrunc {12}
                    {\xintSeries {1}{\cnta}{\coeffleibnitz}}\dots
\endgraf
\ifnum\cnta < 30 \advance\cnta 1 \repeat
|
\begin{multicols}{3}
  \def\coeffleibnitz #1{\the\numexpr\ifodd #1 1\else-1\fi\relax/#1[0]} \cnta 1
  \loop
  \noindent\hbox to 2em{\hfil\digitstt{\the\cnta.} }% 
  \xintTrunc {12}{\xintSeries {1}{\cnta}{\coeffleibnitz}}\dots
    \endgraf
    \ifnum\cnta < 30 \advance\cnta 1 \repeat
\end{multicols}

\subsection{\csbh{xintiSeries}}\label{xintiSeries}

\def\coeff #1{\xintiTrunc {40}
   {\the\numexpr\ifodd #1 -2\else2\fi\relax/\the\numexpr 2*#1+1\relax [0]}}% 

 \csa{xintiSeries}|{A}{B}{\coeff}| computes
 $\sum_{\text{|n=A|}}^{\text{|n=B|}}|\coeff{n}|$ where now |\coeff{n}|
 \emph{must} expand to a (possibly long) integer, as is acceptable on input by
 the 
 integer-only \csa{xintiAdd}.
\dverb|&
\def\coeff #1{\xintiTrunc {40}{\xintMON{#1}/#1.5}}%
% better:
\def\coeff #1{\xintiTrunc {40}
   {\the\numexpr 2*\xintiMON{#1}\relax/\the\numexpr 2*#1+1\relax [0]}}% 
% better still:
\def\coeff #1{\xintiTrunc {40}
 {\the\numexpr\ifodd #1 -2\else2\fi\relax/\the\numexpr 2*#1+1\relax [0]}}% 
% (-1)^n/(n+1/2) times 10^40, truncated to an integer.
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} \approx
        \xintTrunc {40}{\xintiSeries {0}{50}{\coeff}[-40]}\dots\]
|
The |#1.5| trick to define the |\coeff| macro was neat, but |1/3.5|, for
example, turns internally into |10/35| whereas it would be more efficient to
have |2/7|. The second way of coding the wanted coefficient avoids a superfluous
factor of five and leads to a faster evaluation. The third way is faster, after
all there is no need to use \csb{xintMON} (or rather \csb{xintiMON} which has
less parsing overhead) on integers
obeying the \TeX{} bound. The denominator having no sign, we have added the
|[0]| as this speeds up (infinitesimally) the parsing.
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} \approx \xintTrunc
{40}{\xintiSeries {0}{50}{\coeff}[-40]}\] We should have cut out at
least the last two digits: truncating errors originating with the first
coefficients of the sum will never go away, and each truncation
introduces an uncertainty in the last digit, so as we have 40 terms, we
should trash the last two digits, or at least round at 38 digits. It is
interesting to compare with the computation where rounding rather than
truncation is used, and with the decimal
expansion of the exactly computed partial sum of the series:
\dverb|&
\def\coeff #1{\xintiRound {40} % rounding at 40
  {\the\numexpr\ifodd #1 -2\else2\fi\relax/\the\numexpr 2*#1+1\relax [0]}}% 
% (-1)^n/(n+1/2) times 10^40, rounded to an integer.
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} \approx
        \xintTrunc {40}{\xintiSeries {0}{50}{\coeff}[-40]}\]
\def\exactcoeff #1%
  {\the\numexpr\ifodd #1 -2\else2\fi\relax/\the\numexpr 2*#1+1\relax [0]}%
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} 
   = \xintTrunc {50}{\xintSeries {0}{50}{\exactcoeff}}\dots\]
|
\def\coeff #1{\xintiRound {40}
   {\the\numexpr\ifodd #1 -2\else2\fi\relax/\the\numexpr 2*#1+1\relax [0]}}% 
% (-1)^n/(n+1/2) times 10^40, rounded to an integer.
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} \approx
        \xintTrunc {40}{\xintiSeries {0}{50}{\coeff}[-40]}\]
\def\exactcoeff #1%
  {\the\numexpr\ifodd #1 -2\else2\fi\relax/\the\numexpr 2*#1+1\relax [0]}%
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} 
   = \xintTrunc {50}{\xintSeries {0}{50}{\exactcoeff}}\dots\]
This shows indeed that our sum of truncated terms
estimated wrongly the 39th and 40th digits of the exact result\footnote{as
  the series 
  is alternating, we can roughly expect an error of $\sqrt{40}$ and the
  last two digits are off by 4 units, which is not contradictory to our
  expectations.} and that the sum of rounded terms fared a bit better. 

\subsection{\csbh{xintRationalSeries}}\label{xintRationalSeries}

{\small \hspace*{\parindent}New with release |1.04|.\par}

\noindent \csa{xintRationalSeries}|{A}{B}{f}{\ratio}| evaluates
$\sum_{\text{|n=A|}}^{\text{|n=B|}}|F(n)|$, where |F(n)| is specified indirectly
via the data of |f=F(A)| and the one-parameter macro |\ratio| which must be such
that |\macro{n}| expands to |F(n)/F(n-1)|. The name indicates that
\csa{xintRationalSeries} was designed to be useful in the cases where
|F(n)/F(n-1)| is a rational function of |n| but it may be anything expanding to
a fraction. The macro |\ratio| must be an expandable-only compatible command and
expand to its value after iterated full expansion of its first token. |A| and
|B| are fed to a |\numexpr| hence may be count registers or arithmetic
expressions built with such; they must obey the \TeX{} bound. The initial term
|f| may be a macro |\f|, it will be expanded to its value representing |F(A)|.

\dverb|& 
\def\ratio #1{2/#1[0]}% 2/n, to compute exp(2)
\cnta 0 % previously declared count
\loop \edef\z {\xintRationalSeries {0}{\cnta}{1}{\ratio }}%
\noindent$\sum_{n=0}^{\the\cnta} \frac{2^n}{n!}= 
           \xintTrunc{12}\z\dots=
           \xintFrac\z=\xintFrac{\xintIrr\z}$\vtop to 5pt{}\endgraf
\ifnum\cnta<20 \advance\cnta 1 \repeat
|
\def\ratio #1{2/#1[0]}% 2/n, comes from the series of exp(2)
\cnta 0
\loop
\edef\z {\xintRationalSeries {0}{\cnta}{1}{\ratio }}%
\noindent$\sum_{n=0}^{\the\cnta} \frac{2^n}{n!}= 
           \xintTrunc{12}\z\dots=
           \xintFrac\z=\xintFrac{\xintIrr\z}$\vtop to 5pt{}\endgraf
\ifnum\cnta<20 \advance\cnta 1 \repeat

\medskip
Such computations would become quickly completely inaccessible via the
\csb{xintSeries} macros, as the factorials in the denominators would get
all multiplied together: the raw addition and subtraction on fractions
just blindly multiplies denominators! Whereas \csa{xintRationalSeries}
evaluate the partial sums via a less silly iterative scheme. 
\dverb|&
\def\ratio #1{-1/#1[0]}% -1/n, comes from the series of exp(-1)
\cnta 0 % previously declared count
\loop   
\edef\z {\xintRationalSeries {0}{\cnta}{1}{\ratio }}% 
\noindent$\sum_{n=0}^{\the\cnta} \frac{(-1)^n}{n!}= 
           \xintTrunc{20}\z\dots=\xintFrac{\z}=\xintFrac{\xintIrr\z}$
         \vtop to 5pt{}\endgraf
\ifnum\cnta<20 \advance\cnta 1 \repeat
|
\def\ratio #1{-1/#1[0]}% -1/n, comes from the series of exp(-1)
\cnta 0 % previously declared count

\loop   
\edef\z {\xintRationalSeries {0}{\cnta}{1}{\ratio }}% 
\noindent$\sum_{n=0}^{\the\cnta} \frac{(-1)^n}{n!}= 
           \xintTrunc{20}\z\dots=\xintFrac{\z}=\xintFrac{\xintIrr\z}$
         \vtop to 5pt{}\endgraf
\ifnum\cnta<20 \advance\cnta 1 \repeat


 \def\ratioexp #1#2{\xintDiv{#1}{#2}}% #1/#2

\medskip We can incorporate an indeterminate if we define |\ratio| to be
a macro with two parameters: |\def\ratioexp
  #1#2{\xintDiv{#1}{#2}}|\texttt{\%}| x/n: x=#1, n=#2|.
Then, if |\x| expands to some fraction |x|, the
command \centeredline{|\xintRationalSeries {0}{b}{1}{\ratioexp{\x}}|}
will compute $\sum_{n=0}^{n=b} x^n/n!$:\par
\dverb|&
\cnta 0
\def\ratioexp #1#2{\xintDiv{#1}{#2}}% #1/#2
\loop
\noindent
$\sum_{n=0}^{\the\cnta} (.57)^n/n! = \xintTrunc {50}
     {\xintRationalSeries {0}{\cnta}{1}{\ratioexp{.57}}}\dots$
     \vtop to 5pt {}\endgraf
\ifnum\cnta<50 \advance\cnta 10 \repeat
|

\cnta 0
\loop
\noindent
$\sum_{n=0}^{\the\cnta} (.57)^n/n! = \xintTrunc {50}
     {\xintRationalSeries {0}{\cnta}{1}{\ratioexp{.57}}}\dots$
     \vtop to 5pt {}\endgraf
\ifnum\cnta<50 \advance\cnta 10 \repeat
Observe that in this last example the |x| was directly inserted; if it
had been a more complicated explicit fraction it would have been
worthwile to use |\ratioexp\x| with |\x| defined to expand to its value.
In the further situation where this fraction |x| is not explicit but
itself defined via a complicated, and time-costly, formula, it should be
noted that \csa{xintRationalSeries} will do again the evaluation of |\x|
for each term of the partial sum. The easiest is thus when |x| can be
defined as an |\edef|. If however, you are in an expandable-only context
and cannot store in a macro like |\x| the value to be used, a variant of
\csa{xintRationalSeries} is needed which will first evaluate this |\x| and then
use this result without recomputing it. This is \csb{xintRationalSeriesX},
documented next.

Here is a slightly more complicated evaluation:
\dverb|&
\cnta 1
\loop \edef\z {\xintRationalSeries 
                   {\cnta}
                   {2*\cnta-1} 
                   {\xintiPow {\the\cnta}{\cnta}/\xintFac{\cnta}}
                   {\ratioexp{\the\cnta}}}%
\edef\w {\xintRationalSeries {0}{2*\cnta-1}{1}{\ratioexp{\the\cnta}}}%
\noindent
$\sum_{n=\the\cnta}^{\the\numexpr 2*\cnta-1\relax} \frac{\the\cnta^n}{n!}/%
          \sum_{n=0}^{\the\numexpr 2*\cnta-1\relax} \frac{\the\cnta^n}{n!} =
          \xintTrunc{8}{\xintDiv\z\w}\dots$ \vtop to 5pt{}\endgraf
\ifnum\cnta<20 \advance\cnta 1 \repeat
|
\cnta 1
\begin{multicols}{2}
\loop \edef\z {\xintRationalSeries 
                   {\cnta}
                   {2*\cnta-1} 
                   {\xintiPow {\the\cnta}{\cnta}/\xintFac{\cnta}}
                   {\ratioexp{\the\cnta}}}%
\edef\w {\xintRationalSeries {0}{2*\cnta-1}{1}{\ratioexp{\the\cnta}}}%
\noindent$\sum_{n=\the\cnta}^{\the\numexpr 2*\cnta-1\relax} \frac{\the\cnta^n}{n!}/%
          \sum_{n=0}^{\the\numexpr 2*\cnta-1\relax} \frac{\the\cnta^n}{n!} =
          \xintTrunc{8}{\xintDiv\z\w}\dots$ \vtop to 5pt{}\endgraf
\ifnum\cnta<20 \advance\cnta 1 \repeat
\end{multicols}

\subsection{\csbh{xintRationalSeriesX}}\label{xintRationalSeriesX}

{\small \hspace*{\parindent}New with release |1.04|.\par}

\noindent\csa{xintRationalSeriesX}|{A}{B}{\first}{\ratio}{\g}| is a parametrized
version of \csa{xintRationalSeries} where |\first| is turned into a one
parameter macro with |\first{\g}| giving |F(A,\g)| and |\ratio| is a two
parameters macro such that |\ratio{n}{\g}| gives |F(n,\g)/F(n-1,\g)|. The
parameter |\g| is evaluated only once at the beginning of the computation, and
can thus itself be the yet unevaluated result of a previous computation.

Let |\ratio| be such a two-parameters macro; note the subtle differences
between\centeredline{|\xintRationalSeries {A}{B}{\first}{\ratio{\g}}|}
\centeredline{and |\xintRationalSeriesX {A}{B}{\first}{\ratio}{\g}|.} First the
location of braces differ... then, in the former case |\first| is a
\emph{no-parameter} macro expanding to a fractional number, and in the latter,
it is a 
\emph{one-parameter} macro which will use |\g|. Furthermore the |X| variant
will expand |\g| at the very beginning whereas the former non-|X| former variant
will evaluate it each time it needs it (which is bad if this
evaluation is time-costly, but good if |\g| is a big explicit fraction
encapsulated in a macro).


The example will use the macro \csb{xintPowerSeries} which computes
efficiently exact partial sums of power series, and is discussed in the
next section.
\dverb|&
\def\firstterm #1{1[0]}% first term of the exponential series
% although it is the constant 1, here it must be defined as a
% one-parameter macro. Next comes the ratio function for exp:
\def\ratioexp  #1#2{\xintDiv {#1}{#2}}% x/n
% These are the (-1)^{n-1}/n of the log(1+h) series:
\def\coefflog #1{\the\numexpr\ifodd #1 1\else-1\fi\relax/#1[0]}% 
% Let L(h) be the first 10 terms of the log(1+h) series and
% let E(t) be the first 10 terms of the exp(t) series.
% The following computes E(L(a/10)) for a=1,...,12.
\cnta 0
\loop
\noindent\xintTrunc {18}{%
     \xintRationalSeriesX {0}{9}{\firstterm}{\ratioexp}
         {\xintPowerSeries{1}{10}{\coefflog}{\the\cnta[-1]}}}\dots 
\endgraf
\ifnum\cnta < 12 \advance \cnta 1 \repeat
|

\def\firstterm #1{1[0]}% first term of the exponential series
% although it is the constant 1, here it must be defined as a
% one-parameter macro. Next comes the ratio function for exp:
\def\ratioexp  #1#2{\xintDiv {#1}{#2}}% x/n
% These are the (-1)^{n-1}/n of the log(1+h) series
\def\coefflog #1{\the\numexpr\ifodd #1 1\else-1\fi\relax/#1[0]}% 
% Let L(h) be the first 10 terms of the log(1+h) series and
% let E(t) be the first 10 terms of the exp(t) series.
% The following computes E(L(a/12)) for a=1,..., 12.
\begin{multicols}{3}\raggedcolumns
  \cnta 1
  \loop
  \noindent\xintTrunc {18}{%
            \xintRationalSeriesX {0}{9}{\firstterm}{\ratioexp}
    {\xintPowerSeries{1}{10}{\coefflog}{\the\cnta[-1]}}}\dots
  \endgraf
  \ifnum\cnta < 12 \advance \cnta 1 \repeat
\end{multicols}
  % to see how they look like...
  % \loop
  % \noindent\printnumber{%
  %   \xintRationalSeriesX {0}{9}{\firstterm}{\ratioexp}
  %   {\xintPowerSeries{1}{10}{\coefflog}{\the\cnta[-2]}}}\dots
  % \endgraf
  % \ifnum\cnta < 60 \advance \cnta 1 \repeat

These completely exact operations rapidly create numbers with many digits. Let
us print in full the raw fractions created by the operation illustrated above:

\edef\z{\xintRationalSeriesX {0}{9}{\firstterm}
{\ratioexp}{\xintPowerSeries{1}{10}{\coefflog}{1[-1]}}}

|E(L(1[-1]))=|\digitstt{\printnumber{\z}} (length of numerator:
\xintLen {\xintNumerator \z})

\edef\z{\xintRationalSeriesX {0}{9}{\firstterm}
{\ratioexp}{\xintPowerSeries{1}{10}{\coefflog}{12[-2]}}}

|E(L(12[-2]))=|\digitstt{\printnumber{\z}} (length of numerator:
\xintLen {\xintNumerator \z})

\edef\z{\xintRationalSeriesX {0}{9}{\firstterm}
{\ratioexp}{\xintPowerSeries{1}{10}{\coefflog}{123[-3]}}}

|E(L(123[-3]))=|\digitstt{\printnumber{\z}} (length of numerator:
\xintLen {\xintNumerator \z})


We see that the denominators here remain the same, as our input only had various
powers of ten as denominators, and \xintfracname efficiently assemble (some
only, as we can see) powers of ten. Notice that 1 more digit in an input
denominator seems to mean 90 more in the raw output. We can check that with some
other test cases:


\edef\z{\xintRationalSeriesX {0}{9}{\firstterm}
{\ratioexp}{\xintPowerSeries{1}{10}{\coefflog}{1/7}}}

|E(L(1/7))=|\digitstt{\printnumber{\z}} (length of numerator:
\xintLen {\xintNumerator \z}; length of denominator:
\xintLen {\xintDenominator \z})

\edef\z{\xintRationalSeriesX {0}{9}{\firstterm}
{\ratioexp}{\xintPowerSeries{1}{10}{\coefflog}{1/71}}}

|E(L(1/71))=|\digitstt{\printnumber{\z}} (length of numerator:
\xintLen {\xintNumerator \z}; length of denominator:
\xintLen {\xintDenominator \z})


\edef\z{\xintRationalSeriesX {0}{9}{\firstterm}
{\ratioexp}{\xintPowerSeries{1}{10}{\coefflog}{1/712}}}

|E(L(1/712))=|\digitstt{\printnumber{\z}} (length of numerator:
\xintLen {\xintNumerator \z}; length of denominator:
\xintLen {\xintDenominator \z})

% \pdfresettimer
% \edef\w{\xintDenominator{\xintIrr{\z}}}
% \the\pdfelapsedtime

For info the last fraction put into irreducible form still has 288 digits in its
denominator.\footnote{putting this fraction in irreducible form takes more time
  than is typical of the other computations in this document; so exceptionally I
  have hard-coded the 288 in the document source.} Thus
decimal numbers such as |0.123| (equivalently 
|123[-3]|) give less computing intensive tasks than fractions such as |1/712|:
in the case of decimal numbers the (raw) denominators originate in the
coefficients of the series themselves, powers of ten of the input within
brackets being treated separately. And even then the
numerators will grow with the size of the input in a sort of linear way, the
coefficient being given by the order of series: here 10 from the log and 9 from
the exp, so 90. One more digit in the input means 90 more digits in the
numerator of the output: obviously we can not go on composing such partial sums
of series and hope that \xintname will joyfully do all at the speed of light!
Briefly said, imagine that the rules of the game make the programmer like a
security guard at an airport scanning machine: a never-ending flux of passengers
keep on arriving and all you can do is re-shuffle the first nine of them,
organize marriages among some, execute some, move children farther back among
the first nine only. If a passenger comes along with many hand luggages, this
will slow down the process even if you move him to ninth position, because
sooner or later you will have to digest him, and the children will be big too.
There is no way to move some guy out of the file and to a discrete interrogatory
room for separate treatment or to give him/her some badge saying ``I left my
stuff in storage box 357''.

Hence, truncating the output (or better, rounding) is the only way to go if one
needs a general calculus of special functions. This is why the package
\xintseriesname provides, besides \csb{xintSeries}, \csb{xintRationalSeries}, or
\csb{xintPowerSeries} which compute \emph{exact} sums, also has
\csb{xintFxPtPowerSeries} for fixed-point computations.

Update: release |1.08a| of \xintseriesname now includes a tentative naive 
\csb{xintFloatPowerSeries}.

\subsection{\csbh{xintPowerSeries}}\label{xintPowerSeries}

\csa{xintPowerSeries}|{A}{B}{\coeff}{f}| evaluates the sum 
$\sum_{\text{|n=A|}}^{\text{|n=B|}}|\coeff{n}|\cdot |f|^{\text{|n|}}$. The
initial and final indices are given to a |\numexpr| expression. The |\coeff|
macro (which, as argument to \csa{xintPowerSeries} is expanded only at the time
|\coeff{n}| is needed) should be defined as a one-parameter expandable command,
its input will be an explicit number.

The |f| can be either a fraction directly input or a macro |\f| expanding to
such a fraction. It is actually more efficient to encapsulate an explicit
fraction |f| in such a macro, if it has big numerators and denominators (`big'
means hundreds of digits) as it will then take less space in the processing
until being (repeatedly) used.

This macro computes the \emph{exact} result (one can use it also for polynomial
evaluation). Starting with release |1.04| a Horner scheme for polynomial
evaluation is used, which has the advantage to avoid a denominator build-up
which was plaguing the |1.03| version. \footnote{with powers |f\string^k|, from
  |k=0| to |N|, a denominator |d| of |f| became
  |d\string^\string{1+2+\dots+N\string}|, which is bad. With the |1.04| method,
  the part of the denominator originating from |f| does not accumulate to more
  than |d\string^N|. }

\begin{framed}
  Note: as soon as the coefficients look like factorials, it is more efficient
  to use the \csb{xintRationalSeries} macro whose evaluation, also based on a
  similar Horner scheme, will avoid a denominator build-up originating in the
  coefficients themselves.
\end{framed}

\dverb|&
\def\geom #1{1[0]} % the geometric series
\def\f {5/17[0]}   
\[ \sum_{n=0}^{n=20} \Bigl(\frac 5{17}\Bigr)^n 
 =\xintFrac{\xintIrr{\xintPowerSeries {0}{20}{\geom}{\f}}}
 =\xintFrac{\xinttheexpr (17^21-5^21)/12/17^20\relax}\]
|
\def\geom #1{1[0]} % the geometric series
\def\f {5/17[0]}   %  
\[ \sum_{n=0}^{n=20} \Bigl(\frac 5{17}\Bigr)^n 
 =\xintFrac{\xintIrr{\xintPowerSeries {0}{20}{\geom}{\f}}}
 =\xintFrac{\xinttheexpr (17^21-5^21)/12/17^20\relax}\]

\dverb|&
\def\coefflog #1{1/#1[0]}% 1/n
\def\f {1/2[0]}%
\[ \log 2 \approx \sum_{n=1}^{20} \frac1{n\cdot 2^n} 
    = \xintFrac {\xintIrr {\xintPowerSeries {1}{20}{\coefflog}{\f}}}\]
\[ \log 2 \approx \sum_{n=1}^{50} \frac1{n\cdot 2^n} 
    = \xintFrac {\xintIrr {\xintPowerSeries {1}{50}{\coefflog}{\f}}}\]
|
\def\coefflog #1{1/#1[0]} % 1/n
\def\f {1/2[0]}%
\[ \log 2 \approx \sum_{n=1}^{20} \frac1{n\cdot 2^n} 
         = \xintFrac {\xintIrr {\xintPowerSeries
             {1}{20}{\coefflog}{\f}}}\]
\[ \log 2 \approx \sum_{n=1}^{50} \frac1{n\cdot 2^n} 
    = \xintFrac {\xintIrr {\xintPowerSeries {1}{50}{\coefflog}{\f}}}\]
\dverb|&
\cnta 1 % previously declared count
\loop   % in this loop we recompute from scratch each partial sum! 
% we can afford that, as \xintPowerSeries is fast enough.
\noindent\hbox to 2em{\hfil\texttt{\the\cnta.} }% 
         \xintTrunc {12}
             {\xintPowerSeries {1}{\cnta}{\coefflog}{\f}}\dots
\endgraf
\ifnum \cnta < 30 \advance\cnta 1 \repeat
|
\setlength{\columnsep}{0pt}
\begin{multicols}{3}
      \cnta 1 % previously declared count
      \loop % in this loop we recompute from scratch each partial sum!
% we can afford that, as \xintPowerSeries is fast enough.
\noindent\hbox to 2em{\hfil\texttt{\the\cnta.} }% 
         \xintTrunc {12}{\xintPowerSeries {1}{\cnta}{\coefflog}{\f}}\dots
\endgraf
\ifnum \cnta < 30 \advance\cnta 1 \repeat
\end{multicols}
\dverb|&
%\def\coeffarctg #1{1/\the\numexpr\xintMON{#1}*(2*#1+1)\relax }% 
\def\coeffarctg  #1{1/\the\numexpr\ifodd #1 -2*#1-1\else2*#1+1\fi\relax }% 
% the above gives (-1)^n/(2n+1). The sign being in the denominator, 
%             **** no [0] should be added ****, 
% else nothing is guaranteed to work (even if it could by sheer luck)
% NOTE in passing this aspect of \numexpr: 
%         ****  \numexpr -(1)\relax does not work!!! ****
\def\f {1/25[0]}% 1/5^2
\[\mathrm{Arctg}(\frac15)\approx
            \frac15\sum_{n=0}^{15} \frac{(-1)^n}{(2n+1)25^n} 
= \xintFrac{\xintIrr {\xintDiv 
            {\xintPowerSeries {0}{15}{\coeffarctg}{\f}}{5}}}\]
|
\def\coeffarctg #1{1/\the\numexpr\ifodd #1 -2*#1-1\else2*#1+1\fi\relax }% 
\def\f {1/25[0]}% 1/5^2
\[\mathrm{Arctg}(\frac15)\approx
            \frac15\sum_{n=0}^{15} \frac{(-1)^n}{(2n+1)25^n} 
= \xintFrac{\xintIrr {\xintDiv 
            {\xintPowerSeries {0}{15}{\coeffarctg}{\f}}{5}}}\]

\subsection{\csbh{xintPowerSeriesX}}\label{xintPowerSeriesX}

{\small\hspace*{\parindent}New with release |1.04|.\par}

\noindent This is the same as \csb{xintPowerSeries} apart from the fact that the
last 
parameter |f| is expanded once and for all before being then used repeatedly. If
the |f| parameter is to be an explicit big fraction with many (dozens) digits,
rather than using it directly it is slightly better to have some macro 
|\g| defined to expand to the explicit fraction and then use
\csb{xintPowerSeries} with |\g|; 
but if |f| has not yet been evaluated and will be the output of a complicated
expansion of some |\f|, and if, due to an expanding only context, doing
|\edef\g{\f}| is no option, then \csa{xintPowerSeriesX} should be used with |\f|
as last parameter. 
\dverb|& 
\def\ratioexp #1#2{\xintDiv {#1}{#2}}% x/n
% These are the (-1)^{n-1}/n of the log(1+h) series:
\def\coefflog #1{\the\numexpr\ifodd #1 1\else-1\fi\relax/#1[0]}% 
% Let L(h) be the first 10 terms of the log(1+h) series and
% let E(t) be the first 10 terms of the exp(t) series.
% The following computes L(E(a/10)-1) for a=1,..., 12.
\cnta 1
\loop
\noindent\xintTrunc {18}{%
   \xintPowerSeriesX {1}{10}{\coefflog}
  {\xintSub
      {\xintRationalSeries {0}{9}{1[0]}{\ratioexp{\the\cnta[-1]}}}
      {1}}}\dots
\endgraf
\ifnum\cnta < 12 \advance \cnta 1 \repeat
|
\cnta 0
\def\ratioexp  #1#2{\xintDiv {#1}{#2}}% x/n
% These are the (-1)^{n-1}/n of the log(1+h) series
\def\coefflog #1{\the\numexpr\ifodd #1 1\else-1\fi\relax/#1[0]}% 
% Let L(h) be the first 10 terms of the log(1+h) series and
% let E(t) be the first 10 terms of the exp(t) series.
% The following computes L(E(a/10)-1) for a=1,..., 12.
\begin{multicols}{3}\raggedcolumns
\cnta 1
  \loop
  \noindent\xintTrunc {18}{%
     \xintPowerSeriesX {1}{10}{\coefflog}
    {\xintSub
        {\xintRationalSeries {0}{9}{1[0]}{\ratioexp{\the\cnta[-1]}}}
        {1}}}\dots
  \endgraf
  \ifnum\cnta < 12 \advance \cnta 1 \repeat
\end{multicols}


\subsection{\csbh{xintFxPtPowerSeries}}\label{xintFxPtPowerSeries}

\csa{xintFxPtPowerSeries}|{A}{B}{\coeff}{f}{D}| computes
$\sum_{\text{|n=A|}}^{\text{|n=B|}}|\coeff{n}|\cdot |f|^{\,\text{|n|}}$ with each
    term of the series truncated to |D| digits after the decimal point. As
    usual, |A| and |B| are completely expanded through their inclusion in a
    |\numexpr| expression. Regarding |D| it will be similarly be expanded each
    time it is used inside an \csa{xintTrunc}. The one-parameter macro |\coeff|
    is similarly  expanded at the time it is used inside the
    computations. Idem for |f|. If |f| itself is some complicated macro it is
    thus better to use the variant \csb{xintFxPtPowerSeriesX} which expands it
    first and then uses the result of that expansion.

The current (|1.04|) implementation is: the first power |f^A| is
computed exactly, then \emph{truncated}. Then each successive power is
obtained from the previous one by multiplication by the exact value of
|f|, and truncated. And |\coeff{n}|\raisebox{.5ex}{|.|}|f^n| is obtained
from that by multiplying by |\coeff{n}| (untruncated) and then
truncating. Finally the sum is computed exactly. Apart from that
\csa{xintFxPtPowerSeries} (where |FxPt| means `fixed-point') is like
\csa{xintPowerSeries}.

There should be a variant for things of the type $\sum c_n \frac {f^n}{n!}$ to
avoid having to compute the factorial from scratch at each coefficient, the same
way \csa{xintFxPtPowerSeries} does not compute |f^n| from scratch at each |n|.
Perhaps in the next package release.

\def\coeffexp #1{1/\xintFac {#1}[0]}% [0] for faster parsing
\def\f {-1/2[0]}%
\newcount\cnta 

\setlength{\multicolsep}{0pt}

\begin{multicols}{3}[%
\centeredline{$e^{-\frac12}\approx{}$}]%
\cnta 0 
\noindent\loop
$\xintFxPtPowerSeries {0}{\cnta}{\coeffexp}{\f}{20}$\\
\ifnum\cnta<19
\advance\cnta 1
\repeat\par
\end{multicols}
\dverb|&
\def\coeffexp #1{1/\xintFac {#1}[0]}% 1/n!
\def\f {-1/2[0]}% [0] for faster input parsing
\cnta 0 % previously declared \count register
\noindent\loop
$\xintFxPtPowerSeries {0}{\cnta}{\coeffexp}{\f}{20}$\\ 
\ifnum\cnta<19 \advance\cnta 1 \repeat\par
% One should **not** trust the final digits, as the potential truncation
% errors of up to 10^{-20} per term accumulate and never disappear! (the
% effect is attenuated by the alternating signs in the series). We  can
% confirm that the last two digits (of our evaluation of the nineteenth
% partial sum) are wrong via the evaluation with more digits:   
|
\centeredline{|\xintFxPtPowerSeries {0}{19}{\coeffexp}{\f}{25}=|
\digitstt{\xintFxPtPowerSeries {0}{19}{\coeffexp}{\f}{25}}}

\texttt{\hyphenchar\font45 }

\edef\z{\xintIrr {\xintPowerSeries {0}{19}{\coeffexp}{\f}}}

It is no difficulty for \xintfracname to compute exactly, with the help
of \csa{xintPowerSeries}, the nineteenth partial sum, and to then give
(the start of) its exact decimal expansion:
\centeredline{|\xintPowerSeries {0}{19}{\coeffexp}{\f}| ${}=
  \displaystyle\xintFrac{\z}$%
  \vphantom{\vrule height 20pt depth 12pt}}%
\centeredline{${}=\xintTrunc {30}{\z}\dots$} Thus, one should always
estimate a priori how many ending digits are not reliable: if there are
|N| terms and |N| has |k| digits, then digits up to but excluding the
last |k| may usually be trusted. If we are optimistic and the series is
alternating we may even replace |N| with $\sqrt{|N|}$ to get the number |k|
of digits possibly of dubious significance.


\subsection{\csbh{xintFxPtPowerSeriesX}}\label{xintFxPtPowerSeriesX}

{\small\hspace*{\parindent}New with release |1.04|.\par}

\noindent\csa{xintFxPtPowerSeriesX}|{A}{B}{\coeff}{\f}{D}| computes, exactly as
\csa{xintFxPtPowerSeries}, the sum of
|\coeff{n}|\raisebox{.5ex}{|.|}|\f^n| from |n=A| to |n=B| with each term
of the series being \emph{truncated} to |D| digits after the decimal
point. The sole difference is that |\f| is first expanded and it
is the result of this which is used in the computations.

% Let us illustrate this on the computation of |(1+y)^{5/3}| where
% |1+y=(1+x)^{3/5}| and each of the two binomial series is evaluated with ten
% terms, the results being computed with |8| digits after the decimal point, and
% &|f|<1/10&. 


Let us illustrate this on the numerical exploration of the identity
\centeredline{|log(1+x) = -log(1/(1+x))|}%
Let |L(h)=log(1+h)|, and |D(h)=L(h)+L(-h/(1+h))|. Theoretically thus,
|D(h)=0| but we shall evaluate |L(h)| and |-h/(1+h)| keeping only 10
terms of their respective series. We will assume &|h|<0.5&. With only
ten terms kept in the power series we do not have quite 3 digits
precision as &2^10=1024&. So it wouldn't make sense to evaluate things
more precisely than, say circa 5 digits after the decimal points.
\dverb|&
\cnta 0
\def\coefflog #1{\the\numexpr\ifodd#1 1\else-1\fi\relax/#1[0]}% (-1)^{n-1}/n
\def\coeffalt #1{\the\numexpr\ifodd#1 -1\else1\fi\relax [0]}%   (-1)^n
\loop
\noindent \hbox to 2.5cm {\hss\texttt{D(\the\cnta/100): }}%
\xintAdd {\xintFxPtPowerSeriesX {1}{10}{\coefflog}{\the\cnta [-2]}{5}}
         {\xintFxPtPowerSeriesX {1}{10}{\coefflog} 
             {\xintFxPtPowerSeriesX {1}{10}{\coeffalt}{\the\cnta [-2]}{5}} 
          {5}}\endgraf 
\ifnum\cnta < 49 \advance\cnta 7 \repeat
|

\cnta 0
\def\coefflog #1{\the\numexpr\ifodd#1 1\else-1\fi\relax/#1[0]}% (-1)^{n-1}/n
\def\coeffalt #1{\the\numexpr\ifodd#1 -1\else1\fi\relax [0]}%   (-1)^n


\begin{multicols}2
\loop
\noindent \hbox to 2.5cm {\hss\texttt{D(\the\cnta/100): }}%
\digitstt{\xintAdd {\xintFxPtPowerSeriesX {1}{10}{\coefflog}{\the\cnta [-2]}{5}}
         {\xintFxPtPowerSeriesX {1}{10}{\coefflog} 
             {\xintFxPtPowerSeriesX {1}{10}{\coeffalt}{\the\cnta [-2]}{5}} 
          {5}}}\endgraf 
\ifnum\cnta < 49 \advance\cnta 7 \repeat
\end{multicols}

Let's say we evaluate functions on |[-1/2,+1/2]| with values more or less also
in |[-1/2,+1/2]| and we want to keep 4 digits of precision. So, roughly we need
at least 14 terms in series like the geometric or log series. Let's make this
15. Then it doesn't make sense to compute intermediate summands with more than 6
digits precision. So we compute with 6 digits
precision but return only 4 digits (rounded) after the decimal point.
This result with 4 post-decimal points precision is then used as input
to the next evaluation.
\dverb|&
\loop
\noindent \hbox to 2.5cm {\hss\texttt{D(\the\cnta/100): }}%
\xintRound{4}
 {\xintAdd {\xintFxPtPowerSeriesX {1}{15}{\coefflog}{\the\cnta [-2]}{6}}
           {\xintFxPtPowerSeriesX {1}{15}{\coefflog} 
                  {\xintRound {4}{\xintFxPtPowerSeriesX {1}{15}{\coeffalt}
                                 {\the\cnta [-2]}{6}}} 
            {6}}%
 }\endgraf 
\ifnum\cnta < 49 \advance\cnta 7 \repeat
|

\begin{multicols}2
\loop
\noindent \hbox to 2.5cm {\hss\texttt{D(\the\cnta/100): }}%
\digitstt{\xintRound{4}
 {\xintAdd {\xintFxPtPowerSeriesX {1}{15}{\coefflog}{\the\cnta [-2]}{6}}
           {\xintFxPtPowerSeriesX {1}{15}{\coefflog} 
                  {\xintRound {4}{\xintFxPtPowerSeriesX {1}{15}{\coeffalt}
                                 {\the\cnta [-2]}{6}}} 
            {6}}%
 }}\endgraf 
\ifnum\cnta < 49 \advance\cnta 7 \repeat
\end{multicols}


Not bad... I have cheated a bit: the `four-digits precise' numeric
evaluations were left unrounded in the final addition. However the inner
rounding to four digits worked fine and made the next step faster than
it would have been with longer inputs. The morale is that one should not
use the raw results of \csa{xintFxPtPowerSeriesX} with the |D| digits
with which it was computed, as the last are to be considered garbage.
Rather, one should keep from the output only some smaller number of
digits. This will make further computations faster and not less precise.
I guess there should be some command to do this final truncating, or
better, rounding, at a given number |D'<D| of digits. Maybe for the next
release.


\subsection{\csbh{xintFloatPowerSeries}}\label{xintFloatPowerSeries}

{\small\hspace*{\parindent}New with |1.08a|.\par}

\noindent\csa{xintFloatPowerSeries}|[P]{A}{B}{\coeff}{f}| computes 
$\sum_{\text{|n=A|}}^{\text{|n=B|}}|\coeff{n}|\cdot |f|^{\,\text{|n|}}$
with a floating point
precision given by the optional parameter |P| or by the current setting of
|\xintDigits|.

In the current, preliminary, version, no attempt has been made to try to
guarantee to the final result the precision |P|. Rather, |P| is used for all
intermediate floating point evaluations. So
rounding errors will make some of the last printed digits invalid. The
operations done are first the evaluation of |f^A| using \csa{xintFloatPow}, then
each successive power is obtained from this first one by multiplication by |f|
using \csa{xintFloatMul}, then again with \csa{xintFloatMul} this is multiplied
with |\coeff{n}|, and the sum is done adding one term at a time with
\csa{xintFloatAdd}. To sum up, this is just the naive transformation of
\csa{xintFxPtPowerSeries} from fixed point to floating point.

\def\coefflog #1{\the\numexpr\ifodd#1 1\else-1\fi\relax/#1[0]}%

\dverb+&
\def\coefflog #1{\the\numexpr\ifodd#1 1\else-1\fi\relax/#1[0]}%
\xintFloatPowerSeries [8]{1}{30}{\coefflog}{-1/2[0]}+
\centeredline{\digitstt{\xintFloatPowerSeries [8]{1}{30}{\coefflog}{-1/2[0]}}}

\subsection{\csbh{xintFloatPowerSeriesX}}\label{xintFloatPowerSeriesX}

{\small\hspace*{\parindent}New with |1.08a|.\par}

\noindent\csa{xintFloatPowerSeriesX}|[P]{A}{B}{\coeff}{f}| is like 
\csa{xintFloatPowerSeries} with the difference that |f| is
expanded once and for all at the start of the computation, thus allowing
efficient chaining of such series evaluations.
\def\coefflog #1{\the\numexpr\ifodd#1 1\else-1\fi\relax/#1[0]}%

\dverb+&
\def\coeffexp #1{1/\xintFac {#1}[0]}% 1/n! (exact, not float)
\def\coefflog #1{\the\numexpr\ifodd#1 1\else-1\fi\relax/#1[0]}%
\xintFloatPowerSeriesX [8]{0}{30}{\coeffexp}
    {\xintFloatPowerSeries [8]{1}{30}{\coefflog}{-1/2[0]}}+
\centeredline{\digitstt{\xintFloatPowerSeriesX [8]{0}{30}{\coeffexp}
    {\xintFloatPowerSeries [8]{1}{30}{\coefflog}{-1/2[0]}}}}
 

\subsection{Computing \texorpdfstring{$\log 2$}{log(2)} and \texorpdfstring{$\pi$}{pi}}\label{ssec:Machin}

In this final section, the use of \csb{xintFxPtPowerSeries} (and
\csb{xintPowerSeries}) will be
illustrated on the (expandable... why make things simple when it is so easy to
make them difficult!) computations of the first digits of the decimal expansion
of the familiar constants $\log 2$ and $\pi$.

Let us start with $\log 2$. We will get it from this formula (which is
left as an exercise): \centeredline{\digitstt{log(2)=-2\,log(1-13/256)-%
  5\,log(1-1/9)}}%
The number of terms to be kept in the log series, for a desired
precision of |10^{-D}| was roughly estimated without much theoretical
analysis. Computing exactly the partial sums with \csa{xintPowerSeries}
and then printing the truncated values, from |D=0| up to |D=100| showed
that it worked in terms of quality of the approximation. Because of
possible strings of zeros or nines in the exact decimal expansion (in
the present case of $\log 2$, strings of zeros around the fourtieth and
the sixtieth decimals), this
does not mean though that all digits printed were always exact. In
the end one always end up having to compute at some higher level of
desired precision to validate the earlier result.

Then we tried with \csa{xintFxPtPowerSeries}: this is worthwile only for
|D|'s at least 50, as the exact evaluations are faster (with these
short-length |f|'s) for a lower
number of digits. And as expected the degradation in the quality of
approximation was in this range of the order of two or three digits.
This meant roughly that the 3+1=4 ending digits were wrong. Again, we ended
up having to compute with five more digits and compare with the earlier
value to validate it. We use truncation rather than rounding because our
goal is not to obtain the correct rounded decimal expansion but the
correct exact truncated one.

% 693147180559945309417232121458176568075500134360255254120680009493

\dverb|&
\def\coefflog #1{1/#1[0]}% 1/n
\def\xa {13/256[0]}%  we will compute log(1-13/256)
\def\xb {1/9[0]}%     we will compute log(1-1/9)
\def\LogTwo #1%
%  get log(2)=-2log(1-13/256)- 5log(1-1/9) 
{% we want to use \printnumber, hence need something expanding in two steps
 % only, so we use here the \romannumeral0 method
  \romannumeral0\expandafter\LogTwoDoIt \expandafter
    % Nb Terms for 1/9:
  {\the\numexpr #1*150/143\expandafter}\expandafter
    % Nb Terms for 13/256:
  {\the\numexpr #1*100/129\expandafter}\expandafter
    % We print #1 digits, but we know the ending ones are garbage
  {\the\numexpr #1\relax}% allows #1 to be a count register
}%
\def\LogTwoDoIt #1#2#3% 
%  #1=nb of terms for 1/9, #2=nb of terms for 13/256, 
{% #3=nb of digits for computations, also used for printing
 \xinttrunc {#3} % lowercase form to stop the \romannumeral0 expansion!
 {\xintAdd
  {\xintMul {2}{\xintFxPtPowerSeries {1}{#2}{\coefflog}{\xa}{#3}}}
  {\xintMul {5}{\xintFxPtPowerSeries {1}{#1}{\coefflog}{\xb}{#3}}}%
 }%
}%
\noindent $\log 2 \approx \LogTwo {60}\dots$\endgraf
\noindent\phantom{$\log 2$}${}\approx{}$\printnumber{\LogTwo {65}}\dots\endgraf
\noindent\phantom{$\log 2$}${}\approx{}$\printnumber{\LogTwo {70}}\dots\endgraf
|
\def\coefflog #1{1/#1[0]}% 1/n
\def\xa {13/256[0]}% we will compute log(1-13/256)
\def\xb {1/9[0]}%    we will compute log(1-1/9)
\def\LogTwo #1% get log(2)=-2log(1-13/256)- 5log(1-1/9) with #1 digits precision
{% this #1 may be a count register, if desired
    \romannumeral0\expandafter\LogTwoDoIt \expandafter
    {\the\numexpr #1*150/143\expandafter}\expandafter % Nb Terms for 1/9
    {\the\numexpr #1*100/129\expandafter}\expandafter % Nb Terms for 13/256
    {\the\numexpr #1\relax }%
}% 
\def\LogTwoDoIt #1#2#3% #1=nb of terms for 1/9, #2=nb of terms for 13/256, 
{%                     #3=nb of digits for computations
  \xinttrunc {#3}
    {\xintAdd
      {\xintMul {2}{\xintFxPtPowerSeries {1}{#2}{\coefflog}{\xa}{#3}}}
      {\xintMul {5}{\xintFxPtPowerSeries {1}{#1}{\coefflog}{\xb}{#3}}}%
    }%
}%

\noindent $\log 2 \approx {}$\digitstt{\LogTwo {60}\dots}\endgraf
\noindent\phantom{$\log 2$}${}\approx{}$\digitstt{\printnumber{\LogTwo
    {65}}\dots}\endgraf 
\noindent\phantom{$\log 2$}${}\approx{}$\digitstt{\printnumber{\LogTwo
    {70}}\dots}\endgraf 

Here is the code doing an exact evaluation of the partial sums. We have
added a |+1| to the number of digits for estimating the number of terms
to keep from the log series: we experimented that this gets exactly the
first |D| digits, for all values from |D=0| to |D=100|, except in one
case (|D=40|) where the last digit is wrong. For values of |D|
higher than |100| it is more efficient to use the code using
\csa{xintFxPtPowerSeries}. 
\dverb|&
\def\LogTwo #1% get log(2)=-2log(1-13/256)- 5log(1-1/9)
{% 
    \romannumeral0\expandafter\LogTwoDoIt \expandafter
    {\the\numexpr (#1+1)*150/143\expandafter}\expandafter
    {\the\numexpr (#1+1)*100/129\expandafter}\expandafter
    {\the\numexpr #1\relax}%
}% 
\def\LogTwoDoIt #1#2#3%
{%   #3=nb of digits for truncating an EXACT partial sum
  \xinttrunc {#3}
    {\xintAdd
      {\xintMul {2}{\xintPowerSeries {1}{#2}{\coefflog}{\xa}}}
      {\xintMul {5}{\xintPowerSeries {1}{#1}{\coefflog}{\xb}}}%
    }%
}%
|

Let us turn now to Pi, computed with the Machin formula. Again the numbers of
terms to keep in the two |arctg| series were roughly estimated, and some
experimentations showed that removing the last three digits was enough (at least
for |D=0-100| range). And the algorithm does print the correct digits when used
with |D=1000| (to be convinced of that one needs to run it for |D=1000| and
again, say for |D=1010|.) A theoretical analysis could help confirm that this
algorithm always gets better than |10^{-D}| precision, but again, strings of
zeros or nines encountered in the decimal expansion may falsify the ending
digits, nines may be zeros (and the last non-nine one should be increased) and
zeros may be nine (and the last non-zero one should be decreased). 
\dverb|&
% pi = 16 Arctg(1/5) - 4 Arctg(1/239) (John Machin's formula)
\def\coeffarctg #1{\the\numexpr\ifodd#1 -1\else1\fi\relax/% 
                                       \the\numexpr 2*#1+1\relax [0]}% 
% the above computes (-1)^n/(2n+1).
% Alternatives: 
% \def\coeffarctg #1{1/\the\numexpr\xintiMON{#1}*(2*#1+1)\relax }%
% The [0] can *not* be used above, as the denominator is signed.
% \def\coeffarctg #1{\xintiMON{#1}/\the\numexpr 2*#1+1\relax [0]}%
\def\xa {1/25[0]}%      1/5^2, the [0] for faster parsing
\def\xb {1/57121[0]}% 1/239^2, the [0] for faster parsing
\def\Machin #1{% \Machin {\mycount} is allowed
    \romannumeral0\expandafter\MachinA \expandafter
     % number of terms for arctg(1/5):
    {\the\numexpr (#1+3)*5/7\expandafter}\expandafter 
     % number of terms for arctg(1/239):  
    {\the\numexpr (#1+3)*10/45\expandafter}\expandafter
     % do the computations with 3 additional digits:
    {\the\numexpr #1+3\expandafter}\expandafter
     % allow #1 to be a count register:
    {\the\numexpr #1\relax }}%
\def\MachinA #1#2#3#4% 
% #4: digits to keep after decimal point for final printing
% #3=#4+3: digits for evaluation of the necessary number of terms
% to be kept in the arctangent series, also used to truncate each
% individual summand.
{\xinttrunc {#4} % must be lowercase to stop \romannumeral0! 
 {\xintSub  
  {\xintMul {16/5}{\xintFxPtPowerSeries {0}{#1}{\coeffarctg}{\xa}{#3}}}
  {\xintMul {4/239}{\xintFxPtPowerSeries {0}{#2}{\coeffarctg}{\xb}{#3}}}%
 }}%
\[ \pi = \Machin {60}\dots \]
|
\def\coeffarctg #1{\the\numexpr\ifodd#1 -1\else1\fi\relax/% 
                                       \the\numexpr 2*#1+1\relax [0]}% 
%\def\coeffarctg #1{\romannumeral0\xintmon{#1}/\the\numexpr 2*#1+1\relax }% 
\def\xa {1/25[0]}%      1/5^2, the [0] for faster parsing
\def\xb {1/57121[0]}% 1/239^2, the [0] for faster parsing
\def\Machin #1{% #1 may be a count register, \Machin {\mycount} is allowed
    \romannumeral0\expandafter\MachinA \expandafter
     % number of terms for arctg(1/5):
    {\the\numexpr (#1+3)*5/7\expandafter}\expandafter 
     % number of terms for arctg(1/239):  
    {\the\numexpr (#1+3)*10/45\expandafter}\expandafter
     % do the computations with 3 additional digits:
    {\the\numexpr #1+3\expandafter}\expandafter
     % allow #1 to be a count register:
    {\the\numexpr #1\relax }}%
\def\MachinA #1#2#3#4% 
{\xinttrunc {#4} 
 {\xintSub  
  {\xintMul {16/5}{\xintFxPtPowerSeries {0}{#1}{\coeffarctg}{\xa}{#3}}}
  {\xintMul{4/239}{\xintFxPtPowerSeries {0}{#2}{\coeffarctg}{\xb}{#3}}}%
 }}%
\begin{framed}
  \[ \pi = \Machin {60}\dots \]
\end{framed}
Here is a variant|\MachinBis|,
which evaluates the partial sums \emph{exactly} using
\csa{xintPowerSeries}, before their final truncation. No need for a
``|+3|'' then.
\dverb|&
\def\MachinBis #1{% #1 may be a count register,
% the final result will be truncated to #1 digits post decimal point
    \romannumeral0\expandafter\MachinBisA \expandafter
     % number of terms for arctg(1/5):
    {\the\numexpr #1*5/7\expandafter}\expandafter 
     % number of terms for arctg(1/239):  
    {\the\numexpr #1*10/45\expandafter}\expandafter
      % allow #1 to be a count register:
    {\the\numexpr #1\relax }}%
\def\MachinBisA #1#2#3% 
{\xinttrunc {#3} %
 {\xintSub  
   {\xintMul {16/5}{\xintPowerSeries {0}{#1}{\coeffarctg}{\xa}}}
   {\xintMul{4/239}{\xintPowerSeries {0}{#2}{\coeffarctg}{\xb}}}%
}}%
|

\def\MachinBis #1{% #1 may be a count register,
% the final result will be truncated to #1 digits post decimal point
    \romannumeral0\expandafter\MachinBisA \expandafter
     % number of terms for arctg(1/5):
    {\the\numexpr #1*5/7\expandafter}\expandafter 
     % number of terms for arctg(1/239):  
    {\the\numexpr #1*10/45\expandafter}\expandafter
      % allow #1 to be a count register:
    {\the\numexpr #1\relax }}%
\def\MachinBisA #1#2#3% 
{\xinttrunc {#3} %
 {\xintSub  
   {\xintMul {16/5}{\xintPowerSeries {0}{#1}{\coeffarctg}{\xa}}}
   {\xintMul{4/239}{\xintPowerSeries {0}{#2}{\coeffarctg}{\xb}}}%
}}%

Let us use this variant for a loop showing the build-up of digits:
\dverb|&
    \cnta 0 % previously declared \count register
    \loop
    \MachinBis{\cnta} \endgraf  % Plain's \loop does not accept \par
    \ifnum\cnta < 30 \advance\cnta 1 \repeat
|
\begin{multicols}{2}
  \cnta 0 % previously declared \count register
  \loop \noindent
        \centeredline{\digitstt{\MachinBis{\cnta}}}%
  \ifnum\cnta < 30
  \advance\cnta 1 \repeat
\end{multicols}


You want more digits and have some time? Copy the |\Machin|
code to a Plain \TeX{} or \LaTeX{} document loading \xintseriesname, and
compile:
\dverb|&
\newwrite\outfile
\immediate\openout\outfile \jobname-out\relax
\immediate\write\outfile {\Machin {1000}}
\immediate\closeout\outfile
|
This will create a file with the correct first 1000 digits of $\pi$
after the decimal point. On my laptop (a 2012 model) this took about 42 
seconds last time I tried (and for 200 digits it is less than 1 second).
As mentioned in the introduction, the file
\href{http://www.ctan.org/pkg/pi}{pi.tex} by \textsc{D.
  Roegel} shows that orders of magnitude faster computations are
possible within \TeX{}, but recall our constraints of complete
expandability and be merciful, please.

% \newwrite\outfile
% \immediate\openout\outfile \jobname-out\relax
% \pdfresettimer
% \immediate\write\outfile {\Machin {1000}}
% \edef\temps{\the\pdfelapsedtime}
% \immediate\closeout\outfile

% \temps: \xintRound {2}{\temps/65536} secondes


\textbf{Why truncating rather than rounding?} One of our main competitors
on the market of scientific computing, a canadian product (not
encumbered with expandability constraints, and having barely ever heard
of \TeX{} ;-), prints numbers rounded in the last digit. Why didn't we
follow suit in the macros \csa{xintFxPtPowerSeries} and
\csa{xintFxPtPowerSeriesX}? To round at |D| digits, and excluding a
rewrite or cloning of the division algorithm which anyhow would add to
it some overhead in its final steps, \xintfracname needs to truncate at
|D+1|, then round. And rounding loses information! So, with more time
spent, we obtain a worst result than the one truncated at |D+1| (one
could imagine that additions and so on, done with only |D| digits, cost
less; true, but this is a negligeable effect per summand compared to the
additional cost for this term of having been truncated at |D+1| then
rounded). Rounding is the way to go when setting up algorithms to
evaluate functions destined to be composed one after the other: exact
algebraic operations with many summands and an |f| variable which is a
fraction are costly and create an even bigger fraction; replacing |f|
with a reasonable rounding, and rounding the result, is necessary to
allow arbitrary chaining.

But, for the
computation of a single constant, we are really interested in the exact
decimal expansion, so we truncate and compute more terms until the
earlier result gets validated. Finally if we do want the rounding we can
always do it on a value computed with |D+1| truncation.

%%  \clearpage

\section{Commands of the \xintcfracname package} 

This package was first included in release |1.04| of the \xintname bundle. 


\localtableofcontents


\subsection{Package overview}

A \emph{simple} continued fraction has coefficients
|[c0,c1,...,cN]| (usually called partial quotients, but I really
dislike this entrenched terminology), where |c0| is a positive or
negative integer and the others are positive integers. As we will
see it is possible with \xintcfracname to specify the coefficient
function |c:n->cn|. Note that the index then starts at zero as
indicated. With the |amsmath| macro |\cfrac| one can display such a
continued fraction as 
\[ c_0 + \cfrac{1}{c_1+\cfrac1{c_2+\cfrac1{c_3+\cfrac1{\ddots}}}}\]
Here is a concrete example:
\[ \xintFrac {208341/66317}=\xintCFrac {208341/66317}\] But the
difference with |amsmath|'s |\cfrac| is that this was input as
\centeredline{|\[ \xintFrac {208341/66317}=\xintCFrac
  {208341/66317} \]|} The command \csb{xintCFrac} produces in two
expansion steps the whole thing with the many chained |\cfrac|'s and all
necessary braces, ready to be printed, in math mode. This is \LaTeX{}
only and with the |amsmath| package (we shall mention another method for
Plain \TeX{} users of |amstex|).

A \emph{generalized} continued fraction has the same structure but
the numerators are not restricted to be ones, and numbers used in
the continued fraction may be arbitrary, also fractions,
irrationals, indeterminates. The \emph{centered} continued
fraction associated to a rational number is an
example:\centeredline{|\[ \xintFrac {915286/188421}=\xintGCFrac {\xintFtoCC
  {915286/188421}} \]|}
\[ \xintFrac {915286/188421}=\xintGCFrac {\xintFtoCC {915286/188421}}
=\xintCFrac {915286/188421}\] The command \csb{xintGCFrac}, contrarily to
\csb{xintCFrac}, does not compute anything, it just typesets. Here, it is the
command \csb{xintFtoCC} which did the computation of
the centered continued fraction of |f|. Its output has the `inline format'
described in the next paragraph. In the display, we also used \csa{xintCFrac}
(code not shown), for comparison of the two types of continued fractions.

A generalized continued fraction may be input `inline' as:
\centeredline{|a0+b0/a1+b1/a2+b2/...../a(n-1)+b(n-1)/an|}%
Fractions among the coefficients are allowed but they must be enclosed
within braces. Signed integers may be left without braces (but the |+|
signs are mandatory). Or, they may
be macros expanding (in two steps) to some number or fractional number.
\centeredline{|\xintGCFrac {1+-1/57+\xintPow {-3}{7}/\xintQuo {132}{25}}|}
\[ \xintFrac{\xintGCtoF  {1+-1/57+\xintPow {-3}{7}/\xintQuo {132}{25}}}=
   \xintGCFrac {1+-1/57+\xintPow {-3}{7}/\xintQuo {132}{25}}\]
The left hand side was obtained with the following code:
\centeredline{|\xintFrac{\xintGCtoF  {1+-1/57+\xintPow {-3}{7}/\xintQuo
      {132}{25}}}|}
It uses the macro \csb{xintGCtoF} to convert a generalized fraction from the
`inline format' to the fraction it evaluates to.

A simple continued fraction is a special case of a generalized continued
fraction and may be input as such to macros expecting the `inline format', for
example |-7+1/6+1/19+1/1+1/33|. There is a simpler comma separated format:
\centeredline{|\xintFrac{\xintCstoF{-7,6,19,1,33}}=&
               \xintCFrac{\xintCstoF{-7,6,19,1,33}}|}
\[
\xintFrac{\xintCstoF{-7,6,19,1,33}}=\xintCFrac{\xintCstoF{-7,6,19,1,33}}\] This
comma separated format may also be used with fractions among the coefficients:
of course in that case, computing with \csb{xintFtoCs} from the resulting |f|
its real coefficients will give a new comma separated list
with only integers. This list has no spaces: the spaces in the display below
arise from the math mode processing.
\centeredline{|\xintFrac{1084483/398959}=[\xintFtoCs{1084483/398959}]|}
\[\xintFrac{1084483/398959}=[\xintFtoCs{1084483/398959}]\]
If one prefers other separators, one can use \csb{xintFtoCx} whose first
argument will be the separator to be used. 
\centeredline{|\xintFrac{2721/1001}=\xintFtoCx {+1/(}{2721/1001})\cdots)|}
\[\xintFrac{2721/1001}=\xintFtoCx {+1/(}{2721/1001})\cdots)\]
People using Plain \TeX{} and |amstex| can achieve the same effect as
|\xintCFrac| with:
|$$\xintFwOver{2721/1001}=\xintFtoCx {+\cfrac1\\ }{2721/1001}\endcfrac$$|

Using \csa{xintFtoCx} with first argument an empty pair of braces |{}| will
return the list of the coefficients of the continued fraction of |f|, without
separator, and each one enclosed in a pair of group braces. This can then be
manipulated by the non-expandable macro \csb{xintAssignArray} or the expandable
ones \csb{xintApply} and \csb{xintListWithSep}.

As a shortcut to using \csa{xintFtoCx} with separator |1+/|, there is
\csb{xintFtoGC}:
\centeredline{|2721/1001=\xintFtoGC {2721/1001}|}%
\centeredline{\digitstt{2721/1001=\xintFtoGC {2721/1001}}}
Let us compare in that case with the output of \csb{xintFtoCC}:
\centeredline{|2721/1001=\xintFtoCC {2721/1001}|}%
\centeredline{\digitstt{2721/1001=\xintFtoCC {2721/1001}}}

The `|\printnumber|' macro which we use to print long numbers can also
be useful on long continued fractions. 
\centeredline{|\printnumber{\xintFtoCC {35037018906350720204351049/%|}%
\centeredline{|244241737886197404558180}}|}%
\digitstt{\printnumber{\xintFtoCC {35037018906350720204351049/244241737886197404558180}}}.
If we apply \csb{xintGCtoF} to this generalized continued fraction, we
discover that the original fraction was reducible:
\centeredline{|\xintGCtoF
  {143+1/2+...+-1/9}|\digitstt{=\xintGCtoF{143+1/2+1/5+-1/4+-1/4+-1/4+-1/3+1/2+1/2+1/6+-1/22+1/2+1/10+-1/5+-1/11+-1/3+1/4+-1/2+1/2+1/4+-1/2+1/23+1/3+1/8+-1/6+-1/9}}}

\def\mymacro #1{$\xintFrac{#1}=[\xintFtoCs{#1}]$\vtop to 6pt{}}

\begingroup
\catcode`^\active
\def^#1^{\hbox{\fontfamily{lmtt}\selectfont #1}}%
\catcode`\& 4 
When a generalized continued fraction is built with integers, and
numerators are only |1|'s or |-1|'s, the produced fraction is
irreducible. And if we compute it again with the last sub-fraction
omitted we get another irreducible fraction related to the bigger one by
a Bezout identity. Doing this here we get:
\centeredline{|\xintGCtoF {143+1/2+...+-1/6}|\digitstt{=\xintGCtoF{143+1/2+1/5+-1/4+-1/4+-1/4+-1/3+1/2+1/2+1/6+-1/22+1/2+1/10+-1/5+-1/11+-1/3+1/4+-1/2+1/2+1/4+-1/2+1/23+1/3+1/8+-1/6}}}
and indeed:
\[ \begin{vmatrix}
    ^2897319801297630107^ & ^328124887710626729^\\
      ^20197107104701740^ & ^2287346221788023^ 
   \end{vmatrix} = \digitstt{\xintiSub {\xintiMul {2897319801297630107}{2287346221788023}}{\xintiMul{20197107104701740}{328124887710626729}}}\]

\endgroup

More generally the various fractions obtained from the truncation of a
continued fraction to its initial terms are called the convergents. The
commands of \xintcfracname such as \csb{xintFtoCv}, \csb{xintFtoCCv},
and others which compute such convergents, return them as a list of
braced items, with no separator. This list can then be treated either
with \csa{xint\-AssignArray}, or \csa{xintListWithSep}, or any other way
(but then, some \TeX{} programming knowledge will be necessary). Here
is an example:

\noindent
\centeredline{|$$\xintFrac{915286/188421}\to \xintListWithSep {,}%|}%
\centeredline{|{\xintApply{\xintFrac}{\xintFtoCv{915286/188421}}}$$|}
\[ \xintFrac{915286/188421}\to \xintListWithSep {,}
{\xintApply\xintFrac{\xintFtoCv{915286/188421}}}\]
\centeredline{|$$\xintFrac{915286/188421}\to \xintListWithSep {,}%|}%
\centeredline{|{\xintApply{\xintFrac}{\xintFtoCCv{915286/188421}}}$$|}
\[ \xintFrac{915286/188421}\to \xintListWithSep {,}
{\xintApply\xintFrac{\xintFtoCCv{915286/188421}}}\] We thus see that the
`centered convergents' obtained with \csb{xintFtoCCv} are among the fuller list
of convergents as returned by \csb{xintFtoCv}. 

Here is a more complicated use of \csa{xintApply}
and \csa{xintListWithSep}. We first define a macro which will be applied to each
convergent:\centeredline{|\newcommand{\mymacro}[1]|%
  |{$\xintFrac{#1}=[\xintFtoCs{#1}]$\vtop to 6pt{}}|}%
Next, we use the following code:
\centeredline{|$\xintFrac{49171/18089}\to{}$|}%
\centeredline{|\xintListWithSep {,
  }{\xintApply{\mymacro}{\xintFtoCv{49171/18089}}}|}
It produces:\par
\noindent$ \xintFrac{49171/18089}\to {}$\xintListWithSep {,
  }{\xintApply{\mymacro}{\xintFtoCv{49171/18089}}}.


\def\cn #1{\xintiPow {2}{#1}}%

The macro \csb{xintCntoF} allows to specify the coefficients as
functions of the index. The values to which expand the
coefficient function do not have to be integers. \centeredline{|\def\cn
  #1{\xintiPow {2}{#1}}% 2^n|}%
  \centeredline{|\[\xintFrac{\xintCntoF {6}{\cn}}=\xintCFrac
    [l]{\xintCntoF {6}{\cn}}\]|}%
\[\xintFrac{\xintCntoF {6}{\cn}}=\xintCFrac [l]{\xintCntoF
    {6}{\cn}}\]
Notice the use of the optional argument |[l]| to \csa{xintCFrac}. Other
possibilities are |[r]| and (default) |[c]|.
\def\cn #1{\xintPow {2}{-#1}}%
\centeredline{|\def\cn #1{\xintPow {2}{-#1}}% 1/2^n|}%
\centeredline{%
|\[\xintFrac{\xintCntoF {6}{\cn}} = \xintGCFrac [r]{\xintCntoGC {6}{\cn}}|}%
\centeredline{| = [\xintFtoCs {\xintCntoF {6}{\cn}}]\]|}%
\[\xintFrac{\xintCntoF {6}{\cn}}=\xintGCFrac [r]{\xintCntoGC {6}{\cn}}= 
  [\xintFtoCs {\xintCntoF {6}{\cn}}]\]
We used \csb{xintCntoGC} as we wanted to display also the continued fraction and
not only the fraction returned by \csa{xintCntoF}. 

There are also \csb{xintGCntoF} and \csb{xintGCntoGC} which allow the same for
generalized fractions. The following initial portion of a generalized continued
fraction for $\pi$:
\def\an #1{\the\numexpr 2*#1+1\relax }%
\def\bn #1{\the\numexpr (#1+1)*(#1+1)\relax }%
\[ \xintFrac{\xintDiv {4}{\xintGCntoF {5}{\an}{\bn}}} = 
        \cfrac{4}{\xintGCFrac{\xintGCntoGC {5}{\an}{\bn}}} =
\xintTrunc {10}{\xintDiv {4}{\xintGCntoF {5}{\an}{\bn}}}\dots\]
was obtained with this code:
\dverb|&
\def\an #1{\the\numexpr 2*#1+1\relax }%
\def\bn #1{\the\numexpr (#1+1)*(#1+1)\relax }%
\[ \xintFrac{\xintDiv {4}{\xintGCntoF {5}{\an}{\bn}}} = 
        \cfrac{4}{\xintGCFrac{\xintGCntoGC {5}{\an}{\bn}}} =
\xintTrunc {10}{\xintDiv {4}{\xintGCntoF {5}{\an}{\bn}}}\dots\]
|
We see that the quality of approximation is not fantastic compared to the simple
continued fraction of $\pi$ with about as many terms:
\dverb|&
\[ \xintFrac{\xintCstoF{3,7,15,1,292,1,1}}=
   \xintGCFrac{3+1/7+1/15+1/1+1/292+1/1+1/1}=
   \xintTrunc{10}{\xintCstoF{3,7,15,1,292,1,1}}\dots\]
|
\[ \xintFrac{\xintCstoF{3,7,15,1,292,1,1}}=
\xintGCFrac{3+1/7+1/15+1/1+1/292+1/1+1/1}=
\xintTrunc{10}{\xintCstoF{3,7,15,1,292,1,1}}\dots\]

\hypertarget{e-convergents}{To}
conclude this overview of most of the package functionalities, let us explore
the convergents of Euler's number $e$.
\dverb|&
\def\cn #1{\the\numexpr\ifcase \numexpr #1+3-3*((#1+2)/3)\relax
                           1\or1\or2*(#1/3)\fi\relax }
% produces the pattern 1,1,2,1,1,4,1,1,6,1,1,8,... which are the
% coefficients of the simple continued fraction of e-1.
\cnta 0
\def\mymacro #1{\advance\cnta by 1
                \noindent
                \hbox to 3em {\hfil\small\texttt{\the\cnta.} }%
                $\xintTrunc {30}{\xintAdd {1[0]}{#1}}\dots=
                 \xintFrac{\xintAdd {1[0]}{#1}}$}%
\xintListWithSep{\vtop to 6pt{}\vbox to 12pt{}\par}
    {\xintApply\mymacro{\xintiCstoCv{\xintCntoCs {35}{\cn}}}}
|
\smallskip The volume of computation is kept minimal by the following steps:
\begin{itemize}
\item a comma separated list of the first 36 coefficients is produced by
  \csb{xintCntoCs},
\item this is then given to \csb{xintiCstoCv} which produces the list of the
  convergents (there is also \csb{xintCstoCv}, but our
  coefficients being integers we used the infinitesimally
  faster \csb{xintiCstoCv}),
\item then the whole list was converted into a sequence of one-line paragraphs,
  each convergent becomes the argument to a  macro printing it
  together with its decimal expansion with 30 digits after the decimal point.
\item A count register |\cnta| was used to give a line count serving as a visual
  aid: we could also have done that in an expandable way, but well, let's relax
  from time to time\dots
\end{itemize}


\def\cn #1{\the\numexpr\ifcase \numexpr #1+3-3*((#1+2)/3)\relax
                           1\or1\or2*(#1/3)\fi\relax }
% produces the pattern 1,1,2,1,1,4,1,1,6,1,1,8,... which are the
% coefficients of the simple continued fraction of e-1.
\cnta 0
\def\mymacro #1{\advance\cnta by 1
                \noindent
                \hbox to 3em {\hfil\small\digitstt{\the\cnta.} }%
                $\xintTrunc {30}{\xintAdd {1[0]}{#1}}\dots=
                 \xintFrac{\xintAdd {1[0]}{#1}}$}%
\xintListWithSep{\vtop to 6pt{}\vbox to 12pt{}\par}
    {\xintApply\mymacro{\xintiCstoCv{\xintCntoCs {35}{\cn}}}}

% \def\testmacro #1{\xintTrunc {30}{\xintAdd {1[0]}{#1}}\xintAdd {1[0]}{#1}}
% \pdfresettimer
% \edef\z{\xintApply\testmacro{\xintiCstoCv{\xintCntoCs {35}{\cn}}}}
% (\the\pdfelapsedtime)


\smallskip The actual computation of the list of all 36 convergents accounts for
only 8\% of the total time (total time equal to about 5 hundredths of a second
in my testing, on my laptop): another 80\% is occupied with the computation of
the truncated decimal expansions (and the addition of 1 to everything as the
formula gives the continued fraction of $e-1$). One can with no problem compute
much bigger convergents. Let's get the 200th convergent. It turns out to
have the same first 268 digits after the decimal point as $e-1$. Higher
convergents get more and more digits in proportion to their index: the 500th
convergent already gets 799 digits correct! To allow speedy compilation of the
source of this document when the need arises, I limit here to the 200th
convergent (getting the 500th took about 1.2s on my laptop last time I tried,
and the 200th convergent is obtained ten times faster).
\dverb|&
\edef\z {\xintCntoF {199}{\cn}}%
\begingroup\parindent 0pt \leftskip 2.5cm
\indent\llap {Numerator = }{\printnumber{\xintNumerator\z}\par
\indent\llap {Denominator = }\printnumber{\xintDenominator\z}\par
\indent\llap {Expansion = }\printnumber{\xintTrunc{268}\z}\dots
\par\endgroup
|

\edef\z {\xintCntoF {199}{\cn}}%

\begingroup\parindent 0pt \leftskip 2.5cm
\indent\llap {Numerator = }\digitstt{\printnumber{\xintNumerator\z}}\par
\indent\llap {Denominator = }\digitstt{\printnumber{\xintDenominator\z}}\par
\indent\llap 
    {Expansion = }\digitstt{\printnumber{\xintTrunc{268}\z}\dots}\par\endgroup

One can also use a centered continued fraction: we get more digits but there are
also more computations as the numerators may be either
$1$ or $-1$.

\subsection{\csbh{xintCFrac}}\label{xintCFrac}

\csa{xintCFrac}|{f}| is a math-mode only, \LaTeX{} with |amsmath| only, macro
which first computes then displays with the help of |\cfrac| the simple
continued fraction corresponding to the given fraction (or macro expanding in
two steps to one such). It admits an optional argument which may be |[l]|, |[r]|
or (the default) |[c]| to specify the location of the one's in the numerators of
the sub-fractions. Each coefficient is typeset using the \csb{xintFrac} macro
from the \xintfracname package.

\subsection{\csbh{xintGCFrac}}\label{xintGCFrac}

\csa{xintGCFrac}|{a+b/c+d/e+f/g+h/...}| uses similarly |\cfrac| to typeset a
generalized continued fraction in inline format.  It admits the same optional
argument as \csa{xintCFrac}.
\centeredline{|\[\xintGCFrac {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}}\]|}
\[\xintGCFrac {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}}\]
As can be seen this is typesetting macro, although it does proceed to the
evaluation of the coefficients themselves. See \csb{xintGCtoF} if you are
impatient to see this fraction computed. Numerators and denominators are made
arguments to the
\csb{xintFrac} macro.

\subsection{\csbh{xintGCtoGCx}}\label{xintGCtoGCx}
{\small New with release |1.05|.\par}


\csa{xintGCtoGCx}|{sepa}{sepb}{a+b/c+d/e+f/...+x/y}| returns the list of the
coefficients of the generalized continued fraction of |f|, each one within a
pair of braces, and separated with the help of |sepa| and |sepb|. Thus
\centeredline{|\xintGCtoGCx :;{1+2/3+4/5+6/7}| gives \xintGCtoGCx
  :;{1+2/3+4/5+6/7}} Plain \TeX{}+|amstex| users may be interested in:\par
\noindent|$$\xintGCtoGCx {+\cfrac}{\\}{a+b/...}\endcfrac$$|\par
\noindent
|$$\xintGCtoGCx {+\cfrac\xintFwOver}{\\\xintFwOver}{a+b/...}\endcfrac$$|\par


\subsection{\csbh{xintFtoCs}}\label{xintFtoCs}

\csa{xintFtoCs}|{f}| returns the comma separated list of the coefficients of the
simple continued fraction of |f|.
\centeredline{%
|\[ \xintSignedFrac{-5262046/89233} = [\xintFtoCs{-5262046/89233}]\]|}%
\[ \xintSignedFrac{-5262046/89233} = [\xintFtoCs{-5262046/89233}]\]


\subsection{\csbh{xintFtoCx}}\label{xintFtoCx}

\csa{xintFtoCx}|{sep}{f}| returns the list of the coefficients of the simple
continued fraction of |f|, withing group braces and separated with the help of
|sep|. \centeredline{|$$\xintFtoCx {+\cfrac1\\ }{f}\endcfrac$$|} will
display the 
continued fraction in |\cfrac| format, with Plain \TeX{} and |amstex|.

\subsection{\csbh{xintFtoGC}}\label{xintFtoGC}

\csa{xintFtoGC}|{f}| does the same as \csa{xintFtoCx}|{+1/}{f}|. Its
output may thus be used in the package macros expecting such an `inline
format'. This continued fraction is a \emph{simple} one, not a
\emph{generalized} one, but as it is produced in the format used for
user input of generalized continued fractions, the macro was called
\csa{xintFtoGC} rather than \csa{xintFtoC} for example.
\centeredline{|566827/208524=\xintFtoGC {566827/208524}|}%
\centeredline{566827/208524=\xintFtoGC {566827/208524}}

\subsection{\csbh{xintFtoCC}}\label{xintFtoCC}

\csa{xintFtoCC}|{f}| returns the `centered' continued fraction of |f|, in
`inline format'.
\centeredline{|566827/208524=\xintFtoCC {566827/208524}|}%
\centeredline{566827/208524=\xintFtoCC {566827/208524}}
\centeredline{%
|\[\xintFrac{566827/208524} = \xintGCFrac{\xintFtoCC{566827/208524}}\]|}%
\[\xintFrac{566827/208524} = \xintGCFrac{\xintFtoCC{566827/208524}}\]

\subsection{\csbh{xintFtoCv}}\label{xintFtoCv}

\csa{xintFtoCv}|{f}| returns the list of the (braced) convergents of |f|, with
no separator. To be treated with \csb{xintAssignArray} or \csb{xintListWithSep}.
\centeredline{%
|\[\xintListWithSep{\to}{\xintApply\xintFrac{\xintFtoCv{5211/3748}}}\]|}%
\[\xintListWithSep{\to}{\xintApply\xintFrac{\xintFtoCv{5211/3748}}}\]

\subsection{\csbh{xintFtoCCv}}\label{xintFtoCCv}

\csa{xintFtoCCv}|{f}| returns the list of the (braced) centered convergents of
|f|, with no separator. To be treated with \csb{xintAssignArray} or
\csb{xintListWithSep}.
\centeredline{%
|\[\xintListWithSep{\to}{\xintApply\xintFrac{\xintFtoCCv{5211/3748}}}\]|}%
\[\xintListWithSep{\to}{\xintApply\xintFrac{\xintFtoCCv{5211/3748}}}\]

\subsection{\csbh{xintCstoF}}\label{xintCstoF}

\csa{xintCstoF}|{a,b,c,d,...,z}| computes the fraction corresponding to the
coefficients, which may be fractions or even macros expanding to such
fractions (in two steps). The final fraction may then be highly
reducible.
\centeredline{|\[\xintGCFrac {-1+1/3+1/-5+1/7+1/-9+1/11+1/-13}|}%
\centeredline{|=\xintSignedFrac{\xintCstoF {-1,3,-5,7,-9,11,-13}}|}%
\centeredline{|=\xintSignedFrac{\xintGCtoF  
                {-1+1/3+1/-5+1/7+1/-9+1/11+1/-13}}\]|}%
\[\xintGCFrac {-1+1/3+1/-5+1/7+1/-9+1/11+1/-13}=
\xintSignedFrac{\xintCstoF {-1,3,-5,7,-9,11,-13}}
=\xintSignedFrac{\xintGCtoF  {-1+1/3+1/-5+1/7+1/-9+1/11+1/-13}}\]
\centeredline{|\xintGCFrac{{1/2}+1/{1/3}+1/{1/4}+1/{1/5}}= |}%
\centeredline{|  \xintFrac{\xintCstoF {1/2,1/3,1/4,1/5}}|}%
\[\xintGCFrac{{1/2}+1/{1/3}+1/{1/4}+1/{1/5}}= 
\xintFrac{\xintCstoF {1/2,1/3,1/4,1/5}}\] A generalized continued fraction may
produce a reducible fraction (\csa{xintCstoF} tries its best not to accumulate
in a silly way superfluous factors but will not do simplifications which would
be obvious to a human, like simplification by 3 in the result above).

\subsection{\csbh{xintCstoCv}}\label{xintCstoCv}

\csa{xintCstoCv}|{a,b,c,d,...,z}| returns the list of the corresponding
convergents. It is allowed to use fractions as coefficients (the computed
convergents have then no reason to be the real convergents of the final
fraction). When the coefficients are integers, the convergents are irreducible
fractions, but otherwise it is of course not necessarily the case.
\centeredline{|\xintListWithSep:{\xintCstoCv{1,2,3,4,5,6}}|}%
\centeredline{\digitstt{\xintListWithSep:{\xintCstoCv{1,2,3,4,5,6}}}}
\centeredline{|\xintListWithSep:{\xintCstoCv{1,1/2,1/3,1/4,1/5,1/6}}|}%
\centeredline{\digitstt{\xintListWithSep:{\xintCstoCv{1,1/2,1/3,1/4,1/5,1/6}}}} I
know that these |[0]| are a bit annoying\footnote{and the awful truth is that it
  is added forcefully by \csa{xintCstoCv} at the last step\dots } but this is
the way \xintfracname likes to reception fractions: this format is best for
further processing by the bundle macros. For `inline' printing, one may apply
\csb{xintRaw} and for display in math mode \csb{xintFrac}.
\centeredline{|\[\xintListWithSep{\to}{\xintApply\xintFrac{\xintCstoCv|}%
    \centeredline{|{\xintPow {-.3}{-5},7.3/4.57,\xintCstoF{3/4,9,-1/3}}}}\]|}%
\[\xintListWithSep{\to}{\xintApply\xintFrac{\xintCstoCv
       {\xintPow {-.3}{-5},7.3/4.57,\xintCstoF{3/4,9,-1/3}}}}\]


\subsection{\csbh{xintCstoGC}}\label{xintCstoGC}

\csa{xintCstoGC}|{a,b,..,z}| transforms a comma separated list (or
something expanding to such a list) into an
`inline format' continued fraction |{a}+1/{b}+1/...+1/{z}|. The
coefficients are just copied and put within braces, without expansion.
The output can then be used in \csb{xintGCFrac} for example.
\centeredline{|\[\xintGCFrac {\xintCstoGC {-1,1/2,-1/3,1/4,-1/5}}|}%
\centeredline{|=\xintSignedFrac {\xintCstoF {-1,1/2,-1/3,1/4,-1/5}}\]|}%
\[\xintGCFrac {\xintCstoGC {-1,1/2,-1/3,1/4,-1/5}} =
\xintSignedFrac{\xintCstoF {-1,1/2,-1/3,1/4,-1/5}}\]

\subsection{\csbh{xintGCtoF}}\label{xintGCtoF}

\csa{xintGCtoF}|{a+b/c+d/e+f/g+......+v/w+x/y}| computes the fraction defined by
the inline generalized continued fraction. Coefficients may be fractions but
must then be put within braces. They can be macros. The plus signs are
mandatory.
\dverb|&
\[\xintGCFrac {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}} = 
\xintFrac{\xintGCtoF {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}}} =
\xintFrac{\xintIrr{\xintGCtoF 
                  {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}}}}\]
|
\[\xintGCFrac {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}} = 
\xintFrac{\xintGCtoF {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}}} =
\xintFrac{\xintIrr{\xintGCtoF {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}}}}\]
\dverb|&
\[ \xintGCFrac{{1/2}+{2/3}/{4/5}+{1/2}/{1/5}+{3/2}/{5/3}} = 
   \xintFrac{\xintGCtoF {{1/2}+{2/3}/{4/5}+{1/2}/{1/5}+{3/2}/{5/3}}} \]
|
\[ \xintGCFrac{{1/2}+{2/3}/{4/5}+{1/2}/{1/5}+{3/2}/{5/3}} = 
   \xintFrac{\xintGCtoF {{1/2}+{2/3}/{4/5}+{1/2}/{1/5}+{3/2}/{5/3}}} \] 
The macro tries its best not to accumulate superfluous factor in the
denominators, but doesn't reduce the fraction to irreducible form before
returning it and does not do simplifications which would be obvious to a human.

\subsection{\csbh{xintGCtoCv}}\label{xintGCtoCv}

\csa{xintGCtoCv}|{a+b/c+d/e+f/g+......+v/w+x/y}| returns the list of the
corresponding convergents. The coefficients may be fractions, but must
then be inside braces. Or they may be macros, too. 

The convergents will in the general case be reducible. To put them into
irreducible form, one needs one more step, for example it can be done
with |\xintApply\xintIrr|.
\dverb|&
\[\xintListWithSep{,}{\xintApply\xintFrac
                {\xintGCtoCv{3+{-2}/{7/2}+{3/4}/12+{-56}/3}}}\]
\[\xintListWithSep{,}{\xintApply\xintFrac{\xintApply\xintIrr
                {\xintGCtoCv{3+{-2}/{7/2}+{3/4}/12+{-56}/3}}}}\]
|
\[\xintListWithSep{,}{\xintApply\xintFrac
                {\xintGCtoCv{3+{-2}/{7/2}+{3/4}/12+{-56}/3}}}\]
\[\xintListWithSep{,}{\xintApply\xintFrac{\xintApply\xintIrr
                {\xintGCtoCv{3+{-2}/{7/2}+{3/4}/12+{-56}/3}}}}\]

\subsection{\csbh{xintCntoF}}\label{xintCntoF}

\def\macro #1{\the\numexpr 1+#1*#1\relax}

\csa{xintCntoF}|{N}{\macro}| computes the fraction |f| having coefficients
|c(j)=\macro{j}| for |j=0,1,...,N|. The |N| parameter is given to a |\numexpr|.
The values of the coefficients, as returned by |\macro| do not have to be
positive, nor integers, and it is thus not necessarily the case that the
original |c(j)| are the true coefficients of the final |f|. \centeredline{%
  |\def\macro #1{\the\numexpr 1+#1*#1\relax}\xintCntoF {5}{\macro}|}%
\centeredline{\digitstt{\xintCntoF {5}{\macro}}}

\subsection{\csbh{xintGCntoF}}\label{xintGCntoF}

\def\coeffA #1{\the\numexpr #1+4-3*((#1+2)/3)\relax }%
\def\coeffB #1{\xintMON{#1}}% (-1)^n

\csa{xintGCntoF}|{N}{\macroA}{\macroB}| returns the fraction |f| corresponding
to the inline generalized continued fraction |a0+b0/a1+b1/a2+....+b(N-1)/aN|,
with |a(j)=\macroA{j}| and |b(j)=\macroB{j}|. The |N| parameter is given to a
|\numexpr|. 
\[\xintGCFrac{\xintGCntoGC {6}{\coeffA}{\coeffB}}
= \xintFrac{\xintGCntoF {6}{\coeffA}{\coeffB}}\]
There is also \csb{xintGCntoGC} to get the `inline format' continued
fraction. The previous display was obtained with:
\centeredline{|\def\coeffA #1{\the\numexpr #1+4-3*((#1+2)/3)\relax }%|}%
\centeredline{|\def\coeffB #1{\xintMON{#1}}% (-1)^n|}%
\centeredline{|\[\xintGCFrac{\xintGCntoGC {6}{\coeffA}{\coeffB}}|}%
\centeredline{|  = \xintFrac{\xintGCntoF  {6}{\coeffA}{\coeffB}}\]|}


\subsection{\csbh{xintCntoCs}}\label{xintCntoCs}

\csa{xintCntoCs}|{N}{\macro}| produces the comma separated list of the
corresponding coefficients, from |n=0| to |n=N|. The |N| is given to a
|\numexpr|.
\centeredline{%
|\def\macro #1{\the\numexpr 1+#1*#1\relax}|}%
\centeredline{|\xintCntoCs {5}{\macro}|\digitstt{->\xintCntoCs {5}{\macro}}}%
\centeredline{|\[\xintFrac{\xintCntoF
    {5}{\macro}}=\xintCFrac{\xintCntoF {5}{\macro}}\]|}%
\[ \xintFrac{\xintCntoF
    {5}{\macro}}=\xintCFrac{\xintCntoF {5}{\macro}}\]

\subsection{\csbh{xintCntoGC}}\label{xintCntoGC}

\def\macro #1{\the\numexpr\ifodd#1 -1-#1\else1+#1\fi\relax/%
               \the\numexpr 1+#1*#1\relax}

\csa{xintCntoGC}|{N}{\macro}| evaluates the |c(j)=\macro{j}| from |j=0|
to |j=N| and returns a continued fraction written in inline
format: |{c(0)}+1/{c(1)}+1/...+1/{c(N)}|. The parameter |N| is given to a
|\numexpr|. The coefficients, after expansion, are, as shown, being
enclosed in an added pair of braces, they may thus be
fractions.
\centeredline{%
|\def\macro #1{\the\numexpr\ifodd#1 -1-#1\else1+#1\fi\relax/%|}%
\centeredline{|\the\numexpr 1+#1*#1\relax}|}%
\centeredline{|\edef\x{\xintCntoGC {5}{\macro}}\meaning\x|}%
\centeredline{\edef\x{\xintCntoGC {5}{\macro}}\digitstt{\meaning\x}}%
\centeredline{|\[\xintGCFrac{\xintCntoGC {5}{\macro}}\]|}%
\[\xintGCFrac{\xintCntoGC {5}{\macro}}\]

\subsection{\csbh{xintGCntoGC}}\label{xintGCntoGC}

\csa{xintGCntoGC}|{N}{\macroA}{\macroB}| evaluates the coefficients and then
returns the corresponding |{a0}+{b0}/{a1}+{b1}/{a2}+...+{b(N-1)}/{aN}| inline
generalized fraction. |N| is givent to a |\numexpr|. As shown, the coefficients
are enclosed into added pairs of braces, and may thus be fractions.
\dverb|&
\def\an #1{\the\numexpr #1*#1*#1+1\relax}%
\def\bn #1{\the\numexpr \xintiMON{#1}*(#1+1)\relax}%
$\xintGCntoGC {5}{\an}{\bn}}=\xintGCFrac {\xintGCntoGC {5}{\an}{\bn}}
        = \displaystyle\xintFrac {\xintGCntoF  {5}{\an}{\bn}}$\par
|
\def\an #1{\the\numexpr #1*#1*#1+1\relax}%
\def\bn #1{\the\numexpr \xintiMON{#1}*(#1+1)\relax}%
$\xintGCntoGC {5}{\an}{\bn}=\xintGCFrac {\xintGCntoGC {5}{\an}{\bn}}
        = \displaystyle\xintFrac {\xintGCntoF  {5}{\an}{\bn}}$\par



\subsection{\csbh{xintiCstoF},~\csbh{xintiGCtoF},~\csbh{xint\-iCstoCv},~\csbh{xintiGCtoCv}}\label{xintiCstoF}
\label{xintiGCtoF}
\label{xintiCstoCv}
\label{xintiGCtoCv}

The same as the corresponding macros without the `i', but for
integer-only input. Infinitesimally faster; to notice the higher
efficiency one would need to use them with an input having (at least)
hundreds of coefficients.


\subsection{\csbh{xintGCtoGC}}\label{xintGCtoGC}

\csa{xintGCtoGC}|{a+b/c+d/e+f/g+......+v/w+x/y}| expands (with the usual
meaning) each one of the coefficients and returns an inline continued fraction
of the same type, each expanded coefficient being enclosed withing braces.
\dverb|&
\edef\x {\xintGCtoGC 
  {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}+\xintCstoF {2,-7,-5}/16}}
\meaning\x
|
\edef\x {\xintGCtoGC 
     {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}+\xintCstoF {2,-7,-5}/16}}
\digitstt{\meaning\x}

To be honest I have, it seems, forgotten why I wrote this macro in the
first place.

\catcode`\& 4

\makeatletter
\StopEventually{\end{document}\endinput}
\makeatother


\newgeometry{hmarginratio=4:3,hscale=0.75}

\def\MacroFont{\ttfamily\small\hyphenchar\font45 
               \baselineskip12pt\relax }
\MakePercentIgnore
% 
% \catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
% \let</doc>\relax
% \def<*xint>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%
%</doc>
%<*xint>
% \section {Package \xintname implementation}
% 
% The commenting of the macros is currently (\docdate) very sparse.
%
% 
% \localtableofcontents
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
% 
% The method for package identification and reload detection is copied verbatim
% from the packages by \textsc{Heiko Oberdiek}.
%
% The method for catcodes was also inspired by these packages, we proceed
% slightly differently. |1.05| adds a |\relax| near the end of
% |\XINT_restorecatcodes_endinput|. Plain TeX users following the doc
% instruction to do |\input xint.sty\relax| were anyhow protected from any side
% effect. I did not realize earlier that the |\endinput| would not stop \TeX{}'s
% scan for a number which was initiated by the last |\the\catcode|.
%
% Starting with version |1.06| of the package, also |`| must be sanitized,
% because we replace everywhere in the code the twice-expansion done with
% |\expandafter| by the systematic use of |\romannumeral-`0|.
%
% Starting with version |1.06b| I decide that I suffer from an indigestion of @
% signs, so I replace them all with underscores |_|, \`a la \LaTeX 3. 
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode95=11   % _  (starting with 1.06b, used inside cs names)
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \expandafter\let\expandafter\x\csname ver@xint.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xint}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax % plain-TeX, first loading
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
      \else
        \y{xint}{I was already loaded, aborting input}%
        \aftergroup\endinput
      \fi
    \fi
  \fi
  \def\ChangeCatcodesIfInputNotAborted
  {%
      \endgroup
      \edef\XINT_restorecatcodes_endinput
      {%
        \catcode94=\the\catcode94   % ^
        \catcode96=\the\catcode96   % `
        \catcode47=\the\catcode47   % /
        \catcode41=\the\catcode41   % )
        \catcode40=\the\catcode40   % (
        \catcode42=\the\catcode42   % *
        \catcode43=\the\catcode43   % +
        \catcode62=\the\catcode62   % >
        \catcode60=\the\catcode60   % <
        \catcode58=\the\catcode58   % :
        \catcode46=\the\catcode46   % .
        \catcode45=\the\catcode45   % -
        \catcode44=\the\catcode44   % ,
        \catcode35=\the\catcode35   % #
        \catcode95=\the\catcode95   % _
        \catcode125=\the\catcode125 % }
        \catcode123=\the\catcode123 % {
        \endlinechar=\the\endlinechar
        \catcode13=\the\catcode13   % ^^M
        \catcode32=\the\catcode32   % 
        \catcode61=\the\catcode61\relax   % =
        \noexpand\endinput
      }%
      \def\XINT_setcatcodes
      {%
        \catcode61=12   % =
        \catcode32=10   % space
        \catcode13=5    % ^^M
        \endlinechar=13 % 
        \catcode123=1   % {
        \catcode125=2   % }
        \catcode95=11   % _ (replaces @ everywhere, starting with 1.06b)
        \catcode35=6    % #
        \catcode44=12   % ,
        \catcode45=12   % -
        \catcode46=12   % .
        \catcode58=11   % : (made letter for error cs)
        \catcode60=12   % <
        \catcode62=12   % >
        \catcode43=12   % +
        \catcode42=12   % *
        \catcode40=12   % (
        \catcode41=12   % )
        \catcode47=12   % /
        \catcode96=12   % `
        \catcode94=11   % ^
      }%
      \XINT_setcatcodes
  }%
\ChangeCatcodesIfInputNotAborted 
%    \end{macrocode}
% \subsection{Package identification}
%
% Copied verbatim from \textsc{Heiko Oberdiek}'s packages.
%
%    \begin{macrocode}
\begingroup
  \catcode64=11 % @
  \catcode91=12 % [
  \catcode93=12 % ]
  \catcode58=12 % : (does not really matter, was letter)
  \expandafter\ifx\csname ProvidesPackage\endcsname\relax
    \def\x#1#2#3[#4]{\endgroup
      \immediate\write-1{Package: #3 #4}%
      \xdef#1{#4}%
    }%
  \else
    \def\x#1#2[#3]{\endgroup
      #2[{#3}]%
      \ifx#1\@undefined
        \xdef#1{#3}%
      \fi
      \ifx#1\relax
        \xdef#1{#3}%
      \fi
    }%
  \fi
\expandafter\x\csname ver@xint.sty\endcsname
\ProvidesPackage{xint}%
  [2013/06/14 v1.08b Expandable operations on long numbers (jfB)]%
%    \end{macrocode}
% \subsection{Token management, constants}
%    \begin{macrocode}
\def\xint_gobble_     {}%
\def\xint_gobble_i    #1{}%
\def\xint_gobble_ii   #1#2{}%
\def\xint_gobble_iii  #1#2#3{}%
\def\xint_gobble_iv   #1#2#3#4{}%
\def\xint_gobble_v    #1#2#3#4#5{}%
\def\xint_gobble_vi   #1#2#3#4#5#6{}%
\def\xint_gobble_vii  #1#2#3#4#5#6#7{}%
\def\xint_gobble_viii #1#2#3#4#5#6#7#8{}%
\def\xint_firstoftwo  #1#2{#1}%
\def\xint_secondoftwo #1#2{#2}%
\def\xint_firstoftwo_andstop  #1#2{ #1}%
\def\xint_secondoftwo_andstop #1#2{ #2}%
\def\xint_exchangetwo_keepbraces_andstop #1#2{ {#2}{#1}}%
\def\xint_firstofthree  #1#2#3{#1}%
\def\xint_secondofthree #1#2#3{#2}%
\def\xint_thirdofthree  #1#2#3{#3}%
\def\xint_minus_andstop { -}%
\def\xint_gob_til_R     #1\R {}%
\def\xint_gob_til_W     #1\W {}%
\def\xint_gob_til_Z     #1\Z {}%
\def\xint_gob_til_zero  #10{}%
\def\xint_gob_til_one   #11{}%
\def\xint_gob_til_G     #1G{}%
\def\xint_gob_til_zeros_iii #1000{}%
\def\xint_gob_til_zeros_iv  #10000{}%
\def\xint_gob_til_relax      #1\relax {}%
\def\xint_gob_til_xint_undef #1\xint_undef {}%
\def\xint_gob_til_xint_relax #1\xint_relax {}%
\def\xint_UDzerofork      #10\dummy  #2#3\krof {#2}%
\def\xint_UDsignfork      #1-\dummy  #2#3\krof {#2}%
\def\xint_UDwfork         #1\W\dummy #2#3\krof {#2}%
\def\xint_UDzerosfork     #100\dummy #2#3\krof {#2}%
\def\xint_UDonezerofork   #110\dummy #2#3\krof {#2}%
\def\xint_UDzerominusfork #10-\dummy #2#3\krof {#2}%
\def\xint_UDsignsfork     #1--\dummy #2#3\krof {#2}%
\def\xint_afterfi #1#2\fi {\fi #1}%
\let\xint_relax\relax
\def\xint_braced_xint_relax {\xint_relax }%
\chardef\xint_c_     0
\chardef\xint_c_i    1 
\chardef\xint_c_ii   2
\chardef\xint_c_iii  3
\chardef\xint_c_iv   4
\chardef\xint_c_v    5
\chardef\xint_c_viii 8
\chardef\xint_c_ix   9
\chardef\xint_c_x   10
\newcount\xint_c_x^viii  \xint_c_x^viii 100000000
%    \end{macrocode}
% \subsection{\csh{xintRev}, \csh{xintReverseOrder}}
% \lverb|&
% \xintRev: fait l'expansion avec \romannumeral-`0, vérifie le signe.$\
% \xintReverseOrder: ne fait PAS l'expansion, ne regarde PAS le signe.|
%    \begin{macrocode}
\def\xintRev {\romannumeral0\xintrev }%
\def\xintrev #1%
{% 
    \expandafter\XINT_rev_fork
    \romannumeral-`0#1\xint_relax % empty #1 ok
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
    \xint_relax
}%
\def\XINT_rev_fork #1%
{%
    \xint_UDsignfork
      #1\dummy {\expandafter\xint_minus_andstop
                \romannumeral0\XINT_rord_main {}}%
       -\dummy {\XINT_rord_main {}#1}%
    \krof
}%
\def\XINT_Rev         {\romannumeral0\XINT_rev }%
\def\xintReverseOrder {\romannumeral0\XINT_rev }%
\def\XINT_rev #1%  
{%
    \XINT_rord_main {}#1%
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax
}%
\def\XINT_rord_main #1#2#3#4#5#6#7#8#9%  
{%
    \xint_gob_til_xint_undef #9\XINT_rord_cleanup\xint_undef
    \XINT_rord_main {#9#8#7#6#5#4#3#2#1}%
}%
\def\XINT_rord_cleanup\xint_undef\XINT_rord_main #1#2\xint_relax 
{%
    \expandafter\space\xint_gob_til_xint_relax #1%
}%
%    \end{macrocode}
% \subsection{\csh{xintRevWithBraces}}
% \lverb|New with 1.06. Makes the expansion of its argument and then reverses
% the 
% resulting tokens or braced tokens, adding a pair of braces to each (thus,
% maintaining it when it was already there.)$\
% hmm, at some point when I was cleaning up the code towards 1.07, I have
% accidentally removed the {} which must be after\XINT_revwbr_loop.
% Corrected for 1.07a. Damn'it all the `noexpand` things in 1.07a were buggy,
% this was caused by a frivolous midnight de-commenting-out. Fixed for 1.08.
% |
%    \begin{macrocode}
\def\xintRevWithBraces         {\romannumeral0\xintrevwithbraces }%
\def\xintRevWithBracesNoExpand {\romannumeral0\xintrevwithbracesnoexpand }%
\def\xintrevwithbraces #1%
{%
    \expandafter\XINT_revwbr_loop\expandafter{\expandafter}%
    \romannumeral-`0#1\xint_relax\xint_relax\xint_relax\xint_relax
                      \xint_relax\xint_relax\xint_relax\xint_relax\Z
}%
\def\xintrevwithbracesnoexpand #1%
{%
    \XINT_revwbr_loop {}%
    #1\xint_relax\xint_relax\xint_relax\xint_relax
      \xint_relax\xint_relax\xint_relax\xint_relax\Z
}%
\def\XINT_revwbr_loop #1#2#3#4#5#6#7#8#9% 
{%
    \xint_gob_til_xint_relax #9\XINT_revwbr_finish_a\xint_relax
    \XINT_revwbr_loop {{#9}{#8}{#7}{#6}{#5}{#4}{#3}{#2}#1}%
}%
\def\XINT_revwbr_finish_a\xint_relax\XINT_revwbr_loop #1#2\Z
{%
    \XINT_revwbr_finish_b #2\R\R\R\R\R\R\R\Z #1%
}%
\def\XINT_revwbr_finish_b #1#2#3#4#5#6#7#8\Z
{%
    \xint_gob_til_R 
            #1\XINT_revwbr_finish_c 8%
            #2\XINT_revwbr_finish_c 7%
            #3\XINT_revwbr_finish_c 6%
            #4\XINT_revwbr_finish_c 5%
            #5\XINT_revwbr_finish_c 4%
            #6\XINT_revwbr_finish_c 3%
            #7\XINT_revwbr_finish_c 2%
            \R\XINT_revwbr_finish_c 1\Z
}%
\def\XINT_revwbr_finish_c #1#2\Z
{%
    \expandafter\expandafter\expandafter
        \space
    \csname xint_gobble_\romannumeral #1\endcsname
}%
%    \end{macrocode}
% \subsection{\csh{xintLen}, \csh{xintLength}}
% \lverb|&
% \xintLen -> fait l'expansion, ne compte PAS le signe.$\
% \xintLength -> ne fait PAS l'expansion, compte le signe.$\
% 1.06: improved code is roughly 20$% faster than the one from earlier
% versions.| 
%    \begin{macrocode}
\def\xintiLen {\romannumeral0\xintilen }%
\def\xintilen #1%
{%
    \expandafter\XINT_length_fork
    \romannumeral-`0#1\xint_relax\xint_relax\xint_relax\xint_relax
                      \xint_relax\xint_relax\xint_relax\xint_relax\Z 
}%
\let\xintLen\xintiLen \let\xintlen\xintilen
\def\XINT_Len #1%
{%
    \romannumeral0\XINT_length_fork
    #1\xint_relax\xint_relax\xint_relax\xint_relax
      \xint_relax\xint_relax\xint_relax\xint_relax\Z 
}%
\def\XINT_length_fork #1%
{%
    \expandafter\XINT_length_loop
    \xint_UDsignfork
      #1\dummy {{0}}%
       -\dummy {{0}#1}%
    \krof
}%
\def\XINT_Length {\romannumeral0\XINT_length }%
\def\XINT_length #1%
{%
    \XINT_length_loop 
    {0}#1\xint_relax\xint_relax\xint_relax\xint_relax
         \xint_relax\xint_relax\xint_relax\xint_relax\Z
}%
\let\xintLength\XINT_Length
\def\XINT_length_loop #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_xint_relax #9\XINT_length_finish_a\xint_relax
    \expandafter\XINT_length_loop\expandafter {\the\numexpr #1+8\relax}%
}%
\def\XINT_length_finish_a\xint_relax
    \expandafter\XINT_length_loop\expandafter #1#2\Z
{%
    \XINT_length_finish_b #2\W\W\W\W\W\W\W\Z {#1}%
}%
\def\XINT_length_finish_b #1#2#3#4#5#6#7#8\Z
{%
    \xint_gob_til_W 
            #1\XINT_length_finish_c 8%
            #2\XINT_length_finish_c 7%
            #3\XINT_length_finish_c 6%
            #4\XINT_length_finish_c 5%
            #5\XINT_length_finish_c 4%
            #6\XINT_length_finish_c 3%
            #7\XINT_length_finish_c 2%
            \W\XINT_length_finish_c 1\Z
}%
\def\XINT_length_finish_c #1#2\Z #3%
   {\expandafter\space\the\numexpr #3-#1\relax}%
%    \end{macrocode}
% \subsection{\csh{xintCSVtoList}}
% \lverb|&
% \xintCSVtoList {a,b,..,z} returns {a}{b}...{z}. The comma separated list may
% be a macro which is first expanded. Each chain of spaces from the initial
% input will be collapsed as usual by the TeX initial scanning
% First included in release 1.06.|
%    \begin{macrocode}
\def\xintCSVtoList {\romannumeral0\xintcsvtolist }%
\def\xintCSVtoListNoExpand {\romannumeral0\xintcsvtolistnoexpand }%
\def\xintcsvtolist #1%
{%
    \expandafter\XINT_csvtol_loop_a\expandafter 
    {\expandafter}\romannumeral-`0#1%
        ,\xint_undef,\xint_undef,\xint_undef,\xint_undef
        ,\xint_undef,\xint_undef,\xint_undef,\xint_undef,\Z
}%
\def\xintcsvtolistnoexpand #1%
{%
    \XINT_csvtol_loop_a 
    {}#1,\xint_undef,\xint_undef,\xint_undef,\xint_undef
        ,\xint_undef,\xint_undef,\xint_undef,\xint_undef,\Z
}%
\def\XINT_csvtol_loop_a #1#2,#3,#4,#5,#6,#7,#8,#9,% 
{%
    \xint_gob_til_xint_undef #9\XINT_csvtol_finish_a\xint_undef
    \XINT_csvtol_loop_b {#1}{{#2}{#3}{#4}{#5}{#6}{#7}{#8}{#9}}%
}%
\def\XINT_csvtol_loop_b #1#2{\XINT_csvtol_loop_a {#1#2}}%
\def\XINT_csvtol_finish_a\xint_undef\XINT_csvtol_loop_b #1#2#3\Z
{%
    \XINT_csvtol_finish_b #3\R,\R,\R,\R,\R,\R,\R,\Z #2{#1}%
}%
\def\XINT_csvtol_finish_b #1,#2,#3,#4,#5,#6,#7,#8\Z
{%
    \xint_gob_til_R 
            #1\XINT_csvtol_finish_c 8%
            #2\XINT_csvtol_finish_c 7%
            #3\XINT_csvtol_finish_c 6%
            #4\XINT_csvtol_finish_c 5%
            #5\XINT_csvtol_finish_c 4%
            #6\XINT_csvtol_finish_c 3%
            #7\XINT_csvtol_finish_c 2%
            \R\XINT_csvtol_finish_c 1\Z
}%
\def\XINT_csvtol_finish_c #1#2\Z
{%
    \csname XINT_csvtol_finish_d\romannumeral #1\endcsname
}%
\def\XINT_csvtol_finish_dviii #1#2#3#4#5#6#7#8#9{ #9}%
\def\XINT_csvtol_finish_dvii  #1#2#3#4#5#6#7#8#9{ #9{#1}}%
\def\XINT_csvtol_finish_dvi   #1#2#3#4#5#6#7#8#9{ #9{#1}{#2}}%
\def\XINT_csvtol_finish_dv    #1#2#3#4#5#6#7#8#9{ #9{#1}{#2}{#3}}%
\def\XINT_csvtol_finish_div   #1#2#3#4#5#6#7#8#9{ #9{#1}{#2}{#3}{#4}}%
\def\XINT_csvtol_finish_diii  #1#2#3#4#5#6#7#8#9{ #9{#1}{#2}{#3}{#4}{#5}}%
\def\XINT_csvtol_finish_dii   #1#2#3#4#5#6#7#8#9{ #9{#1}{#2}{#3}{#4}{#5}{#6}}%
\def\XINT_csvtol_finish_di    #1#2#3#4#5#6#7#8#9%
                                            { #9{#1}{#2}{#3}{#4}{#5}{#6}{#7}}%
%    \end{macrocode}
% \subsection{\csh{xintListWithSep}}
% \lverb|&
% \xintListWithSep {sep}{{a}{b}...{z}} returns a sep b sep .... sep z$\
% Included in release 1.04. The 'sep' can be \par's: the macro
% xintlistwithsep etc... are all declared long. 'sep' does not have to be a
% single token. The list may be a macro it is first expanded.
% 1.06 modifies the `feature' of returning sep if the list is empty: the output
% is now empty in that case. (sep was not used for a one element list, but
% strangely it was for a zero-element list).|
%    \begin{macrocode}
\def\xintListWithSep {\romannumeral0\xintlistwithsep }%
\def\xintListWithSepNoExpand {\romannumeral0\xintlistwithsepnoexpand }%
\long\def\xintlistwithsep #1#2%
    {\expandafter\XINT_lws\expandafter {\romannumeral-`0#2}{#1}}%
\long\def\XINT_lws #1#2{\XINT_lws_start {#2}#1\Z }%
\long\def\xintlistwithsepnoexpand #1#2{\XINT_lws_start {#1}#2\Z }%
\long\def\XINT_lws_start #1#2%
{%
    \xint_gob_til_Z #2\XINT_lws_dont\Z 
    \XINT_lws_loop_a {#2}{#1}%
}%
\long\def\XINT_lws_dont\Z\XINT_lws_loop_a #1#2{ }%
\long\def\XINT_lws_loop_a #1#2#3%
{%
    \xint_gob_til_Z #3\XINT_lws_end\Z
    \XINT_lws_loop_b {#1}{#2#3}{#2}%
}%
\long\def\XINT_lws_loop_b #1#2{\XINT_lws_loop_a {#1#2}}%
\long\def\XINT_lws_end\Z\XINT_lws_loop_b #1#2#3{ #1}%
%    \end{macrocode}
% \subsection{\csh{xintNthElt}}
% \lverb|&
% \xintNthElt {i}{{a}{b}...{z}} (or `tokens' abcd...z) returns the i th
% element (one pair of braces removed). The list is first expanded.
% First included in release 1.06. With 1.06a, a value of i = 0 (or negative)
% makes the macro return the length. This is different from \xintLen which is
% for numbers (checks sign) and different from \xintLength which does not first
% expand its argument.|
%    \begin{macrocode}
\def\xintNthElt         {\romannumeral0\xintnthelt }%
\def\xintNthEltNoExpand {\romannumeral0\xintntheltnoexpand }%
\def\xintnthelt #1#2%
{%
    \expandafter\XINT_nthelt\expandafter {\romannumeral-`0#2}%
                                         {\numexpr #1\relax }%
}%
\def\xintntheltnoexpand #1#2%
{%
    \XINT_nthelt {#2}{\numexpr #1\relax}%
}%
\def\XINT_nthelt #1#2%
{%
    \ifnum #2>\xint_c_
          \xint_afterfi {\XINT_nthelt_loop_a {#2}}%
    \else
          \xint_afterfi {\XINT_length_loop {0}}%
    \fi #1\xint_relax\xint_relax\xint_relax\xint_relax
          \xint_relax\xint_relax\xint_relax\xint_relax\Z
}%
\def\XINT_nthelt_loop_a #1%
{%
    \ifnum #1>\xint_c_viii
        \expandafter\XINT_nthelt_loop_b
    \else
        \expandafter\XINT_nthelt_getit
    \fi
    {#1}%
}%
\def\XINT_nthelt_loop_b #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_xint_relax #9\XINT_nthelt_silentend\xint_relax
    \expandafter\XINT_nthelt_loop_a\expandafter{\the\numexpr #1-8\relax}%
}%
\def\XINT_nthelt_silentend #1\Z { }%
\def\XINT_nthelt_getit #1%
{%
    \expandafter\expandafter\expandafter\XINT_nthelt_finish
    \csname xint_gobble_\romannumeral\numexpr#1-1\endcsname
}%
\def\XINT_nthelt_finish #1#2\Z 
{%
    \xint_UDwfork
      #1\dummy { }%
      \W\dummy { #1}%
    \krof
}%
%    \end{macrocode}
% \subsection{\csh{xintApply}}
% \lverb|&
% \xintApply {\macro}{{a}{b}...{z}} returns {\macro{a}}...{\macro{b}}
% where each instance of \macro is expanded. The list is first
% expanded. Introduced with release 1.04|
%    \begin{macrocode}
\def\xintApply         {\romannumeral0\xintapply }%
\def\xintApplyNoExpand {\romannumeral0\xintapplynoexpand }%
\def\xintapply #1#2%
{%
    \expandafter\XINT_apply\expandafter {\romannumeral-`0#2}%
    {#1}%
}%
\def\XINT_apply #1#2{\XINT_apply_loop_a {}{#2}#1\Z }%
\def\xintapplynoexpand #1#2{\XINT_apply_loop_a {}{#1}#2\Z }%
\def\XINT_apply_loop_a #1#2#3%
{%
    \xint_gob_til_Z #3\XINT_apply_end\Z 
    \expandafter
    \XINT_apply_loop_b 
    \expandafter {\romannumeral-`0#2{#3}}{#1}{#2}%
}%
\def\XINT_apply_loop_b #1#2{\XINT_apply_loop_a {#2{#1}}}%
\def\XINT_apply_end\Z\expandafter\XINT_apply_loop_b\expandafter #1#2#3{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintApplyUnbraced}}
% \lverb|&
% \xintApplyUnbraced {\macro}{{a}{b}...{z}} returns \macro{a}...\macro{b}
% where each instance of \macro is expanded using \romannumeral-`0. No braces
% are added: this allows for example a non-expandable \def in \macro, without
% having to do \gdef. The list is first expanded. Introduced with release 1.06b|
%    \begin{macrocode}
\def\xintApplyUnbraced {\romannumeral0\xintapplyunbraced }%
\def\xintApplyUnbracedNoExpand {\romannumeral0\xintapplyunbracednoexpand }%
\def\xintapplyunbraced #1#2%
{%
    \expandafter\XINT_applyunbr\expandafter {\romannumeral-`0#2}%
    {#1}%
}%
\def\XINT_applyunbr #1#2{\XINT_applyunbr_loop_a {}{#2}#1\Z }%
\def\xintapplyunbracednoexpand #1#2%
   {\XINT_applyunbr_loop_a {}{#1}#2\Z }%
\def\XINT_applyunbr_loop_a #1#2#3%
{%
    \xint_gob_til_Z #3\XINT_applyunbr_end\Z 
    \expandafter\XINT_applyunbr_loop_b
    \expandafter {\romannumeral-`0#2{#3}}{#1}{#2}%
}%
\def\XINT_applyunbr_loop_b #1#2{\XINT_applyunbr_loop_a {#2#1}}%
\def\XINT_applyunbr_end\Z
    \expandafter\XINT_applyunbr_loop_b\expandafter #1#2#3{ #2}%
%    \end{macrocode}
% 
% \subsection{\csh{xintAssign},~\csh{xintAssignArray},~\csh{xintDigitsOf}}
% \lverb|&
% \xintAssign {a}{b}..{z}\to\A\B...\Z,$\
% \xintAssignArray {a}{b}..{z}\to\U
%
% version 1.01 corrects an oversight in 1.0 related to the value of
% \escapechar at the time of using \xintAssignArray or \xintRelaxArray
% These macros are an exception in the xint bundle, they do not care at
% all about compatibility with expansion-only contexts. 
%
% In version 1.05a I suddenly see some incongruous \expandafter's in (what is
% called now) \XINT_assignarray_end_c, which I remove.
%
% Release 1.06 modifies the macros created by \xintAssignArray to feed their
% argument to a \numexpr.
%
% Release 1.06a detects an incredible typo in 1.01, (bad copy-paste from
% \xintRelaxArray) which caused \xintAssignArray to use #1 rather than the #2 as
% in the correct earlier 1.0 version!!!  This went through undetected because
% \xint_arrayname, although weird, was still usable: the probability to
% overwrite something was almost zero. The bug got finally revealed doing 
% \xintAssignArray {}{}{}\to\Stuff.
% 
% With release 1.06b an empty argument (or expanding to empty) to
% \xintAssignArray is ok.|
%    \begin{macrocode}
\def\xintAssign #1\to
{%
    \expandafter\XINT_assign_a\romannumeral-`0#1{}\to
}%
\def\XINT_assign_a #1% attention to the # at the beginning of next line
#{%
    \def\xint_temp {#1}%
    \ifx\empty\xint_temp
        \expandafter\XINT_assign_b 
    \else
        \expandafter\XINT_assign_B
    \fi
}%
\def\XINT_assign_b #1#2\to #3%
{% 
    \edef #3{#1}\def\xint_temp {#2}%
    \ifx\empty\xint_temp
      \else
      \xint_afterfi{\XINT_assign_a #2\to }%
    \fi
}%
\def\XINT_assign_B #1\to #2%
{%
    \edef #2{\xint_temp}%
}%
\def\xintRelaxArray #1%
{%
    \edef\XINT_restoreescapechar {\escapechar\the\escapechar\relax}%
    \escapechar -1
    \edef\xint_arrayname {\string #1}%
    \XINT_restoreescapechar
    \expandafter\let\expandafter\xint_temp
                \csname\xint_arrayname 0\endcsname
    \count 255 0
    \loop
      \global\expandafter\let
             \csname\xint_arrayname\the\count255\endcsname\relax
      \ifnum \count 255 < \xint_temp
      \advance\count 255 1
    \repeat  
    \global\expandafter\let\csname\xint_arrayname 00\endcsname\relax
    \global\let #1\relax    
}%
\def\xintAssignArray #1\to #2% 1.06b: #1 may now be empty
{% 
    \edef\XINT_restoreescapechar {\escapechar\the\escapechar\relax }%
    \escapechar -1
    \edef\xint_arrayname {\string #2}%
    \XINT_restoreescapechar
    \count 255 0
    \expandafter\XINT_assignarray_loop \romannumeral-`0#1\xint_relax
    \csname\xint_arrayname 00\endcsname
    \csname\xint_arrayname 0\endcsname 
    {\xint_arrayname}%
    #2%
}%
\def\XINT_assignarray_loop #1%
{%
    \def\xint_temp {#1}%
    \ifx\xint_braced_xint_relax\xint_temp
       \expandafter\edef\csname\xint_arrayname 0\endcsname{\the\count 255 }%
       \expandafter\expandafter\expandafter\XINT_assignarray_end_a
    \else
       \advance\count 255 1
       \expandafter\edef
          \csname\xint_arrayname\the\count 255\endcsname{\xint_temp }%
       \expandafter\XINT_assignarray_loop
    \fi
}%
\def\XINT_assignarray_end_a #1%
{%
    \expandafter\XINT_assignarray_end_b\expandafter #1%
}%
\def\XINT_assignarray_end_b #1#2#3%
{%
    \expandafter\XINT_assignarray_end_c
    \expandafter #1\expandafter #2\expandafter {#3}%
}%
\def\XINT_assignarray_end_c #1#2#3#4%
{%
    \def #4##1%
    {%
        \romannumeral0\expandafter #1\expandafter{\the\numexpr ##1}%
    }%
    \def #1##1%
    {%
        \ifnum ##1< 0
            \xint_afterfi {\xintError:ArrayIndexIsNegative\space 0}%
        \else
            \xint_afterfi {%
              \ifnum ##1>#2
                  \xint_afterfi {\xintError:ArrayIndexBeyondLimit\space 0}%
              \else
                  \xint_afterfi
                  {\expandafter\expandafter\expandafter
                   \space\csname #3##1\endcsname}%
              \fi}%
        \fi
     }%
}%
\let\xintDigitsOf\xintAssignArray
%    \end{macrocode}
% \subsection{\csh{XINT\_RQ}}
% \lverb|&
% cette macro renverse et ajoute le nombre minimal de zéros à
% la fin pour que la longueur soit alors multiple de 4$\
% \romannumeral0\XINT_RQ {}<le truc à renverser>\R\R\R\R\R\R\R\R\Z$\
% Attention, ceci n'est utilisé que pour des chaînes de chiffres, et donc le
% comportement avec des {..} ou autres espaces n'a fait l'objet d'aucune
% attention |
%    \begin{macrocode}
\def\XINT_RQ #1#2#3#4#5#6#7#8#9%  
{%
    \xint_gob_til_R #9\XINT_RQ_end_a\R\XINT_RQ {#9#8#7#6#5#4#3#2#1}%
}%
\def\XINT_RQ_end_a\R\XINT_RQ #1#2\Z 
{%
    \XINT_RQ_end_b #1\Z
}%
\def\XINT_RQ_end_b #1#2#3#4#5#6#7#8%  
{%
    \xint_gob_til_R 
            #8\XINT_RQ_end_viii 
            #7\XINT_RQ_end_vii
            #6\XINT_RQ_end_vi
            #5\XINT_RQ_end_v
            #4\XINT_RQ_end_iv
            #3\XINT_RQ_end_iii
            #2\XINT_RQ_end_ii
            \R\XINT_RQ_end_i
            \Z #2#3#4#5#6#7#8%
}%
\def\XINT_RQ_end_viii #1\Z #2#3#4#5#6#7#8#9\Z { #9}%
\def\XINT_RQ_end_vii  #1\Z #2#3#4#5#6#7#8#9\Z { #8#9000}%
\def\XINT_RQ_end_vi   #1\Z #2#3#4#5#6#7#8#9\Z { #7#8#900}%
\def\XINT_RQ_end_v    #1\Z #2#3#4#5#6#7#8#9\Z { #6#7#8#90}%
\def\XINT_RQ_end_iv   #1\Z #2#3#4#5#6#7#8#9\Z { #5#6#7#8#9}%
\def\XINT_RQ_end_iii  #1\Z #2#3#4#5#6#7#8#9\Z { #4#5#6#7#8#9000}%
\def\XINT_RQ_end_ii   #1\Z #2#3#4#5#6#7#8#9\Z { #3#4#5#6#7#8#900}%
\def\XINT_RQ_end_i      \Z #1#2#3#4#5#6#7#8\Z { #1#2#3#4#5#6#7#80}%
\def\XINT_SQ #1#2#3#4#5#6#7#8%
{%
    \xint_gob_til_R #8\XINT_SQ_end_a\R\XINT_SQ {#8#7#6#5#4#3#2#1}%
}%
\def\XINT_SQ_end_a\R\XINT_SQ #1#2\Z
{%
    \XINT_SQ_end_b #1\Z
}%
\def\XINT_SQ_end_b #1#2#3#4#5#6#7%
{%
    \xint_gob_til_R
            #7\XINT_SQ_end_vii
            #6\XINT_SQ_end_vi
            #5\XINT_SQ_end_v
            #4\XINT_SQ_end_iv
            #3\XINT_SQ_end_iii
            #2\XINT_SQ_end_ii
            \R\XINT_SQ_end_i
            \Z #2#3#4#5#6#7%
}%
\def\XINT_SQ_end_vii  #1\Z #2#3#4#5#6#7#8\Z { #8}%
\def\XINT_SQ_end_vi   #1\Z #2#3#4#5#6#7#8\Z { #7#8000000}%
\def\XINT_SQ_end_v    #1\Z #2#3#4#5#6#7#8\Z { #6#7#800000}%
\def\XINT_SQ_end_iv   #1\Z #2#3#4#5#6#7#8\Z { #5#6#7#80000}%
\def\XINT_SQ_end_iii  #1\Z #2#3#4#5#6#7#8\Z { #4#5#6#7#8000}%
\def\XINT_SQ_end_ii   #1\Z #2#3#4#5#6#7#8\Z { #3#4#5#6#7#800}%
\def\XINT_SQ_end_i      \Z #1#2#3#4#5#6#7\Z { #1#2#3#4#5#6#70}%
\def\XINT_OQ #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_R #9\XINT_OQ_end_a\R\XINT_OQ {#9#8#7#6#5#4#3#2#1}%
}%
\def\XINT_OQ_end_a\R\XINT_OQ #1#2\Z
{%
    \XINT_OQ_end_b #1\Z
}%
\def\XINT_OQ_end_b #1#2#3#4#5#6#7#8%
{%
    \xint_gob_til_R
            #8\XINT_OQ_end_viii
            #7\XINT_OQ_end_vii
            #6\XINT_OQ_end_vi
            #5\XINT_OQ_end_v
            #4\XINT_OQ_end_iv
            #3\XINT_OQ_end_iii
            #2\XINT_OQ_end_ii
            \R\XINT_OQ_end_i
            \Z #2#3#4#5#6#7#8%
}%
\def\XINT_OQ_end_viii #1\Z #2#3#4#5#6#7#8#9\Z { #9}%
\def\XINT_OQ_end_vii  #1\Z #2#3#4#5#6#7#8#9\Z { #8#90000000}%
\def\XINT_OQ_end_vi   #1\Z #2#3#4#5#6#7#8#9\Z { #7#8#9000000}%
\def\XINT_OQ_end_v    #1\Z #2#3#4#5#6#7#8#9\Z { #6#7#8#900000}%
\def\XINT_OQ_end_iv   #1\Z #2#3#4#5#6#7#8#9\Z { #5#6#7#8#90000}%
\def\XINT_OQ_end_iii  #1\Z #2#3#4#5#6#7#8#9\Z { #4#5#6#7#8#9000}%
\def\XINT_OQ_end_ii   #1\Z #2#3#4#5#6#7#8#9\Z { #3#4#5#6#7#8#900}%
\def\XINT_OQ_end_i      \Z #1#2#3#4#5#6#7#8\Z { #1#2#3#4#5#6#7#80}%
%    \end{macrocode}
% \subsection{\csh{XINT\_cuz}}
%    \begin{macrocode}
\def\xint_cleanupzeros_andstop #1#2#3#4%
{%
    \expandafter\space\the\numexpr #1#2#3#4\relax 
}%
\def\xint_cleanupzeros_nospace #1#2#3#4%
{%
    \the\numexpr #1#2#3#4\relax 
}%
\def\XINT_rev_andcuz #1%
{%
    \expandafter\xint_cleanupzeros_andstop 
    \romannumeral0\XINT_rord_main {}#1%
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax 
}%
%    \end{macrocode}
% \lverb|&
% routine CleanUpZeros. Utilisée en particulier par la
% soustraction.$\
% INPUT:  longueur **multiple de 4**  (<-- ATTENTION)$\
% OUTPUT: on a retiré tous les leading zéros, on n'est **plus*
% nécessairement de longueur 4n$\
% Délimiteur pour _main: \W\W\W\W\W\W\W\Z avec SEPT \W|
%    \begin{macrocode}
\def\XINT_cuz #1%
{%
    \XINT_cuz_loop #1\W\W\W\W\W\W\W\Z%
}%
\def\XINT_cuz_loop #1#2#3#4#5#6#7#8%
{%
    \xint_gob_til_W #8\xint_cuz_end_a\W
    \xint_gob_til_Z #8\xint_cuz_end_A\Z
    \XINT_cuz_check_a {#1#2#3#4#5#6#7#8}%
}%
\def\xint_cuz_end_a #1\XINT_cuz_check_a #2%
{%
    \xint_cuz_end_b #2%
}%
\def\xint_cuz_end_b #1#2#3#4#5\Z 
{%
    \expandafter\space\the\numexpr #1#2#3#4\relax
}%
\def\xint_cuz_end_A \Z\XINT_cuz_check_a #1{ 0}%
\def\XINT_cuz_check_a #1%
{%
    \expandafter\XINT_cuz_check_b\the\numexpr #1\relax
}%
\def\XINT_cuz_check_b #1%
{%
    \xint_gob_til_zero #1\xint_cuz_backtoloop 0\XINT_cuz_stop #1%
}%
\def\XINT_cuz_stop #1\W #2\Z{ #1}%
\def\xint_cuz_backtoloop 0\XINT_cuz_stop 0{\XINT_cuz_loop }%
%    \end{macrocode}
% \subsection{\csh{XINT\_isOne}}
% \lverb|&
% Added in 1.03. Attention: does not do any expansion.|
%    \begin{macrocode}
\def\XINT_isOne #1{\romannumeral0\XINT_isone #1\W\Z }%
\def\XINT_isone #1#2%
{%
    \xint_gob_til_one #1\XINT_isone_b 1%
    \expandafter\space\expandafter 0\xint_gob_til_Z #2%
}%
\def\XINT_isone_b #1\xint_gob_til_Z #2%
{%
    \xint_gob_til_W #2\XINT_isone_yes \W
    \expandafter\space\expandafter 0\xint_gob_til_Z
}%
\def\XINT_isone_yes #1\Z { 1}%
%    \end{macrocode}
% \subsection{\csh{xintNum}}
% \lverb|&
% For example \xintNum {----+-+++---+----000000000000003}$\
% 1.05 defines \xintiNum, which allows redefinition of \xintNum by xintfrac.sty
% Slightly modified in 1.06b (\R->\xint_relax) to avoid initial re-scan of
% input stack (while still allowing empty #1)|
%    \begin{macrocode}
\def\xintiNum {\romannumeral0\xintinum }%
\def\xintinum #1%
{%
    \expandafter\XINT_num_loop
    \romannumeral-`0#1\xint_relax\xint_relax\xint_relax\xint_relax
                      \xint_relax\xint_relax\xint_relax\xint_relax\Z 
}%
\let\xintNum\xintiNum \let\xintnum\xintinum
\def\XINT_num #1%
{%
    \XINT_num_loop #1\xint_relax\xint_relax\xint_relax\xint_relax
                     \xint_relax\xint_relax\xint_relax\xint_relax\Z 
}%
\def\XINT_num_loop #1#2#3#4#5#6#7#8%
{% 
    \xint_gob_til_xint_relax #8\XINT_num_end\xint_relax
    \XINT_num_NumEight #1#2#3#4#5#6#7#8%
}%
\def\XINT_num_end\xint_relax\XINT_num_NumEight #1\xint_relax #2\Z
{%
    \expandafter\space\the\numexpr #1+0\relax
}%
\def\XINT_num_NumEight #1#2#3#4#5#6#7#8%
{%
    \ifnum \numexpr #1#2#3#4#5#6#7#8+0= 0
      \xint_afterfi {\expandafter\XINT_num_keepsign_a
                     \the\numexpr #1#2#3#4#5#6#7#81\relax}%
    \else
      \xint_afterfi {\expandafter\XINT_num_finish
                     \the\numexpr #1#2#3#4#5#6#7#8\relax}%
    \fi
}%
\def\XINT_num_keepsign_a #1%
{%
    \xint_gob_til_one#1\XINT_num_gobacktoloop 1\XINT_num_keepsign_b  
}%
\def\XINT_num_gobacktoloop 1\XINT_num_keepsign_b {\XINT_num_loop }%
\def\XINT_num_keepsign_b #1{\XINT_num_loop -}%
\def\XINT_num_finish #1\xint_relax #2\Z { #1}%
%    \end{macrocode}
% \subsection{\csh{xintSgn}}
% \lverb|&
% Changed in 1.05. Earlier code was unnecessarily strange.|
%    \begin{macrocode}
\def\xintiSgn {\romannumeral0\xintisgn }%
\def\xintisgn #1%
{%
    \expandafter\XINT_sgn \romannumeral-`0#1\Z%
}%
\let\xintSgn\xintiSgn \let\xintsgn\xintisgn
\def\XINT_Sgn #1{\romannumeral0\XINT_sgn #1\Z }%
\def\XINT_sgn #1#2\Z
{%
    \xint_UDzerominusfork
      #1-\dummy  { 0}%
      0#1\dummy  { -1}%
       0-\dummy  { 1}%
    \krof
}%
%    \end{macrocode}
% \subsection{\csh{xintSgnFork}}
% \lverb|&
% Expandable three-way fork added in 1.07. It is not used in the code but is
% provided for use inside the arguments to the package macros. The argument #1
% must expand to -1,0 or 1. A \count should be put within a \numexpr..\relax.|
%    \begin{macrocode}
\def\xintSgnFork {\romannumeral0\xintsgnfork }%
\def\xintsgnfork #1%
{%
    \ifcase #1 \xint_afterfi{\expandafter\space\xint_secondofthree}%
            \or\xint_afterfi{\expandafter\space\xint_thirdofthree}%
          \else\xint_afterfi{\expandafter\space\xint_firstofthree}%
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintOpp}}
%    \begin{macrocode}
\def\xintiOpp {\romannumeral0\xintiopp }%
\def\xintiopp #1%
{%
    \expandafter\XINT_opp \romannumeral-`0#1%
}%
\let\xintOpp\xintiOpp \let\xintopp\xintiopp
\def\XINT_Opp #1{\romannumeral0\XINT_opp #1}%
\def\XINT_opp #1%
{%
    \xint_UDzerominusfork
      #1-\dummy  { 0}%      zero
      0#1\dummy  { }%     negative
       0-\dummy  { -#1}%  positive
    \krof
}%
%    \end{macrocode}
% \subsection{\csh{xintAbs}}
%    \begin{macrocode}
\def\xintiAbs {\romannumeral0\xintiabs }%
\def\xintiabs #1%
{%
    \expandafter\XINT_abs \romannumeral-`0#1%
}%
\let\xintAbs\xintiAbs \let\xintabs\xintiabs
\def\XINT_Abs #1{\romannumeral0\XINT_abs #1}%
\def\XINT_abs #1%
{%
    \xint_UDsignfork
      #1\dummy  { }%
       -\dummy  { #1}%
    \krof
}%
%    \end{macrocode}
% \lverb|&
% -----------------------------------------------------------------$\
% -----------------------------------------------------------------$\
% ARITHMETIC OPERATIONS: ADDITION, SUBTRACTION, SUMS,
% MULTIPLICATION, PRODUCTS, FACTORIAL, POWERS, EUCLIDEAN DIVISION.
%
% Release 1.03 re-organizes sub-routines to facilitate future developments: the
% diverse variants of addition, with diverse conditions on inputs and output are
% first listed; they will be used in multiplication, or in the summation, or in
% the power routines. I am aware that the commenting is close to non-existent,
% sorry about that.
%
% ADDITION I: \XINT_add_A
%
% INPUT:$\
% \romannumeral0\XINT_add_A 0{}<N1>\W\X\Y\Z <N2>\W\X\Y\Z$\
%     1.    <N1> et <N2> renversés $\
%     2.    de longueur 4n (avec des leading zéros éventuels)$\
%     3.    l'un des deux ne doit pas se terminer par 0000$\$relax
% [Donc on peut avoir 0000 comme input si l'autre est >0 et ne se termine pas en
% 0000 bien sûr]. On peut avoir l'un des deux vides. Mais alors l'autre ne doit
% être ni vide ni 0000.
%
% OUTPUT: la somme <N1>+<N2>, ordre normal, plus sur 4n, pas de leading zeros
% La procédure est plus rapide lorsque <N1> est le plus court des deux.$\
% Nota bene: (30 avril 2013). J'ai une version qui est deux fois plus rapide sur
% des nombres d'environ 1000 chiffres chacun, et qui commence à être avantageuse
% pour des nombres d'au moins 200 chiffres. Cependant il serait vraiment
% compliqué d'en étendre l'utilisation aux emplois de l'addition dans les
% autres routines, comme celle de multiplication ou celle de division; et son
% implémentation ajouterait au minimum la mesure de la longueur des summands.|
%    \begin{macrocode}
\def\XINT_add_A #1#2#3#4#5#6%  
{%
    \xint_gob_til_W #3\xint_add_az\W
    \XINT_add_AB #1{#3#4#5#6}{#2}% 
}%
\def\xint_add_az\W\XINT_add_AB #1#2%  
{%
    \XINT_add_AC_checkcarry #1% 
}%
%    \end{macrocode}
% \lverb|&
% ici #2 est prévu pour l'addition, mais attention il devra être renversé
% pour \numexpr. #3 = résultat partiel. #4 = chiffres qui restent. On vérifie si
% le deuxième nombre s'arrête.|
%    \begin{macrocode}
\def\XINT_add_AB #1#2#3#4\W\X\Y\Z #5#6#7#8%  
{%
    \xint_gob_til_W #5\xint_add_bz\W 
    \XINT_add_ABE #1#2{#8#7#6#5}{#3}#4\W\X\Y\Z 
}%
\def\XINT_add_ABE #1#2#3#4#5#6%
{%
    \expandafter\XINT_add_ABEA\the\numexpr #1+10#5#4#3#2+#6\relax.%
}%
\def\XINT_add_ABEA #1#2#3.#4%  
{%
    \XINT_add_A  #2{#3#4}%
}%
%    \end{macrocode}
% \lverb|&
% ici le deuxième nombre est fini
% #6 part à la poubelle, #2#3#4#5 est le #2 dans \XINT_add_AB
% on ne vérifie pas la retenue cette fois, mais les fois suivantes|
%    \begin{macrocode}
\def\xint_add_bz\W\XINT_add_ABE #1#2#3#4#5#6%
{%
    \expandafter\XINT_add_CC\the\numexpr #1+10#5#4#3#2\relax.%
}%
\def\XINT_add_CC #1#2#3.#4%  
{%
    \XINT_add_AC_checkcarry  #2{#3#4}% on va examiner et \'eliminer #2
}%
%    \end{macrocode}
% \lverb|&
% retenue plus chiffres qui restent de l'un des deux nombres.
% #2 = résultat partiel
% #3#4#5#6 = summand, avec plus significatif à droite|
%    \begin{macrocode}
\def\XINT_add_AC_checkcarry #1%
{%
    \xint_gob_til_zero #1\xint_add_AC_nocarry 0\XINT_add_C 
}%
\def\xint_add_AC_nocarry 0\XINT_add_C #1#2\W\X\Y\Z
{%
    \expandafter
    \xint_cleanupzeros_andstop
    \romannumeral0%
    \XINT_rord_main {}#2%
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax
    #1%
}%
\def\XINT_add_C #1#2#3#4#5%  
{%
    \xint_gob_til_W #2\xint_add_cz\W
    \XINT_add_CD {#5#4#3#2}{#1}%
}%
\def\XINT_add_CD #1%
{%
    \expandafter\XINT_add_CC\the\numexpr 1+10#1\relax.%
}%
\def\xint_add_cz\W\XINT_add_CD #1#2{ 1#2}%
%    \end{macrocode}
% \lverb|Addition II: \XINT_addr_A.$\
% INPUT: \romannumeral0\XINT_addr_A 0{}<N1>\W\X\Y\Z <N2>\W\X\Y\Z
%
% Comme \XINT_add_A, la différence principale c'est qu'elle donne son résultat
% aussi *sur 4n*, renversé. De plus cette variante accepte que l'un ou même les
% deux inputs soient vides. Utilisé par la sommation et par la division (pour
% les quotients). Et aussi par la multiplication d'ailleurs.$\ 
% INPUT: comme pour \XINT_add_A$\
%     1.    <N1> et <N2> renversés $\
%     2.    de longueur 4n (avec des leading zéros éventuels)$\
%     3.    l'un des deux ne doit pas se terminer par 0000$\
% OUTPUT: la somme <N1>+<N2>, *aussi renversée* et *sur 4n*|
%    \begin{macrocode}
\def\XINT_addr_A #1#2#3#4#5#6%  
{%
    \xint_gob_til_W #3\xint_addr_az\W
    \XINT_addr_B #1{#3#4#5#6}{#2}% 
}%
\def\xint_addr_az\W\XINT_addr_B #1#2%  
{%
    \XINT_addr_AC_checkcarry #1%
}%
\def\XINT_addr_B #1#2#3#4\W\X\Y\Z #5#6#7#8%  
{%
    \xint_gob_til_W #5\xint_addr_bz\W
    \XINT_addr_E #1#2{#8#7#6#5}{#3}#4\W\X\Y\Z 
}%
\def\XINT_addr_E #1#2#3#4#5#6%
{%
    \expandafter\XINT_addr_ABEA\the\numexpr #1+10#5#4#3#2+#6\relax
}%
\def\XINT_addr_ABEA #1#2#3#4#5#6#7%  
{%
    \XINT_addr_A  #2{#7#6#5#4#3}%
}%
\def\xint_addr_bz\W\XINT_addr_E #1#2#3#4#5#6%
{%
    \expandafter\XINT_addr_CC\the\numexpr #1+10#5#4#3#2\relax
}%
\def\XINT_addr_CC #1#2#3#4#5#6#7%  
{%
    \XINT_addr_AC_checkcarry  #2{#7#6#5#4#3}%
}%
\def\XINT_addr_AC_checkcarry #1%
{%
    \xint_gob_til_zero #1\xint_addr_AC_nocarry 0\XINT_addr_C 
}%
\def\xint_addr_AC_nocarry 0\XINT_addr_C #1#2\W\X\Y\Z { #1#2}%
\def\XINT_addr_C #1#2#3#4#5%  
{%
    \xint_gob_til_W #2\xint_addr_cz\W
    \XINT_addr_D {#5#4#3#2}{#1}%
}%
\def\XINT_addr_D #1%
{%
    \expandafter\XINT_addr_CC\the\numexpr 1+10#1\relax
}%
\def\xint_addr_cz\W\XINT_addr_D #1#2{ #21000}%
%    \end{macrocode}
% \lverb|ADDITION III, \XINT_addm_A$\
% INPUT:\romannumeral0\XINT_addm_A 0{}<N1>\W\X\Y\Z <N2>\W\X\Y\Z$\
%     1.    <N1> et <N2> renversés$\
%     2.    <N1> de longueur 4n ; <N2> non$\
%     3.    <N2> est *garanti au moins aussi long* que <N1>$\
% OUTPUT: la somme <N1>+<N2>, ordre normal, pas sur 4n, leading zeros retirés.
% Utilisé par la multiplication.|
%    \begin{macrocode}
\def\XINT_addm_A #1#2#3#4#5#6%  
{%
    \xint_gob_til_W #3\xint_addm_az\W
    \XINT_addm_AB #1{#3#4#5#6}{#2}% 
}%
\def\xint_addm_az\W\XINT_addm_AB #1#2%  
{%
    \XINT_addm_AC_checkcarry #1%
}%
\def\XINT_addm_AB #1#2#3#4\W\X\Y\Z #5#6#7#8%  
{%
    \XINT_addm_ABE #1#2{#8#7#6#5}{#3}#4\W\X\Y\Z 
}%
\def\XINT_addm_ABE #1#2#3#4#5#6%
{%
    \expandafter\XINT_addm_ABEA\the\numexpr #1+10#5#4#3#2+#6\relax.%
}%
\def\XINT_addm_ABEA #1#2#3.#4%  
{%
    \XINT_addm_A  #2{#3#4}%
}%
\def\XINT_addm_AC_checkcarry #1%
{%
    \xint_gob_til_zero #1\xint_addm_AC_nocarry 0\XINT_addm_C 
}%
\def\xint_addm_AC_nocarry 0\XINT_addm_C #1#2\W\X\Y\Z
{%
    \expandafter
    \xint_cleanupzeros_andstop
    \romannumeral0%
    \XINT_rord_main {}#2%
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax
    #1%
}%
\def\XINT_addm_C #1#2#3#4#5%  
{%
    \xint_gob_til_W 
    #5\xint_addm_cw
    #4\xint_addm_cx 
    #3\xint_addm_cy 
    #2\xint_addm_cz 
    \W\XINT_addm_CD {#5#4#3#2}{#1}%
}%
\def\XINT_addm_CD #1%
{%
    \expandafter\XINT_addm_CC\the\numexpr 1+10#1\relax.%
}%
\def\XINT_addm_CC #1#2#3.#4%  
{%
    \XINT_addm_AC_checkcarry  #2{#3#4}%
}%
\def\xint_addm_cw 
    #1\xint_addm_cx
    #2\xint_addm_cy
    #3\xint_addm_cz
    \W\XINT_addm_CD 
{%
    \expandafter\XINT_addm_CDw\the\numexpr 1+#1#2#3\relax.%
}%
\def\XINT_addm_CDw #1.#2#3\X\Y\Z 
{%
    \XINT_addm_end #1#3%
}%
\def\xint_addm_cx 
    #1\xint_addm_cy
    #2\xint_addm_cz
    \W\XINT_addm_CD 
{%
    \expandafter\XINT_addm_CDx\the\numexpr 1+#1#2\relax.%
}%
\def\XINT_addm_CDx #1.#2#3\Y\Z 
{%
    \XINT_addm_end #1#3%
}%
\def\xint_addm_cy 
    #1\xint_addm_cz
    \W\XINT_addm_CD
{%
    \expandafter\XINT_addm_CDy\the\numexpr 1+#1\relax.%
}%
\def\XINT_addm_CDy  #1.#2#3\Z 
{%
    \XINT_addm_end #1#3%
}%
\def\xint_addm_cz\W\XINT_addm_CD #1#2#3{\XINT_addm_end #1#3}%
\def\XINT_addm_end #1#2#3#4#5%
    {\expandafter\space\the\numexpr #1#2#3#4#5\relax}%
%    \end{macrocode}
% \lverb|ADDITION IV, variante \XINT_addp_A$\
% INPUT:
% \romannumeral0\XINT_addp_A 0{}<N1>\W\X\Y\Z <N2>\W\X\Y\Z$\
%     1.    <N1> et <N2> renversés$\
%     2.    <N1> de longueur 4n ; <N2> non$\
%     3.    <N2> est *garanti au moins aussi long* que <N1>$\
% OUTPUT: la somme <N1>+<N2>, dans l'ordre renversé, sur 4n, et en faisant
% attention de ne pas terminer en 0000.
% Utilisé par la multiplication servant pour le calcul des puissances.|
%    \begin{macrocode}
\def\XINT_addp_A #1#2#3#4#5#6%  
{%
    \xint_gob_til_W #3\xint_addp_az\W
    \XINT_addp_AB #1{#3#4#5#6}{#2}% 
}%
\def\xint_addp_az\W\XINT_addp_AB #1#2%  
{%
    \XINT_addp_AC_checkcarry #1%
}%
\def\XINT_addp_AC_checkcarry #1%
{%
    \xint_gob_til_zero #1\xint_addp_AC_nocarry 0\XINT_addp_C 
}%
\def\xint_addp_AC_nocarry 0\XINT_addp_C 
{%
    \XINT_addp_F
}%
\def\XINT_addp_AB #1#2#3#4\W\X\Y\Z #5#6#7#8%  
{%
    \XINT_addp_ABE #1#2{#8#7#6#5}{#3}#4\W\X\Y\Z 
}%
\def\XINT_addp_ABE #1#2#3#4#5#6%
{%
    \expandafter\XINT_addp_ABEA\the\numexpr #1+10#5#4#3#2+#6\relax
}%
\def\XINT_addp_ABEA #1#2#3#4#5#6#7%  
{% 
   \XINT_addp_A  #2{#7#6#5#4#3}%<-- attention on met donc \`a droite
}%
\def\XINT_addp_C #1#2#3#4#5%  
{%
    \xint_gob_til_W 
    #5\xint_addp_cw
    #4\xint_addp_cx 
    #3\xint_addp_cy 
    #2\xint_addp_cz 
    \W\XINT_addp_CD   {#5#4#3#2}{#1}%
}%
\def\XINT_addp_CD #1%
{%
    \expandafter\XINT_addp_CC\the\numexpr 1+10#1\relax
}%
\def\XINT_addp_CC #1#2#3#4#5#6#7%
{%
    \XINT_addp_AC_checkcarry  #2{#7#6#5#4#3}%
}%
\def\xint_addp_cw 
    #1\xint_addp_cx
    #2\xint_addp_cy
    #3\xint_addp_cz
    \W\XINT_addp_CD 
{%
    \expandafter\XINT_addp_CDw\the\numexpr \xint_c_i+10#1#2#3\relax
}%
\def\XINT_addp_CDw #1#2#3#4#5#6%  
{%
    \xint_gob_til_zeros_iv #2#3#4#5\XINT_addp_endDw_zeros 
                          0000\XINT_addp_endDw #2#3#4#5%
}%
\def\XINT_addp_endDw_zeros 0000\XINT_addp_endDw 0000#1\X\Y\Z{ #1}%
\def\XINT_addp_endDw #1#2#3#4#5\X\Y\Z{ #5#4#3#2#1}%
\def\xint_addp_cx 
    #1\xint_addp_cy
    #2\xint_addp_cz
    \W\XINT_addp_CD 
{%
    \expandafter\XINT_addp_CDx\the\numexpr \xint_c_i+100#1#2\relax
}%
\def\XINT_addp_CDx #1#2#3#4#5#6%  
{%
    \xint_gob_til_zeros_iv #2#3#4#5\XINT_addp_endDx_zeros
                          0000\XINT_addp_endDx #2#3#4#5%
}%
\def\XINT_addp_endDx_zeros 0000\XINT_addp_endDx 0000#1\Y\Z{ #1}%
\def\XINT_addp_endDx #1#2#3#4#5\Y\Z{ #5#4#3#2#1}%
\def\xint_addp_cy #1\xint_addp_cz\W\XINT_addp_CD 
{%
    \expandafter\XINT_addp_CDy\the\numexpr \xint_c_i+1000#1\relax
}%
\def\XINT_addp_CDy #1#2#3#4#5#6%  
{%
    \xint_gob_til_zeros_iv #2#3#4#5\XINT_addp_endDy_zeros
                          0000\XINT_addp_endDy #2#3#4#5%
}%
\def\XINT_addp_endDy_zeros 0000\XINT_addp_endDy 0000#1\Z{ #1}%
\def\XINT_addp_endDy #1#2#3#4#5\Z{ #5#4#3#2#1}%
\def\xint_addp_cz\W\XINT_addp_CD #1#2{ #21000}%
\def\XINT_addp_F #1#2#3#4#5%  
{%
    \xint_gob_til_W 
    #5\xint_addp_Gw
    #4\xint_addp_Gx 
    #3\xint_addp_Gy 
    #2\xint_addp_Gz 
    \W\XINT_addp_G   {#2#3#4#5}{#1}%
}%
\def\XINT_addp_G #1#2%
{%
    \XINT_addp_F {#2#1}%
}%
\def\xint_addp_Gw 
    #1\xint_addp_Gx
    #2\xint_addp_Gy
    #3\xint_addp_Gz
    \W\XINT_addp_G #4%
{%
    \xint_gob_til_zeros_iv  #3#2#10\XINT_addp_endGw_zeros 
                          0000\XINT_addp_endGw #3#2#10%
}%
\def\XINT_addp_endGw_zeros 0000\XINT_addp_endGw 0000#1\X\Y\Z{ #1}%
\def\XINT_addp_endGw #1#2#3#4#5\X\Y\Z{ #5#1#2#3#4}%
\def\xint_addp_Gx
    #1\xint_addp_Gy
    #2\xint_addp_Gz
    \W\XINT_addp_G #3%
{%
    \xint_gob_til_zeros_iv  #2#100\XINT_addp_endGx_zeros 
                         0000\XINT_addp_endGx #2#100%
}%
\def\XINT_addp_endGx_zeros 0000\XINT_addp_endGx 0000#1\Y\Z{ #1}%
\def\XINT_addp_endGx #1#2#3#4#5\Y\Z{ #5#1#2#3#4}%
\def\xint_addp_Gy
    #1\xint_addp_Gz
    \W\XINT_addp_G #2%
{%
    \xint_gob_til_zeros_iv   #1000\XINT_addp_endGy_zeros 
                         0000\XINT_addp_endGy #1000%
}%
\def\XINT_addp_endGy_zeros 0000\XINT_addp_endGy 0000#1\Z{ #1}%
\def\XINT_addp_endGy #1#2#3#4#5\Z{ #5#1#2#3#4}%
\def\xint_addp_Gz\W\XINT_addp_G #1#2{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintAdd}}
%    \begin{macrocode}
\def\xintiAdd {\romannumeral0\xintiadd }%
\def\xintiadd #1%
{%
    \expandafter\xint_add\expandafter{\romannumeral-`0#1}%
}%
\let\xintAdd\xintiAdd \let\xintadd\xintiadd
\def\xint_add #1#2%
{%
    \expandafter\XINT_add_fork \romannumeral-`0#2\Z #1\Z 
}%
\def\XINT_Add #1#2{\romannumeral0\XINT_add_fork #2\Z #1\Z }%
\def\XINT_add #1#2{\XINT_add_fork #2\Z #1\Z }%
%    \end{macrocode}
% \lverb|ADDITION 
% Ici #1#2 vient du *deuxième* argument de \xintAdd et  #3#4 donc du *premier*
% [algo plus efficace lorsque le premier est plus long que le second]|
%    \begin{macrocode}
\def\XINT_add_fork #1#2\Z #3#4\Z
{%
    \xint_UDzerofork
      #1\dummy \XINT_add_secondiszero
      #3\dummy \XINT_add_firstiszero
       0\dummy 
        {\xint_UDsignsfork
          #1#3\dummy \XINT_add_minusminus          % #1 = #3 = -
           #1-\dummy \XINT_add_minusplus           % #1 = -
           #3-\dummy \XINT_add_plusminus           % #3 = -
            --\dummy \XINT_add_plusplus
         \krof }%
    \krof
    {#2}{#4}#1#3%
}%
\def\XINT_add_secondiszero #1#2#3#4{ #4#2}%
\def\XINT_add_firstiszero #1#2#3#4{ #3#1}%
%    \end{macrocode}
% \lverb|#1 vient du *deuxième* et #2 vient du *premier*|
%    \begin{macrocode}
\def\XINT_add_minusminus #1#2#3#4%
{%
    \expandafter\xint_minus_andstop%
    \romannumeral0\XINT_add_pre {#2}{#1}%
}%
\def\XINT_add_minusplus #1#2#3#4%
{%
    \XINT_sub_pre {#4#2}{#1}%
}%
\def\XINT_add_plusminus #1#2#3#4%
{%
    \XINT_sub_pre {#3#1}{#2}%
}%
\def\XINT_add_plusplus #1#2#3#4%
{%
    \XINT_add_pre {#4#2}{#3#1}%
}%
\def\XINT_add_pre #1%
{%
  \expandafter\XINT_add_pre_b\expandafter
  {\romannumeral0\XINT_RQ {}#1\R\R\R\R\R\R\R\R\Z }%
}%
\def\XINT_add_pre_b #1#2%
{% 
    \expandafter\XINT_add_A
        \expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT_RQ {}#2\R\R\R\R\R\R\R\R\Z
        \W\X\Y\Z #1\W\X\Y\Z
}%
%    \end{macrocode}
% \subsection{\csh{xintSub}}
%    \begin{macrocode}
\def\xintiSub {\romannumeral0\xintisub }%
\def\xintisub #1%
{%
    \expandafter\xint_sub\expandafter{\romannumeral-`0#1}%
}%
\let\xintSub\xintiSub \let\xintsub\xintisub
\def\xint_sub #1#2%
{%
    \expandafter\XINT_sub_fork \romannumeral-`0#2\Z #1\Z 
}%
\def\XINT_Sub #1#2{\romannumeral0\XINT_sub_fork #2\Z #1\Z }%
\def\XINT_sub #1#2{\XINT_sub_fork #2\Z #1\Z }%
%    \end{macrocode}
% \lverb|&
% SOUSTRACTION
% #3#4-#1#2:
% #3#4 vient du *premier*
% #1#2 vient du *second*|
%    \begin{macrocode}
\def\XINT_sub_fork #1#2\Z #3#4\Z
{%
    \xint_UDsignsfork
          #1#3\dummy \XINT_sub_minusminus
           #1-\dummy \XINT_sub_minusplus   % attention, #3=0 possible
           #3-\dummy \XINT_sub_plusminus   % attention, #1=0 possible
            --\dummy {\xint_UDzerofork
                      #1\dummy \XINT_sub_secondiszero
                      #3\dummy \XINT_sub_firstiszero
                       0\dummy \XINT_sub_plusplus
                      \krof }%
    \krof
    {#2}{#4}#1#3%
}%
\def\XINT_sub_secondiszero #1#2#3#4{ #4#2}%
\def\XINT_sub_firstiszero  #1#2#3#4{ -#3#1}%
\def\XINT_sub_plusplus #1#2#3#4%
{%
    \XINT_sub_pre {#4#2}{#3#1}%
}%
\def\XINT_sub_minusminus #1#2#3#4%
{%
    \XINT_sub_pre {#1}{#2}%
}%
\def\XINT_sub_minusplus #1#2#3#4% 
{%
    \xint_gob_til_zero #4\xint_sub_mp0\XINT_add_pre {#4#2}{#1}%
}%
\def\xint_sub_mp0\XINT_add_pre #1#2{ #2}%
\def\XINT_sub_plusminus #1#2#3#4% 
{%
    \xint_gob_til_zero #3\xint_sub_pm0\expandafter\xint_minus_andstop%
    \romannumeral0\XINT_add_pre {#2}{#3#1}%
}%
\def\xint_sub_pm #1\XINT_add_pre #2#3{ -#2}%
\def\XINT_sub_pre #1%
{%
  \expandafter\XINT_sub_pre_b\expandafter
  {\romannumeral0\XINT_RQ {}#1\R\R\R\R\R\R\R\R\Z }%
}%
\def\XINT_sub_pre_b #1#2%
{% 
    \expandafter\XINT_sub_A
        \expandafter1\expandafter{\expandafter}%
    \romannumeral0\XINT_RQ {}#2\R\R\R\R\R\R\R\R\Z
        \W\X\Y\Z #1 \W\X\Y\Z
}%
%    \end{macrocode}
% \lverb|&
% \romannumeral0\XINT_sub_A 1{}<N1>\W\X\Y\Z<N2>\W\X\Y\Z$\
% N1 et N2 sont présentés à l'envers ET ON A RAJOUTÉ DES ZÉROS
% POUR QUE LEURS LONGUEURS À CHACUN SOIENT MULTIPLES DE 4, MAIS
% AUCUN NE SE TERMINE EN 0000.$\ output: N2 - N1$\
% Elle donne le résultat dans le **bon ordre**, avec le bon signe,
% et sans zéros superflus.|
%    \begin{macrocode}
\def\XINT_sub_A #1#2#3\W\X\Y\Z #4#5#6#7%  
{%
    \xint_gob_til_W 
    #4\xint_sub_az 
    \W\XINT_sub_B #1{#4#5#6#7}{#2}#3\W\X\Y\Z 
}%
\def\XINT_sub_B #1#2#3#4#5#6#7%  
{%
    \xint_gob_til_W 
    #4\xint_sub_bz 
    \W\XINT_sub_onestep #1#2{#7#6#5#4}{#3}%
}%
%    \end{macrocode}
% \lverb|&
% d'abord la branche principale
% #6 = 4 chiffres de N1, plus significatif en *premier*, 
% #2#3#4#5 chiffres de N2, plus significatif en *dernier*
% On veut N2 - N1.|
%    \begin{macrocode}
\def\XINT_sub_onestep #1#2#3#4#5#6%
{%
    \expandafter\XINT_sub_backtoA\the\numexpr 11#5#4#3#2-#6+#1-\xint_c_i\relax.%
}%
%    \end{macrocode}
% \lverb|ON PRODUIT LE RÉSULTAT DANS LE BON ORDRE|
%    \begin{macrocode}
\def\XINT_sub_backtoA #1#2#3.#4%
{%
    \XINT_sub_A #2{#3#4}%
}%
\def\xint_sub_bz 
    \W\XINT_sub_onestep #1#2#3#4#5#6#7%
{%
    \xint_UDzerofork
      #1\dummy  \XINT_sub_C   % une retenue
       0\dummy  \XINT_sub_D   % pas de retenue
    \krof
    {#7}#2#3#4#5%
}%
\def\XINT_sub_D #1#2\W\X\Y\Z
{%
    \expandafter
    \xint_cleanupzeros_andstop
    \romannumeral0%
    \XINT_rord_main {}#2%
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax
    #1%
}%
\def\XINT_sub_C #1#2#3#4#5%
{%
    \xint_gob_til_W 
    #2\xint_sub_cz 
    \W\XINT_sub_AC_onestep {#5#4#3#2}{#1}%
}%
\def\XINT_sub_AC_onestep #1%
{%
    \expandafter\XINT_sub_backtoC\the\numexpr 11#1-\xint_c_i\relax.%
}%
\def\XINT_sub_backtoC #1#2#3.#4%
{%
    \XINT_sub_AC_checkcarry #2{#3#4}% la retenue va \^etre examin\'ee
}%
\def\XINT_sub_AC_checkcarry #1%
{%
    \xint_gob_til_one #1\xint_sub_AC_nocarry 1\XINT_sub_C 
}%
\def\xint_sub_AC_nocarry 1\XINT_sub_C #1#2\W\X\Y\Z
{%
    \expandafter
    \XINT_cuz_loop
    \romannumeral0%
    \XINT_rord_main {}#2%
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax
    #1\W\W\W\W\W\W\W\Z
}%
\def\xint_sub_cz\W\XINT_sub_AC_onestep #1%
{%
    \XINT_cuz
}%
\def\xint_sub_az\W\XINT_sub_B #1#2#3#4#5#6#7%  
{%
    \xint_gob_til_W 
    #4\xint_sub_ez 
    \W\XINT_sub_Eenter #1{#3}#4#5#6#7%
}%
%    \end{macrocode}
% \lverb|le premier nombre continue, le résultat sera < 0.|
%    \begin{macrocode}
\def\XINT_sub_Eenter #1#2%
{%
    \expandafter
    \XINT_sub_E\expandafter1\expandafter{\expandafter}%
    \romannumeral0%
    \XINT_rord_main {}#2%
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax
    \W\X\Y\Z #1%
}%
\def\XINT_sub_E #1#2#3#4#5#6%
{%
    \xint_gob_til_W #3\xint_sub_F\W
    \XINT_sub_Eonestep #1{#6#5#4#3}{#2}%
}%
\def\XINT_sub_Eonestep #1#2%
{%
    \expandafter\XINT_sub_backtoE\the\numexpr 109999-#2+#1\relax.%
}%
\def\XINT_sub_backtoE #1#2#3.#4%
{%
    \XINT_sub_E #2{#3#4}%
}%
\def\xint_sub_F\W\XINT_sub_Eonestep #1#2#3#4%
{%
    \xint_UDonezerofork
      #4#1\dummy {\XINT_sub_Fdec 0}% soustraire  1. Et faire signe -
      #1#4\dummy {\XINT_sub_Finc 1}% additionner 1. Et faire signe -
        10\dummy  \XINT_sub_DD     % terminer. Mais avec signe -
    \krof
    {#3}%
}%
\def\XINT_sub_DD {\expandafter\xint_minus_andstop\romannumeral0\XINT_sub_D }%
\def\XINT_sub_Fdec #1#2#3#4#5#6%
{%
    \xint_gob_til_W #3\xint_sub_Fdec_finish\W
    \XINT_sub_Fdec_onestep #1{#6#5#4#3}{#2}%
}%
\def\XINT_sub_Fdec_onestep #1#2%
{%
    \expandafter\XINT_sub_backtoFdec\the\numexpr 11#2+#1-\xint_c_i\relax.%
}%
\def\XINT_sub_backtoFdec #1#2#3.#4%
{%
    \XINT_sub_Fdec #2{#3#4}%
}%
\def\xint_sub_Fdec_finish\W\XINT_sub_Fdec_onestep #1#2%
{%
    \expandafter\xint_minus_andstop\romannumeral0\XINT_cuz
}%
\def\XINT_sub_Finc #1#2#3#4#5#6%
{%
    \xint_gob_til_W #3\xint_sub_Finc_finish\W
    \XINT_sub_Finc_onestep #1{#6#5#4#3}{#2}%
}%
\def\XINT_sub_Finc_onestep #1#2%
{%
    \expandafter\XINT_sub_backtoFinc\the\numexpr 10#2+#1\relax.%
}%
\def\XINT_sub_backtoFinc #1#2#3.#4%
{%
    \XINT_sub_Finc #2{#3#4}%
}%
\def\xint_sub_Finc_finish\W\XINT_sub_Finc_onestep #1#2#3%
{%
    \xint_UDzerofork
     #1\dummy {\expandafter\xint_minus_andstop\xint_cleanupzeros_nospace}%
      0\dummy { -1}%
    \krof
    #3%
}%
\def\xint_sub_ez\W\XINT_sub_Eenter #1%
{%
    \xint_UDzerofork
      #1\dummy \XINT_sub_K % il y a une retenue
       0\dummy \XINT_sub_L % pas de retenue
    \krof
}%
\def\XINT_sub_L #1\W\X\Y\Z {\XINT_cuz_loop #1\W\W\W\W\W\W\W\Z }%
\def\XINT_sub_K #1%
{%
    \expandafter
    \XINT_sub_KK\expandafter1\expandafter{\expandafter}%
    \romannumeral0%
    \XINT_rord_main {}#1%
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax
}%
\def\XINT_sub_KK #1#2#3#4#5#6%
{%
    \xint_gob_til_W #3\xint_sub_KK_finish\W
    \XINT_sub_KK_onestep #1{#6#5#4#3}{#2}%
}%
\def\XINT_sub_KK_onestep #1#2%
{%
    \expandafter\XINT_sub_backtoKK\the\numexpr 109999-#2+#1\relax.%
}%
\def\XINT_sub_backtoKK #1#2#3.#4%
{%
    \XINT_sub_KK #2{#3#4}%
}%
\def\xint_sub_KK_finish\W\XINT_sub_KK_onestep #1#2#3%
{%
    \expandafter\xint_minus_andstop
    \romannumeral0\XINT_cuz_loop #3\W\W\W\W\W\W\W\Z
}%
%    \end{macrocode}
% \subsection{\csh{xintCmp}}
%    \begin{macrocode}
\def\xintiCmp {\romannumeral0\xinticmp }%
\def\xinticmp #1%
{%
    \expandafter\xint_cmp\expandafter{\romannumeral-`0#1}%
}%
\let\xintCmp\xintiCmp \let\xintcmp\xinticmp
\def\xint_cmp #1#2%
{%
    \expandafter\XINT_cmp_fork \romannumeral-`0#2\Z #1\Z 
}%
\def\XINT_Cmp #1#2{\romannumeral0\XINT_cmp_fork #2\Z #1\Z }%
%    \end{macrocode}
% \lverb|&
% COMPARAISON $\
% 1 si #3#4>#1#2, 0 si #3#4=#1#2, -1 si #3#4<#1#2$\
% #3#4 vient du *premier*,$ 
% #1#2 vient du *second*|
%    \begin{macrocode}
\def\XINT_cmp_fork #1#2\Z #3#4\Z
{%
    \xint_UDsignsfork
          #1#3\dummy \XINT_cmp_minusminus
           #1-\dummy \XINT_cmp_minusplus   
           #3-\dummy \XINT_cmp_plusminus   
            --\dummy {\xint_UDzerosfork
                      #1#3\dummy \XINT_cmp_zerozero
                       #10\dummy \XINT_cmp_zeroplus
                       #30\dummy \XINT_cmp_pluszero
                        00\dummy \XINT_cmp_plusplus
                      \krof }%
    \krof
    {#2}{#4}#1#3%
}%
\def\XINT_cmp_minusplus #1#2#3#4{ 1}%
\def\XINT_cmp_plusminus #1#2#3#4{ -1}%
\def\XINT_cmp_zerozero  #1#2#3#4{ 0}%
\def\XINT_cmp_zeroplus  #1#2#3#4{ 1}%
\def\XINT_cmp_pluszero  #1#2#3#4{ -1}%
\def\XINT_cmp_plusplus #1#2#3#4%
{%
    \XINT_cmp_pre {#4#2}{#3#1}%
}%
\def\XINT_cmp_minusminus #1#2#3#4%
{%
    \XINT_cmp_pre {#1}{#2}%
}%
\def\XINT_cmp_pre #1%
{%
  \expandafter\XINT_cmp_pre_b\expandafter
  {\romannumeral0\XINT_RQ {}#1\R\R\R\R\R\R\R\R\Z }%
}%
\def\XINT_cmp_pre_b #1#2%
{% 
    \expandafter\XINT_cmp_A
    \expandafter1\expandafter{\expandafter}%
    \romannumeral0\XINT_RQ {}#2\R\R\R\R\R\R\R\R\Z
        \W\X\Y\Z #1\W\X\Y\Z
}%
%    \end{macrocode}
% \lverb|&
% COMPARAISON$\
% N1 et N2 sont présentés à l'envers ET ON A RAJOUTÉ DES ZÉROS
% POUR QUE LEUR LONGUEURS À CHACUN SOIENT MULTIPLES DE 4, MAIS
% AUCUN NE SE TERMINE EN 0000.
% routine appelée via$\ 
% \XINT_cmp_A 1{}<N1>\W\X\Y\Z<N2>\W\X\Y\Z$\
% ATTENTION RENVOIE 1 SI N1 < N2, 0 si N1 = N2, -1 si N1 > N2|
%    \begin{macrocode}
\def\XINT_cmp_A #1#2#3\W\X\Y\Z #4#5#6#7%  
{%
    \xint_gob_til_W #4\xint_cmp_az\W
    \XINT_cmp_B #1{#4#5#6#7}{#2}#3\W\X\Y\Z 
}%
\def\XINT_cmp_B #1#2#3#4#5#6#7%  
{%
    \xint_gob_til_W#4\xint_cmp_bz\W
    \XINT_cmp_onestep #1#2{#7#6#5#4}{#3}%
}%
\def\XINT_cmp_onestep #1#2#3#4#5#6%
{%
    \expandafter\XINT_cmp_backtoA\the\numexpr 11#5#4#3#2-#6+#1-\xint_c_i\relax.%
}%
\def\XINT_cmp_backtoA #1#2#3.#4%
{%
    \XINT_cmp_A #2{#3#4}%
}%
\def\xint_cmp_bz\W\XINT_cmp_onestep #1\Z { 1}%
\def\xint_cmp_az\W\XINT_cmp_B #1#2#3#4#5#6#7%  
{%
    \xint_gob_til_W #4\xint_cmp_ez\W
    \XINT_cmp_Eenter #1{#3}#4#5#6#7%
}%
\def\XINT_cmp_Eenter #1\Z { -1}%
\def\xint_cmp_ez\W\XINT_cmp_Eenter #1%
{%
    \xint_UDzerofork
      #1\dummy \XINT_cmp_K             %     il y a une retenue
       0\dummy \XINT_cmp_L             %     pas de retenue
    \krof
}%
\def\XINT_cmp_K #1\Z { -1}%
\def\XINT_cmp_L #1{\XINT_OneIfPositive_main #1}%
\def\XINT_OneIfPositive #1%
{%
    \XINT_OneIfPositive_main #1\W\X\Y\Z%
}%
\def\XINT_OneIfPositive_main #1#2#3#4%
{%
    \xint_gob_til_Z #4\xint_OneIfPositive_terminated\Z
    \XINT_OneIfPositive_onestep #1#2#3#4%
}%
\def\xint_OneIfPositive_terminated\Z\XINT_OneIfPositive_onestep\W\X\Y\Z { 0}%
\def\XINT_OneIfPositive_onestep #1#2#3#4%
{%
    \expandafter\XINT_OneIfPositive_check\the\numexpr #1#2#3#4\relax
}%
\def\XINT_OneIfPositive_check #1%
{%
    \xint_gob_til_zero #1\xint_OneIfPositive_backtomain 0%
    \XINT_OneIfPositive_finish #1%
}%
\def\XINT_OneIfPositive_finish #1\W\X\Y\Z{ 1}%
\def\xint_OneIfPositive_backtomain 0\XINT_OneIfPositive_finish 0%
                   {\XINT_OneIfPositive_main }%
%    \end{macrocode}
% \subsection{\csh{xintGeq}}
% \lverb|&
% PLUS GRAND OU ÉGAL
% attention compare les **valeurs absolues**|
%    \begin{macrocode}
\def\xintiGeq {\romannumeral0\xintigeq }%
\def\xintigeq #1%
{%
    \expandafter\xint_geq\expandafter {\romannumeral-`0#1}%
}%
\let\xintGeq\xintiGeq \let\xintgeq\xintigeq
\def\xint_geq #1#2%
{%
    \expandafter\XINT_geq_fork \romannumeral-`0#2\Z #1\Z 
}%
\def\XINT_Geq #1#2{\romannumeral0\XINT_geq_fork #2\Z #1\Z }%
%    \end{macrocode}
% \lverb|&
% PLUS GRAND OU ÉGAL 
% ATTENTION, TESTE les VALEURS ABSOLUES|
%    \begin{macrocode}
\def\XINT_geq_fork #1#2\Z #3#4\Z
{%
    \xint_UDzerofork
      #1\dummy \XINT_geq_secondiszero % |#1#2|=0
      #3\dummy \XINT_geq_firstiszero % |#1#2|>0
       0\dummy {\xint_UDsignsfork
                  #1#3\dummy \XINT_geq_minusminus
                   #1-\dummy \XINT_geq_minusplus   
                   #3-\dummy \XINT_geq_plusminus
                    --\dummy \XINT_geq_plusplus
                \krof }%
    \krof
    {#2}{#4}#1#3%
}%
\def\XINT_geq_secondiszero     #1#2#3#4{ 1}%
\def\XINT_geq_firstiszero      #1#2#3#4{ 0}%
\def\XINT_geq_plusplus   #1#2#3#4{\XINT_geq_pre {#4#2}{#3#1}}%
\def\XINT_geq_minusminus #1#2#3#4{\XINT_geq_pre {#2}{#1}}%
\def\XINT_geq_minusplus  #1#2#3#4{\XINT_geq_pre {#4#2}{#1}}%
\def\XINT_geq_plusminus  #1#2#3#4{\XINT_geq_pre {#2}{#3#1}}%
\def\XINT_geq_pre #1%
{%
  \expandafter\XINT_geq_pre_b\expandafter
  {\romannumeral0\XINT_RQ {}#1\R\R\R\R\R\R\R\R\Z }%
}%
\def\XINT_geq_pre_b #1#2%
{% 
    \expandafter\XINT_geq_A
    \expandafter1\expandafter{\expandafter}%
    \romannumeral0\XINT_RQ {}#2\R\R\R\R\R\R\R\R\Z
        \W\X\Y\Z #1 \W\X\Y\Z
}%
%    \end{macrocode}
% \lverb|&
% PLUS GRAND OU ÉGAL$\
% N1 et N2 sont présentés à l'envers ET ON A RAJOUTÉ DES ZÉROS
% POUR QUE LEURS LONGUEURS À CHACUN SOIENT MULTIPLES DE 4, MAIS
% AUCUN NE SE TERMINE EN 0000$\
% routine appelée via$\ 
% \romannumeral0\XINT_geq_A 1{}<N1>\W\X\Y\Z<N2>\W\X\Y\Z$\
% ATTENTION RENVOIE 1 SI N1 < N2 ou N1 = N2 et 0 si N1 > N2|
%    \begin{macrocode}
\def\XINT_geq_A #1#2#3\W\X\Y\Z #4#5#6#7%  
{%
    \xint_gob_til_W #4\xint_geq_az\W
    \XINT_geq_B #1{#4#5#6#7}{#2}#3\W\X\Y\Z 
}%
\def\XINT_geq_B #1#2#3#4#5#6#7%  
{%
    \xint_gob_til_W #4\xint_geq_bz\W
    \XINT_geq_onestep #1#2{#7#6#5#4}{#3}%
}%
\def\XINT_geq_onestep #1#2#3#4#5#6%
{%
    \expandafter\XINT_geq_backtoA\the\numexpr 11#5#4#3#2-#6+#1-\xint_c_i\relax.%
}%
\def\XINT_geq_backtoA #1#2#3.#4%
{%
    \XINT_geq_A #2{#3#4}%
}%
\def\xint_geq_bz\W\XINT_geq_onestep #1\W\X\Y\Z { 1}%
\def\xint_geq_az\W\XINT_geq_B #1#2#3#4#5#6#7%  
{%
    \xint_gob_til_W #4\xint_geq_ez\W
    \XINT_geq_Eenter #1%
}%
\def\XINT_geq_Eenter #1\W\X\Y\Z { 0}%
\def\xint_geq_ez\W\XINT_geq_Eenter #1%
{%
    \xint_UDzerofork
      #1\dummy { 0}             %     il y a une retenue
       0\dummy { 1}             %     pas de retenue
    \krof
}%
%    \end{macrocode}
% \subsection{\csh{xintMax}}
% \lverb|&
% The rationale is that it is more efficient than using \xintCmp.
% 1.03 makes the code a tiny bit slower but easier to re-use for fractions.
% Note: actually since 1.08a code for fractions does not all reduce to these
% entry points, so perhaps I should revert the changes made in 1.03.|
%    \begin{macrocode}
\def\xintiMax {\romannumeral0\xintimax }%
\def\xintimax #1%
{%
    \expandafter\xint_max\expandafter {\romannumeral-`0#1}%
}%
\let\xintMax\xintiMax \let\xintmax\xintimax
\def\xint_max #1#2%
{%
    \expandafter\XINT_max_pre\expandafter {\romannumeral-`0#2}{#1}%
}%
\def\XINT_max_pre #1#2{\XINT_max_fork #1\Z #2\Z {#2}{#1}}%
\def\XINT_Max #1#2{\romannumeral0\XINT_max_fork #2\Z #1\Z {#1}{#2}}%
%    \end{macrocode}
% \lverb|&
% #3#4 vient du *premier*,
% #1#2 vient du *second*|
%    \begin{macrocode}
\def\XINT_max_fork #1#2\Z #3#4\Z
{%
    \xint_UDsignsfork
          #1#3\dummy \XINT_max_minusminus  % A < 0, B < 0
           #1-\dummy \XINT_max_minusplus   % B < 0, A >= 0   
           #3-\dummy \XINT_max_plusminus   % A < 0, B >= 0 
            --\dummy {\xint_UDzerosfork
                      #1#3\dummy \XINT_max_zerozero % A = B = 0
                       #10\dummy \XINT_max_zeroplus % B = 0, A > 0
                       #30\dummy \XINT_max_pluszero % A = 0, B > 0
                        00\dummy \XINT_max_plusplus % A, B > 0
                      \krof }%
    \krof
    {#2}{#4}#1#3%
}%
%    \end{macrocode}
% \lverb|&
% A = #4#2, B = #3#1|
%    \begin{macrocode}
\def\XINT_max_zerozero  #1#2#3#4{\xint_firstoftwo_andstop }%
\def\XINT_max_zeroplus  #1#2#3#4{\xint_firstoftwo_andstop }%
\def\XINT_max_pluszero  #1#2#3#4{\xint_secondoftwo_andstop }%
\def\XINT_max_minusplus #1#2#3#4{\xint_firstoftwo_andstop }%
\def\XINT_max_plusminus #1#2#3#4{\xint_secondoftwo_andstop }%
\def\XINT_max_plusplus  #1#2#3#4%
{%
    \ifodd\XINT_Geq {#4#2}{#3#1}
      \expandafter\xint_firstoftwo_andstop
    \else
      \expandafter\xint_secondoftwo_andstop
    \fi
}%
%    \end{macrocode}
% \lverb+#3=-, #4=-, #1 = |B| = -B, #2 = |A| = -A+
%    \begin{macrocode}
\def\XINT_max_minusminus #1#2#3#4%
{%
    \ifodd\XINT_Geq {#1}{#2}
      \expandafter\xint_firstoftwo_andstop
    \else
      \expandafter\xint_secondoftwo_andstop
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintMin}}
%    \begin{macrocode}
\def\xintiMin {\romannumeral0\xintimin }%
\def\xintimin #1%
{%
    \expandafter\xint_min\expandafter {\romannumeral-`0#1}%
}%
\let\xintMin\xintiMin \let\xintmin\xintimin
\def\xint_min #1#2%
{%
    \expandafter\XINT_min_pre\expandafter {\romannumeral-`0#2}{#1}%
}%
\def\XINT_min_pre #1#2{\XINT_min_fork #1\Z #2\Z {#2}{#1}}%
\def\XINT_Min #1#2{\romannumeral0\XINT_min_fork #2\Z #1\Z {#1}{#2}}%
%    \end{macrocode}
% \lverb|&
% #3#4 vient du *premier*,
% #1#2 vient du *second*|
%    \begin{macrocode}
\def\XINT_min_fork #1#2\Z #3#4\Z
{%
    \xint_UDsignsfork
          #1#3\dummy \XINT_min_minusminus  % A < 0, B < 0
           #1-\dummy \XINT_min_minusplus   % B < 0, A >= 0   
           #3-\dummy \XINT_min_plusminus   % A < 0, B >= 0 
            --\dummy {\xint_UDzerosfork
                      #1#3\dummy \XINT_min_zerozero % A = B = 0
                       #10\dummy \XINT_min_zeroplus % B = 0, A > 0
                       #30\dummy \XINT_min_pluszero % A = 0, B > 0
                        00\dummy \XINT_min_plusplus % A, B > 0
                      \krof }%
    \krof
    {#2}{#4}#1#3%
}%
%    \end{macrocode}
% \lverb|&
% A = #4#2, B = #3#1|
%    \begin{macrocode}
\def\XINT_min_zerozero  #1#2#3#4{\xint_firstoftwo_andstop }%
\def\XINT_min_zeroplus  #1#2#3#4{\xint_secondoftwo_andstop }%
\def\XINT_min_pluszero  #1#2#3#4{\xint_firstoftwo_andstop }%
\def\XINT_min_minusplus #1#2#3#4{\xint_secondoftwo_andstop }%
\def\XINT_min_plusminus #1#2#3#4{\xint_firstoftwo_andstop }%
\def\XINT_min_plusplus  #1#2#3#4%
{%
    \ifodd\XINT_Geq {#4#2}{#3#1}
      \expandafter\xint_secondoftwo_andstop
    \else
      \expandafter\xint_firstoftwo_andstop
    \fi
}%
%    \end{macrocode}
% \lverb+#3=-, #4=-, #1 = |B| = -B, #2 = |A| = -A+
%    \begin{macrocode}
\def\XINT_min_minusminus #1#2#3#4%
{%
    \ifodd\XINT_Geq {#1}{#2}
      \expandafter\xint_secondoftwo_andstop
    \else
      \expandafter\xint_firstoftwo_andstop
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintSum}, \csh{xintSumExpr}}
% \lverb|&
% \xintSum {{a}{b}...{z}}$\
% \xintSumExpr {a}{b}...{z}\relax$\
% 1.03 (drastically) simplifies and makes the routines more efficient (for big
% computations). Also the way \xintSum and \xintSumExpr ...\relax are related.
% has been modified. Now \xintSumExpr \z \relax is accepted input when
% \z expands to a list of braced terms (prior only \xintSum {\z} or \xintSum \z
% was possible).  |
%    \begin{macrocode}
\def\xintiSum {\romannumeral0\xintisum }%
\def\xintisum #1{\xintisumexpr #1\relax }%
\def\xintiSumExpr {\romannumeral0\xintisumexpr }%
\def\xintisumexpr {\expandafter\XINT_sumexpr\romannumeral-`0}%
\let\xintSum\xintiSum \let\xintsum\xintisum 
\let\xintSumExpr\xintiSumExpr \let\xintsumexpr\xintisumexpr
\def\XINT_sumexpr {\XINT_sum_loop {0000}{0000}}%
\def\XINT_sum_loop #1#2#3%
{%
    \expandafter\XINT_sum_checksign\romannumeral-`0#3\Z {#1}{#2}%
}%
\def\XINT_sum_checksign #1%
{%
    \xint_gob_til_relax #1\XINT_sum_finished\relax
    \xint_gob_til_zero #1\XINT_sum_skipzeroinput0%
    \xint_UDsignfork
      #1\dummy \XINT_sum_N
       -\dummy {\XINT_sum_P #1}%
    \krof
}%
\def\XINT_sum_finished #1\Z #2#3%
{%
    \XINT_sub_A 1{}#3\W\X\Y\Z #2\W\X\Y\Z
}%
\def\XINT_sum_skipzeroinput #1\krof #2\Z {\XINT_sum_loop }%
\def\XINT_sum_P #1\Z #2%
{%
    \expandafter\XINT_sum_loop\expandafter
    {\romannumeral0\expandafter
     \XINT_addr_A\expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT_RQ {}#1\R\R\R\R\R\R\R\R\Z
    \W\X\Y\Z #2\W\X\Y\Z }%
}%
\def\XINT_sum_N #1\Z #2#3%
{%
    \expandafter\XINT_sum_NN\expandafter
    {\romannumeral0\expandafter
     \XINT_addr_A\expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT_RQ {}#1\R\R\R\R\R\R\R\R\Z
    \W\X\Y\Z #3\W\X\Y\Z }{#2}%
}%
\def\XINT_sum_NN #1#2{\XINT_sum_loop {#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintMul}}
%    \begin{macrocode}
\def\xintiMul {\romannumeral0\xintimul }%
\def\xintimul #1%
{%
    \expandafter\xint_mul\expandafter {\romannumeral-`0#1}%
}%
\let\xintMul\xintiMul \let\xintmul\xintimul
\def\xint_mul #1#2%
{%
    \expandafter\XINT_mul_fork \romannumeral-`0#2\Z #1\Z 
}%
\def\XINT_Mul #1#2{\romannumeral0\XINT_mul_fork #2\Z #1\Z }%
%    \end{macrocode}
% \lverb|&
% MULTIPLICATION$\
% Ici #1#2 = 2e input et #3#4 = 1er input $\
% Release 1.03 adds some overhead to first compute and compare the
% lengths of the two inputs. The algorithm is asymmetrical and whether
% the first input is the longest or the shortest sometimes has a strong
% impact. 50 digits times 1000 digits used to be 5 times faster
% than 1000 digits times 50 digits. With the new code, the user input
% order does not matter as it is decided by the routine what is best.
% This is important for  the extension to fractions, as there is no way
% then to generally control or guess the most frequent sizes of the
% inputs besides actually computing their lengths.  |
%    \begin{macrocode}
\def\XINT_mul_fork #1#2\Z #3#4\Z
{%
    \xint_UDzerofork
      #1\dummy \XINT_mul_zero
      #3\dummy \XINT_mul_zero
       0\dummy 
        {\xint_UDsignsfork
          #1#3\dummy \XINT_mul_minusminus          % #1 = #3 = -
           #1-\dummy {\XINT_mul_minusplus #3}%          % #1 = -
           #3-\dummy {\XINT_mul_plusminus #1}%          % #3 = -
            --\dummy {\XINT_mul_plusplus #1#3}%
         \krof }%
    \krof
    {#2}{#4}%
}%
\def\XINT_mul_zero #1#2{ 0}%
\def\XINT_mul_minusminus #1#2%
{%
      \expandafter\XINT_mul_choice_a
      \expandafter{\romannumeral0\XINT_length {#2}}%
      {\romannumeral0\XINT_length {#1}}{#1}{#2}%
}%
\def\XINT_mul_minusplus #1#2#3%
{%
    \expandafter\xint_minus_andstop\romannumeral0\expandafter
    \XINT_mul_choice_a
    \expandafter{\romannumeral0\XINT_length {#1#3}}%
    {\romannumeral0\XINT_length {#2}}{#2}{#1#3}%
}%
\def\XINT_mul_plusminus #1#2#3%
{%
    \expandafter\xint_minus_andstop\romannumeral0\expandafter
    \XINT_mul_choice_a
    \expandafter{\romannumeral0\XINT_length {#3}}%
    {\romannumeral0\XINT_length {#1#2}}{#1#2}{#3}%
}%
\def\XINT_mul_plusplus #1#2#3#4%
{%
    \expandafter\XINT_mul_choice_a
    \expandafter{\romannumeral0\XINT_length {#2#4}}%
    {\romannumeral0\XINT_length {#1#3}}{#1#3}{#2#4}%
}%
\def\XINT_mul_choice_a #1#2%
{%
    \expandafter\XINT_mul_choice_b\expandafter{#2}{#1}%
}%
\def\XINT_mul_choice_b #1#2%
{%
    \ifnum #1<\xint_c_v
       \expandafter\XINT_mul_choice_littlebyfirst
    \else
    \ifnum #2<\xint_c_v
      \expandafter\expandafter\expandafter\XINT_mul_choice_littlebysecond
      \else
      \expandafter\expandafter\expandafter\XINT_mul_choice_compare
      \fi
    \fi      
    {#1}{#2}%
}%
\def\XINT_mul_choice_littlebyfirst #1#2#3#4%
{%
    \expandafter\XINT_mul_M
    \expandafter{\the\numexpr #3\expandafter}%
    \romannumeral0\XINT_RQ {}#4\R\R\R\R\R\R\R\R\Z \Z\Z\Z\Z
}%
\def\XINT_mul_choice_littlebysecond #1#2#3#4%
{%
    \expandafter\XINT_mul_M
    \expandafter{\the\numexpr #4\expandafter}%
    \romannumeral0\XINT_RQ {}#3\R\R\R\R\R\R\R\R\Z \Z\Z\Z\Z
}%
\def\XINT_mul_choice_compare #1#2%
{%
    \ifnum #1>#2
        \expandafter \XINT_mul_choice_i
    \else
        \expandafter \XINT_mul_choice_ii
    \fi
    {#1}{#2}%
}%
\def\XINT_mul_choice_i #1#2%
{%
   \ifnum #1<\numexpr\ifcase \numexpr (#2-\xint_c_iii)/\xint_c_iv\relax
                     \or 330\or 168\or 109\or 80\or 66\or 52\else 0\fi\relax
       \expandafter\XINT_mul_choice_same   
   \else
       \expandafter\XINT_mul_choice_permute
   \fi
}% 
\def\XINT_mul_choice_ii #1#2%
{%
   \ifnum #2<\numexpr\ifcase \numexpr (#1-\xint_c_iii)/\xint_c_iv\relax
                     \or 330\or 168\or 109\or 80\or 66\or 52\else 0\fi\relax
       \expandafter\XINT_mul_choice_permute  
   \else
       \expandafter\XINT_mul_choice_same
   \fi
}% 
\def\XINT_mul_choice_same #1#2%
{%
    \expandafter\XINT_mul_enter
    \romannumeral0\XINT_RQ {}#1\R\R\R\R\R\R\R\R\Z
    \Z\Z\Z\Z #2\W\W\W\W
}%
\def\XINT_mul_choice_permute #1#2%
{%
    \expandafter\XINT_mul_enter
    \romannumeral0\XINT_RQ {}#2\R\R\R\R\R\R\R\R\Z
    \Z\Z\Z\Z #1\W\W\W\W 
}%
%    \end{macrocode}
% \lverb|&
% Cette portion de routine d'addition se branche directement sur _addr_
% lorsque 
% le premier nombre est épuisé, ce qui est garanti arriver avant le second
% nombre. Elle produit son résultat toujours sur 4n, renversé. Ses deux inputs
% sont garantis sur 4n.|
%    \begin{macrocode}
\def\XINT_mul_Ar #1#2#3#4#5#6%  
{%
    \xint_gob_til_Z #6\xint_mul_br\Z\XINT_mul_Br #1{#6#5#4#3}{#2}% 
}%
\def\xint_mul_br\Z\XINT_mul_Br #1#2%  
{%
     \XINT_addr_AC_checkcarry #1%
}%
\def\XINT_mul_Br #1#2#3#4\W\X\Y\Z #5#6#7#8%
{%
    \expandafter\XINT_mul_ABEAr
    \the\numexpr #1+10#2+#8#7#6#5\relax.{#3}#4\W\X\Y\Z
}%
\def\XINT_mul_ABEAr #1#2#3#4#5#6.#7%
{%
    \XINT_mul_Ar #2{#7#6#5#4#3}%
}%
%    \end{macrocode}
% \lverb|&
% << Petite >> multiplication.
% mul_Mr renvoie le résultat *à l'envers*, sur *4n*$\
% \romannumeral0\XINT_mul_Mr {<n>}<N>\Z\Z\Z\Z$\
% Fait la multiplication de <N> par <n>, qui est < 10000.
% <N> est présenté *à l'envers*, sur *4n*. Lorsque <n> vaut 0, donne 0000.|
%    \begin{macrocode}
\def\XINT_mul_Mr #1%
{%
    \expandafter\XINT_mul_Mr_checkifzeroorone\expandafter{\the\numexpr #1}%
}%
\def\XINT_mul_Mr_checkifzeroorone #1%
{%
    \ifcase #1
      \expandafter\XINT_mul_Mr_zero
    \or 
      \expandafter\XINT_mul_Mr_one
    \else
      \expandafter\XINT_mul_Nr
    \fi
    {0000}{}{#1}%
}%
\def\XINT_mul_Mr_zero #1\Z\Z\Z\Z { 0000}%
\def\XINT_mul_Mr_one #1#2#3#4\Z\Z\Z\Z { #4}%
\def\XINT_mul_Nr #1#2#3#4#5#6#7%
{% 
    \xint_gob_til_Z #4\xint_mul_pr\Z\XINT_mul_Pr {#1}{#3}{#7#6#5#4}{#2}{#3}%
}%
\def\XINT_mul_Pr #1#2#3%
{%
    \expandafter\XINT_mul_Lr\the\numexpr \xint_c_x^viii+#1+#2*#3\relax 
}%
\def\XINT_mul_Lr 1#1#2#3#4#5#6#7#8#9%
{%
    \XINT_mul_Nr {#1#2#3#4}{#9#8#7#6#5}%
}%
\def\xint_mul_pr\Z\XINT_mul_Pr #1#2#3#4#5%
{%
    \xint_gob_til_zeros_iv #1\XINT_mul_Mr_end_nocarry 0000%
    \XINT_mul_Mr_end_carry #1{#4}%
}%
\def\XINT_mul_Mr_end_nocarry 0000\XINT_mul_Mr_end_carry 0000#1{ #1}%
\def\XINT_mul_Mr_end_carry #1#2#3#4#5{ #5#4#3#2#1}%
%    \end{macrocode}
% \lverb|&
% << Petite >> multiplication.
% renvoie le résultat *à l'endroit*, avec *nettoyage des leading zéros*.$\
% \romannumeral0\XINT_mul_M  {<n>}<N>\Z\Z\Z\Z$\
% Fait la multiplication de <N> par <n>, qui est < 10000.
% <N> est présenté *à l'envers*, sur *4n*. |
%    \begin{macrocode}
\def\XINT_mul_M #1%
{%
    \expandafter\XINT_mul_M_checkifzeroorone\expandafter{\the\numexpr #1}%
}%
\def\XINT_mul_M_checkifzeroorone #1%
{%
    \ifcase #1
      \expandafter\XINT_mul_M_zero
    \or 
      \expandafter\XINT_mul_M_one
    \else
      \expandafter\XINT_mul_N
    \fi
    {0000}{}{#1}%
}%
\def\XINT_mul_M_zero #1\Z\Z\Z\Z { 0}%
\def\XINT_mul_M_one #1#2#3#4\Z\Z\Z\Z 
{%
    \expandafter\xint_cleanupzeros_andstop\romannumeral0\XINT_rev{#4}%
}%
\def\XINT_mul_N #1#2#3#4#5#6#7%
{% 
    \xint_gob_til_Z #4\xint_mul_p\Z\XINT_mul_P {#1}{#3}{#7#6#5#4}{#2}{#3}%
}%
\def\XINT_mul_P #1#2#3%
{%
    \expandafter\XINT_mul_L\the\numexpr \xint_c_x^viii+#1+#2*#3\relax 
}%
\def\XINT_mul_L 1#1#2#3#4#5#6#7#8#9%
{%
    \XINT_mul_N {#1#2#3#4}{#5#6#7#8#9}%
}%
\def\xint_mul_p\Z\XINT_mul_P #1#2#3#4#5%
{%
    \XINT_mul_M_end #1#4%
}%
\def\XINT_mul_M_end #1#2#3#4#5#6#7#8%
{%
    \expandafter\space\the\numexpr #1#2#3#4#5#6#7#8\relax
}%
%    \end{macrocode}
% \lverb|&
% Routine de multiplication principale
% (attention délimiteurs modifiés pour 1.08)$\
% Le résultat partiel est toujours maintenu avec significatif à
% droite et il a un nombre multiple de 4 de chiffres$\
% \romannumeral0\XINT_mul_enter <N1>\Z\Z\Z\Z <N2>\W\W\W\W$\
% avec <N1> *renversé*, *longueur 4n* (zéros éventuellement ajoutés
% au-delà du chiffre le plus significatif)
% et <N2> dans l'ordre *normal*, et pas forcément longueur 4n.
% pas de signes.$\
% Pour 1.08: dans \XINT_mul_enter et les modifs de 1.03
% qui filtrent les courts, on pourrait croire  que le
% second opérande a au moins quatre chiffres; mais le problème c'est que
% ceci est appelé par \XINT_sqr. Et de plus \XINT_sqr est utilisé dans
% la nouvelle routine d'extraction de racine carrée: je ne veux pas
% rajouter l'overhead à \XINT_sqr de voir si a longueur est au moins 4.
% Dilemme donc. Il ne semble pas y avoir d'autres accès
% directs (celui de big fac n'est pas un problème). J'ai presque été
% tenté de faire du 5x4, mais si on veut maintenir les résultats
% intermédiaires sur 4n, il y a des complications. Par ailleurs,
% je modifie aussi un petit peu la façon de coder la suite, compte tenu
% du style que j'ai développé ultérieurement. Attention terminaison
% modifiée pour le deuxième opérande.|
%    \begin{macrocode}
\def\XINT_mul_enter #1\Z\Z\Z\Z #2#3#4#5%
{% 
    \xint_gob_til_W #5\XINT_mul_exit_a\W
    \XINT_mul_start {#2#3#4#5}#1\Z\Z\Z\Z 
}%
\def\XINT_mul_exit_a\W\XINT_mul_start #1%
{%
    \XINT_mul_exit_b #1%
}%
\def\XINT_mul_exit_b #1#2#3#4%
{%
    \xint_gob_til_W
      #2\XINT_mul_exit_ci
      #3\XINT_mul_exit_cii
      \W\XINT_mul_exit_ciii #1#2#3#4%
}%
\def\XINT_mul_exit_ciii #1\W #2\Z\Z\Z\Z \W\W\W
{%
    \XINT_mul_M {#1}#2\Z\Z\Z\Z
}%
\def\XINT_mul_exit_cii\W\XINT_mul_exit_ciii #1\W\W #2\Z\Z\Z\Z \W\W
{%
    \XINT_mul_M {#1}#2\Z\Z\Z\Z
}%
\def\XINT_mul_exit_ci\W\XINT_mul_exit_cii
                     \W\XINT_mul_exit_ciii #1\W\W\W #2\Z\Z\Z\Z \W
{%
    \XINT_mul_M {#1}#2\Z\Z\Z\Z
}%
\def\XINT_mul_start #1#2\Z\Z\Z\Z 
{%
    \expandafter\XINT_mul_main\expandafter
    {\romannumeral0\XINT_mul_Mr {#1}#2\Z\Z\Z\Z}#2\Z\Z\Z\Z 
}%
\def\XINT_mul_main #1#2\Z\Z\Z\Z #3#4#5#6%
{%
    \xint_gob_til_W #6\XINT_mul_finish_a\W
    \XINT_mul_compute {#3#4#5#6}{#1}#2\Z\Z\Z\Z 
}%
\def\XINT_mul_compute #1#2#3\Z\Z\Z\Z 
{%
    \expandafter\XINT_mul_main\expandafter
    {\romannumeral0\expandafter
     \XINT_mul_Ar\expandafter0\expandafter{\expandafter}%
     \romannumeral0\XINT_mul_Mr {#1}#3\Z\Z\Z\Z 
     \W\X\Y\Z 0000#2\W\X\Y\Z }#3\Z\Z\Z\Z 
}%
%    \end{macrocode}
% \lverb|&
% Ici, le deuxième nombre se termine. Fin du calcul. On utilise la variante
% \XINT_addm_A de l'addition car on sait que le deuxième terme est au moins
% aussi long que le premier. Lorsque le multiplicateur avait longueur 4n, la
% dernière addition a fourni le résultat à l'envers, il faut donc encore le
% renverser. |
%    \begin{macrocode}
\def\XINT_mul_finish_a\W\XINT_mul_compute #1%
{%
    \XINT_mul_finish_b #1%
}%
\def\XINT_mul_finish_b #1#2#3#4%
{%
    \xint_gob_til_W
      #1\XINT_mul_finish_c
      #2\XINT_mul_finish_ci
      #3\XINT_mul_finish_cii
      \W\XINT_mul_finish_ciii #1#2#3#4%
}%
\def\XINT_mul_finish_ciii #1\W #2#3\Z\Z\Z\Z \W\W\W
{%
    \expandafter\XINT_addm_A\expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT_mul_Mr {#1}#3\Z\Z\Z\Z \W\X\Y\Z 000#2\W\X\Y\Z 
}%
\def\XINT_mul_finish_cii
    \W\XINT_mul_finish_ciii #1\W\W #2#3\Z\Z\Z\Z \W\W
{%
    \expandafter\XINT_addm_A\expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT_mul_Mr {#1}#3\Z\Z\Z\Z \W\X\Y\Z 00#2\W\X\Y\Z 
}%
\def\XINT_mul_finish_ci #1\XINT_mul_finish_ciii #2\W\W\W #3#4\Z\Z\Z\Z \W 
{%
    \expandafter\XINT_addm_A\expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT_mul_Mr {#2}#4\Z\Z\Z\Z \W\X\Y\Z 0#3\W\X\Y\Z 
}%
\def\XINT_mul_finish_c #1\XINT_mul_finish_ciii \W\W\W\W #2#3\Z\Z\Z\Z
{%
    \expandafter\xint_cleanupzeros_andstop\romannumeral0\XINT_rev{#2}%
}%
%    \end{macrocode}
% \lverb|&
% Variante de la Multiplication$\
%   \romannumeral0\XINT_mulr_enter <N1>\Z\Z\Z\Z <N2>\W\W\W\W $\
%   Ici <N1> est à l'envers sur 4n, et <N2> est à l'endroit, pas sur 4n, comme
%   dans \XINT_mul_enter, mais le résultat est lui-même fourni *à l'envers*, sur
%   *4n* (en faisant attention de ne pas avoir 0000 à la fin).$\
% Utilisé par le calcul des puissances. J'ai modifié dans 1.08 sur le
% modèle de la nouvelle version de \XINT_mul_enter. Je pourrais économiser des
% macros et fusionner \XINT_mul_enter et \XINT_mulr_enter. Une autre fois.|
%    \begin{macrocode}
\def\XINT_mulr_enter #1\Z\Z\Z\Z #2#3#4#5%
{% 
    \xint_gob_til_W #5\XINT_mulr_exit_a\W
    \XINT_mulr_start {#2#3#4#5}#1\Z\Z\Z\Z 
}%
\def\XINT_mulr_exit_a\W\XINT_mulr_start #1%
{%
    \XINT_mulr_exit_b #1%
}%
\def\XINT_mulr_exit_b #1#2#3#4%
{%
    \xint_gob_til_W
      #2\XINT_mulr_exit_ci
      #3\XINT_mulr_exit_cii
      \W\XINT_mulr_exit_ciii #1#2#3#4%
}%
\def\XINT_mulr_exit_ciii #1\W #2\Z\Z\Z\Z \W\W\W
{%
    \XINT_mul_Mr {#1}#2\Z\Z\Z\Z
}%
\def\XINT_mulr_exit_cii\W\XINT_mulr_exit_ciii #1\W\W #2\Z\Z\Z\Z \W\W
{%
    \XINT_mul_Mr {#1}#2\Z\Z\Z\Z
}%
\def\XINT_mulr_exit_ci\W\XINT_mulr_exit_cii
                     \W\XINT_mulr_exit_ciii #1\W\W\W #2\Z\Z\Z\Z \W
{%
    \XINT_mul_Mr {#1}#2\Z\Z\Z\Z
}%
\def\XINT_mulr_start #1#2\Z\Z\Z\Z 
{%
    \expandafter\XINT_mulr_main\expandafter
    {\romannumeral0\XINT_mul_Mr {#1}#2\Z\Z\Z\Z}#2\Z\Z\Z\Z 
}%
\def\XINT_mulr_main #1#2\Z\Z\Z\Z #3#4#5#6%
{%
    \xint_gob_til_W #6\XINT_mulr_finish_a\W
    \XINT_mulr_compute {#3#4#5#6}{#1}#2\Z\Z\Z\Z 
}%
\def\XINT_mulr_compute #1#2#3\Z\Z\Z\Z 
{%
    \expandafter\XINT_mulr_main\expandafter
    {\romannumeral0\expandafter
     \XINT_mul_Ar\expandafter0\expandafter{\expandafter}%
     \romannumeral0\XINT_mul_Mr {#1}#3\Z\Z\Z\Z 
     \W\X\Y\Z 0000#2\W\X\Y\Z }#3\Z\Z\Z\Z 
}%
\def\XINT_mulr_finish_a\W\XINT_mulr_compute #1%
{%
    \XINT_mulr_finish_b #1%
}%
\def\XINT_mulr_finish_b #1#2#3#4%
{%
    \xint_gob_til_W
      #1\XINT_mulr_finish_c
      #2\XINT_mulr_finish_ci
      #3\XINT_mulr_finish_cii
      \W\XINT_mulr_finish_ciii #1#2#3#4%
}%
\def\XINT_mulr_finish_ciii #1\W #2#3\Z\Z\Z\Z \W\W\W
{%
    \expandafter\XINT_addp_A\expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT_mul_Mr {#1}#3\Z\Z\Z\Z \W\X\Y\Z 000#2\W\X\Y\Z 
}%
\def\XINT_mulr_finish_cii
    \W\XINT_mulr_finish_ciii #1\W\W #2#3\Z\Z\Z\Z \W\W
{%
    \expandafter\XINT_addp_A\expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT_mul_Mr {#1}#3\Z\Z\Z\Z \W\X\Y\Z 00#2\W\X\Y\Z 
}%
\def\XINT_mulr_finish_ci #1\XINT_mulr_finish_ciii #2\W\W\W #3#4\Z\Z\Z\Z \W 
{%
    \expandafter\XINT_addp_A\expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT_mul_Mr {#2}#4\Z\Z\Z\Z \W\X\Y\Z 0#3\W\X\Y\Z 
}%
\def\XINT_mulr_finish_c #1\XINT_mulr_finish_ciii \W\W\W\W #2#3\Z\Z\Z\Z { #2}%
%    \end{macrocode}
% \subsection{\csh{xintSqr}}
%    \begin{macrocode}
\def\xintiSqr {\romannumeral0\xintisqr }%
\def\xintisqr #1%
{%
    \expandafter\XINT_sqr\expandafter {\romannumeral0\xintiabs{#1}}% 
}%
\let\xintSqr\xintiSqr \let\xintsqr\xintisqr
\def\XINT_sqr #1%
{% 
    \expandafter\XINT_mul_enter
          \romannumeral0%
          \XINT_RQ {}#1\R\R\R\R\R\R\R\R\Z
          \Z\Z\Z\Z #1\W\W\W\W
}%
%    \end{macrocode}
% \subsection{\csh{xintPrd}, \csh{xintPrdExpr}}
% \lverb|&
% \xintPrd {{a}...{z}}$\
% \xintPrdExpr {a}...{z}\relax$\
% Release 1.02 modified the product routine.  The earlier version was faster in
% situations where each new term is bigger than the product of all previous
% terms, a situation which arises in the algorithm for computing powers. The
% 1.02 version was changed to be more efficient on big products, where the new
% term is small compared to what has been computed so far (the power algorithm
% now has its own product routine). 
% 
% Finally, the 1.03 version just simplifies everything as the multiplication now
% decides what is best, with the price of a little overhead. So the code has
% been dramatically reduced here. 
% 
% In 1.03 I also modify the way \xintPrd and \xintPrdExpr ...\relax are
% related. Now \xintPrdExpr \z \relax is accepted input when \z expands
% to a list of braced terms (prior only \xintPrd {\z} or \xintPrd \z was
% possible). 
%
% In 1.06a I suddenly decide that \xintProductExpr was a silly name, and as the
% package is new and certainly not used, I decide I may just switch to
% \xintPrdExpr which I should have used from the beginning.|
%    \begin{macrocode}
\def\xintiPrd {\romannumeral0\xintiprd }%
\def\xintiprd #1{\xintiprdexpr #1\relax }%
\let\xintPrd\xintiPrd 
\let\xintprd\xintiprd
\def\xintiPrdExpr {\romannumeral0\xintiprdexpr }%
\def\xintiprdexpr {\expandafter\XINT_prdexpr\romannumeral-`0}%
\let\xintPrdExpr\xintiPrdExpr 
\let\xintprdexpr\xintiprdexpr
\def\XINT_prdexpr {\XINT_prod_loop_a 1\Z }%
\def\XINT_prod_loop_a #1\Z #2%
{%
    \expandafter\XINT_prod_loop_b \romannumeral-`0#2\Z #1\Z \Z
}%
\def\XINT_prod_loop_b #1%
{%
   \xint_gob_til_relax #1\XINT_prod_finished\relax
   \XINT_prod_loop_c #1%
}%
\def\XINT_prod_loop_c
{%
    \expandafter\XINT_prod_loop_a\romannumeral0\XINT_mul_fork
}%
\def\XINT_prod_finished #1\Z #2\Z \Z { #2}%
%    \end{macrocode}
% \subsection{\csh{xintFac}}
% \lverb|&
% Modified with 1.02 and again in 1.03 for greater efficiency. I am
% tempted, 
% here and elsewhere, to use \ifcase\XINT_Geq  {#1}{1000000000}  rather than
% \ifnum\XINT_Length {#1}>9 but for the time being I leave things as they stand.
% With release 1.05, rather than using \XINT_Length I opt finally for direct use
% of \numexpr (which will throw a suitable number too big message), and to raise
% the \xintError:$\ FactorialOfTooBigNumber for argument larger than 1000000
% (rather than 1000000000).| 
%    \begin{macrocode}
\def\xintiFac {\romannumeral0\xintifac }%
\def\xintifac #1%
{%
    \expandafter\XINT_fac_fork\expandafter{\the\numexpr #1}%
}%
\let\xintFac\xintiFac \let\xintfac\xintifac
\def\XINT_fac_fork #1%
{%
    \ifcase\XINT_Sgn {#1}
       \xint_afterfi{\expandafter\space\expandafter 1\xint_gobble_i }%
    \or
       \expandafter\XINT_fac_checklength
    \else
       \xint_afterfi{\expandafter\xintError:FactorialOfNegativeNumber
                \expandafter\space\expandafter 1\xint_gobble_i }%
    \fi
    {#1}%
}%
\def\XINT_fac_checklength #1%
{%
    \ifnum #1>999999
         \xint_afterfi{\expandafter\xintError:FactorialOfTooBigNumber
                       \expandafter\space\expandafter 1\xint_gobble_i }%
    \else
         \xint_afterfi{\ifnum #1>9999
                          \expandafter\XINT_fac_big_loop
                       \else
                          \expandafter\XINT_fac_loop
                       \fi }%
    \fi
    {#1}%
}%
\def\XINT_fac_big_loop #1{\XINT_fac_big_loop_main {10000}{#1}{}}%
\def\XINT_fac_big_loop_main #1#2#3%
{%
    \ifnum #1<#2
        \expandafter
            \XINT_fac_big_loop_main
        \expandafter
           {\the\numexpr #1+1\expandafter }%
    \else
        \expandafter\XINT_fac_big_docomputation
    \fi
    {#2}{#3{#1}}%
}%
\def\XINT_fac_big_docomputation #1#2%
{%
    \expandafter \XINT_fac_bigcompute_loop \expandafter
    {\romannumeral0\XINT_fac_loop {9999}}#2\relax
}%
\def\XINT_fac_bigcompute_loop #1#2%
{%
    \xint_gob_til_relax #2\XINT_fac_bigcompute_end\relax
    \expandafter\XINT_fac_bigcompute_loop\expandafter
    {\expandafter\XINT_mul_enter
     \romannumeral0\XINT_RQ {}#2\R\R\R\R\R\R\R\R\Z
     \Z\Z\Z\Z #1\W\W\W\W }% 
}%
\def\XINT_fac_bigcompute_end #1#2#3#4#5%
{%
    \XINT_fac_bigcompute_end_ #5%
}%
\def\XINT_fac_bigcompute_end_ #1\R #2\Z \W\X\Y\Z #3\W\X\Y\Z { #3}%
\def\XINT_fac_loop #1{\XINT_fac_loop_main 1{1000}{#1}}%
\def\XINT_fac_loop_main #1#2#3%
{%
    \ifnum #3>#1
    \else
        \expandafter\XINT_fac_loop_exit
    \fi
    \expandafter\XINT_fac_loop_main\expandafter
    {\the\numexpr #1+1\expandafter }\expandafter
    {\romannumeral0\XINT_mul_Mr {#1}#2\Z\Z\Z\Z }%
    {#3}%
}%
\def\XINT_fac_loop_exit #1#2#3#4#5#6#7%
{%
    \XINT_fac_loop_exit_ #6%
}%
\def\XINT_fac_loop_exit_ #1#2#3%
{%
    \XINT_mul_M 
}%
%    \end{macrocode}
% \subsection{\csh{xintPow}}
% \lverb|&
% 1.02 modified the \XINT_posprod routine, and this meant that the
% original 
% version was moved here and renamed to \XINT_pow_posprod, as it was well
% adapted for computing powers. Then I moved in 1.03 the special variants of
% multiplication (hence of addition) which were needed to earlier in this file.
% Modified in 1.06, the exponent is  given to a \numexpr  rather than twice
% expanded. |
%    \begin{macrocode}
\def\xintiPow {\romannumeral0\xintipow }%
\def\xintipow #1%
{%
    \expandafter\xint_pow\romannumeral-`0#1\Z%
}%
\let\xintPow\xintiPow \let\xintpow\xintipow
\def\xint_pow #1#2\Z 
{% 
    \xint_UDsignfork
      #1\dummy \XINT_pow_Aneg
       -\dummy \XINT_pow_Anonneg
    \krof
       #1{#2}%
}%
\def\XINT_pow_Aneg #1#2#3%
{%
   \expandafter\XINT_pow_Aneg_\expandafter{\the\numexpr #3}{#2}%
}%
\def\XINT_pow_Aneg_ #1%
{%
   \ifodd #1
       \expandafter\XINT_pow_Aneg_Bodd
   \fi
   \XINT_pow_Anonneg_ {#1}%
}%
\def\XINT_pow_Aneg_Bodd #1%
{%
    \expandafter\XINT_opp\romannumeral0\XINT_pow_Anonneg_ 
}%
%    \end{macrocode}
% \lverb|&
% B = #3, faire le xpxp. Modified with 1.06: use of \numexpr.|
%    \begin{macrocode}
\def\XINT_pow_Anonneg #1#2#3%
{%
   \expandafter\XINT_pow_Anonneg_\expandafter {\the\numexpr #3}{#1#2}%
}%
%    \end{macrocode}
% \lverb+#1 = B, #2 = |A|+
%    \begin{macrocode}
\def\XINT_pow_Anonneg_ #1#2%
{%
    \ifcase\XINT_Cmp {#2}{1}
        \expandafter\XINT_pow_AisOne
    \or 
        \expandafter\XINT_pow_AatleastTwo
    \else
        \expandafter\XINT_pow_AisZero
    \fi
    {#1}{#2}%
}%
\def\XINT_pow_AisOne #1#2{ 1}%
%    \end{macrocode}
% \lverb|&
% #1 = B|
%    \begin{macrocode}
\def\XINT_pow_AisZero #1#2%
{%
     \ifcase\XINT_Sgn {#1}
         \xint_afterfi { 1}%
     \or
         \xint_afterfi { 0}%
     \else
         \xint_afterfi {\xintError:DivisionByZero\space 0}%
     \fi
}%
\def\XINT_pow_AatleastTwo #1%
{%
    \ifcase\XINT_Sgn {#1}
        \expandafter\XINT_pow_BisZero
    \or
        \expandafter\XINT_pow_checkBsize
    \else
        \expandafter\XINT_pow_BisNegative
    \fi
    {#1}%
}%
\def\XINT_pow_BisNegative #1#2{\xintError:FractionRoundedToZero\space 0}%
\def\XINT_pow_BisZero #1#2{ 1}%
%    \end{macrocode}
% \lverb|&
% B = #1 > 0, A = #2 > 1. With 1.05, I replace \xintiLen{#1}>9 by direct
% use 
% of \numexpr [to generate an error message if the exponent is too large]
% 1.06: \numexpr was already used above.|
%    \begin{macrocode}
\def\XINT_pow_checkBsize #1#2%
{%
    \ifnum #1>999999999 
        \expandafter\XINT_pow_BtooBig
    \else
        \expandafter\XINT_pow_loop
    \fi
    {#1}{#2}\XINT_pow_posprod
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax
}%
\def\XINT_pow_BtooBig #1\xint_relax #2\xint_relax 
                         {\xintError:ExponentTooBig\space 0}%
\def\XINT_pow_loop #1#2%
{%
    \ifnum #1 = 1
        \expandafter\XINT_pow_loop_end 
    \else
        \xint_afterfi{\expandafter\XINT_pow_loop_a
            \expandafter{\the\numexpr 2*(#1/2)-#1\expandafter }% b mod 2
            \expandafter{\the\numexpr #1-#1/2\expandafter }%     [b/2]
            \expandafter{\romannumeral0\xintisqr{#2}}}%
    \fi
    {{#2}}%
}%
\def\XINT_pow_loop_end {\romannumeral0\XINT_rord_main {}\relax }%
\def\XINT_pow_loop_a #1%
{%
    \ifnum #1 = 1
        \expandafter\XINT_pow_loop
    \else
        \expandafter\XINT_pow_loop_throwaway
    \fi
}%
\def\XINT_pow_loop_throwaway #1#2#3%
{%
   \XINT_pow_loop {#1}{#2}% 
}%
%    \end{macrocode}
% \lverb|&
% Routine de produit servant pour le calcul des puissances. Chaque
% nouveau 
%    terme est plus grand que ce qui a déjà été calculé. Par conséquent on a
%    intérêt à le conserver en second dans la routine de multiplication, donc le
%    précédent calcul a intérêt à avoir été donné sur 4n, à l'envers. Il faut
%    donc modifier la multiplication pour qu'elle fasse cela. Ce qui oblige à
%    utiliser une version spéciale de l'addition également.|
%    \begin{macrocode}
\def\XINT_pow_posprod #1%
{%
    \XINT_pow_pprod_checkifempty #1\Z
}%
\def\XINT_pow_pprod_checkifempty #1%
{%
    \xint_gob_til_relax #1\XINT_pow_pprod_emptyproduct\relax 
    \XINT_pow_pprod_RQfirst #1%
}%
\def\XINT_pow_pprod_emptyproduct #1\Z { 1}%
\def\XINT_pow_pprod_RQfirst #1\Z
{%
    \expandafter\XINT_pow_pprod_getnext\expandafter
    {\romannumeral0\XINT_RQ {}#1\R\R\R\R\R\R\R\R\Z}%
}%
\def\XINT_pow_pprod_getnext #1#2%
{%
    \XINT_pow_pprod_checkiffinished #2\Z {#1}%
}%
\def\XINT_pow_pprod_checkiffinished #1%
{%
    \xint_gob_til_relax #1\XINT_pow_pprod_end\relax 
    \XINT_pow_pprod_compute #1%
}%
\def\XINT_pow_pprod_compute #1\Z #2%
{%
    \expandafter\XINT_pow_pprod_getnext\expandafter
    {\romannumeral0\XINT_mulr_enter #2\Z\Z\Z\Z #1\W\W\W\W }%
}%
\def\XINT_pow_pprod_end\relax\XINT_pow_pprod_compute #1\Z #2%
{%
    \expandafter\xint_cleanupzeros_andstop
    \romannumeral0\XINT_rev {#2}%
}%
%    \end{macrocode}
% \subsection{\csh{xintDivision}, \csh{xintQuo}, \csh{xintRem}}
%    \begin{macrocode}
\def\xintiQuo {\romannumeral0\xintiquo }%
\def\xintiRem {\romannumeral0\xintirem }%
\def\xintiquo {\expandafter\xint_firstoftwo_andstop
               \romannumeral0\xintidivision }%
\def\xintirem {\expandafter\xint_secondoftwo_andstop
               \romannumeral0\xintidivision }%
\let\xintQuo\xintiQuo \let\xintquo\xintiquo
\let\xintRem\xintiRem \let\xintrem\xintirem
%    \end{macrocode}
% \lverb|&
% #1 = A, #2 = B. On calcule le quotient de A par B.$\
% 1.03 adds the detection of 1 for B.|
%    \begin{macrocode}
\def\xintiDivision {\romannumeral0\xintidivision }%
\def\xintidivision #1%
{%
    \expandafter\xint_division\expandafter {\romannumeral-`0#1}%
}%
\let\xintDivision\xintiDivision \let\xintdivision\xintidivision
\def\xint_division #1#2%
{%
    \expandafter\XINT_div_fork \romannumeral-`0#2\Z #1\Z 
}%
\def\XINT_Division #1#2{\romannumeral0\XINT_div_fork #2\Z #1\Z }%
%    \end{macrocode}
% \lverb|&
% #1#2 = 2e input = diviseur = B. 
% #3#4 = 1er input = divisé = A|
%    \begin{macrocode}
\def\XINT_div_fork #1#2\Z #3#4\Z
{%
    \xint_UDzerofork
      #1\dummy \XINT_div_BisZero
      #3\dummy \XINT_div_AisZero
       0\dummy 
        {\xint_UDsignfork
           #1\dummy \XINT_div_BisNegative  % B < 0
           #3\dummy \XINT_div_AisNegative  % A < 0, B > 0
            -\dummy \XINT_div_plusplus     % B > 0, A > 0
         \krof }%
    \krof
    {#2}{#4}#1#3% #1#2=B, #3#4=A
}%
\def\XINT_div_BisZero #1#2#3#4{\xintError:DivisionByZero\space {0}{0}}%
\def\XINT_div_AisZero #1#2#3#4{ {0}{0}}%
%    \end{macrocode}
% \lverb|&
% jusqu'à présent c'est facile.$\
% minusplus signifie B < 0, A > 0$\
% plusminus signifie B > 0, A < 0$\
% Ici #3#1 correspond au diviseur B et #4#2 au divisé A.
%
% Cases with B<0 or especially A<0 are treated sub-optimally in terms of
% post-processing, things get reversed which could have been produced directly
% in the wanted order, but A,B>0 is given priority for optimization. |
%    \begin{macrocode}
\def\XINT_div_plusplus #1#2#3#4%
{%
    \XINT_div_prepare {#3#1}{#4#2}%
}%
%    \end{macrocode}
% \lverb|&
% B = #3#1 < 0, A non nul positif ou négatif|
%    \begin{macrocode}
\def\XINT_div_BisNegative #1#2#3#4%
{%
    \expandafter\XINT_div_BisNegative_post
    \romannumeral0\XINT_div_fork #1\Z #4#2\Z
}%
\def\XINT_div_BisNegative_post #1%
{%
    \expandafter\space\expandafter {\romannumeral0\XINT_opp #1}%
}%
%    \end{macrocode}
% \lverb|&
% B = #3#1 > 0, A =-#2< 0|
%    \begin{macrocode}
\def\XINT_div_AisNegative #1#2#3#4%
{%
    \expandafter\XINT_div_AisNegative_post
    \romannumeral0\XINT_div_prepare {#3#1}{#2}{#3#1}%
}%
\def\XINT_div_AisNegative_post #1#2%
{%
    \ifcase\XINT_Sgn {#2}
       \expandafter \XINT_div_AisNegative_zerorem
    \or
       \expandafter \XINT_div_AisNegative_posrem
    \fi
    {#1}{#2}%
}%
%    \end{macrocode}
% \lverb|&
% en #3 on a une copie de B (à l'endroit)|
%    \begin{macrocode}
\def\XINT_div_AisNegative_zerorem #1#2#3%
{%
    \expandafter\space\expandafter {\romannumeral0\XINT_opp #1}{0}%
}%
%    \end{macrocode}
% \lverb!#1 = quotient, #2 = reste, #3 = diviseur initial (à l'endroit)
% remplace Reste par B - Reste, après avoir remplacé Q par -(Q+1)
% de sorte que la formule a = qb + r, 0<= r < |b| est valable!
%    \begin{macrocode}
\def\XINT_div_AisNegative_posrem #1%
{%
    \expandafter \XINT_div_AisNegative_posrem_b \expandafter
       {\romannumeral0\xintiopp{\xintInc {#1}}}%
}%
\def\XINT_div_AisNegative_posrem_b #1#2#3%
{%
    \expandafter \xint_exchangetwo_keepbraces_andstop \expandafter
    {\romannumeral0\XINT_sub {#3}{#2}}{#1}%
}%
%    \end{macrocode}
% \lverb|&
% par la suite A et B sont > 0.
% #1 = B. Pour le moment à l'endroit.
% Calcul du plus petit K = 4n >= longueur de B$\
% 1.03 adds the interception of B=1|
%    \begin{macrocode}
\def\XINT_div_prepare #1%
{%
    \expandafter \XINT_div_prepareB_aa \expandafter
        {\romannumeral0\XINT_length {#1}}{#1}% B > 0 ici
}%
\def\XINT_div_prepareB_aa #1%
{%
    \ifnum #1=1
      \expandafter\XINT_div_prepareB_ab
    \else
      \expandafter\XINT_div_prepareB_a
    \fi
    {#1}%
}%
\def\XINT_div_prepareB_ab #1#2%
{%
    \ifnum #2=1
      \expandafter\XINT_div_prepareB_BisOne
    \else 
      \expandafter\XINT_div_prepareB_e
    \fi {000}{3}{4}{#2}%
}%
\def\XINT_div_prepareB_BisOne #1#2#3#4#5{ {#5}{0}}%
\def\XINT_div_prepareB_a #1%
{%
  \expandafter\XINT_div_prepareB_c\expandafter
  {\the\numexpr \xint_c_iv*((#1+\xint_c_i)/\xint_c_iv)}{#1}%
}%
%    \end{macrocode}
% \lverb|&
% #1 = K|
%    \begin{macrocode}
\def\XINT_div_prepareB_c #1#2%
{%
    \ifcase \numexpr #1-#2\relax
       \expandafter\XINT_div_prepareB_d
    \or
       \expandafter\XINT_div_prepareB_di
    \or
       \expandafter\XINT_div_prepareB_dii
    \or
       \expandafter\XINT_div_prepareB_diii
    \fi {#1}%
}%
\def\XINT_div_prepareB_d    {\XINT_div_prepareB_e {}{0}}%
\def\XINT_div_prepareB_di   {\XINT_div_prepareB_e {0}{1}}%
\def\XINT_div_prepareB_dii  {\XINT_div_prepareB_e {00}{2}}%
\def\XINT_div_prepareB_diii {\XINT_div_prepareB_e {000}{3}}%
%    \end{macrocode}
% \lverb|&
% #1 = zéros à rajouter à B, #2=c, #3=K, #4 = B|
%    \begin{macrocode}
\def\XINT_div_prepareB_e #1#2#3#4%
{%
    \XINT_div_prepareB_f #4#1\Z {#3}{#2}{#1}%
}%
%    \end{macrocode}
% \lverb|&
% x = #1#2#3#4 = 4 premiers chiffres de B. #1 est non nul.
% Ensuite on renverse B pour calculs plus rapides par la suite.|
%    \begin{macrocode}
\def\XINT_div_prepareB_f #1#2#3#4#5\Z
{%
    \expandafter \XINT_div_prepareB_g \expandafter
        {\romannumeral0\XINT_rev {#1#2#3#4#5}}{#1#2#3#4}%
}%
%    \end{macrocode}
% \lverb|&
% #3= K, #4 = c, #5= {} ou {0} ou {00} ou {000}, #6 = A initial
% #1 = B préparé et renversé, #2 = x = quatre premiers chiffres
% On multiplie aussi A par 10^c.$\
% B, x, K, c, {} ou {0} ou {00} ou {000}, A initial|
%    \begin{macrocode}
\def\XINT_div_prepareB_g #1#2#3#4#5#6%
{%
    \XINT_div_prepareA_a {#6#5}{#2}{#3}{#1}{#4}%
}%
%    \end{macrocode}
% \lverb|&
% A, x, K, B, c, |
%    \begin{macrocode}
\def\XINT_div_prepareA_a #1%
{%
    \expandafter \XINT_div_prepareA_b \expandafter
       {\romannumeral0\XINT_length {#1}}{#1}% A >0 ici
}%
%    \end{macrocode}
% \lverb|&
% L0, A, x, K, B, ...|
%    \begin{macrocode}
\def\XINT_div_prepareA_b #1%
{%
  \expandafter\XINT_div_prepareA_c\expandafter{\the\numexpr 4*((#1+1)/4)}{#1}%
}%
%    \end{macrocode}
% \lverb|&
% L, L0, A, x, K, B,...|
%    \begin{macrocode}
\def\XINT_div_prepareA_c #1#2%
{%
    \ifcase \numexpr #1-#2\relax
       \expandafter\XINT_div_prepareA_d
    \or
       \expandafter\XINT_div_prepareA_di
    \or
       \expandafter\XINT_div_prepareA_dii
    \or
       \expandafter\XINT_div_prepareA_diii
    \fi {#1}%
}%
\def\XINT_div_prepareA_d     {\XINT_div_prepareA_e {}}%
\def\XINT_div_prepareA_di    {\XINT_div_prepareA_e {0}}%
\def\XINT_div_prepareA_dii   {\XINT_div_prepareA_e {00}}%
\def\XINT_div_prepareA_diii  {\XINT_div_prepareA_e {000}}%
%    \end{macrocode}
% \lverb|&
% #1#3 = A préparé, #2 = longueur de ce A préparé, |
%    \begin{macrocode}
\def\XINT_div_prepareA_e #1#2#3%
{%
    \XINT_div_startswitch {#1#3}{#2}% 
}%
%    \end{macrocode}
% \lverb|&
% A, L, x, K, B, c|
%    \begin{macrocode}
\def\XINT_div_startswitch #1#2#3#4%
{%
    \ifnum #2 > #4
      \expandafter\XINT_div_body_a
    \else
    \ifnum #2 = #4
      \expandafter\expandafter\expandafter\XINT_div_final_a
    \else
      \expandafter\expandafter\expandafter\XINT_div_finished_a
    \fi\fi {#1}{#4}{#3}{0000}{#2}%
}%
%    \end{macrocode}
% \lverb|&
% ---- "Finished": A, K, x, Q, L, B, c|
%    \begin{macrocode}
\def\XINT_div_finished_a #1#2#3%
{%
  \expandafter\XINT_div_finished_b\expandafter {\romannumeral0\XINT_cuz {#1}}%
}%
%    \end{macrocode}
% \lverb|&
% A, Q, L, B, c
% no leading zeros in A at this stage|
%    \begin{macrocode}
\def\XINT_div_finished_b #1#2#3#4#5%
{%
    \ifcase \XINT_Sgn {#1}
       \xint_afterfi {\XINT_div_finished_c {0}}%
    \or
       \xint_afterfi {\expandafter\XINT_div_finished_c\expandafter
                      {\romannumeral0\XINT_dsh_checksignx #5\Z {#1}}%
                     }%
    \fi
    {#2}%
}%
\def\XINT_div_finished_c #1#2%
{%
    \expandafter\space\expandafter {\romannumeral0\XINT_rev_andcuz {#2}}{#1}%
}%
%    \end{macrocode}
% \lverb|&
% ---- "Final": A, K, x, Q, L, B, c|
%    \begin{macrocode}
\def\XINT_div_final_a #1%
{%
    \XINT_div_final_b #1\Z
}%
\def\XINT_div_final_b #1#2#3#4#5\Z
{%
    \xint_gob_til_zeros_iv #1#2#3#4\xint_div_final_c0000%
    \XINT_div_final_c {#1#2#3#4}{#1#2#3#4#5}%
}%
\def\xint_div_final_c0000\XINT_div_final_c #1{\XINT_div_finished_a }%
%    \end{macrocode}
% \lverb|&
% a, A, K, x, Q, L, B ,c
% 1.01: code ré-écrit pour optimisations diverses.
% 1.04: again, code rewritten for tiny speed increase (hopefully).|
%    \begin{macrocode}
\def\XINT_div_final_c #1#2#3#4%
{%
    \expandafter \XINT_div_final_da \expandafter
    {\the\numexpr #1-(#1/#4)*#4\expandafter }\expandafter
    {\the\numexpr #1/#4\expandafter }\expandafter
    {\romannumeral0\xint_cleanupzeros_andstop #2}%
}%
%    \end{macrocode}
% \lverb|&
% r, q, A sans leading zéros, Q, L, B à l'envers sur 4n, c|
%    \begin{macrocode}
\def\XINT_div_final_da #1%
{%
    \ifnum #1>\xint_c_ix
       \expandafter\XINT_div_final_dP
    \else
       \xint_afterfi
       {\ifnum #1<\xint_c_
        \expandafter\XINT_div_final_dN
        \else
        \expandafter\XINT_div_final_db
        \fi }%
    \fi
}%
\def\XINT_div_final_dN #1%
{%
    \expandafter\XINT_div_final_dP\the\numexpr #1-\xint_c_i\relax
}%
\def\XINT_div_final_dP #1#2#3#4#5% q,A,Q,L,B (puis c)
{%
    \expandafter \XINT_div_final_f \expandafter
    {\romannumeral0\xintisub {#2}%
        {\romannumeral0\XINT_mul_M {#1}#5\Z\Z\Z\Z }}%
    {\romannumeral0\XINT_add_A 0{}#1000\W\X\Y\Z #3\W\X\Y\Z }% 
}%
\def\XINT_div_final_db #1#2#3#4#5% q,A,Q,L,B (puis c)
{% 
    \expandafter\XINT_div_final_dc\expandafter
    {\romannumeral0\xintisub {#2}%
        {\romannumeral0\XINT_mul_M {#1}#5\Z\Z\Z\Z }}%
    {#1}{#2}{#3}{#4}{#5}%
}%
\def\XINT_div_final_dc #1#2%
{%
    \ifnum\XINT_Sgn{#1}<\xint_c_
    \xint_afterfi 
    {\expandafter\XINT_div_final_dP\the\numexpr #2-\xint_c_i\relax}%
    \else \xint_afterfi {\XINT_div_final_e {#1}#2}%
    \fi
}%
\def\XINT_div_final_e #1#2#3#4#5#6% A final, q, trash, Q, L, B
{%
    \XINT_div_final_f {#1}%
    {\romannumeral0\XINT_add_A 0{}#2000\W\X\Y\Z #4\W\X\Y\Z }%
}%
\def\XINT_div_final_f #1#2#3% R,Q \`a d\'evelopper,c
{%
    \ifcase \XINT_Sgn {#1}
       \xint_afterfi {\XINT_div_final_end {0}}%
    \or
       \xint_afterfi {\expandafter\XINT_div_final_end\expandafter
                      {\romannumeral0\XINT_dsh_checksignx #3\Z {#1}}%
                     }%
    \fi
    {#2}%
}%
\def\XINT_div_final_end #1#2%
{%
    \expandafter\space\expandafter {#2}{#1}%
}%
%    \end{macrocode}
% \lverb|&
% Boucle Principale (on reviendra en div_body_b pas div_body_a)$\
% A, K, x, Q, L, B, c|
%    \begin{macrocode}
\def\XINT_div_body_a #1%
{%
    \XINT_div_body_b #1\Z {#1}%
}%
\def\XINT_div_body_b #1#2#3#4#5#6#7#8#9\Z
{%
    \XINT_div_body_c {#1#2#3#4#5#6#7#8}%
}%
%    \end{macrocode}
% \lverb|&
% a, A, K, x, Q, L, B, c|
%    \begin{macrocode}
\def\XINT_div_body_c #1#2#3%
{%
    \XINT_div_body_d {#3}{}#2\Z {#1}{#3}%
}%
\def\XINT_div_body_d #1#2#3#4#5#6%
{%
    \ifnum #1 >\xint_c_
        \expandafter\XINT_div_body_d
        \expandafter{\the\numexpr #1-\xint_c_iv\expandafter }%
    \else
        \expandafter\XINT_div_body_e
    \fi
    {#6#5#4#3#2}%
}%
\def\XINT_div_body_e #1#2\Z #3%
{%
    \XINT_div_body_f {#3}{#1}{#2}%
}%
%    \end{macrocode}
% \lverb|&
% a, alpha (à l'envers), alpha' (à l'endroit), K, x, Q, L, B (à l'envers), c|
%    \begin{macrocode}
\def\XINT_div_body_f #1#2#3#4#5#6#7#8%
{%
    \expandafter\XINT_div_body_gg
    \the\numexpr (#1+(#5+\xint_c_i)/\xint_c_ii)/(#5+\xint_c_i)+99999\relax 
    {#8}{#2}{#8}{#4}{#5}{#3}{#6}{#7}{#8}%
}%
%    \end{macrocode}
% \lverb|&
% q1 sur six chiffres (il en a 5 au max), B, alpha, B, K, x, alpha', Q, L, B, c|
%    \begin{macrocode}
\def\XINT_div_body_gg #1#2#3#4#5#6%
{%
    \xint_UDzerofork
      #2\dummy \XINT_div_body_gk 
       0\dummy {\XINT_div_body_ggk #2}%
    \krof
    {#3#4#5#6}%
}%
\def\XINT_div_body_gk #1#2#3%
{%
    \expandafter\XINT_div_body_h 
    \romannumeral0\XINT_div_sub_xpxp 
    {\romannumeral0\XINT_mul_Mr {#1}#2\Z\Z\Z\Z }{#3}\Z {#1}%
}%
\def\XINT_div_body_ggk #1#2#3%
{%
    \expandafter \XINT_div_body_gggk \expandafter
    {\romannumeral0\XINT_mul_Mr {#1}0000#3\Z\Z\Z\Z }%
    {\romannumeral0\XINT_mul_Mr {#2}#3\Z\Z\Z\Z }%
    {#1#2}%  
}%
\def\XINT_div_body_gggk #1#2#3#4%
{%
    \expandafter\XINT_div_body_h
    \romannumeral0\XINT_div_sub_xpxp
    {\romannumeral0\expandafter\XINT_mul_Ar
     \expandafter0\expandafter{\expandafter}#2\W\X\Y\Z #1\W\X\Y\Z }%
    {#4}\Z {#3}%
}%
%    \end{macrocode}
% \lverb|&
% alpha1 = alpha-q1 B, \Z, q1, B, K, x, alpha', Q, L, B, c|
%    \begin{macrocode}
\def\XINT_div_body_h #1#2#3#4#5#6#7#8#9\Z 
{%
    \ifnum #1#2#3#4>\xint_c_
        \xint_afterfi{\XINT_div_body_i {#1#2#3#4#5#6#7#8}}%
    \else
        \expandafter\XINT_div_body_k
    \fi
    {#1#2#3#4#5#6#7#8#9}%
}%
\def\XINT_div_body_k #1#2#3%
{%
    \XINT_div_body_l {#1}{#2}%
}%
%    \end{macrocode}
% \lverb|&
% a1, alpha1 (à l'endroit), q1, B, K, x, alpha', Q, L, B, c|
%    \begin{macrocode}
\def\XINT_div_body_i #1#2#3#4#5#6%
{%
    \expandafter\XINT_div_body_j
    \expandafter{\the\numexpr (#1+(#6+1)/2)/(#6+1)-1}%
       {#2}{#3}{#4}{#5}{#6}%
}%
\def\XINT_div_body_j #1#2#3#4%
{%
    \expandafter \XINT_div_body_l \expandafter
    {\romannumeral0\XINT_div_sub_xpxp
       {\romannumeral0\XINT_mul_Mr {#1}#4\Z\Z\Z\Z }{\XINT_Rev{#2}}}%
    {#3+#1}%
}%
%    \end{macrocode}
% \lverb|&
% alpha2 (à l'endroit, ou alpha1), q1+q2 (ou q1), K, x, alpha', Q, L, B, c|
%    \begin{macrocode}
\def\XINT_div_body_l #1#2#3#4#5#6#7%
{%
   \expandafter\XINT_div_body_m
   \the\numexpr \xint_c_x^viii+#2\relax {#6}{#3}{#7}{#1#5}{#4}%
}%
%    \end{macrocode}
% \lverb|&
% chiffres de q, Q, K, L, A'=nouveau A, x, B, c|
%    \begin{macrocode}
\def\XINT_div_body_m 1#1#2#3#4#5#6#7#8%
{%
    \ifnum #1#2#3#4>\xint_c_
       \xint_afterfi {\XINT_div_body_n {#8#7#6#5#4#3#2#1}}%
    \else
       \xint_afterfi {\XINT_div_body_n {#8#7#6#5}}%
    \fi
}%
%    \end{macrocode}
% \lverb|&
% q renversé, Q, K, L, A', x, B, c|
%    \begin{macrocode}
\def\XINT_div_body_n #1#2%
{%
    \expandafter\XINT_div_body_o\expandafter
    {\romannumeral0\XINT_addr_A 0{}#1\W\X\Y\Z #2\W\X\Y\Z }%
}%
%    \end{macrocode}
% \lverb|&
% q+Q, K, L, A', x, B, c|
%    \begin{macrocode}
\def\XINT_div_body_o #1#2#3#4%
{%
    \XINT_div_body_p {#3}{#2}{}#4\Z {#1}%
}%
%    \end{macrocode}
% \lverb|&
% L, K, {}, A'\Z, q+Q, x, B, c |
%    \begin{macrocode}
\def\XINT_div_body_p #1#2#3#4#5#6#7%
{%
    \ifnum #1 > #2
        \xint_afterfi
        {\ifnum #4#5#6#7 > \xint_c_
           \expandafter\XINT_div_body_q
         \else
           \expandafter\XINT_div_body_repeatp
         \fi }%
    \else
        \expandafter\XINT_div_gotofinal_a
    \fi
    {#1}{#2}{#3}#4#5#6#7%
}%
%    \end{macrocode}
% \lverb|&
% L, K, zeros,  A' avec moins de zéros\Z, q+Q, x, B, c|
%    \begin{macrocode}
\def\XINT_div_body_repeatp #1#2#3#4#5#6#7%
{%
    \expandafter\XINT_div_body_p\expandafter{\the\numexpr #1-4}{#2}{0000#3}%
}%
%    \end{macrocode}
% \lverb|&
% L -> L-4, zeros->zeros+0000, répéter jusqu'à ce que soit L=K
% soit on ne trouve plus 0000$\
% nouveau L, K, zeros, nouveau A=#4, \Z, Q+q (à l'envers), x, B, c|
%    \begin{macrocode}
\def\XINT_div_body_q #1#2#3#4\Z #5#6%
{%
    \XINT_div_body_b #4\Z {#4}{#2}{#6}{#3#5}{#1}%
}%
%    \end{macrocode}
% \lverb|&
% A, K, x, Q, L, B, c --> iterate$\
% Boucle Principale achevée. ATTENTION IL FAUT AJOUTER 4 ZEROS DE MOINS QUE CEUX
% QUI ONT ÉTÉ PRÉPARÉS DANS #3!!$\
% L, K (L=K), zeros, A\Z, Q, x, B, c|
%    \begin{macrocode}
\def\XINT_div_gotofinal_a #1#2#3#4\Z %
{%
    \XINT_div_gotofinal_b #3\Z {#4}{#1}%
}%
\def\XINT_div_gotofinal_b 0000#1\Z #2#3#4#5%
{%
    \XINT_div_final_a {#2}{#3}{#5}{#1#4}{#3}%
}%
%    \end{macrocode}
% \lverb|&
% La soustraction spéciale.
% 
% Elle fait l'expansion (une fois pour le premier, deux fois pour le second) de
% ses arguments. Ceux-ci doivent être à l'envers sur 4n. De plus on sait a
% priori que le second est > le premier. Et le résultat de la différence est
% renvoyé **avec la même longueur que le second** (donc avec des leading zéros
% éventuels), et *à l'endroit*.|
%    \begin{macrocode}
\def\XINT_div_sub_xpxp #1%
{%
    \expandafter \XINT_div_sub_xpxp_a  \expandafter{#1}%
}%
\def\XINT_div_sub_xpxp_a #1#2%
{%
    \expandafter\expandafter\expandafter\XINT_div_sub_xpxp_b
     #2\W\X\Y\Z #1\W\X\Y\Z
}%
\def\XINT_div_sub_xpxp_b
{%
    \XINT_div_sub_A 1{}%
}%
\def\XINT_div_sub_A #1#2#3#4#5#6%  
{%
    \xint_gob_til_W #3\xint_div_sub_az\W
    \XINT_div_sub_B #1{#3#4#5#6}{#2}% 
}%
\def\XINT_div_sub_B #1#2#3#4\W\X\Y\Z #5#6#7#8%  
{%
    \xint_gob_til_W #5\xint_div_sub_bz\W
    \XINT_div_sub_onestep #1#2{#8#7#6#5}{#3}#4\W\X\Y\Z 
}%
\def\XINT_div_sub_onestep #1#2#3#4#5#6%
{%
    \expandafter\XINT_div_sub_backtoA
    \the\numexpr 11#5#4#3#2-#6+#1-\xint_c_i\relax.%
}%
\def\XINT_div_sub_backtoA #1#2#3.#4%
{%
    \XINT_div_sub_A #2{#3#4}%
}%
\def\xint_div_sub_bz\W\XINT_div_sub_onestep #1#2#3#4#5#6#7%
{%
    \xint_UDzerofork
      #1\dummy  \XINT_div_sub_C   %
       0\dummy  \XINT_div_sub_D   % pas de retenue
    \krof
    {#7}#2#3#4#5%
}%
\def\XINT_div_sub_D #1#2\W\X\Y\Z
{%
    \expandafter\space
    \romannumeral0%
    \XINT_rord_main {}#2%
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax
    #1%
}%
\def\XINT_div_sub_C #1#2#3#4#5%
{%
    \xint_gob_til_W #2\xint_div_sub_cz\W
    \XINT_div_sub_AC_onestep {#5#4#3#2}{#1}%
}%
\def\XINT_div_sub_AC_onestep #1%
{%
    \expandafter\XINT_div_sub_backtoC\the\numexpr 11#1-\xint_c_i\relax.%
}%
\def\XINT_div_sub_backtoC #1#2#3.#4%
{%
    \XINT_div_sub_AC_checkcarry #2{#3#4}% la retenue va \^etre examin\'ee
}%
\def\XINT_div_sub_AC_checkcarry #1%
{%
    \xint_gob_til_one #1\xint_div_sub_AC_nocarry 1\XINT_div_sub_C 
}%
\def\xint_div_sub_AC_nocarry 1\XINT_div_sub_C #1#2\W\X\Y\Z
{%
    \expandafter\space
    \romannumeral0%
    \XINT_rord_main {}#2%
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax
    #1%
}%
\def\xint_div_sub_cz\W\XINT_div_sub_AC_onestep #1#2{ #2}%
\def\xint_div_sub_az\W\XINT_div_sub_B #1#2#3#4\Z { #3}%
%    \end{macrocode}
% \lverb|&
% &
% -----------------------------------------------------------------$\
% -----------------------------------------------------------------$\
% DECIMAL OPERATIONS: FIRST DIGIT, LASTDIGIT, ODDNESS,
% MULTIPLICATION BY TEN, QUOTIENT BY TEN, QUOTIENT OR
% MULTIPLICATION BY POWER OF TEN, SPLIT OPERATION.|
% \subsection{\csh{xintFDg}}
% \lverb|&
% FIRST DIGIT. Code simplified in 1.05.  
% And prepared for redefinition by xintfrac to parse through \xintNum|
%    \begin{macrocode}
\def\xintiFDg {\romannumeral0\xintifdg }%
\def\xintifdg #1%
{%
    \expandafter\XINT_fdg \romannumeral-`0#1\W\Z
}%
\let\xintFDg\xintiFDg \let\xintfdg\xintifdg
\def\XINT_FDg #1{\romannumeral0\XINT_fdg #1\W\Z }%
\def\XINT_fdg #1#2#3\Z
{%
    \xint_UDzerominusfork
      #1-\dummy  { 0}%   zero
      0#1\dummy  { #2}%  negative
       0-\dummy  { #1}%  positive
    \krof
}%
%    \end{macrocode}
% \subsection{\csh{xintLDg}}
% \lverb|&
% LAST DIGIT. Simplified in 1.05. And prepared for extension by xintfrac
%    to parse through \xintNum|
%    \begin{macrocode}
\def\xintiLDg {\romannumeral0\xintildg }%
\def\xintildg #1%
{%
    \expandafter\XINT_ldg\expandafter {\romannumeral-`0#1}%
}%
\let\xintLDg\xintiLDg \let\xintldg\xintildg
\def\XINT_LDg #1{\romannumeral0\XINT_ldg {#1}}%
\def\XINT_ldg #1%
{%
    \expandafter\XINT_ldg_\romannumeral0\XINT_rev {#1}\Z
}%
\def\XINT_ldg_ #1#2\Z{ #1}%
%    \end{macrocode}
% \subsection{\csh{xintMON}}
% \lverb|&
% MINUS ONE TO THE POWER N|
%    \begin{macrocode}
\def\xintiMON {\romannumeral0\xintimon }%
\def\xintimon #1%
{%
    \ifodd\xintiLDg {#1}
        \xint_afterfi{ -1}%
    \else
        \xint_afterfi{ 1}%
    \fi
}%
\def\xintiMMON {\romannumeral0\xintimmon }%
\def\xintimmon #1%
{%
    \ifodd\xintiLDg {#1}
        \xint_afterfi{ 1}%
    \else
        \xint_afterfi{ -1}%
    \fi
}%
\let\xintMON\xintiMON \let\xintmon\xintimon
\let\xintMMON\xintiMMON \let\xintmmon\xintimmon
%    \end{macrocode}
% \subsection{\csh{xintOdd}}
% \lverb|&
% ODDNESS. 1.05 defines \xintiOdd, so \xintOdd can be modified by
% xintfrac to parse through \xintNum.|
%    \begin{macrocode}
\def\xintiOdd {\romannumeral0\xintiodd }%
\def\xintiodd #1%
{%
    \ifodd\xintiLDg{#1}
        \xint_afterfi{ 1}%
    \else
        \xint_afterfi{ 0}%
    \fi
}%
\def\XINT_Odd #1%
{\romannumeral0%
    \ifodd\XINT_LDg{#1}
        \xint_afterfi{ 1}%
    \else
        \xint_afterfi{ 0}%
    \fi
}%
\let\xintOdd\xintiOdd \let\xintodd\xintiodd
%    \end{macrocode}
% \subsection{\csh{xintDSL}}
% \lverb|&
% DECIMAL SHIFT LEFT (=MULTIPLICATION PAR 10)|
%    \begin{macrocode}
\def\xintDSL {\romannumeral0\xintdsl }%
\def\xintdsl #1%
{%
    \expandafter\XINT_dsl \romannumeral-`0#1\Z
}%
\def\XINT_DSL #1{\romannumeral0\XINT_dsl #1\Z }%
\def\XINT_dsl #1%
{%
    \xint_gob_til_zero #1\xint_dsl_zero 0\XINT_dsl_ #1%
}%
\def\xint_dsl_zero 0\XINT_dsl_ 0#1\Z { 0}%
\def\XINT_dsl_ #1\Z { #10}%
%    \end{macrocode}
% \subsection{\csh{xintDSR}}
% \lverb|&
% DECIMAL SHIFT RIGHT (=DIVISION PAR 10)|
%    \begin{macrocode}
\def\xintDSR {\romannumeral0\xintdsr }%
\def\xintdsr #1%
{%
    \expandafter\XINT_dsr_a\expandafter {\romannumeral-`0#1}\W\Z
}%
\def\XINT_DSR #1{\romannumeral0\XINT_dsr_a {#1}\W\Z }%
\def\XINT_dsr_a
{%
    \expandafter\XINT_dsr_b\romannumeral0\XINT_rev
}%
\def\XINT_dsr_b #1#2#3\Z
{%
    \xint_gob_til_W #2\xint_dsr_onedigit\W
    \xint_minus #2\xint_dsr_onedigit-%
    \expandafter\XINT_dsr_removew
    \romannumeral0\XINT_rev {#2#3}%
}%
\def\xint_dsr_onedigit #1\XINT_rev #2{ 0}%
\def\XINT_dsr_removew #1\W { }%
%    \end{macrocode}
% \subsection{\csh{xintDSH}, \csh{xintDSHr}}
% \lverb+DECIMAL SHIFTS \xintDSH {x}{A}$\
% si x <= 0, fait A -> A.10^(|x|). v1.03 corrige l'oversight pour A=0.n 
% si x >  0, et A >=0, fait A -> quo(A,10^(x))$\
% si x >  0, et A < 0, fait A -> -quo(-A,10^(x))$\
% (donc pour x > 0 c'est comme DSR itéré x fois)$\
% \xintDSHr donne le `reste' (si x<=0 donne zéro).
%
% Release 1.06 now feeds x to a \numexpr first. I will revise the legacy code on
% another occasion.+
%    \begin{macrocode}
\def\xintDSHr {\romannumeral0\xintdshr }%
\def\xintdshr #1%
{%
    \expandafter\XINT_dshr_checkxpositive \the\numexpr #1\relax\Z
}%
\def\XINT_dshr_checkxpositive #1%
{%
    \xint_UDzerominusfork
      0#1\dummy \XINT_dshr_xzeroorneg
      #1-\dummy \XINT_dshr_xzeroorneg
       0-\dummy \XINT_dshr_xpositive
    \krof #1%
}%
\def\XINT_dshr_xzeroorneg #1\Z #2{ 0}%
\def\XINT_dshr_xpositive #1\Z 
{%
    \expandafter\xint_secondoftwo_andstop\romannumeral0\xintdsx {#1}%
}%
\def\xintDSH {\romannumeral0\xintdsh }%
\def\xintdsh #1#2%
{%
    \expandafter\xint_dsh\expandafter {\romannumeral-`0#2}{#1}%
}%
\def\xint_dsh #1#2%
{%
    \expandafter\XINT_dsh_checksignx \the\numexpr #2\relax\Z {#1}%
}%
\def\XINT_dsh_checksignx #1%
{%
    \xint_UDzerominusfork
      #1-\dummy  \XINT_dsh_xiszero
      0#1\dummy  \XINT_dsx_xisNeg_checkA     % on passe direct dans DSx
       0-\dummy  {\XINT_dsh_xisPos #1}%
    \krof
}%
\def\XINT_dsh_xiszero #1\Z #2{ #2}%
\def\XINT_dsh_xisPos #1\Z #2%
{%
    \expandafter\xint_firstoftwo_andstop
    \romannumeral0\XINT_dsx_checksignA #2\Z {#1}% via DSx
}%
%    \end{macrocode}
% \subsection{\csh{xintDSx}}
% \lverb+Je fais cette routine pour la version 1.01, après modification de
% \xintDecSplit. Dorénavant \xintDSx fera appel à \xintDecSplit et de même 
% \xintDSH fera appel à \xintDSx. J'ai donc supprimé entièrement l'ancien code
% de \xintDSH et re-écrit entièrement celui de \xintDecSplit pour x positif.
%
% --> Attention le cas x=0 est traité dans la même catégorie que x > 0 <--$\
% si x < 0, fait A -> A.10^(|x|)$\
% si x >=  0, et A >=0, fait A -> {quo(A,10^(x))}{rem(A,10^(x))}$\
% si x >=  0, et A < 0, d'abord on calcule {quo(-A,10^(x))}{rem(-A,10^(x))}$\
%    puis, si le premier n'est pas nul on lui donne le signe -$\
%          si le premier est nul on donne le signe - au second.
%
% On peut donc toujours reconstituer l'original A par 10^x Q \pm R
% où il faut prendre le signe plus si Q est positif ou nul et le signe moins si
% Q est strictement négatif.
%
% Release 1.06 has a faster and more compactly coded \XINT_dsx_zeroloop. 
% Also, x is now given to a \numexpr. The earlier code should be then
% simplified, but I leave as is for the time being. 
%
% In 1.07, I decide to modify
% the coding of \XINT_dsx_zeroloop, to avoid
% impacting the input stack (which prevented doing truncation or rounding or
% float with more than eight times the size of input stack; 40000 = 8x5000
% digits on my installation.) I think this was the only place in the code with
% such non tail recursion, as I recall being careful to avoid problems within
% the Factorial and Power routines, but I would need to check. Too tired now
% after having finished \xintexpr, \xintNewExpr, and \xintfloatexpr!+
%    \begin{macrocode}
\def\xintDSx {\romannumeral0\xintdsx }%
\def\xintdsx #1#2%
{%
    \expandafter\xint_dsx\expandafter {\romannumeral-`0#2}{#1}%
}%
\def\xint_dsx #1#2%
{%
    \expandafter\XINT_dsx_checksignx \the\numexpr #2\relax\Z {#1}%
}%
\def\XINT_DSx #1#2{\romannumeral0\XINT_dsx_checksignx #1\Z {#2}}%
\def\XINT_dsx #1#2{\XINT_dsx_checksignx #1\Z {#2}}%
\def\XINT_dsx_checksignx #1%
{%
    \xint_UDzerominusfork
      #1-\dummy  \XINT_dsx_xisZero
      0#1\dummy  \XINT_dsx_xisNeg_checkA
       0-\dummy  {\XINT_dsx_xisPos #1}%
    \krof
}%
\def\XINT_dsx_xisZero #1\Z #2{ {#2}{0}}% attention comme x > 0
\def\XINT_dsx_xisNeg_checkA #1\Z #2%
{%
    \XINT_dsx_xisNeg_checkA_ #2\Z {#1}%
}%
\def\XINT_dsx_xisNeg_checkA_ #1#2\Z #3%
{%
    \xint_gob_til_zero #1\XINT_dsx_xisNeg_Azero 0%
    \XINT_dsx_xisNeg_checkx {#3}{#3}{}\Z {#1#2}%
}%
\def\XINT_dsx_xisNeg_Azero #1\Z #2{ 0}%
\def\XINT_dsx_xisNeg_checkx #1%
{%
    \ifnum #1>999999999
       \xint_afterfi 
       {\xintError:TooBigDecimalShift
        \expandafter\space\expandafter 0\xint_gobble_iv }%
    \else 
       \expandafter \XINT_dsx_zeroloop 
    \fi
}%
\def\XINT_dsx_zeroloop #1#2%
{%
    \ifnum #1<9 \XINT_dsx_exita\fi
    \expandafter\XINT_dsx_zeroloop\expandafter 
        {\the\numexpr #1-8}{#200000000}%
}%
\def\XINT_dsx_exita\fi\expandafter\XINT_dsx_zeroloop 
{%
    \fi\expandafter\XINT_dsx_exitb
}%
\def\XINT_dsx_exitb #1#2%
{%
    \expandafter\expandafter\expandafter
    \XINT_dsx_addzeros\csname xint_gobble_\romannumeral -#1\endcsname #2%
}%
\def\XINT_dsx_addzeros #1\Z #2{ #2#1}%
\def\XINT_dsx_xisPos #1\Z #2%
{%
    \XINT_dsx_checksignA #2\Z {#1}%
}%
\def\XINT_dsx_checksignA #1%
{%
    \xint_UDzerominusfork
      #1-\dummy  \XINT_dsx_AisZero
      0#1\dummy  \XINT_dsx_AisNeg
       0-\dummy  {\XINT_dsx_AisPos #1}%
    \krof
}%
\def\XINT_dsx_AisZero #1\Z #2{ {0}{0}}%
\def\XINT_dsx_AisNeg #1\Z #2%
{%
    \expandafter\XINT_dsx_AisNeg_dosplit_andcheckfirst
    \romannumeral0\XINT_split_checksizex {#2}{#1}%
}%
\def\XINT_dsx_AisNeg_dosplit_andcheckfirst #1%
{%
    \XINT_dsx_AisNeg_checkiffirstempty #1\Z
}%
\def\XINT_dsx_AisNeg_checkiffirstempty #1%
{%
    \xint_gob_til_Z #1\XINT_dsx_AisNeg_finish_zero\Z
    \XINT_dsx_AisNeg_finish_notzero #1%
}%
\def\XINT_dsx_AisNeg_finish_zero\Z
    \XINT_dsx_AisNeg_finish_notzero\Z #1%
{%
    \expandafter\XINT_dsx_end
    \expandafter {\romannumeral0\XINT_num {-#1}}{0}%
}%
\def\XINT_dsx_AisNeg_finish_notzero #1\Z #2%
{%
    \expandafter\XINT_dsx_end
    \expandafter {\romannumeral0\XINT_num {#2}}{-#1}%
}%
\def\XINT_dsx_AisPos #1\Z #2%
{%
    \expandafter\XINT_dsx_AisPos_finish
    \romannumeral0\XINT_split_checksizex {#2}{#1}%
}%
\def\XINT_dsx_AisPos_finish #1#2%
{%
    \expandafter\XINT_dsx_end
    \expandafter {\romannumeral0\XINT_num {#2}}%
                 {\romannumeral0\XINT_num {#1}}%
}%
\def\XINT_dsx_end #1#2%
{%
    \expandafter\space\expandafter{#2}{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintDecSplit},~\csh{xintDecSplitL},~\csh{xintDecSplitR}}
% \lverb!DECIMAL SPLIT
%
% The macro \xintDecSplit {x}{A} first replaces A with |A| (*)
% This macro cuts the number into two pieces L and R. The concatenation LR
% always reproduces |A|, and R may be empty or have leading zeros. The
% position of the cut is specified by the first argument x. If x is zero or
% positive the cut location is x slots to the left of the right end of the
% number. If x becomes equal to or larger than the length of the number then L
% becomes empty. If x is negative the location of the cut is |x| slots to the
% right of the left end of the number. 
%
% (*) warning: this may change in a future version. Only the behavior
% for A non-negative is guaranteed to remain the same.
%
% v1.05a: \XINT_split_checksizex does not compute the length anymore, rather the
% error will be from a \numexpr; but the limit of 999999999 does not make much
% sense. 
%
% v1.06: Improvements in \XINT_split_fromleft_loop, \XINT_split_fromright_loop
% and related macros. More readable coding, speed gains.
% Also, I now feed immediately a \numexpr with x. Some simplifications should
% probably be made to the code, which is kept as is for the time being.!
%    \begin{macrocode}
\def\xintDecSplitL {\romannumeral0\xintdecsplitl }%
\def\xintDecSplitR {\romannumeral0\xintdecsplitr }%
\def\xintdecsplitl 
{%
    \expandafter\xint_firstoftwo_andstop
    \romannumeral0\xintdecsplit 
}%
\def\xintdecsplitr 
{%
    \expandafter\xint_secondoftwo_andstop
    \romannumeral0\xintdecsplit 
}%
\def\xintDecSplit {\romannumeral0\xintdecsplit }%
\def\xintdecsplit #1#2%
{%
    \expandafter \xint_split \expandafter
    {\romannumeral0\xintiabs {#2}}{#1}%  fait expansion de A
}%
\def\xint_split #1#2%
{%
    \expandafter\XINT_split_checksizex\expandafter{\the\numexpr #2}{#1}% 
}%
\def\XINT_split_checksizex #1% 999999999 is anyhow very big, could be reduced
{%
    \ifnum\numexpr\XINT_Abs{#1}>999999999 
       \xint_afterfi {\xintError:TooBigDecimalSplit\XINT_split_bigx }%
    \else
       \expandafter\XINT_split_xfork
    \fi
    #1\Z
}%
\def\XINT_split_bigx  #1\Z #2%
{%
    \ifcase\XINT_Sgn {#1}
    \or \xint_afterfi { {}{#2}}% positive big x
    \else  
        \xint_afterfi { {#2}{}}% negative big x
    \fi
}%
\def\XINT_split_xfork #1%
{%
    \xint_UDzerominusfork
      #1-\dummy  \XINT_split_zerosplit
      0#1\dummy  \XINT_split_fromleft
       0-\dummy  {\XINT_split_fromright #1}%
    \krof
}%
\def\XINT_split_zerosplit #1\Z #2{ {#2}{}}%
\def\XINT_split_fromleft  #1\Z #2%
{%
    \XINT_split_fromleft_loop {#1}{}#2\W\W\W\W\W\W\W\W\Z 
}%
\def\XINT_split_fromleft_loop #1%
{%
    \ifnum #1<8 \XINT_split_fromleft_exita\fi
    \expandafter\XINT_split_fromleft_loop_perhaps\expandafter
    {\the\numexpr #1-8\expandafter}\XINT_split_fromleft_eight
}%
\def\XINT_split_fromleft_eight #1#2#3#4#5#6#7#8#9{#9{#1#2#3#4#5#6#7#8#9}}%
\def\XINT_split_fromleft_loop_perhaps #1#2%
{%
    \xint_gob_til_W #2\XINT_split_fromleft_toofar\W
    \XINT_split_fromleft_loop {#1}%
}%
\def\XINT_split_fromleft_toofar\W\XINT_split_fromleft_loop #1#2#3\Z
{%
    \XINT_split_fromleft_toofar_b #2\Z
}%
\def\XINT_split_fromleft_toofar_b #1\W #2\Z { {#1}{}}%
\def\XINT_split_fromleft_exita\fi
    \expandafter\XINT_split_fromleft_loop_perhaps\expandafter #1#2%
   {\fi \XINT_split_fromleft_exitb #1}%
\def\XINT_split_fromleft_exitb\the\numexpr #1-8\expandafter
{%
    \csname XINT_split_fromleft_endsplit_\romannumeral #1\endcsname
}%
\def\XINT_split_fromleft_endsplit_ #1#2\W #3\Z { {#1}{#2}}%
\def\XINT_split_fromleft_endsplit_i #1#2%
                {\XINT_split_fromleft_checkiftoofar #2{#1#2}}%
\def\XINT_split_fromleft_endsplit_ii #1#2#3%
                {\XINT_split_fromleft_checkiftoofar #3{#1#2#3}}%
\def\XINT_split_fromleft_endsplit_iii #1#2#3#4%
                {\XINT_split_fromleft_checkiftoofar #4{#1#2#3#4}}%
\def\XINT_split_fromleft_endsplit_iv #1#2#3#4#5%
                {\XINT_split_fromleft_checkiftoofar #5{#1#2#3#4#5}}%
\def\XINT_split_fromleft_endsplit_v #1#2#3#4#5#6%
                {\XINT_split_fromleft_checkiftoofar #6{#1#2#3#4#5#6}}%
\def\XINT_split_fromleft_endsplit_vi #1#2#3#4#5#6#7%
                {\XINT_split_fromleft_checkiftoofar #7{#1#2#3#4#5#6#7}}%
\def\XINT_split_fromleft_endsplit_vii #1#2#3#4#5#6#7#8%
                {\XINT_split_fromleft_checkiftoofar #8{#1#2#3#4#5#6#7#8}}%
\def\XINT_split_fromleft_checkiftoofar #1#2#3\W #4\Z 
{%
    \xint_gob_til_W #1\XINT_split_fromleft_wenttoofar\W
    \space {#2}{#3}%
}%
\def\XINT_split_fromleft_wenttoofar\W\space #1%
{%
    \XINT_split_fromleft_wenttoofar_b #1\Z
}%
\def\XINT_split_fromleft_wenttoofar_b #1\W #2\Z { {#1}}%
\def\XINT_split_fromright #1\Z #2%
{%
    \expandafter \XINT_split_fromright_a \expandafter
    {\romannumeral0\XINT_rev {#2}}{#1}{#2}%
}%
\def\XINT_split_fromright_a #1#2%
{%
    \XINT_split_fromright_loop {#2}{}#1\W\W\W\W\W\W\W\W\Z
}%
\def\XINT_split_fromright_loop #1%
{%
    \ifnum #1<8 \XINT_split_fromright_exita\fi
    \expandafter\XINT_split_fromright_loop_perhaps\expandafter
    {\the\numexpr #1-8\expandafter }\XINT_split_fromright_eight
}%
\def\XINT_split_fromright_eight #1#2#3#4#5#6#7#8#9{#9{#9#8#7#6#5#4#3#2#1}}%
\def\XINT_split_fromright_loop_perhaps #1#2%
{%
    \xint_gob_til_W #2\XINT_split_fromright_toofar\W
    \XINT_split_fromright_loop {#1}%
}%
\def\XINT_split_fromright_toofar\W\XINT_split_fromright_loop #1#2#3\Z { {}}%
\def\XINT_split_fromright_exita\fi
    \expandafter\XINT_split_fromright_loop_perhaps\expandafter #1#2%
    {\fi \XINT_split_fromright_exitb #1}%
\def\XINT_split_fromright_exitb\the\numexpr #1-8\expandafter
{%
    \csname XINT_split_fromright_endsplit_\romannumeral #1\endcsname
}%
\def\XINT_split_fromright_endsplit_ #1#2\W #3\Z #4%
{%
    \expandafter\space\expandafter {\romannumeral0\XINT_rev{#2}}{#1}%
}%
\def\XINT_split_fromright_endsplit_i   #1#2%
            {\XINT_split_fromright_checkiftoofar #2{#2#1}}%
\def\XINT_split_fromright_endsplit_ii  #1#2#3%
            {\XINT_split_fromright_checkiftoofar #3{#3#2#1}}%
\def\XINT_split_fromright_endsplit_iii #1#2#3#4%
            {\XINT_split_fromright_checkiftoofar #4{#4#3#2#1}}%
\def\XINT_split_fromright_endsplit_iv  #1#2#3#4#5%
            {\XINT_split_fromright_checkiftoofar #5{#5#4#3#2#1}}%
\def\XINT_split_fromright_endsplit_v   #1#2#3#4#5#6%
            {\XINT_split_fromright_checkiftoofar #6{#6#5#4#3#2#1}}%
\def\XINT_split_fromright_endsplit_vi  #1#2#3#4#5#6#7%
            {\XINT_split_fromright_checkiftoofar #7{#7#6#5#4#3#2#1}}%
\def\XINT_split_fromright_endsplit_vii #1#2#3#4#5#6#7#8%
            {\XINT_split_fromright_checkiftoofar #8{#8#7#6#5#4#3#2#1}}%
\def\XINT_split_fromright_checkiftoofar #1%
{%
    \xint_gob_til_W #1\XINT_split_fromright_wenttoofar\W
    \XINT_split_fromright_endsplit_
}%
\def\XINT_split_fromright_wenttoofar\W\XINT_split_fromright_endsplit_ #1\Z #2%
    { {}{#2}}%
%    \end{macrocode}
% \subsection{\csh{xintDouble}}
% \lverb!v1.08!
%    \begin{macrocode}
\def\xintDouble {\romannumeral0\xintdouble }%
\def\xintdouble #1%
{%
     \expandafter\XINT_dbl\romannumeral-`0#1%
     \R\R\R\R\R\R\R\Z \W\W\W\W\W\W\W 
}%
\def\XINT_dbl #1%
{%
    \xint_UDzerominusfork
      #1-\dummy  \XINT_dbl_zero
      0#1\dummy  \XINT_dbl_neg
       0-\dummy {\XINT_dbl_pos #1}%
    \krof
}%
\def\XINT_dbl_zero #1\Z \W\W\W\W\W\W\W { 0}%
\def\XINT_dbl_neg 
   {\expandafter\xint_minus_andstop\romannumeral0\XINT_dbl_pos }%
\def\XINT_dbl_pos 
{%
    \expandafter\XINT_dbl_a \expandafter{\expandafter}\expandafter 0%
    \romannumeral0\XINT_SQ {}% 
}%
\def\XINT_dbl_a #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_W #9\XINT_dbl_end_a\W
    \expandafter\XINT_dbl_b
    \the\numexpr \xint_c_x^viii+#2+\xint_c_ii*#9#8#7#6#5#4#3\relax {#1}%
}%
\def\XINT_dbl_b 1#1#2#3#4#5#6#7#8#9%
{%
    \XINT_dbl_a {#2#3#4#5#6#7#8#9}{#1}%
}%
\def\XINT_dbl_end_a #1+#2+#3\relax #4%
{%
    \expandafter\XINT_dbl_end_b #2#4%
}%
\def\XINT_dbl_end_b #1#2#3#4#5#6#7#8%
{%
    \expandafter\space\the\numexpr #1#2#3#4#5#6#7#8\relax
}%
%    \end{macrocode}
% \subsection{\csh{xintHalf}}
% \lverb!v1.08!
%    \begin{macrocode}
\def\xintHalf {\romannumeral0\xinthalf }%
\def\xinthalf #1%
{%
     \expandafter\XINT_half\romannumeral-`0#1%
     \R\R\R\R\R\R\R\Z \W\W\W\W\W\W\W 
}%
\def\XINT_half #1%
{%
    \xint_UDzerominusfork
      #1-\dummy  \XINT_half_zero
      0#1\dummy  \XINT_half_neg
       0-\dummy {\XINT_half_pos #1}%
    \krof
}%
\def\XINT_half_zero #1\Z \W\W\W\W\W\W\W { 0}%
\def\XINT_half_neg {\expandafter\XINT_opp\romannumeral0\XINT_half_pos }%
\def\XINT_half_pos {\expandafter\XINT_half_a\romannumeral0\XINT_SQ {}}%
\def\XINT_half_a #1#2#3#4#5#6#7#8%
{%
    \xint_gob_til_W #8\XINT_half_dont\W
    \expandafter\XINT_half_b
    \the\numexpr \xint_c_x^viii+\xint_c_v*#7#6#5#4#3#2#1\relax #8%
}%
\def\XINT_half_dont\W\expandafter\XINT_half_b
    \the\numexpr \xint_c_x^viii+\xint_c_v*#1#2#3#4#5#6#7\relax \W\W\W\W\W\W\W
{%
    \expandafter\space
    \the\numexpr (#1#2#3#4#5#6#7+\xint_c_i)/\xint_c_ii-\xint_c_i \relax
}%
\def\XINT_half_b 1#1#2#3#4#5#6#7#8%
{%
    \XINT_half_c {#2#3#4#5#6#7}{#1}%
}%
\def\XINT_half_c #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_W #3\XINT_half_end_a #2\W
    \expandafter\XINT_half_d
    \the\numexpr \xint_c_x^viii+\xint_c_v*#9#8#7#6#5#4#3+#2\relax {#1}%
}%
\def\XINT_half_d 1#1#2#3#4#5#6#7#8#9%
{%
    \XINT_half_c {#2#3#4#5#6#7#8#9}{#1}%
}%
\def\XINT_half_end_a #1\W #2\relax #3%
{%
    \xint_gob_til_zero #1\XINT_half_end_b 0\space #1#3%
}%
\def\XINT_half_end_b 0\space 0#1#2#3#4#5#6#7%
{%
    \expandafter\space\the\numexpr #1#2#3#4#5#6#7\relax
}%
%    \end{macrocode}
% \subsection{\csh{xintDec}}
% \lverb!v1.08!
%    \begin{macrocode}
\def\xintDec {\romannumeral0\xintdec }%
\def\xintdec #1%
{%
     \expandafter\XINT_dec\romannumeral-`0#1%
     \R\R\R\R\R\R\R\R\Z \W\W\W\W\W\W\W\W 
}%
\def\XINT_dec #1%
{%
    \xint_UDzerominusfork
      #1-\dummy  \XINT_dec_zero
      0#1\dummy  \XINT_dec_neg
       0-\dummy {\XINT_dec_pos #1}%
    \krof
}%
\def\XINT_dec_zero #1\W\W\W\W\W\W\W\W { -1}%
\def\XINT_dec_neg 
   {\expandafter\xint_minus_andstop\romannumeral0\XINT_inc_pos }%
\def\XINT_dec_pos
{%
    \expandafter\XINT_dec_a \expandafter{\expandafter}%
    \romannumeral0\XINT_OQ {}%
}%
\def\XINT_dec_a #1#2#3#4#5#6#7#8#9%
{%
    \expandafter\XINT_dec_b
    \the\numexpr 11#9#8#7#6#5#4#3#2-\xint_c_i\relax {#1}%
}%
\def\XINT_dec_b 1#1%
{%
    \xint_gob_til_one #1\XINT_dec_A 1\XINT_dec_c 
}%
\def\XINT_dec_c #1#2#3#4#5#6#7#8#9{\XINT_dec_a {#1#2#3#4#5#6#7#8#9}}%
\def\XINT_dec_A 1\XINT_dec_c #1#2#3#4#5#6#7#8#9%
   {\XINT_dec_B {#1#2#3#4#5#6#7#8#9}}%
\def\XINT_dec_B #1#2\W\W\W\W\W\W\W\W 
{% 
    \expandafter\XINT_dec_cleanup
    \romannumeral0\XINT_rord_main {}#2%
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax
    #1%
}%
\def\XINT_dec_cleanup #1#2#3#4#5#6#7#8%
{\expandafter\space\the\numexpr #1#2#3#4#5#6#7#8\relax }%
%    \end{macrocode}
% \subsection{\csh{xintInc}}
% \lverb!v1.08!
%    \begin{macrocode}
\def\xintInc {\romannumeral0\xintinc }%
\def\xintinc #1%
{%
     \expandafter\XINT_inc\romannumeral-`0#1%
     \R\R\R\R\R\R\R\R\Z \W\W\W\W\W\W\W\W
}%
\def\XINT_inc #1%
{%
    \xint_UDzerominusfork
      #1-\dummy  \XINT_inc_zero
      0#1\dummy  \XINT_inc_neg
       0-\dummy {\XINT_inc_pos #1}%
    \krof
}%
\def\XINT_inc_zero #1\W\W\W\W\W\W\W\W { 1}%
\def\XINT_inc_neg {\expandafter\XINT_opp\romannumeral0\XINT_dec_pos }%
\def\XINT_inc_pos
{%
    \expandafter\XINT_inc_a \expandafter{\expandafter}%
    \romannumeral0\XINT_OQ {}%
}%
\def\XINT_inc_a #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_W #9\XINT_inc_end\W
    \expandafter\XINT_inc_b
    \the\numexpr 10#9#8#7#6#5#4#3#2+\xint_c_i\relax {#1}%
}%
\def\XINT_inc_b 1#1%
{%
    \xint_gob_til_zero #1\XINT_inc_A 0\XINT_inc_c 
}%
\def\XINT_inc_c #1#2#3#4#5#6#7#8#9{\XINT_inc_a {#1#2#3#4#5#6#7#8#9}}%
\def\XINT_inc_A 0\XINT_inc_c #1#2#3#4#5#6#7#8#9%
               {\XINT_dec_B {#1#2#3#4#5#6#7#8#9}}%
\def\XINT_inc_end\W #1\relax #2{ 1#2}%
%    \end{macrocode}
% \subsection{\csh{xintiSqrt}, \csh{xintiSquareRoot}}
% \lverb!v1.08!
%    \begin{macrocode}
\def\XINT_dsx_addzerosnofuss #1{\XINT_dsx_zeroloop {#1}{}\Z }%
\def\xintiSqrt {\romannumeral0\xintisqrt }%
\def\xintisqrt
    {\expandafter\XINT_sqrt_post\romannumeral0\xintisquareroot }%
\def\XINT_sqrt_post #1#2{\XINT_dec_pos #1\R\R\R\R\R\R\R\R\Z
                                         \W\W\W\W\W\W\W\W }%
\def\xintiSquareRoot {\romannumeral0\xintisquareroot }%
\def\xintisquareroot #1%
    {\expandafter\XINT_sqrt_checkin\romannumeral-`0#1\Z}%
\def\XINT_sqrt_checkin #1%
{%
    \xint_UDzerominusfork
     #1-\dummy  \XINT_sqrt_iszero
     0#1\dummy  \XINT_sqrt_isneg
      0-\dummy {\XINT_sqrt #1}%
    \krof
}%
\def\XINT_sqrt_iszero #1\Z { 0}%
\def\XINT_sqrt_isneg  #1\Z {\xintError:RootOfNegative\space 0}%
\def\XINT_sqrt #1\Z
{%
    \expandafter\XINT_sqrt_start\expandafter
    {\romannumeral0\XINT_length {#1}}{#1}%
}%
\def\XINT_sqrt_start #1%
{%
    \ifnum #1<\xint_c_x
       \expandafter\XINT_sqrt_small_a
    \else
       \expandafter\XINT_sqrt_big_a
    \fi
    {#1}%
}%
\def\XINT_sqrt_small_a #1{\XINT_sqrt_a {#1}\XINT_sqrt_small_d }%
\def\XINT_sqrt_big_a   #1{\XINT_sqrt_a {#1}\XINT_sqrt_big_d   }%
\def\XINT_sqrt_a #1%
{%
   \ifodd #1
     \expandafter\XINT_sqrt_bB
   \else
     \expandafter\XINT_sqrt_bA
   \fi
   {#1}%
}%
\def\XINT_sqrt_bA #1#2#3%
{%
    \XINT_sqrt_bA_b #3\Z #2{#1}{#3}%
}%
\def\XINT_sqrt_bA_b #1#2#3\Z 
{%
    \XINT_sqrt_c {#1#2}%
}%
\def\XINT_sqrt_bB #1#2#3%
{%
    \XINT_sqrt_bB_b #3\Z #2{#1}{#3}%
}%
\def\XINT_sqrt_bB_b #1#2\Z 
{%
    \XINT_sqrt_c #1%
}%
\def\XINT_sqrt_c #1#2%
{%
    \expandafter #2%
    \ifcase #1
    \or 2\or 2\or 2\or 3\or 3\or 3\or 3\or 3\or %3+5
    4\or 4\or 4\or 4\or 4\or 4\or 4\or           %+7
    5\or 5\or 5\or 5\or 5\or 5\or 5\or 5\or 5\or %+9
    6\or 6\or 6\or 6\or 6\or 6\or 6\or 6\or 6\or 6\or 6\or %+11
    7\or 7\or 7\or 7\or 7\or 7\or 7\or 7\or 7\or 7\or 7\or 7\or 7\or %+13
    8\or 8\or 8\or 8\or 8\or 8\or 8\or 
    8\or 8\or 8\or 8\or 8\or 8\or 8\or 8\or %+15
    9\or 9\or 9\or 9\or 9\or 9\or 9\or 9\or 
    9\or 9\or 9\or 9\or 9\or 9\or 9\or 9\or 9\or %+17
    10\or 10\or 10\or 10\or 10\or 10\or 10\or 10\or 10\or
    10\or 10\or 10\or 10\or 10\or 10\or 10\or 10\or 10\or 10\or\fi %+19
}%
\def\XINT_sqrt_small_d #1\or #2\fi #3%
{%
   \fi
   \expandafter\XINT_sqrt_small_de
   \ifcase \numexpr #3/\xint_c_ii-\xint_c_i\relax
      {}%
   \or
      0%
   \or 
      {00}%
   \or
      {000}%
   \or
      {0000}%
   \or
   \fi {#1}%
}%
\def\XINT_sqrt_small_de #1\or #2\fi #3%
{%
    \fi\XINT_sqrt_small_e {#3#1}%
}%
\def\XINT_sqrt_small_e #1#2%
{%
   \expandafter\XINT_sqrt_small_f\expandafter {\the\numexpr #1*#1-#2}{#1}%
}%
\def\XINT_sqrt_small_f #1#2%
{%
   \expandafter\XINT_sqrt_small_g\expandafter
   {\the\numexpr ((#1+#2)/(\xint_c_ii*#2))-\xint_c_i}{#1}{#2}%
}%
\def\XINT_sqrt_small_g #1%
{%
    \ifnum #1>\xint_c_
       \expandafter\XINT_sqrt_small_h
    \else
       \expandafter\XINT_sqrt_small_end
    \fi
    {#1}%
}%
\def\XINT_sqrt_small_h #1#2#3%
{%
    \expandafter\XINT_sqrt_small_f\expandafter
    {\the\numexpr #2-\xint_c_ii*#1*#3+#1*#1\expandafter}\expandafter
    {\the\numexpr #3-#1}%
}%
\def\XINT_sqrt_small_end #1#2#3{ {#3}{#2}}%
\def\XINT_sqrt_big_d #1\or #2\fi #3% 
{%
   \fi
   \ifodd #3
     \xint_afterfi{\expandafter\XINT_sqrt_big_eB}%
   \else
     \xint_afterfi{\expandafter\XINT_sqrt_big_eA}%
   \fi
   \expandafter{\the\numexpr #3/\xint_c_ii }{#1}% 
}%
\def\XINT_sqrt_big_eA  #1#2#3%
{%
    \XINT_sqrt_big_eA_a #3\Z {#2}{#1}{#3}%
}%
\def\XINT_sqrt_big_eA_a #1#2#3#4#5#6#7#8#9\Z 
{%
    \XINT_sqrt_big_eA_b {#1#2#3#4#5#6#7#8}%
}%
\def\XINT_sqrt_big_eA_b #1#2%
{%
    \expandafter\XINT_sqrt_big_f
    \romannumeral0\XINT_sqrt_small_e {#2000}{#1}{#1}%
}%
\def\XINT_sqrt_big_eB #1#2#3%
{%
    \XINT_sqrt_big_eB_a #3\Z {#2}{#1}{#3}%
}%
\def\XINT_sqrt_big_eB_a #1#2#3#4#5#6#7#8#9%
{%
    \XINT_sqrt_big_eB_b {#1#2#3#4#5#6#7#8#9}%
}%
\def\XINT_sqrt_big_eB_b #1#2\Z #3%
{%
    \expandafter\XINT_sqrt_big_f
    \romannumeral0\XINT_sqrt_small_e {#30000}{#1}{#1}%
}%
\def\XINT_sqrt_big_f #1#2#3#4%
{%
   \expandafter\XINT_sqrt_big_f_a\expandafter
   {\the\numexpr #2+#3\expandafter}\expandafter
   {\romannumeral-`0\XINT_dsx_addzerosnofuss 
                    {\numexpr #4-\xint_c_iv\relax}{#1}}{#4}%
}%
\def\XINT_sqrt_big_f_a #1#2#3#4%
{%
   \expandafter\XINT_sqrt_big_g\expandafter
   {\romannumeral0\xintisub 
       {\XINT_dsx_addzerosnofuss 
        {\numexpr \xint_c_ii*#3-\xint_c_viii\relax}{#1}}{#4}}%
   {#2}{#3}% 
}%
\def\XINT_sqrt_big_g #1#2%
{%
    \expandafter\XINT_sqrt_big_j
    \romannumeral0\xintidivision{#1}
        {\romannumeral0\XINT_dbl_pos #2\R\R\R\R\R\R\R\Z \W\W\W\W\W\W\W }{#2}%
}%
\def\XINT_sqrt_big_j #1%
{%
    \ifcase\XINT_Sgn {#1}
        \expandafter \XINT_sqrt_big_end
    \or \expandafter \XINT_sqrt_big_k
    \fi {#1}%
}%
\def\XINT_sqrt_big_k #1#2#3%
{%
    \expandafter\XINT_sqrt_big_l\expandafter
    {\romannumeral0\xintisub {#3}{#1}}%
    {\romannumeral0\xintiadd {#2}{\xintiSqr {#1}}}%
}%
\def\XINT_sqrt_big_l #1#2%
{%
   \expandafter\XINT_sqrt_big_g\expandafter
   {#2}{#1}%
}%
\def\XINT_sqrt_big_end #1#2#3#4{ {#3}{#2}}%
\XINT_restorecatcodes_endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xint>\relax
%\def<*xintbinhex>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xint>
%<*xintbinhex>
% \section{Package \xintbinhexname implementation}
% 
% The commenting is currently (\docdate) very sparse.
%
% \localtableofcontents
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
%
% The code for reload detection is copied from \textsc{Heiko
% Oberdiek}'s packages, and adapted here to check for previous
% loading of the master \xintname package.
%
% The method for catcodes is slightly different, but still
% directly inspired by these packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \def\space { }%
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xintbinhex.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xint.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintbinhex}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintbinhex.sty
      \ifx\w\relax % but xint.sty not yet loaded.
         \y{xintbinhex}{Package xint is required}%
         \y{xintbinhex}{Will try \string\input\space xint.sty}%
         \def\z{\endgroup\input xint.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xint.sty not yet loaded.
            \y{xintbinhex}{Package xint is required}%
            \y{xintbinhex}{Will try \string\RequirePackage{xint}}%
            \def\z{\endgroup\RequirePackage{xint}}%
          \fi
      \else
        \y{xintbinhex}{I was already loaded, aborting input}%
        \aftergroup\endinput
      \fi
    \fi
  \fi
\z%
%    \end{macrocode}
% \subsection{Confirmation of \xintname loading}
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \def\empty {}%
  \expandafter\let\expandafter\w\csname ver@xint.sty\endcsname
  \ifx\w\relax % Plain TeX, user gave a file name at the prompt
      \y{xintbinhex}{Loading of package xint failed, aborting input}%
      \aftergroup\endinput
  \fi
  \ifx\w\empty % LaTeX, user gave a file name at the prompt
      \y{xintbinhex}{Loading of package xint failed, aborting input}%
      \aftergroup\endinput
  \fi
\endgroup%
%    \end{macrocode}
% \subsection{Catcodes}
%
% Perhaps catcodes have changed after the loading of \xintname
% and prior to the current loading of \xintbinhexname, so we can not employ
% the |\XINT_restorecatcodes_endinput| in this style file. But
% there is no problem using |\XINT_setcatcodes|.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode95=11   % _
  \def\x
  {%
      \endgroup
      \edef\XINT_binhex_restorecatcodes_endinput
      {%
        \catcode94=\the\catcode94   % ^
        \catcode96=\the\catcode96   % `
        \catcode47=\the\catcode47   % /
        \catcode41=\the\catcode41   % )
        \catcode40=\the\catcode40   % (
        \catcode42=\the\catcode42   % *
        \catcode43=\the\catcode43   % +
        \catcode62=\the\catcode62   % >
        \catcode60=\the\catcode60   % <
        \catcode58=\the\catcode58   % :
        \catcode46=\the\catcode46   % .
        \catcode45=\the\catcode45   % -
        \catcode44=\the\catcode44   % ,
        \catcode35=\the\catcode35   % #
        \catcode95=\the\catcode95   % _
        \catcode125=\the\catcode125 % }
        \catcode123=\the\catcode123 % {
        \endlinechar=\the\endlinechar
        \catcode13=\the\catcode13   % ^^M
        \catcode32=\the\catcode32   % 
        \catcode61=\the\catcode61\relax   % =
        \noexpand\endinput
      }%
      \XINT_setcatcodes % defined in xint.sty
  }%
\x
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\begingroup
  \catcode64=11 % @
  \catcode91=12 % [
  \catcode93=12 % ]
  \catcode58=12 % :
  \expandafter\ifx\csname ProvidesPackage\endcsname\relax
    \def\x#1#2#3[#4]{\endgroup
      \immediate\write-1{Package: #3 #4}%
      \xdef#1{#4}%
    }%
  \else
    \def\x#1#2[#3]{\endgroup
      #2[{#3}]%
      \ifx#1\@undefined
        \xdef#1{#3}%
      \fi
      \ifx#1\relax
        \xdef#1{#3}%
      \fi
    }%
  \fi
\expandafter\x\csname ver@xintbinhex.sty\endcsname
\ProvidesPackage{xintbinhex}%
  [2013/06/14 v1.08b Expandable binary and hexadecimal conversions (jfB)]%
%    \end{macrocode}
% \subsection{Constants, etc...}
% \lverb!v1.08!
%    \begin{macrocode}
\chardef\xint_c_xvi           16
\chardef\xint_c_ii^v          32
\chardef\xint_c_ii^vi         64
\chardef\xint_c_ii^vii       128
\mathchardef\xint_c_ii^viii  256
\mathchardef\xint_c_ii^xii  4096
\newcount\xint_c_ii^xv  \xint_c_ii^xv  32768
\newcount\xint_c_ii^xvi \xint_c_ii^xvi 65536
\newcount\xint_c_x^v    \xint_c_x^v    100000
\newcount\xint_c_x^ix   \xint_c_x^ix   1000000000
\def\XINT_tmp_def #1{%
  \expandafter\edef\csname XINT_sdth_#1\endcsname
  {\ifcase #1 0\or 1\or 2\or 3\or 4\or 5\or 6\or 7\or
              8\or 9\or A\or B\or C\or D\or E\or F\fi}}%
\xintApplyUnbraced\XINT_tmp_def 
    {{0}{1}{2}{3}{4}{5}{6}{7}{8}{9}{10}{11}{12}{13}{14}{15}}%
\def\XINT_tmp_def #1{%
  \expandafter\edef\csname XINT_sdtb_#1\endcsname
  {\ifcase #1 
   0000\or 0001\or 0010\or 0011\or 0100\or 0101\or 0110\or 0111\or
   1000\or 1001\or 1010\or 1011\or 1100\or 1101\or 1110\or 1111\fi}}%
\xintApplyUnbraced\XINT_tmp_def 
    {{0}{1}{2}{3}{4}{5}{6}{7}{8}{9}{10}{11}{12}{13}{14}{15}}%
\let\XINT_tmp_def\empty
\expandafter\def\csname XINT_sbtd_0000\endcsname {0}%
\expandafter\def\csname XINT_sbtd_0001\endcsname {1}%
\expandafter\def\csname XINT_sbtd_0010\endcsname {2}%
\expandafter\def\csname XINT_sbtd_0011\endcsname {3}%
\expandafter\def\csname XINT_sbtd_0100\endcsname {4}%
\expandafter\def\csname XINT_sbtd_0101\endcsname {5}%
\expandafter\def\csname XINT_sbtd_0110\endcsname {6}%
\expandafter\def\csname XINT_sbtd_0111\endcsname {7}%
\expandafter\def\csname XINT_sbtd_1000\endcsname {8}%
\expandafter\def\csname XINT_sbtd_1001\endcsname {9}%
\expandafter\def\csname XINT_sbtd_1010\endcsname {10}%
\expandafter\def\csname XINT_sbtd_1011\endcsname {11}%
\expandafter\def\csname XINT_sbtd_1100\endcsname {12}%
\expandafter\def\csname XINT_sbtd_1101\endcsname {13}%
\expandafter\def\csname XINT_sbtd_1110\endcsname {14}%
\expandafter\def\csname XINT_sbtd_1111\endcsname {15}%
\expandafter\let\csname XINT_sbth_0000\expandafter\endcsname
                \csname XINT_sbtd_0000\endcsname
\expandafter\let\csname XINT_sbth_0001\expandafter\endcsname
                \csname XINT_sbtd_0001\endcsname
\expandafter\let\csname XINT_sbth_0010\expandafter\endcsname
                \csname XINT_sbtd_0010\endcsname
\expandafter\let\csname XINT_sbth_0011\expandafter\endcsname
                \csname XINT_sbtd_0011\endcsname
\expandafter\let\csname XINT_sbth_0100\expandafter\endcsname
                \csname XINT_sbtd_0100\endcsname
\expandafter\let\csname XINT_sbth_0101\expandafter\endcsname
                \csname XINT_sbtd_0101\endcsname
\expandafter\let\csname XINT_sbth_0110\expandafter\endcsname
                \csname XINT_sbtd_0110\endcsname
\expandafter\let\csname XINT_sbth_0111\expandafter\endcsname
                \csname XINT_sbtd_0111\endcsname
\expandafter\let\csname XINT_sbth_1000\expandafter\endcsname
                \csname XINT_sbtd_1000\endcsname
\expandafter\let\csname XINT_sbth_1001\expandafter\endcsname
                \csname XINT_sbtd_1001\endcsname
\expandafter\def\csname XINT_sbth_1010\endcsname {A}%
\expandafter\def\csname XINT_sbth_1011\endcsname {B}%
\expandafter\def\csname XINT_sbth_1100\endcsname {C}%
\expandafter\def\csname XINT_sbth_1101\endcsname {D}%
\expandafter\def\csname XINT_sbth_1110\endcsname {E}%
\expandafter\def\csname XINT_sbth_1111\endcsname {F}%
\expandafter\def\csname XINT_shtb_0\endcsname {0000}%
\expandafter\def\csname XINT_shtb_1\endcsname {0001}%
\expandafter\def\csname XINT_shtb_2\endcsname {0010}%
\expandafter\def\csname XINT_shtb_3\endcsname {0011}%
\expandafter\def\csname XINT_shtb_4\endcsname {0100}%
\expandafter\def\csname XINT_shtb_5\endcsname {0101}%
\expandafter\def\csname XINT_shtb_6\endcsname {0110}%
\expandafter\def\csname XINT_shtb_7\endcsname {0111}%
\expandafter\def\csname XINT_shtb_8\endcsname {1000}%
\expandafter\def\csname XINT_shtb_9\endcsname {1001}%
\def\XINT_shtb_A {1010}%
\def\XINT_shtb_B {1011}%
\def\XINT_shtb_C {1100}%
\def\XINT_shtb_D {1101}%
\def\XINT_shtb_E {1110}%
\def\XINT_shtb_F {1111}%
\def\XINT_shtb_G {}%
\def\XINT_smallhex #1%
{%
    \expandafter\XINT_smallhex_a\expandafter
    {\the\numexpr (#1+\xint_c_viii)/\xint_c_xvi-\xint_c_i}{#1}%
}%
\def\XINT_smallhex_a #1#2%
{%
    \csname XINT_sdth_#1\expandafter\expandafter\expandafter\endcsname
    \csname XINT_sdth_\the\numexpr #2-\xint_c_xvi*#1\endcsname
}%
\def\XINT_smallbin #1%
{%
    \expandafter\XINT_smallbin_a\expandafter
    {\the\numexpr (#1+\xint_c_viii)/\xint_c_xvi-\xint_c_i}{#1}%
}%
\def\XINT_smallbin_a #1#2%
{%
    \csname XINT_sdtb_#1\expandafter\expandafter\expandafter\endcsname
    \csname XINT_sdtb_\the\numexpr #2-\xint_c_xvi*#1\endcsname
}%
%    \end{macrocode}
% \subsection{\csh{xintDecToHex}, \csh{xintDecToBin}}
% \lverb!v1.08!
%    \begin{macrocode}
\def\xintDecToHex {\romannumeral0\xintdectohex }%
\def\xintdectohex #1%
        {\expandafter\XINT_dth_checkin\romannumeral-`0#1\W\W\W\W \T}%
\def\XINT_dth_checkin #1%
{%
    \xint_UDsignfork
       #1\dummy \XINT_dth_N
        -\dummy {\XINT_dth_P #1}%
     \krof
}%
\def\XINT_dth_N {\expandafter\xint_minus_andstop\romannumeral0\XINT_dth_P }%
\def\XINT_dth_P {\expandafter\XINT_dth_III\romannumeral-`0\XINT_dtbh_I {0.}}%
\def\xintDecToBin {\romannumeral0\xintdectobin }%
\def\xintdectobin #1%
        {\expandafter\XINT_dtb_checkin\romannumeral-`0#1\W\W\W\W \T }%
\def\XINT_dtb_checkin #1%
{%
    \xint_UDsignfork
       #1\dummy \XINT_dtb_N
        -\dummy {\XINT_dtb_P #1}%
     \krof
}%
\def\XINT_dtb_N {\expandafter\xint_minus_andstop\romannumeral0\XINT_dtb_P }%
\def\XINT_dtb_P {\expandafter\XINT_dtb_III\romannumeral-`0\XINT_dtbh_I {0.}}%
\def\XINT_dtbh_I #1#2#3#4#5%
{%
    \xint_gob_til_W #5\XINT_dtbh_II_a\W\XINT_dtbh_I_a  {}{#2#3#4#5}#1\Z.%
}%
\def\XINT_dtbh_II_a\W\XINT_dtbh_I_a #1#2{\XINT_dtbh_II_b #2}%
\def\XINT_dtbh_II_b #1#2#3#4%
{%
    \xint_gob_til_W
      #1\XINT_dtbh_II_c
      #2\XINT_dtbh_II_ci
      #3\XINT_dtbh_II_cii
      \W\XINT_dtbh_II_ciii #1#2#3#4%
}%  
\def\XINT_dtbh_II_c \W\XINT_dtbh_II_ci
                    \W\XINT_dtbh_II_cii
                    \W\XINT_dtbh_II_ciii \W\W\W\W {{}}%
\def\XINT_dtbh_II_ci #1\XINT_dtbh_II_ciii #2\W\W\W 
   {\XINT_dtbh_II_d {}{#2}{0}}%
\def\XINT_dtbh_II_cii\W\XINT_dtbh_II_ciii #1#2\W\W 
   {\XINT_dtbh_II_d {}{#1#2}{00}}%
\def\XINT_dtbh_II_ciii #1#2#3\W
   {\XINT_dtbh_II_d {}{#1#2#3}{000}}%
\def\XINT_dtbh_I_a #1#2#3.%
{%
    \xint_gob_til_Z #3\XINT_dtbh_I_z\Z
    \expandafter\XINT_dtbh_I_b\the\numexpr #2+#30000.{#1}%    
}%
\def\XINT_dtbh_I_b #1.%
{%
    \expandafter\XINT_dtbh_I_c\the\numexpr 
    (#1+\xint_c_ii^xv)/\xint_c_ii^xvi-\xint_c_i.#1.%
}%
\def\XINT_dtbh_I_c #1.#2.%
{%
    \expandafter\XINT_dtbh_I_d\expandafter 
    {\the\numexpr #2-\xint_c_ii^xvi*#1}{#1}%   
}%
\def\XINT_dtbh_I_d #1#2#3{\XINT_dtbh_I_a {#3#1.}{#2}}%
\def\XINT_dtbh_I_z\Z\expandafter\XINT_dtbh_I_b\the\numexpr #1+#2.%
{%
    \ifnum #1=\xint_c_ \expandafter\XINT_dtbh_I_end_zb\fi
    \XINT_dtbh_I_end_za {#1}%
}%
\def\XINT_dtbh_I_end_za #1#2{\XINT_dtbh_I {#2#1.}}%
\def\XINT_dtbh_I_end_zb\XINT_dtbh_I_end_za #1#2{\XINT_dtbh_I {#2}}%
\def\XINT_dtbh_II_d #1#2#3#4.%
{%
    \xint_gob_til_Z #4\XINT_dtbh_II_z\Z
    \expandafter\XINT_dtbh_II_e\the\numexpr #2+#4#3.{#1}{#3}%    
}%
\def\XINT_dtbh_II_e #1.%
{%
    \expandafter\XINT_dtbh_II_f\the\numexpr 
        (#1+\xint_c_ii^xv)/\xint_c_ii^xvi-\xint_c_i.#1.%
}%
\def\XINT_dtbh_II_f #1.#2.%
{%
    \expandafter\XINT_dtbh_II_g\expandafter 
    {\the\numexpr #2-\xint_c_ii^xvi*#1}{#1}%   
}%
\def\XINT_dtbh_II_g #1#2#3{\XINT_dtbh_II_d {#3#1.}{#2}}%
\def\XINT_dtbh_II_z\Z\expandafter\XINT_dtbh_II_e\the\numexpr #1+#2.%
{%
    \ifnum #1=\xint_c_ \expandafter\XINT_dtbh_II_end_zb\fi
    \XINT_dtbh_II_end_za {#1}%
}%
\def\XINT_dtbh_II_end_za #1#2#3{{}#2#1.\Z.}%
\def\XINT_dtbh_II_end_zb\XINT_dtbh_II_end_za #1#2#3{{}#2\Z.}%
\def\XINT_dth_III #1#2.%
{%
    \xint_gob_til_Z #2\XINT_dth_end\Z
    \expandafter\XINT_dth_III\expandafter
    {\romannumeral-`0\XINT_dth_small #2.#1}%
}%
\def\XINT_dth_small #1.%
{%
    \expandafter\XINT_smallhex\expandafter
    {\the\numexpr (#1+\xint_c_ii^vii)/\xint_c_ii^viii-\xint_c_i\expandafter}%
    \romannumeral-`0\expandafter\XINT_smallhex\expandafter
    {\the\numexpr
    #1-((#1+\xint_c_ii^vii)/\xint_c_ii^viii-\xint_c_i)*\xint_c_ii^viii}% 
}%
\def\XINT_dth_end\Z\expandafter\XINT_dth_III\expandafter #1#2\T 
{%
    \XINT_dth_end_b #1%
}%
\def\XINT_dth_end_b #1.{\XINT_dth_end_c }%
\def\XINT_dth_end_c #1{\xint_gob_til_zero #1\XINT_dth_end_d 0\space #1}%
\def\XINT_dth_end_d 0\space 0#1%
{%  
    \xint_gob_til_zero #1\XINT_dth_end_e 0\space #1%
}%
\def\XINT_dth_end_e 0\space 0#1%
{%
    \xint_gob_til_zero #1\XINT_dth_end_f 0\space #1%
}%
\def\XINT_dth_end_f 0\space 0{ }%
\def\XINT_dtb_III #1#2.%
{%
    \xint_gob_til_Z #2\XINT_dtb_end\Z
    \expandafter\XINT_dtb_III\expandafter
    {\romannumeral-`0\XINT_dtb_small #2.#1}%
}%
\def\XINT_dtb_small #1.%
{%
    \expandafter\XINT_smallbin\expandafter
    {\the\numexpr (#1+\xint_c_ii^vii)/\xint_c_ii^viii-\xint_c_i\expandafter}%
    \romannumeral-`0\expandafter\XINT_smallbin\expandafter
    {\the\numexpr
    #1-((#1+\xint_c_ii^vii)/\xint_c_ii^viii-\xint_c_i)*\xint_c_ii^viii}% 
}%
\def\XINT_dtb_end\Z\expandafter\XINT_dtb_III\expandafter #1#2\T 
{%
    \XINT_dtb_end_b #1%
}%
\def\XINT_dtb_end_b #1.{\XINT_dtb_end_c }%
\def\XINT_dtb_end_c #1#2#3#4#5#6#7#8%
{%
    \expandafter\XINT_dtb_end_d\the\numexpr #1#2#3#4#5#6#7#8\relax
}%
\def\XINT_dtb_end_d #1#2#3#4#5#6#7#8#9%
{%
    \expandafter\space\the\numexpr #1#2#3#4#5#6#7#8#9\relax
}%
%    \end{macrocode}
% \subsection{\csh{xintHexToDec}}
% \lverb!v1.08!
%    \begin{macrocode}
\def\xintHexToDec {\romannumeral0\xinthextodec }%
\def\xinthextodec #1%
        {\expandafter\XINT_htd_checkin\romannumeral-`0#1\W\W\W\W \T }%
\def\XINT_htd_checkin #1%
{%
    \xint_UDsignfork
       #1\dummy \XINT_htd_neg
        -\dummy {\XINT_htd_I {0000}#1}%
     \krof
}%
\def\XINT_htd_neg {\expandafter\xint_minus_andstop
                   \romannumeral0\XINT_htd_I {0000}}%
\def\XINT_htd_I #1#2#3#4#5%
{%
    \xint_gob_til_W #5\XINT_htd_II_a\W
    \XINT_htd_I_a  {}{"#2#3#4#5}#1\Z\Z\Z\Z
}%
\def\XINT_htd_II_a \W\XINT_htd_I_a #1#2{\XINT_htd_II_b #2}%
\def\XINT_htd_II_b "#1#2#3#4%
{%
    \xint_gob_til_W
      #1\XINT_htd_II_c
      #2\XINT_htd_II_ci
      #3\XINT_htd_II_cii
      \W\XINT_htd_II_ciii #1#2#3#4%
}%  
\def\XINT_htd_II_c \W\XINT_htd_II_ci
                   \W\XINT_htd_II_cii
                   \W\XINT_htd_II_ciii \W\W\W\W #1\Z\Z\Z\Z\T 
{%
    \expandafter\xint_cleanupzeros_andstop
    \romannumeral0\XINT_rord_main {}#1%
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax
}%
\def\XINT_htd_II_ci #1\XINT_htd_II_ciii 
                      #2\W\W\W {\XINT_htd_II_d {}{"#2}{\xint_c_xvi}}%
\def\XINT_htd_II_cii\W\XINT_htd_II_ciii 
                      #1#2\W\W {\XINT_htd_II_d {}{"#1#2}{\xint_c_ii^viii}}%
\def\XINT_htd_II_ciii #1#2#3\W {\XINT_htd_II_d {}{"#1#2#3}{\xint_c_ii^xii}}%
\def\XINT_htd_I_a #1#2#3#4#5#6%
{%
    \xint_gob_til_Z #3\XINT_htd_I_end_a\Z
    \expandafter\XINT_htd_I_b\the\numexpr
    #2+\xint_c_ii^xvi*#6#5#4#3+\xint_c_x^ix\relax {#1}%    
}%
\def\XINT_htd_I_b 1#1#2#3#4#5#6#7#8#9{\XINT_htd_I_c {#1#2#3#4#5}{#9#8#7#6}}%
\def\XINT_htd_I_c #1#2#3{\XINT_htd_I_a {#3#2}{#1}}%
\def\XINT_htd_I_end_a\Z\expandafter\XINT_htd_I_b\the\numexpr #1+#2\relax
{%  
    \expandafter\XINT_htd_I_end_b\the\numexpr \xint_c_x^v+#1\relax 
}%
\def\XINT_htd_I_end_b 1#1#2#3#4#5%
{%
    \xint_gob_til_zero #1\XINT_htd_I_end_bz0%
    \XINT_htd_I_end_c #1#2#3#4#5%
}%
\def\XINT_htd_I_end_c #1#2#3#4#5#6{\XINT_htd_I {#6#5#4#3#2#1000}}%
\def\XINT_htd_I_end_bz0\XINT_htd_I_end_c 0#1#2#3#4%
{%
    \xint_gob_til_zeros_iv #1#2#3#4\XINT_htd_I_end_bzz 0000%
    \XINT_htd_I_end_D {#4#3#2#1}%
}%
\def\XINT_htd_I_end_D  #1#2{\XINT_htd_I {#2#1}}%
\def\XINT_htd_I_end_bzz 0000\XINT_htd_I_end_D #1{\XINT_htd_I }%
\def\XINT_htd_II_d #1#2#3#4#5#6#7%
{%
    \xint_gob_til_Z #4\XINT_htd_II_end_a\Z
    \expandafter\XINT_htd_II_e\the\numexpr
    #2+#3*#7#6#5#4+\xint_c_x^viii\relax {#1}{#3}%    
}%
\def\XINT_htd_II_e 1#1#2#3#4#5#6#7#8{\XINT_htd_II_f {#1#2#3#4}{#5#6#7#8}}%
\def\XINT_htd_II_f #1#2#3{\XINT_htd_II_d {#2#3}{#1}}%
\def\XINT_htd_II_end_a\Z\expandafter\XINT_htd_II_e
    \the\numexpr #1+#2\relax #3#4\T
{%  
    \XINT_htd_II_end_b #1#3%
}%
\def\XINT_htd_II_end_b #1#2#3#4#5#6#7#8%
{%
    \expandafter\space\the\numexpr #1#2#3#4#5#6#7#8\relax
}%
%    \end{macrocode}
% \subsection{\csh{xintBinToDec}}
% \lverb!v1.08!
%    \begin{macrocode}
\def\xintBinToDec {\romannumeral0\xintbintodec }%
\def\xintbintodec #1{\expandafter\XINT_btd_checkin
                     \romannumeral-`0#1\W\W\W\W\W\W\W\W \T }%
\def\XINT_btd_checkin #1%
{%
    \xint_UDsignfork
       #1\dummy \XINT_btd_neg
        -\dummy {\XINT_btd_I {000000}#1}%
     \krof
}%
\def\XINT_btd_neg {\expandafter\xint_minus_andstop
                               \romannumeral0\XINT_btd_I {000000}}%
\def\XINT_btd_I #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_W #9\XINT_btd_II_a {#2#3#4#5#6#7#8#9}\W
    \XINT_btd_I_a {}{\csname XINT_sbtd_#2#3#4#5\endcsname*\xint_c_xvi+%
                     \csname XINT_sbtd_#6#7#8#9\endcsname}%
    #1\Z\Z\Z\Z\Z\Z
}%
\def\XINT_btd_II_a #1\W\XINT_btd_I_a #2#3{\XINT_btd_II_b #1}%
\def\XINT_btd_II_b #1#2#3#4#5#6#7#8%
{%
    \xint_gob_til_W 
      #1\XINT_btd_II_c
      #2\XINT_btd_II_ci
      #3\XINT_btd_II_cii
      #4\XINT_btd_II_ciii
      #5\XINT_btd_II_civ
      #6\XINT_btd_II_cv
      #7\XINT_btd_II_cvi
      \W\XINT_btd_II_cvii #1#2#3#4#5#6#7#8%
}%
\def\XINT_btd_II_c #1\XINT_btd_II_cvii \W\W\W\W\W\W\W\W #2\Z\Z\Z\Z\Z\Z\T
{%
    \expandafter\XINT_btd_II_c_end
    \romannumeral0\XINT_rord_main {}#2%
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax
}%
\def\XINT_btd_II_c_end #1#2#3#4#5#6%
{%
    \expandafter\space\the\numexpr #1#2#3#4#5#6\relax
}%
\def\XINT_btd_II_ci  #1\XINT_btd_II_cvii #2\W\W\W\W\W\W\W
   {\XINT_btd_II_d {}{#2}{\xint_c_ii }}%
\def\XINT_btd_II_cii #1\XINT_btd_II_cvii #2\W\W\W\W\W\W
   {\XINT_btd_II_d {}{\csname XINT_sbtd_00#2\endcsname }{\xint_c_iv }}%
\def\XINT_btd_II_ciii #1\XINT_btd_II_cvii #2\W\W\W\W\W
   {\XINT_btd_II_d {}{\csname XINT_sbtd_0#2\endcsname }{\xint_c_viii }}%
\def\XINT_btd_II_civ #1\XINT_btd_II_cvii #2\W\W\W\W
   {\XINT_btd_II_d {}{\csname XINT_sbtd_#2\endcsname}{\xint_c_xvi }}%
\def\XINT_btd_II_cv #1\XINT_btd_II_cvii #2#3#4#5#6\W\W\W
{%
    \XINT_btd_II_d {}{\csname XINT_sbtd_#2#3#4#5\endcsname*\xint_c_ii+%
                          #6}{\xint_c_ii^v }%
}%
\def\XINT_btd_II_cvi #1\XINT_btd_II_cvii #2#3#4#5#6#7\W\W
{%
    \XINT_btd_II_d {}{\csname XINT_sbtd_#2#3#4#5\endcsname*\xint_c_iv+%
                      \csname XINT_sbtd_00#6#7\endcsname}{\xint_c_ii^vi }%
}%
\def\XINT_btd_II_cvii #1#2#3#4#5#6#7\W
{%
    \XINT_btd_II_d {}{\csname XINT_sbtd_#1#2#3#4\endcsname*\xint_c_viii+%
                      \csname XINT_sbtd_0#5#6#7\endcsname}{\xint_c_ii^vii }%
}%
\def\XINT_btd_II_d #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_Z #4\XINT_btd_II_end_a\Z
    \expandafter\XINT_btd_II_e\the\numexpr
    #2+(\xint_c_x^ix+#3*#9#8#7#6#5#4)\relax {#1}{#3}%    
}%
\def\XINT_btd_II_e 1#1#2#3#4#5#6#7#8#9{\XINT_btd_II_f {#1#2#3}{#4#5#6#7#8#9}}%
\def\XINT_btd_II_f #1#2#3{\XINT_btd_II_d {#2#3}{#1}}%
\def\XINT_btd_II_end_a\Z\expandafter\XINT_btd_II_e
    \the\numexpr #1+(#2\relax #3#4\T
{%  
    \XINT_btd_II_end_b #1#3%
}%
\def\XINT_btd_II_end_b #1#2#3#4#5#6#7#8#9%
{%
    \expandafter\space\the\numexpr #1#2#3#4#5#6#7#8#9\relax
}%
\def\XINT_btd_I_a #1#2#3#4#5#6#7#8%
{%
    \xint_gob_til_Z #3\XINT_btd_I_end_a\Z
    \expandafter\XINT_btd_I_b\the\numexpr
    #2+\xint_c_ii^viii*#8#7#6#5#4#3+\xint_c_x^ix\relax {#1}%    
}%
\def\XINT_btd_I_b 1#1#2#3#4#5#6#7#8#9{\XINT_btd_I_c {#1#2#3}{#9#8#7#6#5#4}}%
\def\XINT_btd_I_c #1#2#3{\XINT_btd_I_a {#3#2}{#1}}%
\def\XINT_btd_I_end_a\Z\expandafter\XINT_btd_I_b
    \the\numexpr #1+\xint_c_ii^viii #2\relax
{%  
    \expandafter\XINT_btd_I_end_b\the\numexpr 1000+#1\relax 
}%
\def\XINT_btd_I_end_b 1#1#2#3%
{%
    \xint_gob_til_zeros_iii #1#2#3\XINT_btd_I_end_bz 000%
    \XINT_btd_I_end_c #1#2#3%
}%
\def\XINT_btd_I_end_c #1#2#3#4{\XINT_btd_I {#4#3#2#1000}}%
\def\XINT_btd_I_end_bz 000\XINT_btd_I_end_c 000{\XINT_btd_I }%
%    \end{macrocode}
% \subsection{\csh{xintBinToHex}}
% \lverb!v1.08!
%    \begin{macrocode}
\def\xintBinToHex {\romannumeral0\xintbintohex }%
\def\xintbintohex #1%
{%
    \expandafter\XINT_bth_checkin
                     \romannumeral0\expandafter\XINT_num_loop
                     \romannumeral-`0#1\xint_relax\xint_relax
                                       \xint_relax\xint_relax
                     \xint_relax\xint_relax\xint_relax\xint_relax\Z
    \R\R\R\R\R\R\R\R\Z \W\W\W\W\W\W\W\W
}%
\def\XINT_bth_checkin #1%
{%
    \xint_UDsignfork
       #1\dummy  \XINT_bth_N
        -\dummy {\XINT_bth_P #1}%
     \krof
}%
\def\XINT_bth_N {\expandafter\xint_minus_andstop\romannumeral0\XINT_bth_P }%
\def\XINT_bth_P {\expandafter\XINT_bth_I\expandafter{\expandafter}%
                 \romannumeral0\XINT_OQ {}}%
\def\XINT_bth_I #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_W #9\XINT_bth_end_a\W
    \expandafter\expandafter\expandafter
    \XINT_bth_I
    \expandafter\expandafter\expandafter
    {\csname XINT_sbth_#9#8#7#6\expandafter\expandafter\expandafter\endcsname
     \csname XINT_sbth_#5#4#3#2\endcsname #1}%
}%
\def\XINT_bth_end_a\W \expandafter\expandafter\expandafter
    \XINT_bth_I       \expandafter\expandafter\expandafter #1%
{%
    \XINT_bth_end_b #1%
}%
\def\XINT_bth_end_b  #1\endcsname #2\endcsname #3%
{%
    \xint_gob_til_zero #3\XINT_bth_end_z 0\space #3%
}%
\def\XINT_bth_end_z0\space 0{ }%
%    \end{macrocode}
% \subsection{\csh{xintHexToBin}}
% \lverb!v1.08!
%    \begin{macrocode}
\def\xintHexToBin {\romannumeral0\xinthextobin }%
\def\xinthextobin #1%
{%
    \expandafter\XINT_htb_checkin\romannumeral-`0#1GGGGGGGG\T
}%
\def\XINT_htb_checkin #1%
{%
    \xint_UDsignfork
       #1\dummy  \XINT_htb_N
        -\dummy {\XINT_htb_P #1}%
     \krof
}%
\def\XINT_htb_N {\expandafter\xint_minus_andstop\romannumeral0\XINT_htb_P }%
\def\XINT_htb_P {\XINT_htb_I_a {}}%
\def\XINT_htb_I_a #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_G #9\XINT_htb_II_a G%
    \expandafter\expandafter\expandafter
    \XINT_htb_I_b
    \expandafter\expandafter\expandafter
    {\csname XINT_shtb_#2\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#3\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#4\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#5\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#6\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#7\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#8\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#9\endcsname }{#1}%
}%
\def\XINT_htb_I_b #1#2{\XINT_htb_I_a {#2#1}}%
\def\XINT_htb_II_a G\expandafter\expandafter\expandafter\XINT_htb_I_b
{%
    \expandafter\expandafter\expandafter \XINT_htb_II_b
}%
\def\XINT_htb_II_b #1#2#3\T
{%
    \XINT_num_loop #2#1%
    \xint_relax\xint_relax\xint_relax\xint_relax
    \xint_relax\xint_relax\xint_relax\xint_relax\Z    
}%
%    \end{macrocode}
% \subsection{\csh{xintCHexToBin}}
% \lverb!v1.08!
%    \begin{macrocode}
\def\xintCHexToBin {\romannumeral0\xintchextobin }%
\def\xintchextobin #1%
{%
    \expandafter\XINT_chtb_checkin\romannumeral-`0#1%
    \R\R\R\R\R\R\R\R\Z \W\W\W\W\W\W\W\W
}%
\def\XINT_chtb_checkin #1%
{%
    \xint_UDsignfork
       #1\dummy  \XINT_chtb_N
        -\dummy {\XINT_chtb_P #1}%
     \krof
}%
\def\XINT_chtb_N {\expandafter\xint_minus_andstop\romannumeral0\XINT_chtb_P }%
\def\XINT_chtb_P {\expandafter\XINT_chtb_I\expandafter{\expandafter}%
                  \romannumeral0\XINT_OQ {}}%
\def\XINT_chtb_I #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_W #9\XINT_chtb_end_a\W
    \expandafter\expandafter\expandafter
    \XINT_chtb_I
    \expandafter\expandafter\expandafter
    {\csname XINT_shtb_#9\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#8\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#7\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#6\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#5\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#4\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#3\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#2\endcsname
     #1}%
}%
\def\XINT_chtb_end_a\W\expandafter\expandafter\expandafter
    \XINT_chtb_I\expandafter\expandafter\expandafter #1%
{%
    \XINT_chtb_end_b #1%
    \xint_relax\xint_relax\xint_relax\xint_relax
    \xint_relax\xint_relax\xint_relax\xint_relax\Z    
}%
\def\XINT_chtb_end_b #1\W#2\W#3\W#4\W#5\W#6\W#7\W#8\W\endcsname 
{%
    \XINT_num_loop
}%
\XINT_binhex_restorecatcodes_endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xintbinhex>\relax
%\def<*xintgcd>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xintbinhex>
%<*xintgcd>
% \section{Package \xintgcdname implementation}
% 
% The commenting is currently (\docdate) very sparse.
%
% \localtableofcontents
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
%
% The code for reload detection is copied from \textsc{Heiko
% Oberdiek}'s packages, and adapted here to check for previous
% loading of the master \xintname package.
%
% The method for catcodes is slightly different, but still
% directly inspired by these packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \def\space { }%
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xintgcd.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xint.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintgcd}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintgcd.sty
      \ifx\w\relax % but xint.sty not yet loaded.
         \y{xintgcd}{Package xint is required}%
         \y{xintgcd}{Will try \string\input\space xint.sty}%
         \def\z{\endgroup\input xint.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xint.sty not yet loaded.
            \y{xintgcd}{Package xint is required}%
            \y{xintgcd}{Will try \string\RequirePackage{xint}}%
            \def\z{\endgroup\RequirePackage{xint}}%
          \fi
      \else
        \y{xintgcd}{I was already loaded, aborting input}%
        \aftergroup\endinput
      \fi
    \fi
  \fi
\z%
%    \end{macrocode}
% \subsection{Confirmation of \xintname loading}
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \def\empty {}%
  \expandafter\let\expandafter\w\csname ver@xint.sty\endcsname
  \ifx\w\relax % Plain TeX, user gave a file name at the prompt
      \y{xintgcd}{Loading of package xint failed, aborting input}%
      \aftergroup\endinput
  \fi
  \ifx\w\empty % LaTeX, user gave a file name at the prompt
      \y{xintgcd}{Loading of package xint failed, aborting input}%
      \aftergroup\endinput
  \fi
\endgroup%
%    \end{macrocode}
% \subsection{Catcodes}
%
% Perhaps catcodes have changed after the loading of \xintname
% and prior to the current loading of \xintgcdname, so we can not employ
% the |\XINT_restorecatcodes_endinput| in this style file. But
% there is no problem using |\XINT_setcatcodes|.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode95=11   % _
  \def\x
  {%
      \endgroup
      \edef\XINT_gcd_restorecatcodes_endinput
      {%
        \catcode36=\the\catcode36   % $
        \catcode94=\the\catcode94   % ^
        \catcode96=\the\catcode96   % `
        \catcode47=\the\catcode47   % /
        \catcode41=\the\catcode41   % )
        \catcode40=\the\catcode40   % (
        \catcode42=\the\catcode42   % *
        \catcode43=\the\catcode43   % +
        \catcode62=\the\catcode62   % >
        \catcode60=\the\catcode60   % <
        \catcode58=\the\catcode58   % :
        \catcode46=\the\catcode46   % .
        \catcode45=\the\catcode45   % -
        \catcode44=\the\catcode44   % ,
        \catcode35=\the\catcode35   % #
        \catcode95=\the\catcode95   % _
        \catcode125=\the\catcode125 % }
        \catcode123=\the\catcode123 % {
        \endlinechar=\the\endlinechar
        \catcode13=\the\catcode13   % ^^M
        \catcode32=\the\catcode32   % 
        \catcode61=\the\catcode61\relax   % =
        \noexpand\endinput
      }%
      \XINT_setcatcodes % defined in xint.sty
      \catcode36=3  % $
  }%
\x
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\begingroup
  \catcode64=11 % @
  \catcode91=12 % [
  \catcode93=12 % ]
  \catcode58=12 % :
  \expandafter\ifx\csname ProvidesPackage\endcsname\relax
    \def\x#1#2#3[#4]{\endgroup
      \immediate\write-1{Package: #3 #4}%
      \xdef#1{#4}%
    }%
  \else
    \def\x#1#2[#3]{\endgroup
      #2[{#3}]%
      \ifx#1\@undefined
        \xdef#1{#3}%
      \fi
      \ifx#1\relax
        \xdef#1{#3}%
      \fi
    }%
  \fi
\expandafter\x\csname ver@xintgcd.sty\endcsname
\ProvidesPackage{xintgcd}%
  [2013/06/14 v1.08b Euclide algorithm with xint package (jfB)]%
%    \end{macrocode}
% \subsection{\csh{xintGCD}}
%    \begin{macrocode}
\def\xintGCD {\romannumeral0\xintgcd }%
\def\xintgcd #1%
{%
    \expandafter\XINT_gcd\expandafter{\romannumeral0\xintiabs {#1}}%
}%
\def\XINT_gcd #1#2%
{%
    \expandafter\XINT_gcd_fork\romannumeral0\xintiabs {#2}\Z #1\Z
}%
%    \end{macrocode}
% \lverb|&
% Ici #3#4=A, #1#2=B|
%    \begin{macrocode}
\def\XINT_gcd_fork #1#2\Z #3#4\Z
{%
    \xint_UDzerofork
      #1\dummy \XINT_gcd_BisZero
      #3\dummy \XINT_gcd_AisZero
       0\dummy \XINT_gcd_loop
    \krof
    {#1#2}{#3#4}%
}%
\def\XINT_gcd_AisZero #1#2{ #1}%
\def\XINT_gcd_BisZero #1#2{ #2}%
\def\XINT_gcd_CheckRem #1#2\Z
{%
    \xint_gob_til_zero #1\xint_gcd_end0\XINT_gcd_loop {#1#2}%
}%
\def\xint_gcd_end0\XINT_gcd_loop #1#2{ #2}%
%    \end{macrocode}
% \lverb|#1=B, #2=A|
%    \begin{macrocode}
\def\XINT_gcd_loop #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT_gcd_CheckRem
    \expandafter\xint_secondoftwo
    \romannumeral0\XINT_div_prepare {#1}{#2}\Z 
    {#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintBezout}}
%    \begin{macrocode}
\def\xintBezout {\romannumeral0\xintbezout }%
\def\xintbezout #1%
{%
    \expandafter\xint_bezout\expandafter {\romannumeral-`0#1}%
}%
\def\xint_bezout #1#2%
{%
    \expandafter\XINT_bezout_fork \romannumeral-`0#2\Z #1\Z
}%
%    \end{macrocode}
% \lverb|#3#4 = A, #1#2=B|
%    \begin{macrocode}
\def\XINT_bezout_fork #1#2\Z #3#4\Z
{%
    \xint_UDzerosfork
     #1#3\dummy \XINT_bezout_botharezero
      #10\dummy \XINT_bezout_secondiszero
      #30\dummy \XINT_bezout_firstiszero
       00\dummy 
        {\xint_UDsignsfork
          #1#3\dummy \XINT_bezout_minusminus % A < 0, B < 0
           #1-\dummy \XINT_bezout_minusplus  % A > 0, B < 0
           #3-\dummy \XINT_bezout_plusminus  % A < 0, B > 0
            --\dummy \XINT_bezout_plusplus   % A > 0, B > 0
         \krof }%
    \krof
    {#2}{#4}#1#3{#3#4}{#1#2}% #1#2=B, #3#4=A
}%
\def\XINT_bezout_botharezero #1#2#3#4#5#6%
{%
    \xintError:NoBezoutForZeros
    \space {0}{0}{0}{0}{0}%
}%
%    \end{macrocode}
% \lverb|&
% attention première entrée doit être ici (-1)^n donc 1$\
% #4#2 = 0 = A, B = #3#1|
%    \begin{macrocode}
\def\XINT_bezout_firstiszero #1#2#3#4#5#6%
{%
    \xint_UDsignfork
      #3\dummy { {0}{#3#1}{0}{1}{#1}}%
       -\dummy { {0}{#3#1}{0}{-1}{#1}}%
    \krof
}%
%    \end{macrocode}
% \lverb|#4#2 = A, B = #3#1 = 0|
%    \begin{macrocode}
\def\XINT_bezout_secondiszero #1#2#3#4#5#6%
{%
    \xint_UDsignfork
       #4\dummy{ {#4#2}{0}{-1}{0}{#2}}%
        -\dummy{ {#4#2}{0}{1}{0}{#2}}%
    \krof
}%
%    \end{macrocode}
% \lverb|#4#2= A < 0, #3#1 = B < 0|
%    \begin{macrocode}
\def\XINT_bezout_minusminus #1#2#3#4%
{%
    \expandafter\XINT_bezout_mm_post
    \romannumeral0\XINT_bezout_loop_a 1{#1}{#2}1001%
}%
\def\XINT_bezout_mm_post #1#2%
{%
    \expandafter\XINT_bezout_mm_postb\expandafter
    {\romannumeral0\xintiopp{#2}}{\romannumeral0\xintiopp{#1}}%
}%
\def\XINT_bezout_mm_postb #1#2%
{%
    \expandafter\XINT_bezout_mm_postc\expandafter {#2}{#1}%
}%
\def\XINT_bezout_mm_postc #1#2#3#4#5%
{%
    \space {#4}{#5}{#1}{#2}{#3}%
}%
%    \end{macrocode}
% \lverb|minusplus  #4#2= A > 0, B < 0|
%    \begin{macrocode}
\def\XINT_bezout_minusplus #1#2#3#4%
{%
    \expandafter\XINT_bezout_mp_post
    \romannumeral0\XINT_bezout_loop_a 1{#1}{#4#2}1001%
}%
\def\XINT_bezout_mp_post #1#2%
{%
    \expandafter\XINT_bezout_mp_postb\expandafter
      {\romannumeral0\xintiopp {#2}}{#1}%
}%
\def\XINT_bezout_mp_postb #1#2#3#4#5%
{%
    \space {#4}{#5}{#2}{#1}{#3}%
}%
%    \end{macrocode}
% \lverb|plusminus  A < 0, B > 0|
%    \begin{macrocode}
\def\XINT_bezout_plusminus #1#2#3#4%
{%
    \expandafter\XINT_bezout_pm_post
    \romannumeral0\XINT_bezout_loop_a 1{#3#1}{#2}1001%
}%
\def\XINT_bezout_pm_post #1%
{%
    \expandafter \XINT_bezout_pm_postb \expandafter
        {\romannumeral0\xintiopp{#1}}%
}%
\def\XINT_bezout_pm_postb #1#2#3#4#5%
{%
    \space {#4}{#5}{#1}{#2}{#3}%
}%
%    \end{macrocode}
% \lverb|plusplus|
%    \begin{macrocode}
\def\XINT_bezout_plusplus #1#2#3#4%
{%
    \expandafter\XINT_bezout_pp_post
    \romannumeral0\XINT_bezout_loop_a 1{#3#1}{#4#2}1001%
}%
%    \end{macrocode}
% \lverb|la parité (-1)^N est en #1, et on la jette ici.|
%    \begin{macrocode}
\def\XINT_bezout_pp_post #1#2#3#4#5%
{%
    \space {#4}{#5}{#1}{#2}{#3}%
}%
%    \end{macrocode}
% \lverb|&
% n = 0: 1BAalpha(0)beta(0)alpha(-1)beta(-1)$\
% n général:
% {(-1)^n}{r(n-1)}{r(n-2)}{alpha(n-1)}{beta(n-1)}{alpha(n-2)}{beta(n-2)}$\
% #2 = B, #3 = A|
%    \begin{macrocode}
\def\XINT_bezout_loop_a #1#2#3%
{%
    \expandafter\XINT_bezout_loop_b
    \expandafter{\the\numexpr -#1\expandafter }%
    \romannumeral0\XINT_div_prepare {#2}{#3}{#2}%
}%
%    \end{macrocode}
% \lverb|&
% Le q(n) a ici une existence éphémère, dans le version Bezout Algorithm
% il faudra le conserver. On voudra à la fin
% {{q(n)}{r(n)}{alpha(n)}{beta(n)}}.
% De plus ce n'est plus (-1)^n que l'on veut mais n. (ou dans un autre ordre)$\
% {-(-1)^n}{q(n)}{r(n)}{r(n-1)}{alpha(n-1)}{beta(n-1)}{alpha(n-2)}{beta(n-2)}|
%    \begin{macrocode}
\def\XINT_bezout_loop_b #1#2#3#4#5#6#7#8%
{%
    \expandafter \XINT_bezout_loop_c \expandafter
        {\romannumeral0\xintiadd{\XINT_Mul{#5}{#2}}{#7}}%
        {\romannumeral0\xintiadd{\XINT_Mul{#6}{#2}}{#8}}%
    {#1}{#3}{#4}{#5}{#6}%
}%
%    \end{macrocode}
% \lverb|{alpha(n)}{->beta(n)}{-(-1)^n}{r(n)}{r(n-1)}{alpha(n-1)}{beta(n-1)}|
%    \begin{macrocode}
\def\XINT_bezout_loop_c #1#2%
{%
    \expandafter \XINT_bezout_loop_d \expandafter
        {#2}{#1}%
}%
%    \end{macrocode}
% \lverb|{beta(n)}{alpha(n)}{(-1)^(n+1)}{r(n)}{r(n-1)}{alpha(n-1)}{beta(n-1)}|
%    \begin{macrocode}
\def\XINT_bezout_loop_d #1#2#3#4#5%
{%
    \XINT_bezout_loop_e #4\Z {#3}{#5}{#2}{#1}%
}%
%    \end{macrocode}
% \lverb|r(n)\Z {(-1)^(n+1)}{r(n-1)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}|
%    \begin{macrocode}
\def\XINT_bezout_loop_e #1#2\Z 
{%
    \xint_gob_til_zero #1\xint_bezout_loop_exit0\XINT_bezout_loop_f
    {#1#2}%
}%
%    \end{macrocode}
% \lverb|{r(n)}{(-1)^(n+1)}{r(n-1)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}|
%    \begin{macrocode}
\def\XINT_bezout_loop_f #1#2%
{%
    \XINT_bezout_loop_a {#2}{#1}%
}%
%    \end{macrocode}
% \lverb|{(-1)^(n+1)}{r(n)}{r(n-1)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}
% et itération|
%    \begin{macrocode}
\def\xint_bezout_loop_exit0\XINT_bezout_loop_f #1#2%
{%
    \ifcase #2
    \or  \expandafter\XINT_bezout_exiteven
    \else\expandafter\XINT_bezout_exitodd
    \fi
}%
\def\XINT_bezout_exiteven #1#2#3#4#5%
{%
    \space {#5}{#4}{#1}%
}%
\def\XINT_bezout_exitodd #1#2#3#4#5%
{%
    \space {-#5}{-#4}{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintEuclideAlgorithm}}
% \lverb|&
% Pour Euclide: 
% {N}{A}{D=r(n)}{B}{q1}{r1}{q2}{r2}{q3}{r3}....{qN}{rN=0}$\
% u<2n> = u<2n+3>u<2n+2> + u<2n+4> à la n ième étape|
%    \begin{macrocode}
\def\xintEuclideAlgorithm {\romannumeral0\xinteuclidealgorithm }%
\def\xinteuclidealgorithm #1%
{%
    \expandafter \XINT_euc \expandafter{\romannumeral0\xintiabs {#1}}%
}%
\def\XINT_euc #1#2%
{%
    \expandafter\XINT_euc_fork \romannumeral0\xintiabs {#2}\Z #1\Z
}%
%    \end{macrocode}
% \lverb|Ici #3#4=A, #1#2=B|
%    \begin{macrocode}
\def\XINT_euc_fork #1#2\Z #3#4\Z
{%
    \xint_UDzerofork
      #1\dummy \XINT_euc_BisZero
      #3\dummy \XINT_euc_AisZero
       0\dummy \XINT_euc_a
    \krof
    {0}{#1#2}{#3#4}{{#3#4}{#1#2}}{}\Z
}%
%    \end{macrocode}
% \lverb|&
% Le {} pour protéger {{A}{B}} si on s'arrête après une étape (B divise
% A).
% On va renvoyer:$\
% {N}{A}{D=r(n)}{B}{q1}{r1}{q2}{r2}{q3}{r3}....{qN}{rN=0}|
%    \begin{macrocode}
\def\XINT_euc_AisZero #1#2#3#4#5#6{ {1}{0}{#2}{#2}{0}{0}}%
\def\XINT_euc_BisZero #1#2#3#4#5#6{ {1}{0}{#3}{#3}{0}{0}}%
%    \end{macrocode}
% \lverb|&
% {n}{rn}{an}{{qn}{rn}}...{{A}{B}}{}\Z$\
%  a(n) = r(n-1). Pour n=0 on a juste {0}{B}{A}{{A}{B}}{}\Z$\
% \XINT_div_prepare {u}{v} divise v par u|
%    \begin{macrocode}
\def\XINT_euc_a #1#2#3%
{%
    \expandafter\XINT_euc_b
    \expandafter {\the\numexpr #1+1\expandafter }%
    \romannumeral0\XINT_div_prepare {#2}{#3}{#2}%
}%
%    \end{macrocode}
% \lverb|{n+1}{q(n+1)}{r(n+1)}{rn}{{qn}{rn}}...|
%    \begin{macrocode}
\def\XINT_euc_b #1#2#3#4%
{%
    \XINT_euc_c #3\Z {#1}{#3}{#4}{{#2}{#3}}%
}%
%    \end{macrocode}
% \lverb|r(n+1)\Z {n+1}{r(n+1)}{r(n)}{{q(n+1)}{r(n+1)}}{{qn}{rn}}...$\
% Test si r(n+1) est nul.|
%    \begin{macrocode}
\def\XINT_euc_c #1#2\Z 
{%
    \xint_gob_til_zero #1\xint_euc_end0\XINT_euc_a
}%
%    \end{macrocode}
% \lverb|&
% {n+1}{r(n+1)}{r(n)}{{q(n+1)}{r(n+1)}}...{}\Z
% Ici r(n+1) = 0. On arrête on se prépare à inverser
% {n+1}{0}{r(n)}{{q(n+1)}{r(n+1)}}.....{{q1}{r1}}{{A}{B}}{}\Z$\
% On veut renvoyer: {N=n+1}{A}{D=r(n)}{B}{q1}{r1}{q2}{r2}{q3}{r3}....{qN}{rN=0}|
%    \begin{macrocode}
\def\xint_euc_end0\XINT_euc_a #1#2#3#4\Z%
{%
    \expandafter\xint_euc_end_
    \romannumeral0%
    \XINT_rord_main {}#4{{#1}{#3}}%
    \xint_relax
      \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_undef\xint_undef\xint_undef\xint_undef
    \xint_relax
}%
\def\xint_euc_end_ #1#2#3%
{%
    \space {#1}{#3}{#2}%
}%
%    \end{macrocode}
% \subsection{\csh{xintBezoutAlgorithm}}
% \lverb|&
% Pour Bezout: objectif, renvoyer$\
% {N}{A}{0}{1}{D=r(n)}{B}{1}{0}{q1}{r1}{alpha1=q1}{beta1=1}$\
%       {q2}{r2}{alpha2}{beta2}....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}$\
% alpha0=1, beta0=0, alpha(-1)=0, beta(-1)=1|
%    \begin{macrocode}
\def\xintBezoutAlgorithm {\romannumeral0\xintbezoutalgorithm }%
\def\xintbezoutalgorithm #1%
{%
    \expandafter \XINT_bezalg \expandafter{\romannumeral0\xintiabs {#1}}%
}%
\def\XINT_bezalg #1#2%
{%
    \expandafter\XINT_bezalg_fork \romannumeral0\xintiabs {#2}\Z #1\Z
}%
%    \end{macrocode}
% \lverb|Ici #3#4=A, #1#2=B|
%    \begin{macrocode}
\def\XINT_bezalg_fork #1#2\Z #3#4\Z
{%
    \xint_UDzerofork
      #1\dummy \XINT_bezalg_BisZero
      #3\dummy \XINT_bezalg_AisZero
       0\dummy \XINT_bezalg_a
    \krof
    0{#1#2}{#3#4}1001{{#3#4}{#1#2}}{}\Z
}%
\def\XINT_bezalg_AisZero #1#2#3\Z{ {1}{0}{0}{1}{#2}{#2}{1}{0}{0}{0}{0}{1}}%
\def\XINT_bezalg_BisZero #1#2#3#4\Z{ {1}{0}{0}{1}{#3}{#3}{1}{0}{0}{0}{0}{1}}%
%    \end{macrocode}
% \lverb|&
% pour préparer l'étape n+1 il faut
% {n}{r(n)}{r(n-1)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}&
%                    {{q(n)}{r(n)}{alpha(n)}{beta(n)}}...
% division de #3 par #2|
%    \begin{macrocode}
\def\XINT_bezalg_a #1#2#3%
{%
    \expandafter\XINT_bezalg_b
    \expandafter {\the\numexpr #1+1\expandafter }%
    \romannumeral0\XINT_div_prepare {#2}{#3}{#2}%
}%
%    \end{macrocode}
% \lverb|&
% {n+1}{q(n+1)}{r(n+1)}{r(n)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}...|
%    \begin{macrocode}
\def\XINT_bezalg_b #1#2#3#4#5#6#7#8%
{%
    \expandafter\XINT_bezalg_c\expandafter
     {\romannumeral0\xintiadd {\xintiMul {#6}{#2}}{#8}}%
     {\romannumeral0\xintiadd {\xintiMul {#5}{#2}}{#7}}%
     {#1}{#2}{#3}{#4}{#5}{#6}%
}%
%    \end{macrocode}
% \lverb|&
% {beta(n+1)}{alpha(n+1)}{n+1}{q(n+1)}{r(n+1)}{r(n)}{alpha(n)}{beta(n}}|
%    \begin{macrocode}
\def\XINT_bezalg_c #1#2#3#4#5#6%
{%
    \expandafter\XINT_bezalg_d\expandafter {#2}{#3}{#4}{#5}{#6}{#1}%
}%
%    \end{macrocode}
% \lverb|{alpha(n+1)}{n+1}{q(n+1)}{r(n+1)}{r(n)}{beta(n+1)}|
%    \begin{macrocode}
\def\XINT_bezalg_d #1#2#3#4#5#6#7#8%
{%
    \XINT_bezalg_e #4\Z {#2}{#4}{#5}{#1}{#6}{#7}{#8}{{#3}{#4}{#1}{#6}}%
}%
%    \end{macrocode}
% \lverb|r(n+1)\Z {n+1}{r(n+1)}{r(n)}{alpha(n+1)}{beta(n+1)}$\
%                              {alpha(n)}{beta(n)}{q,r,alpha,beta(n+1)}$\
% Test si r(n+1) est nul.|
%    \begin{macrocode}
\def\XINT_bezalg_e #1#2\Z
{%
    \xint_gob_til_zero #1\xint_bezalg_end0\XINT_bezalg_a
}%
%    \end{macrocode}
% \lverb|&
% Ici r(n+1) = 0. On arrête on se prépare à inverser.$\
% {n+1}{r(n+1)}{r(n)}{alpha(n+1)}{beta(n+1)}{alpha(n)}{beta(n)}$\
%                     {q,r,alpha,beta(n+1)}...{{A}{B}}{}\Z$\
% On veut renvoyer$\
% {N}{A}{0}{1}{D=r(n)}{B}{1}{0}{q1}{r1}{alpha1=q1}{beta1=1}$\
%       {q2}{r2}{alpha2}{beta2}....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}|
%    \begin{macrocode}
\def\xint_bezalg_end0\XINT_bezalg_a #1#2#3#4#5#6#7#8\Z 
{%
    \expandafter\xint_bezalg_end_
    \romannumeral0%
    \XINT_rord_main {}#8{{#1}{#3}}%
    \xint_relax
      \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_undef\xint_undef\xint_undef\xint_undef
    \xint_relax
}%
%    \end{macrocode}
% \lverb|&
% {N}{D}{A}{B}{q1}{r1}{alpha1=q1}{beta1=1}{q2}{r2}{alpha2}{beta2}$\
%      ....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}$\
% On veut renvoyer$\
% {N}{A}{0}{1}{D=r(n)}{B}{1}{0}{q1}{r1}{alpha1=q1}{beta1=1}$\
%        {q2}{r2}{alpha2}{beta2}....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}|
%    \begin{macrocode}
\def\xint_bezalg_end_ #1#2#3#4%
{%
    \space {#1}{#3}{0}{1}{#2}{#4}{1}{0}%
}%
%    \end{macrocode}
% \subsection{\csh{xintTypesetEuclideAlgorithm}}
% \lverb|&
% TYPESETTING
%
% Organisation: 
%
% {N}{A}{D}{B}{q1}{r1}{q2}{r2}{q3}{r3}....{qN}{rN=0}$\
% \U1 = N = nombre d'étapes, \U3 = PGCD, \U2 = A, \U4=B
% q1 = \U5, q2 = \U7 --> qn = \U<2n+3>, rn = \U<2n+4>
% bn = rn. B = r0. A=r(-1)
%
% r(n-2) = q(n)r(n-1)+r(n) (n e étape) 
%
% \U{2n} = \U{2n+3} \times \U{2n+2} + \U{2n+4}, n e étape.
% (avec n entre 1 et N)|
%    \begin{macrocode}
\def\xintTypesetEuclideAlgorithm #1#2%
{% l'algo remplace #1 et #2 par |#1| et |#2|
  \par
  \begingroup
    \xintAssignArray\xintEuclideAlgorithm {#1}{#2}\to\U
    \edef\A{\U2}\edef\B{\U4}\edef\N{\U1}%
    \setbox 0 \vbox{\halign {$##$\cr \A\cr \B \cr}}%
    \noindent
    \count 255 1
    \loop
      \hbox to \wd 0 {\hfil$\U{\numexpr 2*\count 255\relax}$}%
      ${} =  \U{\numexpr 2*\count 255 + 3\relax}
      \times \U{\numexpr 2*\count 255 + 2\relax}
          +  \U{\numexpr 2*\count 255 + 4\relax}$%
    \ifnum \count 255 < \N
      \hfill\break
      \advance \count 255 1
    \repeat
  \par
  \endgroup
}%
%    \end{macrocode}
% \subsection{\csh{xintTypesetBezoutAlgorithm}}
% \lverb|&
% Pour Bezout on a: 
% {N}{A}{0}{1}{D=r(n)}{B}{1}{0}{q1}{r1}{alpha1=q1}{beta1=1}$\
%             {q2}{r2}{alpha2}{beta2}....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}%
% Donc 4N+8 termes:
% U1 = N, U2= A, U5=D, U6=B, q1 = U9, qn = U{4n+5}, n au moins 1$\
% rn = U{4n+6}, n au moins -1$\
% alpha(n) = U{4n+7}, n au moins -1$\
% beta(n)  = U{4n+8}, n au moins -1|
%    \begin{macrocode}
\def\xintTypesetBezoutAlgorithm #1#2%
{%
  \par
  \begingroup
    \parindent0pt
    \xintAssignArray\xintBezoutAlgorithm {#1}{#2}\to\BEZ
    \edef\A{\BEZ2}\edef\B{\BEZ6}\edef\N{\BEZ1}% A = |#1|, B = |#2|
    \setbox 0 \vbox{\halign {$##$\cr \A\cr \B \cr}}%
    \count 255 1
    \loop
      \noindent
      \hbox to \wd 0 {\hfil$\BEZ{4*\count 255 - 2}$}%
      ${} =  \BEZ{4*\count 255 + 5}
      \times \BEZ{4*\count 255 + 2}
          +  \BEZ{4*\count 255 + 6}$\hfill\break
      \hbox to \wd 0 {\hfil$\BEZ{4*\count 255 +7}$}%
      ${} = \BEZ{4*\count 255 + 5}
      \times \BEZ{4*\count 255 + 3}
          +  \BEZ{4*\count 255 - 1}$\hfill\break
      \hbox to \wd 0 {\hfil$\BEZ{4*\count 255 +8}$}% 
      ${} =  \BEZ{4*\count 255 + 5}
      \times \BEZ{4*\count 255 + 4}
          +  \BEZ{4*\count 255 }$
      \endgraf
    \ifnum \count 255 < \N
    \advance \count 255 1
  \repeat
  \par
    \edef\U{\BEZ{4*\N + 4}}%
    \edef\V{\BEZ{4*\N + 3}}%
    \edef\D{\BEZ5}%
    \ifodd\N
       $\U\times\A  - \V\times \B = -\D$%
    \else
       $\U\times\A - \V\times\B = \D$%
    \fi
  \par
  \endgroup
}%
\XINT_gcd_restorecatcodes_endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xintgcd>\relax
%\def<*xintfrac>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xintgcd>
%<*xintfrac>
% \section{Package \xintfracname implementation}
% 
% The commenting is currently (\docdate) very sparse.
%
% \localtableofcontents
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
%
% The code for reload detection is copied from \textsc{Heiko
% Oberdiek}'s packages, and adapted here to check for previous
% loading of the master \xintname package.
%
% The method for catcodes is slightly different, but still
% directly inspired by these packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \def\space { }%
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xintfrac.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xint.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintfrac}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintfrac.sty
      \ifx\w\relax % but xint.sty not yet loaded.
         \y{xintfrac}{Package xint is required}%
         \y{xintfrac}{Will try \string\input\space xint.sty}%
         \def\z{\endgroup\input xint.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xint.sty not yet loaded.
            \y{xintfrac}{Package xint is required}%
            \y{xintfrac}{Will try \string\RequirePackage{xint}}%
            \def\z{\endgroup\RequirePackage{xint}}%
          \fi
      \else
        \y{xintfrac}{I was already loaded, aborting input}%
        \aftergroup\endinput
      \fi
    \fi
  \fi
\z%
%    \end{macrocode}
% \subsection{Confirmation of \xintname loading}
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \def\empty {}%
  \expandafter\let\expandafter\w\csname ver@xint.sty\endcsname
  \ifx\w\relax % Plain TeX, user gave a file name at the prompt
      \y{xintfrac}{Loading of package xint failed, aborting input}%
      \aftergroup\endinput
  \fi
  \ifx\w\empty % LaTeX, user gave a file name at the prompt
      \y{xintfrac}{Loading of package xint failed, aborting input}%
      \aftergroup\endinput
  \fi
\endgroup%
%    \end{macrocode}
% \subsection{Catcodes}
%
% Perhaps catcodes have changed after the loading of \xintname
% and prior to the current loading of \xintfracname, so we can not employ
% the |\XINT_restorecatcodes_endinput| in this style file. But
% there is no problem using |\XINT_setcatcodes|.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode95=11   % _
  \def\x
  {%
      \endgroup
      \edef\XINT_frac_restorecatcodes_endinput
      {%
        \catcode93=\the\catcode93   % ]
        \catcode91=\the\catcode91   % [
        \catcode94=\the\catcode94   % ^
        \catcode96=\the\catcode96   % `
        \catcode47=\the\catcode47   % /
        \catcode41=\the\catcode41   % )
        \catcode40=\the\catcode40   % (
        \catcode42=\the\catcode42   % *
        \catcode43=\the\catcode43   % +
        \catcode62=\the\catcode62   % >
        \catcode60=\the\catcode60   % <
        \catcode58=\the\catcode58   % :
        \catcode46=\the\catcode46   % .
        \catcode45=\the\catcode45   % -
        \catcode44=\the\catcode44   % ,
        \catcode35=\the\catcode35   % #
        \catcode95=\the\catcode95   % _
        \catcode125=\the\catcode125 % }
        \catcode123=\the\catcode123 % {
        \endlinechar=\the\endlinechar
        \catcode13=\the\catcode13   % ^^M
        \catcode32=\the\catcode32   % 
        \catcode61=\the\catcode61\relax   % =
        \noexpand\endinput
      }%
      \XINT_setcatcodes % defined in xint.sty
      \catcode91=12 % [
      \catcode93=12 % ]
  }%
\x
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\begingroup
  \catcode64=11 % @
  \catcode58=12 % :
  \expandafter\ifx\csname ProvidesPackage\endcsname\relax
    \def\x#1#2#3[#4]{\endgroup
      \immediate\write-1{Package: #3 #4}%
      \xdef#1{#4}%
    }%
  \else
    \def\x#1#2[#3]{\endgroup
      #2[{#3}]%
      \ifx#1\@undefined
        \xdef#1{#3}%
      \fi
      \ifx#1\relax
        \xdef#1{#3}%
      \fi
    }%
  \fi
\expandafter\x\csname ver@xintfrac.sty\endcsname
\ProvidesPackage{xintfrac}%
  [2013/06/14 v1.08b Expandable operations on fractions (jfB)]%
\chardef\xint_c_vi     6
\chardef\xint_c_vii    7
\chardef\xint_c_xviii 18
\mathchardef\xint_c_x^iv 10000
%    \end{macrocode}
% \subsection{\csh{xintLen}}
%    \begin{macrocode}
\def\xintLen {\romannumeral0\xintlen }%
\def\xintlen #1%
{%
    \expandafter\XINT_flen\romannumeral0\XINT_infrac {#1}%
}%
\def\XINT_flen #1#2#3%
{%
    \expandafter\space
    \the\numexpr -1+\XINT_Abs {#1}+\XINT_Len {#2}+\XINT_Len {#3}\relax
}%
%    \end{macrocode}
% \subsection{\csh{XINT\_lenrord\_loop}}
%    \begin{macrocode}
\def\XINT_lenrord_loop #1#2#3#4#5#6#7#8#9% 
{%  faire \romannumeral-`0\XINT_lenrord_loop 0{}#1\Z\W\W\W\W\W\W\W\Z
    \xint_gob_til_W #9\XINT_lenrord_W\W
    \expandafter\XINT_lenrord_loop\expandafter 
    {\the\numexpr #1+7}{#9#8#7#6#5#4#3#2}%
}%
\def\XINT_lenrord_W\W\expandafter\XINT_lenrord_loop\expandafter #1#2#3\Z
{%
    \expandafter\XINT_lenrord_X\expandafter {#1}#2\Z
}%
\def\XINT_lenrord_X #1#2\Z
{%
    \XINT_lenrord_Y #2\R\R\R\R\R\R\T {#1}%
}%
\def\XINT_lenrord_Y #1#2#3#4#5#6#7#8\T
{%
    \xint_gob_til_W 
            #7\XINT_lenrord_Z \xint_c_viii
            #6\XINT_lenrord_Z \xint_c_vii
            #5\XINT_lenrord_Z \xint_c_vi
            #4\XINT_lenrord_Z \xint_c_v
            #3\XINT_lenrord_Z \xint_c_iv
            #2\XINT_lenrord_Z \xint_c_iii
            \W\XINT_lenrord_Z \xint_c_ii   \Z
}%
\def\XINT_lenrord_Z #1#2\Z #3% retourne: {longueur}renverse\Z
{%
    \expandafter{\the\numexpr #3-#1\relax}%
}%
%    \end{macrocode}
% \subsection{\csh{XINT\_outfrac}}
% \lverb|&
% 1.06a version now outputs 0/1[0] and not 0[0] in case of zero. More generally
% all macros have been checked in xintfrac, xintseries, xintcfrac, to make sure
% the output format for fractions was always A/B[n]. (except of course \xintIrr,
% \xintJrr, \xintRawWithZeros)|
%    \begin{macrocode}
\def\XINT_outfrac #1#2#3%
{%
    \ifcase\XINT_Sgn{#3}
        \expandafter \XINT_outfrac_divisionbyzero
    \or
        \expandafter \XINT_outfrac_P
    \else
        \expandafter \XINT_outfrac_N 
    \fi
    {#2}{#3}[#1]%
}%
\def\XINT_outfrac_divisionbyzero #1#2{\xintError:DivisionByZero\space #1/0}%
\def\XINT_outfrac_P #1#2%
{%
    \ifcase\XINT_Sgn{#1}
        \expandafter\XINT_outfrac_Zero
    \fi
    \space #1/#2%
}%
\def\XINT_outfrac_Zero #1[#2]{ 0/1[0]}%
\def\XINT_outfrac_N #1#2%
{%
    \expandafter\XINT_outfrac_N_a\expandafter
    {\romannumeral0\XINT_opp #2}{\romannumeral0\XINT_opp #1}%
}%
\def\XINT_outfrac_N_a #1#2%
{%
    \expandafter\XINT_outfrac_P\expandafter {#2}{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{XINT\_inFrac}}
% \lverb|Extended in 1.07 to accept scientific notation on input. With lowercase
% e only. The \xintexpr parser does accept uppercase E also.|
%    \begin{macrocode}
\def\XINT_inFrac {\romannumeral0\XINT_infrac }%
\def\XINT_infrac #1%
{%
    \expandafter\XINT_infrac_ \romannumeral-`0#1[\W]\Z\T
}%
\def\XINT_infrac_ #1[#2#3]#4\Z
{%
    \xint_UDwfork
      #2\dummy \XINT_infrac_A
      \W\dummy \XINT_infrac_B
    \krof
    #1[#2#3]#4%
}%
\def\XINT_infrac_A #1[\W]\T 
{%
    \XINT_frac #1/\W\Z 
}%
\def\XINT_infrac_B #1%
{%
    \xint_gob_til_zero #1\XINT_infrac_Zero0\XINT_infrac_BB #1%
}%
\def\XINT_infrac_BB #1[\W]\T {\XINT_infrac_BC #1/\W\Z }%
\def\XINT_infrac_BC #1/#2#3\Z 
{%
    \xint_UDwfork
     #2\dummy \XINT_infrac_BCa
     \W\dummy {\expandafter\XINT_infrac_BCb \romannumeral-`0#2}%
    \krof
    #3\Z #1\Z
}%
\def\XINT_infrac_BCa \Z #1[#2]#3\Z { {#2}{#1}{1}}%
\def\XINT_infrac_BCb #1[#2]/\W\Z #3\Z { {#2}{#3}{#1}}%
\def\XINT_infrac_Zero #1\T { {0}{0}{1}}%
%    \end{macrocode}
% \subsection{\csh{XINT\_frac}}
% \lverb|Extended in 1.07 to recognize and accept scientific notation both at
% the numerator and (possible) denominator. Only a lowercase e will do here, but
% uppercase E is possible within an \xintexpr..\relax |
%    \begin{macrocode}
\def\XINT_frac #1/#2#3\Z
{%
    \xint_UDwfork
     #2\dummy \XINT_frac_A
     \W\dummy {\expandafter\XINT_frac_U \romannumeral-`0#2}%
    \krof
    #3e\W\Z #1e\W\Z
}%
\def\XINT_frac_U #1e#2#3\Z
{%
    \xint_UDwfork
      #2\dummy  \XINT_frac_Ua
      \W\dummy {\XINT_frac_Ub #2}%
    \krof
    #3\Z #1\Z
}%
\def\XINT_frac_Ua      \Z #1/\W\Z  {\XINT_frac_B #1.\W\Z {0}}%
\def\XINT_frac_Ub #1/\W e\W\Z #2\Z {\XINT_frac_B #2.\W\Z {#1}}%
\def\XINT_frac_B #1.#2#3\Z
{%
    \xint_UDwfork
      #2\dummy  \XINT_frac_Ba
      \W\dummy {\XINT_frac_Bb #2}%
    \krof
    #3\Z #1\Z
}%
\def\XINT_frac_Ba \Z #1\Z {\XINT_frac_T {0}{#1}}%
\def\XINT_frac_Bb #1.\W\Z #2\Z
{%
    \expandafter \XINT_frac_T \expandafter
    {\romannumeral0\XINT_length {#1}}{#2#1}%
}%
\def\XINT_frac_A e\W\Z {\XINT_frac_T {0}{1}{0}}%
\def\XINT_frac_T #1#2#3#4e#5#6\Z
{%
    \xint_UDwfork
      #5\dummy  \XINT_frac_Ta
      \W\dummy {\XINT_frac_Tb #5}%
    \krof
    #6\Z #4\Z {#1}{#2}{#3}%
}%
\def\XINT_frac_Ta \Z #1\Z      {\XINT_frac_C #1.\W\Z {0}}%
\def\XINT_frac_Tb #1e\W\Z #2\Z {\XINT_frac_C #2.\W\Z {#1}}%
\def\XINT_frac_C #1.#2#3\Z
{%
    \xint_UDwfork
      #2\dummy \XINT_frac_Ca
      \W\dummy {\XINT_frac_Cb #2}%
    \krof
    #3\Z #1\Z
}%
\def\XINT_frac_Ca \Z #1\Z {\XINT_frac_D {0}{#1}}%
\def\XINT_frac_Cb #1.\W\Z #2\Z 
{%
    \expandafter\XINT_frac_D\expandafter
    {\romannumeral0\XINT_length {#1}}{#2#1}%
}%
\def\XINT_frac_D #1#2#3#4#5#6%
{%
    \expandafter \XINT_frac_E \expandafter
    {\the\numexpr -#1+#3+#4-#6\expandafter}\expandafter
    {\romannumeral0\XINT_num_loop #2%
     \xint_relax\xint_relax\xint_relax\xint_relax
     \xint_relax\xint_relax\xint_relax\xint_relax\Z }%
    {\romannumeral0\XINT_num_loop #5%
     \xint_relax\xint_relax\xint_relax\xint_relax
     \xint_relax\xint_relax\xint_relax\xint_relax\Z }%
}%
\def\XINT_frac_E #1#2#3%
{%
   \expandafter \XINT_frac_F  #3\Z {#2}{#1}%
}%
\def\XINT_frac_F #1%
{%
    \xint_UDzerominusfork
      #1-\dummy  \XINT_frac_Gdivisionbyzero
      0#1\dummy  \XINT_frac_Gneg
       0-\dummy  {\XINT_frac_Gpos #1}%
    \krof
}%
\def\XINT_frac_Gdivisionbyzero #1\Z #2#3%
{%
   \xintError:DivisionByZero\space {0}{#2}{0}%
}%
\def\XINT_frac_Gneg #1\Z #2#3%
{%
    \expandafter\XINT_frac_H \expandafter{\romannumeral0\XINT_opp #2}{#3}{#1}%
}%
\def\XINT_frac_H #1#2{ {#2}{#1}}%
\def\XINT_frac_Gpos #1\Z #2#3{ {#3}{#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{XINT\_factortens},~\csh{XINT\_cuz\_cnt}}
%    \begin{macrocode}
\def\XINT_factortens #1%
{%
    \expandafter\XINT_cuz_cnt_loop\expandafter
    {\expandafter}\romannumeral0\XINT_rord_main {}#1%
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax
    \R\R\R\R\R\R\R\R\Z
}%
\def\XINT_cuz_cnt #1%
{%
    \XINT_cuz_cnt_loop {}#1\R\R\R\R\R\R\R\R\Z
}%
\def\XINT_cuz_cnt_loop #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_R #9\XINT_cuz_cnt_toofara \R
    \expandafter\XINT_cuz_cnt_checka\expandafter
    {\the\numexpr #1+8\relax}{#2#3#4#5#6#7#8#9}%
}%
\def\XINT_cuz_cnt_toofara\R
    \expandafter\XINT_cuz_cnt_checka\expandafter #1#2%
{%
    \XINT_cuz_cnt_toofarb {#1}#2%
}%
\def\XINT_cuz_cnt_toofarb #1#2\Z {\XINT_cuz_cnt_toofarc #2\Z {#1}}%
\def\XINT_cuz_cnt_toofarc #1#2#3#4#5#6#7#8%
{%
    \xint_gob_til_R #2\XINT_cuz_cnt_toofard 7%
            #3\XINT_cuz_cnt_toofard 6%
            #4\XINT_cuz_cnt_toofard 5%
            #5\XINT_cuz_cnt_toofard 4%
            #6\XINT_cuz_cnt_toofard 3%
            #7\XINT_cuz_cnt_toofard 2%
            #8\XINT_cuz_cnt_toofard 1%
            \Z #1#2#3#4#5#6#7#8%
}%
\def\XINT_cuz_cnt_toofard #1#2\Z #3\R #4\Z #5%
{%
    \expandafter\XINT_cuz_cnt_toofare
    \the\numexpr #3\relax \R\R\R\R\R\R\R\R\Z
    {\the\numexpr #5-#1\relax}\R\Z
}%
\def\XINT_cuz_cnt_toofare #1#2#3#4#5#6#7#8%
{%
    \xint_gob_til_R #2\XINT_cuz_cnt_stopc 1%
            #3\XINT_cuz_cnt_stopc 2%
            #4\XINT_cuz_cnt_stopc 3%
            #5\XINT_cuz_cnt_stopc 4%
            #6\XINT_cuz_cnt_stopc 5%
            #7\XINT_cuz_cnt_stopc 6%
            #8\XINT_cuz_cnt_stopc 7%
            \Z #1#2#3#4#5#6#7#8%
}%
\def\XINT_cuz_cnt_checka #1#2%
{%
    \expandafter\XINT_cuz_cnt_checkb\the\numexpr #2\relax \Z {#1}%
}%
\def\XINT_cuz_cnt_checkb #1%
{%
    \xint_gob_til_zero #1\expandafter\XINT_cuz_cnt_loop\xint_gob_til_Z
    0\XINT_cuz_cnt_stopa #1%
}%
\def\XINT_cuz_cnt_stopa #1\Z 
{%
    \XINT_cuz_cnt_stopb #1\R\R\R\R\R\R\R\R\Z %
}%
\def\XINT_cuz_cnt_stopb #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_R #2\XINT_cuz_cnt_stopc 1%
            #3\XINT_cuz_cnt_stopc 2%
            #4\XINT_cuz_cnt_stopc 3%
            #5\XINT_cuz_cnt_stopc 4%
            #6\XINT_cuz_cnt_stopc 5%
            #7\XINT_cuz_cnt_stopc 6%
            #8\XINT_cuz_cnt_stopc 7%
            #9\XINT_cuz_cnt_stopc 8%
            \Z #1#2#3#4#5#6#7#8#9%
}%
\def\XINT_cuz_cnt_stopc #1#2\Z #3\R #4\Z #5%
{%
    \expandafter\XINT_cuz_cnt_stopd\expandafter
    {\the\numexpr #5-#1}#3%
}%
\def\XINT_cuz_cnt_stopd #1#2\R #3\Z
{%
    \expandafter\space\expandafter
     {\romannumeral0\XINT_rord_main {}#2%
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax }{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintRaw}}
% \lverb|&
% 1.07: this macro simply prints in a user readable form the fraction after its 
% initial scanning. Useful when put inside braces in an \xintexpr, when the
% input is not yet in the A/B[n] form.|
%    \begin{macrocode}
\def\xintRaw {\romannumeral0\xintraw }%
\def\xintraw
{%
    \expandafter\XINT_raw\romannumeral0\XINT_infrac
}%
\def\XINT_raw #1#2#3{ #2/#3[#1]}%
%    \end{macrocode}
% \subsection{\csh{xintRawWithZeros}}
% \lverb|&
% This was called \xintRaw in versions earlier than 1.07|
%    \begin{macrocode}
\def\xintRawWithZeros {\romannumeral0\xintrawwithzeros }%
\def\xintrawwithzeros
{%
    \expandafter\XINT_rawz\romannumeral0\XINT_infrac
}%
\def\XINT_rawz #1%
{%
    \ifcase\XINT_Sgn {#1}
      \expandafter\XINT_rawz_Ba
    \or
      \expandafter\XINT_rawz_A
    \else
      \expandafter\XINT_rawz_Ba
    \fi 
    {#1}%
}%
\def\XINT_rawz_A  #1#2#3{\xint_dsh {#2}{-#1}/#3}%
\def\XINT_rawz_Ba #1#2#3{\expandafter\XINT_rawz_Bb
                        \expandafter{\romannumeral0\xint_dsh {#3}{#1}}{#2}}%
\def\XINT_rawz_Bb #1#2{ #2/#1}%
%    \end{macrocode}
% \subsection{\csh{xintNumerator}}
%    \begin{macrocode}
\def\xintNumerator {\romannumeral0\xintnumerator }%
\def\xintnumerator 
{%
    \expandafter\XINT_numer\romannumeral0\XINT_infrac
}%
\def\XINT_numer #1%
{%
    \ifcase\XINT_Sgn {#1}
      \expandafter\XINT_numer_B
    \or
      \expandafter\XINT_numer_A
    \else
      \expandafter\XINT_numer_B
    \fi 
    {#1}%
}%
\def\XINT_numer_A #1#2#3{\xint_dsh {#2}{-#1}}%
\def\XINT_numer_B #1#2#3{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintDenominator}}
%    \begin{macrocode}
\def\xintDenominator {\romannumeral0\xintdenominator }%
\def\xintdenominator 
{%
    \expandafter\XINT_denom\romannumeral0\XINT_infrac
}%
\def\XINT_denom #1%
{%
    \ifcase\XINT_Sgn {#1}
      \expandafter\XINT_denom_B
    \or
      \expandafter\XINT_denom_A
    \else
      \expandafter\XINT_denom_B
    \fi 
    {#1}%
}%
\def\XINT_denom_A #1#2#3{ #3}%
\def\XINT_denom_B #1#2#3{\xint_dsh {#3}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintFrac}}
%    \begin{macrocode}
\def\xintFrac {\romannumeral0\xintfrac }%
\def\xintfrac #1%
{%
    \expandafter\XINT_fracfrac_A\romannumeral0\XINT_infrac {#1}%
}%
\def\XINT_fracfrac_A #1{\XINT_fracfrac_B #1\Z }%
\catcode`^=7
\def\XINT_fracfrac_B #1#2\Z 
{%
    \xint_gob_til_zero #1\XINT_fracfrac_C 0\XINT_fracfrac_D {10^{#1#2}}%
}%
\def\XINT_fracfrac_C #1#2#3#4#5% 
{%
    \ifcase\XINT_isOne {#5}
    \or \xint_afterfi {\expandafter\xint_firstoftwo_andstop\xint_gobble_ii }%
    \fi
    \space
    \frac {#4}{#5}%
}%
\def\XINT_fracfrac_D #1#2#3%
{%
    \ifcase\XINT_isOne {#3}
    \or \XINT_fracfrac_E
    \fi
    \space
    \frac {#2}{#3}#1%
}%
\def\XINT_fracfrac_E \fi #1#2#3#4{\fi \space #3\cdot }%
%    \end{macrocode}
% \subsection{\csh{xintSignedFrac}}
%    \begin{macrocode}
\def\xintSignedFrac {\romannumeral0\xintsignedfrac }%
\def\xintsignedfrac #1%
{%
    \expandafter\XINT_sgnfrac_a\romannumeral0\XINT_infrac {#1}%
}%
\def\XINT_sgnfrac_a #1#2%
{%
    \XINT_sgnfrac_b #2\Z {#1}%
}%
\def\XINT_sgnfrac_b #1%
{%
    \xint_UDsignfork
      #1\dummy \XINT_sgnfrac_N
       -\dummy {\XINT_sgnfrac_P #1}%
    \krof
}%
\def\XINT_sgnfrac_P #1\Z #2%
{%
    \XINT_fracfrac_A {#2}{#1}%
}%
\def\XINT_sgnfrac_N
{%
    \expandafter\xint_minus_andstop\romannumeral0\XINT_sgnfrac_P 
}%
%    \end{macrocode}
% \subsection{\csh{xintFwOver}}
%    \begin{macrocode}
\def\xintFwOver {\romannumeral0\xintfwover }%
\def\xintfwover #1%
{%
    \expandafter\XINT_fwover_A\romannumeral0\XINT_infrac {#1}%
}%
\def\XINT_fwover_A #1{\XINT_fwover_B #1\Z }%
\def\XINT_fwover_B #1#2\Z 
{%
    \xint_gob_til_zero #1\XINT_fwover_C 0\XINT_fwover_D {10^{#1#2}}%
}%
\catcode`^=11
\def\XINT_fwover_C #1#2#3#4#5% 
{%
    \ifcase\XINT_isOne {#5}
       \xint_afterfi { {#4\over #5}}%
    \or 
       \xint_afterfi { #4}%
    \fi
}%
\def\XINT_fwover_D #1#2#3%
{%
    \ifcase\XINT_isOne {#3}
      \xint_afterfi { {#2\over #3}}%
    \or 
      \xint_afterfi { #2\cdot }%
    \fi
    #1%
}%
%    \end{macrocode}
% \subsection{\csh{xintSignedFwOver}}
%    \begin{macrocode}
\def\xintSignedFwOver {\romannumeral0\xintsignedfwover }%
\def\xintsignedfwover #1%
{%
    \expandafter\XINT_sgnfwover_a\romannumeral0\XINT_infrac {#1}%
}%
\def\XINT_sgnfwover_a #1#2%
{%
    \XINT_sgnfwover_b #2\Z {#1}%
}%
\def\XINT_sgnfwover_b #1%
{%
    \xint_UDsignfork
      #1\dummy \XINT_sgnfwover_N
       -\dummy {\XINT_sgnfwover_P #1}%
    \krof
}%
\def\XINT_sgnfwover_P #1\Z #2%
{%
    \XINT_fwover_A {#2}{#1}%
}%
\def\XINT_sgnfwover_N
{%
    \expandafter\xint_minus_andstop\romannumeral0\XINT_sgnfwover_P 
}%
%    \end{macrocode}
% \subsection{\csh{xintREZ}}
%    \begin{macrocode}
\def\xintREZ {\romannumeral0\xintrez }%
\def\xintrez
{%
    \expandafter\XINT_rez_A\romannumeral0\XINT_infrac
}%
\def\XINT_rez_A #1#2%
{%
    \XINT_rez_AB #2\Z {#1}%
}%
\def\XINT_rez_AB #1%
{%
    \xint_UDzerominusfork
      #1-\dummy \XINT_rez_zero
      0#1\dummy \XINT_rez_neg
       0-\dummy {\XINT_rez_B #1}%
    \krof
}%
\def\XINT_rez_zero #1\Z #2#3{ 0/1[0]}%
\def\XINT_rez_neg {\expandafter\xint_minus_andstop\romannumeral0\XINT_rez_B }%
\def\XINT_rez_B #1\Z 
{%
    \expandafter\XINT_rez_C\romannumeral0\XINT_factortens {#1}%
}%
\def\XINT_rez_C #1#2#3#4%
{%
    \expandafter\XINT_rez_D\romannumeral0\XINT_factortens {#4}{#3}{#2}{#1}%
}%
\def\XINT_rez_D #1#2#3#4#5%
{%
    \expandafter\XINT_rez_E\expandafter
    {\the\numexpr #3+#4-#2}{#1}{#5}%
}%
\def\XINT_rez_E #1#2#3{ #3/#2[#1]}%
%    \end{macrocode}
% \subsection{\csh{xintE}}
% \lverb|added with with 1.07, together with support for `floats'. The fraction
% comes first here, contrarily to \xintTrunc and \xintRound.|
%    \begin{macrocode}
\def\xintE {\romannumeral0\xinte }%
\def\xinte #1%
{%
    \expandafter\XINT_e \romannumeral0\XINT_infrac {#1}%
}%
\def\XINT_e #1#2#3#4%
{%
    \expandafter\XINT_e_end\expandafter{\the\numexpr #1+#4}{#2}{#3}%
}%
\def\xintfE {\romannumeral0\xintfe }%
\def\xintfe #1%
{%
    \expandafter\XINT_fe \romannumeral0\XINT_infrac {#1}%
}%
\def\XINT_fe #1#2#3#4%
{%
    \expandafter\XINT_e_end\expandafter{\the\numexpr #1+\xintNum{#4}}{#2}{#3}%
}%
\def\XINT_e_end #1#2#3{ #2/#3[#1]}%
\let\XINTinFloatfE\xintfE
%    \end{macrocode}
% \subsection{\csh{xintIrr}}
% \lverb|&
% 1.04 fixes a buggy \xintIrr {0}. 
% 1.05 modifies the initial parsing and post-processing to use \xintrawwithzeros
% and to 
% more quickly deal with an input denominator equal to 1. 1.08 version does
% not remove a /1 denominator.|
%    \begin{macrocode}
\def\xintIrr {\romannumeral0\xintirr }%
\def\xintirr #1%
{%
    \expandafter\XINT_irr_start\romannumeral0\xintrawwithzeros {#1}\Z
}%
\def\XINT_irr_start #1#2/#3\Z
{%
    \ifcase\XINT_isOne {#3}
      \xint_afterfi
          {\xint_UDsignfork
               #1\dummy \XINT_irr_negative    
                -\dummy {\XINT_irr_nonneg #1}%       
           \krof}%
    \or
      \xint_afterfi{\XINT_irr_denomisone #1}%
    \fi 
    #2\Z {#3}%
}%
\def\XINT_irr_denomisone #1\Z #2{ #1/1}% changed in 1.08
\def\XINT_irr_negative   #1\Z #2{\XINT_irr_D #1\Z #2\Z \xint_minus_andstop}%
\def\XINT_irr_nonneg     #1\Z #2{\XINT_irr_D #1\Z #2\Z \space}%
\def\XINT_irr_D #1#2\Z #3#4\Z
{%
    \xint_UDzerosfork
       #3#1\dummy \XINT_irr_indeterminate      
       #30\dummy  \XINT_irr_divisionbyzero        
       #10\dummy  \XINT_irr_zero        
        00\dummy  \XINT_irr_loop_a
    \krof      
    {#3#4}{#1#2}{#3#4}{#1#2}%
}%
\def\XINT_irr_indeterminate #1#2#3#4#5{\xintError:NaN\space 0/0}%
\def\XINT_irr_divisionbyzero #1#2#3#4#5{\xintError:DivisionByZero #5#2/0}%
\def\XINT_irr_zero #1#2#3#4#5{ 0/1}% changed in 1.08
\def\XINT_irr_loop_a #1#2%
{%
    \expandafter\XINT_irr_loop_d
    \romannumeral0\XINT_div_prepare {#1}{#2}{#1}%
}%
\def\XINT_irr_loop_d #1#2%
{%
    \XINT_irr_loop_e #2\Z 
}%
\def\XINT_irr_loop_e #1#2\Z
{%
    \xint_gob_til_zero #1\xint_irr_loop_exit0\XINT_irr_loop_a {#1#2}%
}%
\def\xint_irr_loop_exit0\XINT_irr_loop_a #1#2#3#4%
{%
    \expandafter\XINT_irr_loop_exitb\expandafter
    {\romannumeral0\xintiquo {#3}{#2}}%
    {\romannumeral0\xintiquo {#4}{#2}}%
}%
\def\XINT_irr_loop_exitb #1#2%
{%
   \expandafter\XINT_irr_finish\expandafter {#2}{#1}%
}%
\def\XINT_irr_finish #1#2#3{#3#1/#2}% changed in 1.08
%    \end{macrocode}
% \subsection{\csh{xintNum}}
% \lverb|&
% This extension of the xint original xintNum is added in 1.05, as a
% synonym to 
% \xintIrr, but raising an error when the input does not evaluate to an integer.
% Usable with not too much overhead on integer input as \xintIrr 
% checks quickly for a denominator equal to 1 (which will be put there by the
% \XINT_infrac called by \xintrawwithzeros). This way, macros such as \xintQuo
% can be 
% modified with minimal overhead to accept fractional input as long as it
% evaluates to an integer. |
%    \begin{macrocode}
\def\xintNum {\romannumeral0\xintnum }%
\def\xintnum #1{\expandafter\XINT_intcheck\romannumeral0\xintirr {#1}\Z }%
\def\XINT_intcheck #1/#2\Z
{%
    \ifcase\XINT_isOne {#2}
      \xintError:NotAnInteger
    \fi\space #1%
}%
%    \end{macrocode}
% \subsection{\csh{xintJrr}}
% \lverb|&
% Modified similarly as \xintIrr in release 1.05. 1.08 version does
% not remove a /1 denominator.|
%    \begin{macrocode}
\def\xintJrr {\romannumeral0\xintjrr }%
\def\xintjrr #1%
{%
    \expandafter\XINT_jrr_start\romannumeral0\xintrawwithzeros {#1}\Z
}%
\def\XINT_jrr_start #1#2/#3\Z
{%
    \ifcase\XINT_isOne {#3}
      \xint_afterfi
          {\xint_UDsignfork
               #1\dummy \XINT_jrr_negative    
                -\dummy {\XINT_jrr_nonneg #1}%       
           \krof}%
    \or
      \xint_afterfi{\XINT_jrr_denomisone #1}%
    \fi 
    #2\Z {#3}%
}%
\def\XINT_jrr_denomisone #1\Z #2{ #1/1}% changed in 1.08
\def\XINT_jrr_negative   #1\Z #2{\XINT_jrr_D #1\Z #2\Z \xint_minus_andstop }%
\def\XINT_jrr_nonneg     #1\Z #2{\XINT_jrr_D #1\Z #2\Z \space}%
\def\XINT_jrr_D #1#2\Z #3#4\Z
{%
    \xint_UDzerosfork
       #3#1\dummy \XINT_jrr_indeterminate      
       #30\dummy  \XINT_jrr_divisionbyzero        
       #10\dummy  \XINT_jrr_zero        
        00\dummy  \XINT_jrr_loop_a
    \krof      
    {#3#4}{#1#2}1001%
}%
\def\XINT_jrr_indeterminate #1#2#3#4#5#6#7{\xintError:NaN\space 0/0}%
\def\XINT_jrr_divisionbyzero #1#2#3#4#5#6#7{\xintError:DivisionByZero #7#2/0}%
\def\XINT_jrr_zero #1#2#3#4#5#6#7{ 0/1}% changed in 1.08
\def\XINT_jrr_loop_a #1#2%
{%
    \expandafter\XINT_jrr_loop_b
    \romannumeral0\XINT_div_prepare {#1}{#2}{#1}%
}%
\def\XINT_jrr_loop_b #1#2#3#4#5#6#7%
{%
    \expandafter \XINT_jrr_loop_c \expandafter
        {\romannumeral0\xintiadd{\XINT_Mul{#4}{#1}}{#6}}%
        {\romannumeral0\xintiadd{\XINT_Mul{#5}{#1}}{#7}}%
    {#2}{#3}{#4}{#5}%
}%
\def\XINT_jrr_loop_c #1#2%
{%
    \expandafter \XINT_jrr_loop_d \expandafter{#2}{#1}%
}%
\def\XINT_jrr_loop_d #1#2#3#4%
{%
    \XINT_jrr_loop_e #3\Z {#4}{#2}{#1}%
}%
\def\XINT_jrr_loop_e #1#2\Z
{%
    \xint_gob_til_zero #1\xint_jrr_loop_exit0\XINT_jrr_loop_a {#1#2}%
}%
\def\xint_jrr_loop_exit0\XINT_jrr_loop_a #1#2#3#4#5#6%
{%
    \XINT_irr_finish {#3}{#4}%
}%
%    \end{macrocode}
% \subsection{\csh{xintTrunc}, \csh{xintiTrunc}}
% \lverb|&
% Modified in 1.06 to give the first argument to a \numexpr.|
%    \begin{macrocode}
\def\xintTrunc {\romannumeral0\xinttrunc }%
\def\xintiTrunc {\romannumeral0\xintitrunc }%
\def\xinttrunc #1%
{%
    \expandafter\XINT_trunc\expandafter {\the\numexpr #1}%
}%
\def\XINT_trunc #1#2%
{%
    \expandafter\XINT_trunc_G
    \romannumeral0\expandafter\XINT_trunc_A
    \romannumeral0\XINT_infrac {#2}{#1}{#1}%
}%
\def\xintitrunc #1%
{%
    \expandafter\XINT_itrunc\expandafter {\the\numexpr #1}%
}%
\def\XINT_itrunc #1#2%
{%
    \expandafter\XINT_itrunc_G
    \romannumeral0\expandafter\XINT_trunc_A
    \romannumeral0\XINT_infrac {#2}{#1}{#1}%
}%
\def\XINT_trunc_A #1#2#3#4%
{%
    \expandafter\XINT_trunc_checkifzero
    \expandafter{\the\numexpr #1+#4}#2\Z {#3}%
}%
\def\XINT_trunc_checkifzero #1#2#3\Z 
{%
    \xint_gob_til_zero #2\XINT_trunc_iszero0\XINT_trunc_B {#1}{#2#3}%
}%
\def\XINT_trunc_iszero #1#2#3#4#5{ 0\Z 0}%
\def\XINT_trunc_B #1%
{%
    \ifcase\XINT_Sgn {#1}
      \expandafter\XINT_trunc_D
    \or
      \expandafter\XINT_trunc_D
    \else
      \expandafter\XINT_trunc_C
    \fi 
    {#1}%
}%
\def\XINT_trunc_C #1#2#3%
{%
    \expandafter \XINT_trunc_E
    \romannumeral0\xint_dsh {#3}{#1}\Z #2\Z
}%
\def\XINT_trunc_D #1#2%
{%
    \expandafter \XINT_trunc_DE \expandafter
    {\romannumeral0\xint_dsh {#2}{-#1}}%
}%
\def\XINT_trunc_DE #1#2{\XINT_trunc_E #2\Z #1\Z }%
\def\XINT_trunc_E #1#2\Z #3#4\Z
{%
    \xint_UDsignsfork
          #1#3\dummy \XINT_trunc_minusminus          
           #1-\dummy {\XINT_trunc_minusplus #3}%
           #3-\dummy {\XINT_trunc_plusminus #1}%
            --\dummy {\XINT_trunc_plusplus  #3#1}%
    \krof
    {#4}{#2}%
}%
\def\XINT_trunc_minusminus #1#2{\xintiquo {#1}{#2}\Z \space}%
\def\XINT_trunc_minusplus #1#2#3{\xintiquo {#1#2}{#3}\Z \xint_minus_andstop}%
\def\XINT_trunc_plusminus #1#2#3{\xintiquo {#2}{#1#3}\Z \xint_minus_andstop}%
\def\XINT_trunc_plusplus  #1#2#3#4{\xintiquo {#1#3}{#2#4}\Z \space}%
\def\XINT_itrunc_G #1#2\Z #3#4%
{%
    \xint_gob_til_zero #1\XINT_trunc_zero 0\xint_firstoftwo {#3#1#2}0%
}%
\def\XINT_trunc_G #1\Z #2#3%
{%
    \xint_gob_til_zero #2\XINT_trunc_zero 0%
    \expandafter\XINT_trunc_H\expandafter
    {\the\numexpr\romannumeral0\XINT_length {#1}-#3}{#3}{#1}#2%
}%
\def\XINT_trunc_zero 0#10{ 0}%
\def\XINT_trunc_H #1#2%
{%
    \ifnum #1 > 0
        \xint_afterfi {\XINT_trunc_Ha {#2}}%
    \else
        \xint_afterfi {\XINT_trunc_Hb {-#1}}% -0,--1,--2, ....
    \fi
}%
\def\XINT_trunc_Ha
{%
  \expandafter\XINT_trunc_Haa\romannumeral0\xintdecsplit
}%
\def\XINT_trunc_Haa #1#2#3%
{%
    #3#1.#2%
}%
\def\XINT_trunc_Hb #1#2#3%
{%
    \expandafter #3\expandafter0\expandafter.%
    \romannumeral0\XINT_dsx_zeroloop {#1}{}\Z {}#2% #1=-0 possible! 
}%
%    \end{macrocode}
% \subsection{\csh{xintRound}, \csh{xintiRound}}
% \lverb|&
% Modified in 1.06 to give the first argument to a \numexpr.|
%    \begin{macrocode}
\def\xintRound {\romannumeral0\xintround }%
\def\xintiRound {\romannumeral0\xintiround }%
\def\xintround #1%
{%
    \expandafter\XINT_round\expandafter {\the\numexpr #1}%
}%
\def\XINT_round
{%
    \expandafter\XINT_trunc_G\romannumeral0\XINT_round_A
}%
\def\xintiround #1%
{%
    \expandafter\XINT_iround\expandafter {\the\numexpr #1}%
}%
\def\XINT_iround
{%
    \expandafter\XINT_itrunc_G\romannumeral0\XINT_round_A
}%
\def\XINT_round_A #1#2%
{%
    \expandafter\XINT_round_B
    \romannumeral0\expandafter\XINT_trunc_A
    \romannumeral0\XINT_infrac {#2}{\the\numexpr #1+1\relax}{#1}%
}%
\def\XINT_round_B #1\Z
{%
    \expandafter\XINT_round_C
    \romannumeral0\XINT_rord_main {}#1%
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax 
    \Z 
}%
\def\XINT_round_C #1%
{%
    \ifnum #1<5
        \expandafter\XINT_round_Daa
    \else
        \expandafter\XINT_round_Dba
    \fi
}%
\def\XINT_round_Daa #1%
{%
    \xint_gob_til_Z #1\XINT_round_Daz\Z \XINT_round_Da #1%
}%
\def\XINT_round_Daz\Z \XINT_round_Da \Z { 0\Z }%
\def\XINT_round_Da #1\Z 
{%
    \XINT_rord_main {}#1%
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax  \Z  
}%
\def\XINT_round_Dba #1%
{%
    \xint_gob_til_Z #1\XINT_round_Dbz\Z \XINT_round_Db #1%
}%
\def\XINT_round_Dbz\Z \XINT_round_Db \Z { 1\Z }%
\def\XINT_round_Db #1\Z
{%
    \XINT_addm_A 0{}1000\W\X\Y\Z #1000\W\X\Y\Z \Z
}%
%    \end{macrocode}
% \subsection{\csh{xintDigits}}
%    \begin{macrocode}
\mathchardef\XINT_digits 16
\def\xintDigits #1#2%
   {\afterassignment \xint_gobble_i \mathchardef\XINT_digits=}%
\def\xinttheDigits {\number\XINT_digits }%
%    \end{macrocode}
% \subsection{\csh{xintFloat}}
% \lverb|1.07. Completely re-written in 1.08a, with spectacular speed
% gains. The earlier version was seriously silly when dealing with
% inputs having a big power of ten. Again some modifications in 1.08b
% for a better treatment of cases with long explicit numerators or
% denominators. |
%    \begin{macrocode}
\def\xintFloat   {\romannumeral0\xintfloat }%
\def\xintfloat #1{\XINT_float_chkopt #1\Z }%
\def\XINT_float_chkopt #1%
{%
    \ifx [#1\expandafter\XINT_float_opt
       \else\expandafter\XINT_float_noopt
    \fi  #1%
}%
\def\XINT_float_noopt #1\Z
{%
    \expandafter\XINT_float_a\expandafter\XINT_digits
    \romannumeral0\XINT_infrac {#1}\XINT_float_Q
}%
\def\XINT_float_opt [\Z #1]#2%
{%
    \expandafter\XINT_float_a\expandafter 
    {\the\numexpr #1\expandafter}%
    \romannumeral0\XINT_infrac {#2}\XINT_float_Q
}%
\def\XINT_float_a #1#2#3% #1=P, #2=n, #3=A, #4=B
{%
    \XINT_float_fork #3\Z {#1}{#2}% #1 = precision, #2=n
}%
\def\XINT_float_fork #1%
{%
    \xint_UDzerominusfork
     #1-\dummy  \XINT_float_zero
     0#1\dummy  \XINT_float_J
      0-\dummy  {\XINT_float_K #1}%
    \krof
}%
\def\XINT_float_zero #1\Z #2#3#4#5{ 0.e0}%
\def\XINT_float_J {\expandafter\xint_minus_andstop\romannumeral0\XINT_float_K }%
\def\XINT_float_K #1\Z #2% #1=A, #2=P, #3=n, #4=B
{%
    \expandafter\XINT_float_L\expandafter
    {\the\numexpr\xintLength{#1}\expandafter}\expandafter
    {\the\numexpr #2+\xint_c_ii}{#1}{#2}%
}%
\def\XINT_float_L #1#2%
{%
    \ifnum #1>#2
      \expandafter\XINT_float_Ma
    \else
      \expandafter\XINT_float_Mc
    \fi {#1}{#2}%
}%
\def\XINT_float_Ma #1#2#3%
{%
    \expandafter\XINT_float_Mb\expandafter
    {\the\numexpr #1-#2\expandafter}\expandafter
    {\expandafter\xint_firstoftwo
     \romannumeral0\XINT_split_fromleft_loop {#2}{}#3\W\W\W\W\W\W\W\W\Z
     }{#2}%
}%
\def\XINT_float_Mb #1#2#3#4#5#6% #2=A', #3=P+2, #4=P, #5=n, #6=B
{%
   \expandafter\XINT_float_N\expandafter
   {\the\numexpr\xintLength{#6}\expandafter}\expandafter
   {\the\numexpr #3\expandafter}\expandafter
   {\the\numexpr #1+#5}%
   {#6}{#3}{#2}{#4}%
}% long de B, P+2, n', B, |A'|=P+2, A', P
\def\XINT_float_Mc #1#2#3#4#5#6%
{%
   \expandafter\XINT_float_N\expandafter
   {\romannumeral0\XINT_length{#6}}{#2}{#5}{#6}{#1}{#3}{#4}%
}% long de B, P+2, n, B, |A|, A, P
\def\XINT_float_N #1#2%
{%
    \ifnum #1>#2
      \expandafter\XINT_float_O
    \else
      \expandafter\XINT_float_P
    \fi {#1}{#2}%
}%
\def\XINT_float_O #1#2#3#4%
{%
    \expandafter\XINT_float_P\expandafter
    {\the\numexpr #2\expandafter}\expandafter
    {\the\numexpr #2\expandafter}\expandafter
    {\the\numexpr #3-#1+#2\expandafter}\expandafter
    {\expandafter\xint_firstoftwo
     \romannumeral0\XINT_split_fromleft_loop {#2}{}#4\W\W\W\W\W\W\W\W\Z
     }%
}% |B|,P+2,n,B,|A|,A,P
\def\XINT_float_P #1#2#3#4#5#6#7#8%
{%
    \expandafter #8\expandafter {\the\numexpr #1-#5+#2-\xint_c_i}%
    {#6}{#4}{#7}{#3}%
}% |B|-|A|+P+1,A,B,P,n
\def\XINT_float_Q #1%
{%
    \ifnum #1<\xint_c_
      \expandafter\XINT_float_Ri
    \else
      \expandafter\XINT_float_Rii
    \fi {#1}%
}%
\def\XINT_float_Ri #1#2#3%
{%
    \expandafter\XINT_float_Sa
    \romannumeral0\xintiquo {#2}%
         {\romannumeral-`0\XINT_dsx_addzerosnofuss {-#1}{#3}}\Z {#1}%
}%
\def\XINT_float_Rii #1#2#3%
{%
    \expandafter\XINT_float_Sa
    \romannumeral0\xintiquo
         {\romannumeral-`0\XINT_dsx_addzerosnofuss {#1}{#2}}{#3}\Z {#1}%
}%
\def\XINT_float_Sa #1%
{%
    \if #19%
        \xint_afterfi {\XINT_float_Sb\XINT_float_Wb }%
    \else
        \xint_afterfi {\XINT_float_Sb\XINT_float_Wa }%
    \fi #1%
}%
\def\XINT_float_Sb #1#2\Z #3#4%
{%
    \expandafter\XINT_float_T\expandafter
    {\the\numexpr #4+\xint_c_i\expandafter}%
    \romannumeral-`0\XINT_lenrord_loop 0{}#2\Z\W\W\W\W\W\W\W\Z #1{#3}{#4}%
}%
\def\XINT_float_T #1#2#3%
{%
    \ifnum #2>#1
      \xint_afterfi{\XINT_float_U\XINT_float_Xb}%
    \else
      \xint_afterfi{\XINT_float_U\XINT_float_Xa #3}%
    \fi
}%
\def\XINT_float_U #1#2%
{%
    \ifnum #2<\xint_c_v
      \expandafter\XINT_float_Va
    \else
      \expandafter\XINT_float_Vb
    \fi #1%
}%
\def\XINT_float_Va #1#2\Z #3%
{%
    \expandafter#1%
    \romannumeral0\expandafter\XINT_float_Wa
    \romannumeral0\XINT_rord_main {}#2%
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax \Z
}%
\def\XINT_float_Vb #1#2\Z #3%
{%
    \expandafter #1%
    \romannumeral0\expandafter #3%
    \romannumeral0\XINT_addm_A 0{}1000\W\X\Y\Z #2000\W\X\Y\Z \Z
}%
\def\XINT_float_Wa #1{ #1.}%
\def\XINT_float_Wb #1#2%
    {\if #11\xint_afterfi{ 10.}\else\xint_afterfi{ #1.#2}\fi }%
\def\XINT_float_Xa #1\Z #2#3#4%
{%
    \expandafter\XINT_float_Y\expandafter
    {\the\numexpr #3+#4-#2}{#1}%
}%
\def\XINT_float_Xb #1\Z #2#3#4%
{%
    \expandafter\XINT_float_Y\expandafter
    {\the\numexpr #3+#4+\xint_c_i-#2}{#1}%
}%
\def\XINT_float_Y #1#2{ #2e#1}%
%    \end{macrocode}
% \subsection{\csh{XINT\_inFloat}}
% \lverb|1.07. Completely rewritten in 1.08a for immensely greater efficiency
% when the 
% power of ten is big: previous version had some very serious bottlenecks
% arising from the creation of long strings of zeros, which made things such as
% 2^999999 completely impossible, but now even 2^999999999 with 24 significant
% digits is no problem! Again (slightly) improved in 1.08b. | 
%    \begin{macrocode}
\def\XINT_inFloat [#1]#2%
{%
    \expandafter\XINT_infloat_a\expandafter 
    {\the\numexpr #1\expandafter}%
    \romannumeral0\XINT_infrac {#2}\XINT_infloat_Q
}%
\def\XINT_infloat_a #1#2#3% #1=P, #2=n, #3=A, #4=B
{%
    \XINT_infloat_fork #3\Z {#1}{#2}% #1 = precision, #2=n
}%
\def\XINT_infloat_fork #1%
{%
    \xint_UDzerominusfork
     #1-\dummy  \XINT_infloat_zero
     0#1\dummy  \XINT_infloat_J
      0-\dummy  {\XINT_float_K #1}%
    \krof
}%
\def\XINT_infloat_zero #1\Z #2#3#4#5{0[0]}%
\def\XINT_infloat_J {\expandafter-\romannumeral-`0\XINT_float_K }%
\def\XINT_infloat_Q #1%
{%
    \ifnum #1<\xint_c_
      \expandafter\XINT_infloat_Ri
    \else
      \expandafter\XINT_infloat_Rii
    \fi {#1}%
}%
\def\XINT_infloat_Ri #1#2#3%
{%
    \expandafter\XINT_infloat_S\expandafter
    {\romannumeral0\xintiquo {#2}%
         {\romannumeral-`0\XINT_dsx_addzerosnofuss {-#1}{#3}}}{#1}%
}%
\def\XINT_infloat_Rii #1#2#3%
{%
    \expandafter\XINT_infloat_S\expandafter
    {\romannumeral0\xintiquo
         {\romannumeral-`0\XINT_dsx_addzerosnofuss {#1}{#2}}{#3}}{#1}%
}%
\def\XINT_infloat_S #1#2#3%
{%
    \expandafter\XINT_infloat_T\expandafter
    {\the\numexpr #3+\xint_c_i\expandafter}%
    \romannumeral-`0\XINT_lenrord_loop 0{}#1\Z\W\W\W\W\W\W\W\Z
    {#2}%
}%
\def\XINT_infloat_T #1#2#3%
{%
    \ifnum #2>#1
      \xint_afterfi{\XINT_infloat_U\XINT_infloat_Wb}%
    \else
      \xint_afterfi{\XINT_infloat_U\XINT_infloat_Wa #3}%
    \fi
}%
\def\XINT_infloat_U #1#2%
{%
    \ifnum #2<\xint_c_v
      \expandafter\XINT_infloat_Va
    \else
      \expandafter\XINT_infloat_Vb
    \fi #1%
}%
\def\XINT_infloat_Va #1#2\Z
{%
    \expandafter#1%
    \romannumeral0\XINT_rord_main {}#2%
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax \Z
}%
\def\XINT_infloat_Vb #1#2\Z
{%
    \expandafter #1%
    \romannumeral0\XINT_addm_A 0{}1000\W\X\Y\Z #2000\W\X\Y\Z \Z
}%
\def\XINT_infloat_Wa #1\Z #2#3%
{%
    \expandafter\XINT_infloat_X\expandafter
    {\the\numexpr #3+\xint_c_i-#2}{#1}%
}%
\def\XINT_infloat_Wb #1\Z #2#3%
{%
    \expandafter\XINT_infloat_X\expandafter
    {\the\numexpr #3+\xint_c_ii-#2}{#1}%
}%
\def\XINT_infloat_X #1#2{ #2[#1]}%
%    \end{macrocode}
% \subsection{\csh{xintAdd}}
%    \begin{macrocode}
\def\xintAdd {\romannumeral0\xintadd }%
\def\xintadd #1%
{%
    \expandafter\xint_fadd\expandafter {\romannumeral0\XINT_infrac {#1}}%
}%
\def\xint_fadd #1#2{\expandafter\XINT_fadd_A\romannumeral0\XINT_infrac{#2}#1}%
\def\XINT_fadd_A #1#2#3#4%
{%
    \ifnum #4 > #1
       \xint_afterfi {\XINT_fadd_B {#1}}%
    \else
       \xint_afterfi {\XINT_fadd_B {#4}}%
    \fi
    {#1}{#4}{#2}{#3}%
}%
\def\XINT_fadd_B #1#2#3#4#5#6#7%
{%
    \expandafter\XINT_fadd_C\expandafter
    {\romannumeral0\xintimul {#7}{#5}}%
    {\romannumeral0\xintiadd
    {\romannumeral0\xintimul {\xintDSH {\the\numexpr -#3+#1\relax}{#6}}{#5}}%
    {\romannumeral0\xintimul {#7}{\xintDSH {\the\numexpr -#2+#1\relax}{#4}}}%
    }%
    {#1}%
}%
\def\XINT_fadd_C #1#2#3%
{%
    \expandafter\XINT_fadd_D\expandafter {#2}{#3}{#1}%
}%
\def\XINT_fadd_D #1#2{\XINT_outfrac {#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintSub}}
%    \begin{macrocode}
\def\xintSub {\romannumeral0\xintsub }%
\def\xintsub #1%
{%
    \expandafter\xint_fsub\expandafter {\romannumeral0\XINT_infrac {#1}}%
}%
\def\xint_fsub #1#2%
   {\expandafter\XINT_fsub_A\romannumeral0\XINT_infrac {#2}#1}%
\def\XINT_fsub_A #1#2#3#4%
{%
    \ifnum #4 > #1
       \xint_afterfi {\XINT_fsub_B {#1}}%
    \else
       \xint_afterfi {\XINT_fsub_B {#4}}%
    \fi
    {#1}{#4}{#2}{#3}%
}%
\def\XINT_fsub_B #1#2#3#4#5#6#7%
{%
    \expandafter\XINT_fsub_C\expandafter
    {\romannumeral0\xintimul {#7}{#5}}%
    {\romannumeral0\xintisub
    {\romannumeral0\xintimul {\xintDSH {\the\numexpr -#3+#1\relax}{#6}}{#5}}%
    {\romannumeral0\xintimul {#7}{\xintDSH {\the\numexpr -#2+#1\relax}{#4}}}%
    }%
    {#1}%
}%
\def\XINT_fsub_C #1#2#3%
{%
    \expandafter\XINT_fsub_D\expandafter {#2}{#3}{#1}%
}%
\def\XINT_fsub_D #1#2{\XINT_outfrac {#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintSum}, \csh{xintSumExpr}}
%    \begin{macrocode}
\def\xintSum {\romannumeral0\xintsum }%
\def\xintsum #1{\xintsumexpr #1\relax }%
\def\xintSumExpr {\romannumeral0\xintsumexpr }%
\def\xintsumexpr {\expandafter\XINT_fsumexpr\romannumeral-`0}%
\def\XINT_fsumexpr {\XINT_fsum_loop_a {0/1[0]}}%
\def\XINT_fsum_loop_a #1#2%
{%
    \expandafter\XINT_fsum_loop_b \romannumeral-`0#2\Z {#1}%
}%
\def\XINT_fsum_loop_b #1%
{%
    \xint_gob_til_relax #1\XINT_fsum_finished\relax
    \XINT_fsum_loop_c #1%
}%
\def\XINT_fsum_loop_c #1\Z #2%
{%
    \expandafter\XINT_fsum_loop_a\expandafter{\romannumeral0\xintadd {#2}{#1}}%
}%
\def\XINT_fsum_finished #1\Z #2{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintMul}}
%    \begin{macrocode}
\def\xintMul {\romannumeral0\xintmul }%
\def\xintmul #1%
{%
    \expandafter\xint_fmul\expandafter {\romannumeral0\XINT_infrac {#1}}%
}%
\def\xint_fmul #1#2%
   {\expandafter\XINT_fmul_A\romannumeral0\XINT_infrac {#2}#1}%
\def\XINT_fmul_A #1#2#3#4#5#6%
{%
    \expandafter\XINT_fmul_B
    \expandafter{\the\numexpr #1+#4\expandafter}%
    \expandafter{\romannumeral0\xintimul {#6}{#3}}%
    {\romannumeral0\xintimul {#5}{#2}}%
}%
\def\XINT_fmul_B #1#2#3%
{%
    \expandafter \XINT_fmul_C \expandafter{#3}{#1}{#2}%
}%
\def\XINT_fmul_C #1#2{\XINT_outfrac {#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintSqr}}
%    \begin{macrocode}
\def\xintSqr {\romannumeral0\xintsqr }%
\def\xintsqr #1%
{%
    \expandafter\xint_fsqr\expandafter{\romannumeral0\XINT_infrac {#1}}%
}%
\def\xint_fsqr #1{\XINT_fmul_A #1#1}%
%    \end{macrocode}
% \subsection{\csh{xintPow}}
% \lverb|&
% Modified in 1.06 to give the exponent to a \numexpr.$\
% With 1.07 and for use within the \xintexpr parser, we must allow
% fractions (which are integers in disguise) as input to the exponent, so we
% must have a variant which uses \xintNum and not only \numexpr
% for normalizing the input. Hence the \xintfPow here. 1.08b: well actually I
% think that with xintfrac.sty loaded the exponent should always be allowed to
% be a fraction giving an integer. So I do as for \xintFac, and remove here the
% duplicated. The \xintexpr can thus use directly \xintPow.| 
%    \begin{macrocode}
\def\xintPow {\romannumeral0\xintpow }%
\def\xintpow #1%
{%
    \expandafter\xint_fpow\expandafter {\romannumeral0\XINT_infrac {#1}}%
}%
\def\xint_fpow #1#2%
{%
    \expandafter\XINT_fpow_fork\the\numexpr \xintNum{#2}\relax\Z #1%
}%
\def\XINT_fpow_fork #1#2\Z
{%
    \xint_UDzerominusfork
      #1-\dummy  \XINT_fpow_zero
      0#1\dummy  \XINT_fpow_neg
       0-\dummy  {\XINT_fpow_pos #1}%
    \krof
    {#2}%
}%
\def\XINT_fpow_zero #1#2#3#4%
{%
    \space 1/1[0]%
}%
\def\XINT_fpow_pos #1#2#3#4#5%
{%
    \expandafter\XINT_fpow_pos_A\expandafter
    {\the\numexpr #1#2*#3\expandafter}\expandafter
    {\romannumeral0\xintipow {#5}{#1#2}}%
    {\romannumeral0\xintipow {#4}{#1#2}}%
}%
\def\XINT_fpow_neg #1#2#3#4%
{%
    \expandafter\XINT_fpow_pos_A\expandafter
    {\the\numexpr -#1*#2\expandafter}\expandafter
    {\romannumeral0\xintipow {#3}{#1}}%
    {\romannumeral0\xintipow {#4}{#1}}%
}%
\def\XINT_fpow_pos_A #1#2#3%
{%
    \expandafter\XINT_fpow_pos_B\expandafter {#3}{#1}{#2}%
}%
\def\XINT_fpow_pos_B #1#2{\XINT_outfrac {#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintFac}}
% \lverb|1.07: to be used by the \xintexpr scanner which needs to be able to
% apply \xintFac
% to a fraction which is an integer in disguise; so we use \xintNum and not only
% \numexpr. Je modifie cela dans 1.08b, au lieu d'avoir un \xintfFac
% spécialement pour \xintexpr, tout simplement j'étends \xintFac comme les
% autres macros, pour qu'elle utilise \xintNum. | 
%    \begin{macrocode}
\def\xintFac {\romannumeral0\xintfac }%
\def\xintfac #1%
{%
    \expandafter\XINT_fac_fork\expandafter{\the\numexpr \xintNum{#1}}%
}%
%    \end{macrocode}
% \subsection{\csh{xintPrd}, \csh{xintPrdExpr}}
%    \begin{macrocode}
\def\xintPrd {\romannumeral0\xintprd }%
\def\xintprd #1{\xintprdexpr #1\relax }%
\def\xintPrdExpr {\romannumeral0\xintprdexpr }%
\def\xintprdexpr {\expandafter\XINT_fprdexpr \romannumeral-`0}%
\def\XINT_fprdexpr {\XINT_fprod_loop_a {1/1[0]}}%
\def\XINT_fprod_loop_a #1#2%
{%
    \expandafter\XINT_fprod_loop_b \romannumeral-`0#2\Z {#1}%
}%
\def\XINT_fprod_loop_b #1%
{%
    \xint_gob_til_relax #1\XINT_fprod_finished\relax
    \XINT_fprod_loop_c #1%
}%
\def\XINT_fprod_loop_c #1\Z #2%
{%
  \expandafter\XINT_fprod_loop_a\expandafter{\romannumeral0\xintmul {#1}{#2}}%
}%
\def\XINT_fprod_finished #1\Z #2{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintDiv}}
%    \begin{macrocode}
\def\xintDiv {\romannumeral0\xintdiv }%
\def\xintdiv #1%
{%
    \expandafter\xint_fdiv\expandafter {\romannumeral0\XINT_infrac {#1}}%
}%
\def\xint_fdiv #1#2%
   {\expandafter\XINT_fdiv_A\romannumeral0\XINT_infrac {#2}#1}%
\def\XINT_fdiv_A #1#2#3#4#5#6%
{%
    \expandafter\XINT_fdiv_B
    \expandafter{\the\numexpr #4-#1\expandafter}%
    \expandafter{\romannumeral0\xintimul {#2}{#6}}%
    {\romannumeral0\xintimul {#3}{#5}}%
}%
\def\XINT_fdiv_B #1#2#3%
{%
    \expandafter\XINT_fdiv_C
    \expandafter{#3}{#1}{#2}%
}%
\def\XINT_fdiv_C #1#2{\XINT_outfrac {#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintGeq}}
% \lverb|&
% Rewritten completely in 1.08a to be less dumb when comparing fractions having
% big powers of tens.|
%    \begin{macrocode}
\def\xintGeq {\romannumeral0\xintgeq }%
\def\xintgeq #1%
{%
    \expandafter\xint_fgeq\expandafter {\romannumeral0\xintabs {#1}}%
}%
\def\xint_fgeq #1#2%
{%
    \expandafter\XINT_fgeq_A \romannumeral0\xintabs {#2}#1%
}%
\def\XINT_fgeq_A #1%
{%
    \xint_gob_til_zero #1\XINT_fgeq_Zii 0%
    \XINT_fgeq_B #1%
}%
\def\XINT_fgeq_Zii 0\XINT_fgeq_B #1[#2]#3[#4]{ 1}%
\def\XINT_fgeq_B #1/#2[#3]#4#5/#6[#7]%
{%
    \xint_gob_til_zero #4\XINT_fgeq_Zi 0%
    \expandafter\XINT_fgeq_C\expandafter
    {\the\numexpr #7-#3\expandafter}\expandafter
    {\romannumeral0\xintimul {#4#5}{#2}}%
    {\romannumeral0\xintimul {#6}{#1}}%
}%
\def\XINT_fgeq_Zi 0#1#2#3#4#5#6#7{ 0}%
\def\XINT_fgeq_C #1#2#3%
{%
    \expandafter\XINT_fgeq_D\expandafter
    {#3}{#1}{#2}%
}%
\def\XINT_fgeq_D #1#2#3%
{%
    \xintSgnFork
    {\xintiSgn{\the\numexpr #2+\xintLength{#3}-\xintLength{#1}\relax}}%
    { 0}{\XINT_fgeq_E #2\Z {#3}{#1}}{ 1}%
}%
\def\XINT_fgeq_E #1%
{%
    \xint_UDsignfork
        #1\dummy  \XINT_fgeq_Fd
         -\dummy {\XINT_fgeq_Fn #1}%
    \krof
}%
\def\XINT_fgeq_Fd #1\Z #2#3%
{%
    \expandafter\XINT_fgeq_Fe\expandafter
    {\romannumeral0\XINT_dsx_addzerosnofuss {#1}{#3}}{#2}%
}%
\def\XINT_fgeq_Fe #1#2{\XINT_geq_pre {#2}{#1}}%
\def\XINT_fgeq_Fn #1\Z #2#3%
{%
    \expandafter\XINT_geq_pre\expandafter 
    {\romannumeral0\XINT_dsx_addzerosnofuss {#1}{#2}}{#3}%
}%
%    \end{macrocode}
% \subsection{\csh{xintMax}}
% \lverb|&
% Rewritten completely in 1.08a.|
%    \begin{macrocode}
\def\xintMax {\romannumeral0\xintmax }%
\def\xintmax #1%
{%
    \expandafter\xint_fmax\expandafter {\romannumeral0\xintraw {#1}}%
}%
\def\xint_fmax #1#2%
{%
    \expandafter\XINT_fmax_A\romannumeral0\xintraw {#2}#1%
}%
\def\XINT_fmax_A #1#2/#3[#4]#5#6/#7[#8]%
{%
    \xint_UDsignsfork
      #1#5\dummy \XINT_fmax_minusminus
       -#5\dummy \XINT_fmax_firstneg
       #1-\dummy \XINT_fmax_secondneg
        --\dummy \XINT_fmax_nonneg_a
    \krof
    #1#5{#2/#3[#4]}{#6/#7[#8]}%
}%
\def\XINT_fmax_minusminus --%
   {\expandafter\xint_minus_andstop\romannumeral0\XINT_fmin_nonneg_b }%
\def\XINT_fmax_firstneg #1-#2#3{ #1#2}%
\def\XINT_fmax_secondneg -#1#2#3{ #1#3}%
\def\XINT_fmax_nonneg_a #1#2#3#4%
{%
    \XINT_fmax_nonneg_b {#1#3}{#2#4}%
}%
\def\XINT_fmax_nonneg_b #1#2%
{%
    \ifcase\romannumeral0\XINT_fgeq_A #1#2
        \xint_afterfi{ #1}%
    \or \xint_afterfi{ #2}%
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintMin}}
% \lverb|&
% Rewritten completely in 1.08a.|
%    \begin{macrocode}
\def\xintMin {\romannumeral0\xintmin }%
\def\xintmin #1%
{%
    \expandafter\xint_fmin\expandafter {\romannumeral0\xintraw {#1}}%
}%
\def\xint_fmin #1#2%
{%
    \expandafter\XINT_fmin_A\romannumeral0\xintraw {#2}#1%
}%
\def\XINT_fmin_A #1#2/#3[#4]#5#6/#7[#8]%
{%
    \xint_UDsignsfork
      #1#5\dummy \XINT_fmin_minusminus
       -#5\dummy \XINT_fmin_firstneg
       #1-\dummy \XINT_fmin_secondneg
        --\dummy \XINT_fmin_nonneg_a
    \krof
    #1#5{#2/#3[#4]}{#6/#7[#8]}%
}%
\def\XINT_fmin_minusminus --%
   {\expandafter\xint_minus_andstop\romannumeral0\XINT_fmax_nonneg_b }%
\def\XINT_fmin_firstneg #1-#2#3{ -#3}%
\def\XINT_fmin_secondneg -#1#2#3{ -#2}%
\def\XINT_fmin_nonneg_a #1#2#3#4%
{%
    \XINT_fmin_nonneg_b {#1#3}{#2#4}%
}%
\def\XINT_fmin_nonneg_b #1#2%
{%
    \ifcase\romannumeral0\XINT_fgeq_A #1#2
        \xint_afterfi{ #2}%
    \or \xint_afterfi{ #1}%
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintCmp}}
% \lverb|&
% Rewritten completely in 1.08a to be less dumb when comparing fractions having
% big powers of tens.|
%    \begin{macrocode}
\def\xintCmp {\romannumeral0\xintcmp }%
\def\xintcmp #1%
{%
    \expandafter\xint_fcmp\expandafter {\romannumeral0\xintraw {#1}}%
}%
\def\xint_fcmp #1#2%
{%
    \expandafter\XINT_fcmp_A\romannumeral0\xintraw {#2}#1%
}%
\def\XINT_fcmp_A #1#2/#3[#4]#5#6/#7[#8]%
{%
    \xint_UDsignsfork
      #1#5\dummy \XINT_fcmp_minusminus
       -#5\dummy \XINT_fcmp_firstneg
       #1-\dummy \XINT_fcmp_secondneg
        --\dummy \XINT_fcmp_nonneg_a
    \krof
    #1#5{#2/#3[#4]}{#6/#7[#8]}%
}%
\def\XINT_fcmp_minusminus --#1#2{\XINT_fcmp_B #2#1}%
\def\XINT_fcmp_firstneg #1-#2#3{ -1}%
\def\XINT_fcmp_secondneg -#1#2#3{ 1}%
\def\XINT_fcmp_nonneg_a #1#2%
{%
    \xint_UDzerosfork
      #1#2\dummy \XINT_fcmp_zerozero
       0#2\dummy \XINT_fcmp_firstzero
       #10\dummy \XINT_fcmp_secondzero
        00\dummy \XINT_fcmp_pos
    \krof
    #1#2%
}%
\def\XINT_fcmp_zerozero   #1[#2]#3[#4]{ 0}%
\def\XINT_fcmp_firstzero  #1[#2]#3[#4]{ -1}%
\def\XINT_fcmp_secondzero #1[#2]#3[#4]{ 1}%
\def\XINT_fcmp_pos #1#2#3#4%
{%
    \XINT_fcmp_B #1#3#2#4%
}%
\def\XINT_fcmp_B #1/#2[#3]#4/#5[#6]%
{%
    \expandafter\XINT_fcmp_C\expandafter
    {\the\numexpr #6-#3\expandafter}\expandafter
    {\romannumeral0\xintimul {#4}{#2}}%
    {\romannumeral0\xintimul {#5}{#1}}%
}%
\def\XINT_fcmp_C #1#2#3%
{%
    \expandafter\XINT_fcmp_D\expandafter
    {#3}{#1}{#2}%
}%
\def\XINT_fcmp_D #1#2#3%
{%
    \xintSgnFork
    {\xintiSgn{\the\numexpr #2+\xintLength{#3}-\xintLength{#1}\relax}}%
    { -1}{\XINT_fcmp_E #2\Z {#3}{#1}}{ 1}%
}%
\def\XINT_fcmp_E #1%
{%
    \xint_UDsignfork
        #1\dummy  \XINT_fcmp_Fd
         -\dummy {\XINT_fcmp_Fn #1}%
    \krof
}%
\def\XINT_fcmp_Fd #1\Z #2#3%
{%
    \expandafter\XINT_fcmp_Fe\expandafter
    {\romannumeral0\XINT_dsx_addzerosnofuss {#1}{#3}}{#2}%
}%
\def\XINT_fcmp_Fe #1#2{\XINT_cmp_pre {#2}{#1}}%
\def\XINT_fcmp_Fn #1\Z #2#3%
{%
    \expandafter\XINT_cmp_pre\expandafter 
    {\romannumeral0\XINT_dsx_addzerosnofuss {#1}{#2}}{#3}%
}%
%    \end{macrocode}
% \subsection{\csh{xintAbs}}
%    \begin{macrocode}
\def\xintAbs {\romannumeral0\xintabs }%
\def\xintabs #1%
{%
    \expandafter\xint_fabs\romannumeral0\XINT_infrac {#1}%
}%
\def\xint_fabs #1#2%
{%
    \expandafter\XINT_outfrac\expandafter 
    {\the\numexpr #1\expandafter}\expandafter
    {\romannumeral0\XINT_abs #2}%
}%
%    \end{macrocode}
% \subsection{\csh{xintOpp}}
%    \begin{macrocode}
\def\xintOpp {\romannumeral0\xintopp }%
\def\xintopp #1%
{%
    \expandafter\xint_fopp\romannumeral0\XINT_infrac {#1}%
}%
\def\xint_fopp #1#2%
{%
    \expandafter\XINT_outfrac\expandafter 
    {\the\numexpr #1\expandafter}\expandafter
    {\romannumeral0\XINT_opp #2}%
}%
%    \end{macrocode}
% \subsection{\csh{xintSgn}}
%    \begin{macrocode}
\def\xintSgn {\romannumeral0\xintsgn }%
\def\xintsgn #1%
{%
    \expandafter\xint_fsgn\romannumeral0\XINT_infrac {#1}%
}%
\def\xint_fsgn #1#2#3{\xintisgn {#2}}%
%    \end{macrocode}
% \subsection{\csh{xintDivision},~\csh{xintQuo},~\csh{xintRem}}
%    \begin{macrocode}
\def\xintDivision {\romannumeral0\xintdivision }%
\def\xintdivision #1%
{%
    \expandafter\xint_xdivision\expandafter{\romannumeral0\xintnum {#1}}%
}%
\def\xint_xdivision #1#2%
{%
    \expandafter\XINT_div_fork\romannumeral0\xintnum {#2}\Z #1\Z 
}%
\def\xintQuo {\romannumeral0\xintquo }%
\def\xintRem {\romannumeral0\xintrem }%
\def\xintquo {\expandafter\xint_firstoftwo_andstop
               \romannumeral0\xintdivision }%
\def\xintrem {\expandafter\xint_secondoftwo_andstop
               \romannumeral0\xintdivision }%
%    \end{macrocode}
% \subsection{\csh{xintFDg},~\csh{xintLDg},~\csh{xintMON},~\csh{xint\-MMON},~\csh{xintOdd}}
%    \begin{macrocode}
\def\xintFDg {\romannumeral0\xintfdg }%
\def\xintfdg #1%
{%
    \expandafter\XINT_fdg\romannumeral0\xintnum {#1}\W\Z
}%
\def\xintLDg {\romannumeral0\xintldg }%
\def\xintldg #1%
{%
    \expandafter\XINT_ldg\expandafter{\romannumeral0\xintnum {#1}}%
}%
\def\xintMON {\romannumeral0\xintmon }%
\def\xintmon #1%
{%
    \ifodd\xintLDg {#1}
        \xint_afterfi{ -1}%
    \else
        \xint_afterfi{ 1}%
    \fi
}%
\def\xintMMON {\romannumeral0\xintmmon }%
\def\xintmmon #1%
{%
    \ifodd\xintLDg {#1}
        \xint_afterfi{ 1}%
    \else
        \xint_afterfi{ -1}%
    \fi
}%
\def\xintOdd {\romannumeral0\xintodd }%
\def\xintodd #1%
{%
    \ifodd\xintLDg{#1}
        \xint_afterfi{ 1}%
    \else
        \xint_afterfi{ 0}%
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintFloatAdd}}
% \lverb|1.07|
%    \begin{macrocode}
\def\xintFloatAdd      {\romannumeral0\xintfloatadd }%
\def\xintfloatadd    #1{\XINT_fladd_chkopt \xintfloat #1\Z }%
\def\XINTinFloatAdd   {\romannumeral-`0\XINTinfloatadd }%
\def\XINTinfloatadd #1{\XINT_fladd_chkopt \XINT_inFloat #1\Z }%
\def\XINT_fladd_chkopt #1#2%
{%
    \ifx [#2\expandafter\XINT_fladd_opt
       \else\expandafter\XINT_fladd_noopt
    \fi  #1#2%
}%
\def\XINT_fladd_noopt #1#2\Z #3%
{%
    #1[\XINT_digits]{\XINT_FL_Add {\XINT_digits+2}{#2}{#3}}%
}%
\def\XINT_fladd_opt #1[\Z #2]#3#4%
{%
    #1[#2]{\XINT_FL_Add {#2+2}{#3}{#4}}%
}%
\def\XINT_FL_Add #1#2%
{%
    \expandafter\XINT_FL_Add_a\expandafter{\the\numexpr #1\expandafter}%
    \expandafter{\romannumeral-`0\XINT_inFloat [#1]{#2}}%
}%
\def\XINT_FL_Add_a #1#2#3%
{%
    \expandafter\XINT_FL_Add_b\romannumeral-`0\XINT_inFloat [#1]{#3}#2{#1}%
}%
\def\XINT_FL_Add_b #1%
{%
    \xint_gob_til_zero #1\XINT_FL_Add_zero 0\XINT_FL_Add_c #1%
}%
\def\XINT_FL_Add_c #1[#2]#3%
{%
    \xint_gob_til_zero #3\XINT_FL_Add_zerobis 0\XINT_FL_Add_d #1[#2]#3%
}%
\def\XINT_FL_Add_d #1[#2]#3[#4]#5%
{%
    \xintSgnFork {\ifnum \numexpr #2-#4-#5>1 \expandafter 1%
                  \else\ifnum \numexpr #4-#2-#5>1 
                       \xint_afterfi {\expandafter-\expandafter1}%
                       \else \expandafter\expandafter\expandafter0%
                       \fi
                  \fi}%
    {#3[#4]}{\xintAdd {#1[#2]}{#3[#4]}}{#1[#2]}%
}%
\def\XINT_FL_Add_zero 0\XINT_FL_Add_c 0[0]#1[#2]#3{#1[#2]}%
\def\XINT_FL_Add_zerobis 0\XINT_FL_Add_d #1[#2]0[0]#3{#1[#2]}%
%    \end{macrocode}
% \subsection{\csh{xintFloatSub}}
% \lverb|1.07|
%    \begin{macrocode}
\def\xintFloatSub {\romannumeral0\xintfloatsub }%
\def\xintfloatsub    #1{\XINT_flsub_chkopt \xintfloat #1\Z }%
\def\XINTinFloatSub {\romannumeral-`0\XINTinfloatsub }%
\def\XINTinfloatsub #1{\XINT_flsub_chkopt \XINT_inFloat #1\Z }%
\def\XINT_flsub_chkopt #1#2%
{%
    \ifx [#2\expandafter\XINT_flsub_opt
       \else\expandafter\XINT_flsub_noopt
    \fi  #1#2%
}%
\def\XINT_flsub_noopt #1#2\Z #3%
{%
    #1[\XINT_digits]{\XINT_FL_Add {\XINT_digits+2}{#2}{\xintOpp{#3}}}%
}%
\def\XINT_flsub_opt #1[\Z #2]#3#4%
{%
    #1[#2]{\XINT_FL_Add {#2+2}{#3}{\xintOpp{#4}}}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFloatMul}}
% \lverb|1.07|
%    \begin{macrocode}
\def\xintFloatMul    {\romannumeral0\xintfloatmul}%
\def\xintfloatmul    #1{\XINT_flmul_chkopt \xintfloat #1\Z }%
\def\XINTinFloatMul {\romannumeral-`0\XINTinfloatmul }%
\def\XINTinfloatmul #1{\XINT_flmul_chkopt \XINT_inFloat #1\Z }%
\def\XINT_flmul_chkopt #1#2%
{%
    \ifx [#2\expandafter\XINT_flmul_opt
       \else\expandafter\XINT_flmul_noopt
    \fi  #1#2%
}%
\def\XINT_flmul_noopt #1#2\Z #3%
{%
    #1[\XINT_digits]{\XINT_FL_Mul {\XINT_digits+2}{#2}{#3}}%
}%
\def\XINT_flmul_opt #1[\Z #2]#3#4%
{%
    #1[#2]{\XINT_FL_Mul {#2+2}{#3}{#4}}%
}%
\def\XINT_FL_Mul #1#2%
{%
    \expandafter\XINT_FL_Mul_a\expandafter{\the\numexpr #1\expandafter}%
    \expandafter{\romannumeral-`0\XINT_inFloat [#1]{#2}}%
}%
\def\XINT_FL_Mul_a #1#2#3%
{%
    \expandafter\XINT_FL_Mul_b\romannumeral-`0\XINT_inFloat [#1]{#3}#2%
}%
\def\XINT_FL_Mul_b #1[#2]#3[#4]{\xintE{\xintiMul {#1}{#3}}{#2+#4}}%
%    \end{macrocode}
% \subsection{\csh{xintFloatDiv}}
% \lverb|1.07|
%    \begin{macrocode}
\def\xintFloatDiv    {\romannumeral0\xintfloatdiv}%
\def\xintfloatdiv    #1{\XINT_fldiv_chkopt \xintfloat #1\Z }%
\def\XINTinFloatDiv  {\romannumeral-`0\XINTinfloatdiv }%
\def\XINTinfloatdiv  #1{\XINT_fldiv_chkopt \XINT_inFloat #1\Z }%
\def\XINT_fldiv_chkopt #1#2%
{%
    \ifx [#2\expandafter\XINT_fldiv_opt
       \else\expandafter\XINT_fldiv_noopt
    \fi  #1#2%
}%
\def\XINT_fldiv_noopt #1#2\Z #3%
{%
    #1[\XINT_digits]{\XINT_FL_Div {\XINT_digits+2}{#2}{#3}}%
}%
\def\XINT_fldiv_opt #1[\Z #2]#3#4%
{%
    #1[#2]{\XINT_FL_Div {#2+2}{#3}{#4}}%
}%
\def\XINT_FL_Div #1#2%
{%
    \expandafter\XINT_FL_Div_a\expandafter{\the\numexpr #1\expandafter}%
    \expandafter{\romannumeral-`0\XINT_inFloat [#1]{#2}}%
}%
\def\XINT_FL_Div_a #1#2#3%
{%
    \expandafter\XINT_FL_Div_b\romannumeral-`0\XINT_inFloat [#1]{#3}#2%
}%
\def\XINT_FL_Div_b #1[#2]#3[#4]{\xintE{#3/#1}{#4-#2}}%
%    \end{macrocode}
% \subsection{\csh{xintFloatPow}}
% \lverb|1.07|
%    \begin{macrocode}
\def\xintFloatPow {\romannumeral0\xintfloatpow}%
\def\xintfloatpow #1{\XINT_flpow_chkopt \xintfloat #1\Z }%
\def\XINTinFloatPow {\romannumeral-`0\XINTinfloatpow }%
\def\XINTinfloatpow #1{\XINT_flpow_chkopt \XINT_inFloat #1\Z }%
\def\XINT_flpow_chkopt #1#2%
{%
    \ifx [#2\expandafter\XINT_flpow_opt
       \else\expandafter\XINT_flpow_noopt
    \fi
     #1#2%
}%
\def\XINT_flpow_noopt  #1#2\Z #3%
{%
   \expandafter\XINT_flpow_checkB_start\expandafter
                {\the\numexpr #3\expandafter}\expandafter
                {\the\numexpr \XINT_digits}{#2}{#1[\XINT_digits]}%
}%
\def\XINT_flpow_opt #1[\Z #2]#3#4%
{%
   \expandafter\XINT_flpow_checkB_start\expandafter
               {\the\numexpr #4\expandafter}\expandafter
               {\the\numexpr #2}{#3}{#1[#2]}%
}%
\def\XINT_flpow_checkB_start #1{\XINT_flpow_checkB_a #1\Z }%
\def\XINT_flpow_checkB_a #1%
{%
    \xint_UDzerominusfork
      #1-\dummy  \XINT_flpow_BisZero
      0#1\dummy  {\XINT_flpow_checkB_b 1}%
       0-\dummy  {\XINT_flpow_checkB_b 0#1}%
    \krof
}%
\def\XINT_flpow_BisZero \Z #1#2#3{#3{1/1[0]}}%
\def\XINT_flpow_checkB_b #1#2\Z #3%
{%
    \expandafter\XINT_flpow_checkB_c \expandafter
    {\romannumeral0\XINT_length{#2}}{#3}{#2}#1%
}%
\def\XINT_flpow_checkB_c #1#2%
{%
    \expandafter\XINT_flpow_checkB_d \expandafter
    {\the\numexpr \expandafter\XINT_Length\expandafter
                  {\the\numexpr #1*20/3}+#1+#2+1}%
}%
\def\XINT_flpow_checkB_d #1#2#3#4%
{%
    \expandafter \XINT_flpow_a
    \romannumeral-`0\XINT_inFloat [#1]{#4}{#1}{#2}#3%
}%
\def\XINT_flpow_a #1%
{%
    \xint_UDzerominusfork
      #1-\dummy \XINT_flpow_zero
      0#1\dummy {\XINT_flpow_b 1}%
       0-\dummy {\XINT_flpow_b 0#1}%
    \krof
}%
\def\XINT_flpow_zero [#1]#2#3#4#5%
{%
    \if #41 \xint_afterfi {\xintError:DivisionByZero\space 1.e2147483647}%
    \else \xint_afterfi { 0.e0}\fi
}%
\def\XINT_flpow_b #1#2[#3]#4#5%
{%
    \XINT_flpow_c {#4}{#5}{#2[#3]}{#1*\ifodd #5 1\else 0\fi}%
}%
\def\XINT_flpow_c #1#2#3#4%
{%
    \XINT_flpow_loop {#1}{#2}{#3}{{#1}}\XINT_flpow_prd
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax {#4}%
}%
\def\XINT_flpow_loop #1#2#3%
{%
    \ifnum #2 = 1
        \expandafter\XINT_flpow_loop_end 
    \else
        \xint_afterfi{\expandafter\XINT_flpow_loop_a
            \expandafter{\the\numexpr 2*(#2/2)-#2\expandafter }% b mod 2
            \expandafter{\the\numexpr #2-#2/2\expandafter }%     [b/2]
            \expandafter{\romannumeral-`0\XINTinfloatmul [#1]{#3}{#3}}}%
    \fi
    {#1}{{#3}}%
}%
\def\XINT_flpow_loop_a #1#2#3#4%
{%
    \ifnum #1 = 1
        \expandafter\XINT_flpow_loop
    \else
        \expandafter\XINT_flpow_loop_throwaway
    \fi
    {#4}{#2}{#3}%
}%
\def\XINT_flpow_loop_throwaway #1#2#3#4%
{%
   \XINT_flpow_loop {#1}{#2}{#3}% 
}%
\def\XINT_flpow_loop_end #1{\romannumeral0\XINT_rord_main {}\relax }%
\def\XINT_flpow_prd #1#2%
{%
    \XINT_flpow_prd_getnext {#2}{#1}%
}%
\def\XINT_flpow_prd_getnext #1#2#3%
{%
    \XINT_flpow_prd_checkiffinished #3\Z {#1}{#2}%
}%
\def\XINT_flpow_prd_checkiffinished #1%
{%
    \xint_gob_til_relax #1\XINT_flpow_prd_end\relax 
    \XINT_flpow_prd_compute #1%
}%
\def\XINT_flpow_prd_compute #1\Z #2#3%
{%
    \expandafter\XINT_flpow_prd_getnext\expandafter
    {\romannumeral-`0\XINTinfloatmul [#3]{#1}{#2}}{#3}%
}%
\def\XINT_flpow_prd_end\relax\XINT_flpow_prd_compute 
    \relax\Z #1#2#3%
{%
    \expandafter\XINT_flpow_conclude \the\numexpr #3\relax #1%
}%
\def\XINT_flpow_conclude #1#2[#3]#4%
{%
    \expandafter\XINT_flpow_conclude_really\expandafter
    {\the\numexpr\if #41 -\fi#3\expandafter}%
    \xint_UDzerofork
        #4\dummy {{#2}}%
         0\dummy {{1/#2}}%
    \krof #1%
}%
\def\XINT_flpow_conclude_really #1#2#3#4%
{%
    \xint_UDzerofork
    #3\dummy {#4{#2[#1]}}%
     0\dummy {#4{-#2[#1]}}%
    \krof
}%
%    \end{macrocode}
% \subsection{\csh{xintFloatPower}}
% \lverb|1.07|
%    \begin{macrocode}
\def\xintFloatPower {\romannumeral0\xintfloatpower}%
\def\xintfloatpower #1{\XINT_flpower_chkopt \xintfloat #1\Z }%
\def\XINTinFloatPower {\romannumeral-`0\XINTinfloatpower}%
\def\XINTinfloatpower #1{\XINT_flpower_chkopt \XINT_inFloat #1\Z }%
\def\XINT_flpower_chkopt #1#2%
{%
    \ifx [#2\expandafter\XINT_flpower_opt
       \else\expandafter\XINT_flpower_noopt
    \fi
     #1#2%
}%
\def\XINT_flpower_noopt  #1#2\Z #3%
{%
   \expandafter\XINT_flpower_checkB_start\expandafter
                {\the\numexpr \XINT_digits\expandafter}\expandafter
                {\romannumeral0\xintnum{#3}}{#2}{#1[\XINT_digits]}%
}%
\def\XINT_flpower_opt #1[\Z #2]#3#4%
{%
   \expandafter\XINT_flpower_checkB_start\expandafter
               {\the\numexpr #2\expandafter}\expandafter
               {\romannumeral0\xintnum{#4}}{#3}{#1[#2]}%
}%
\def\XINT_flpower_checkB_start #1#2{\XINT_flpower_checkB_a #2\Z {#1}}%
\def\XINT_flpower_checkB_a #1%
{%
    \xint_UDzerominusfork
      #1-\dummy  \XINT_flpower_BisZero
      0#1\dummy  {\XINT_flpower_checkB_b 1}%
       0-\dummy  {\XINT_flpower_checkB_b 0#1}%
    \krof
}%
\def\XINT_flpower_BisZero \Z #1#2#3{#3{1/1[0]}}%
\def\XINT_flpower_checkB_b #1#2\Z #3%
{%
    \expandafter\XINT_flpower_checkB_c \expandafter
    {\romannumeral0\XINT_length{#2}}{#3}{#2}#1%
}%
\def\XINT_flpower_checkB_c #1#2%
{%
    \expandafter\XINT_flpower_checkB_d \expandafter
    {\the\numexpr \expandafter\XINT_Length\expandafter
                  {\the\numexpr #1*20/3}+#1+#2+1}%
}%
\def\XINT_flpower_checkB_d #1#2#3#4%
{%
    \expandafter \XINT_flpower_a
    \romannumeral-`0\XINT_inFloat [#1]{#4}{#1}{#2}#3%
}%
\def\XINT_flpower_a #1%
{%
    \xint_UDzerominusfork
      #1-\dummy \XINT_flpower_zero
      0#1\dummy {\XINT_flpower_b 1}%
       0-\dummy {\XINT_flpower_b 0#1}%
    \krof
}%
\def\XINT_flpower_zero [#1]#2#3#4#5%
{%
    \if #41 
          \xint_afterfi {\xintError:DivisionByZero\space 1.e2147483647}%
    \else \xint_afterfi { 0.e0}\fi
}%
\def\XINT_flpower_b #1#2[#3]#4#5%
{%
    \XINT_flpower_c {#4}{#5}{#2[#3]}{#1*\xintOdd {#5}}%
}%
\def\XINT_flpower_c #1#2#3#4%
{%
    \XINT_flpower_loop {#1}{#2}{#3}{{#1}}\XINT_flpow_prd
      \xint_relax
        \xint_undef\xint_undef\xint_undef\xint_undef
        \xint_undef\xint_undef\xint_undef\xint_undef
      \xint_relax {#4}%
}%
\def\XINT_flpower_loop #1#2#3%
{%
    \ifcase\XINT_isOne {#2}
        \xint_afterfi{\expandafter\XINT_flpower_loop_x\expandafter
            {\romannumeral-`0\XINTinfloatmul [#1]{#3}{#3}}%
            {\romannumeral0\xintdivision {#2}{2}}}%
    \or \expandafter\XINT_flpow_loop_end 
    \fi
    {#1}{{#3}}%
}%
\def\XINT_flpower_loop_x #1#2{\expandafter\XINT_flpower_loop_a #2{#1}}%
\def\XINT_flpower_loop_a #1#2#3#4%
{%
    \ifnum #2 = 1
        \expandafter\XINT_flpower_loop
    \else
        \expandafter\XINT_flpower_loop_throwaway
    \fi
    {#4}{#1}{#3}%
}%
\def\XINT_flpower_loop_throwaway #1#2#3#4%
{%
   \XINT_flpower_loop {#1}{#2}{#3}% 
}%
%    \end{macrocode}
% \subsection{\csh{xintFloatSqrt}}
% \lverb|1.08|
%    \begin{macrocode}
\def\xintFloatSqrt     {\romannumeral0\xintfloatsqrt }%
\def\xintfloatsqrt   #1{\XINT_flsqrt_chkopt \xintfloat #1\Z }%
\def\XINTinFloatSqrt   {\romannumeral-`0\XINTinfloatsqrt }%
\def\XINTinfloatsqrt #1{\XINT_flsqrt_chkopt \XINT_inFloat #1\Z }%
\def\XINT_flsqrt_chkopt #1#2%
{%
    \ifx [#2\expandafter\XINT_flsqrt_opt
       \else\expandafter\XINT_flsqrt_noopt
    \fi  #1#2%
}%
\def\XINT_flsqrt_noopt #1#2\Z
{%
    #1[\XINT_digits]{\XINT_FL_sqrt \XINT_digits {#2}}%
}%
\def\XINT_flsqrt_opt #1[\Z #2]#3%
{%
    #1[#2]{\XINT_FL_sqrt {#2}{#3}}%
}%
\def\XINT_FL_sqrt #1%
{%
    \ifnum\numexpr #1<\xint_c_xviii 
        \xint_afterfi {\XINT_FL_sqrt_a\xint_c_xviii}%
    \else
        \xint_afterfi {\XINT_FL_sqrt_a {#1+\xint_c_i}}%
    \fi
}%
\def\XINT_FL_sqrt_a #1#2%
{%     
    \expandafter\XINT_FL_sqrt_checkifzeroorneg
    \romannumeral-`0\XINT_inFloat [#1]{#2}%
}%
\def\XINT_FL_sqrt_checkifzeroorneg #1%
{%
    \xint_UDzerominusfork
     #1-\dummy  \XINT_FL_sqrt_iszero
     0#1\dummy  \XINT_FL_sqrt_isneg
      0-\dummy {\XINT_FL_sqrt_b #1}%
    \krof
}%
\def\XINT_FL_sqrt_iszero #1[#2]{0[0]}%
\def\XINT_FL_sqrt_isneg  #1[#2]{\xintError:RootOfNegative 0[0]}%
\def\XINT_FL_sqrt_b #1[#2]%
{%
    \ifodd #2
        \xint_afterfi{\XINT_FL_sqrt_c 01}%
    \else
        \xint_afterfi{\XINT_FL_sqrt_c {}0}%
    \fi
    {#1}{#2}%
}%
\def\XINT_FL_sqrt_c #1#2#3#4%
{%
    \expandafter\XINT_flsqrt\expandafter {\the\numexpr #4-#2}{#3#1}%
}%
\def\XINT_flsqrt #1#2%
{%
    \expandafter\XINT_sqrt_a
    \expandafter{\romannumeral0\XINT_length {#2}}\XINT_flsqrt_big_d {#2}{#1}%
}%
\def\XINT_flsqrt_big_d #1\or #2\fi #3% 
{%
   \fi
   \ifodd #3
     \xint_afterfi{\expandafter\XINT_flsqrt_big_eB}%
   \else
     \xint_afterfi{\expandafter\XINT_flsqrt_big_eA}%
   \fi
   \expandafter {\the\numexpr (#3-\xint_c_i)/\xint_c_ii }{#1}%
}%
\def\XINT_flsqrt_big_eA  #1#2#3%
{%
    \XINT_flsqrt_big_eA_a #3\Z {#2}{#1}{#3}%
}%
\def\XINT_flsqrt_big_eA_a #1#2#3#4#5#6#7#8#9\Z 
{%
    \XINT_flsqrt_big_eA_b {#1#2#3#4#5#6#7#8}%
}%
\def\XINT_flsqrt_big_eA_b #1#2%
{%
    \expandafter\XINT_flsqrt_big_f
    \romannumeral0\XINT_flsqrt_small_e {#2001}{#1}%
}%
\def\XINT_flsqrt_big_eB #1#2#3%
{%
    \XINT_flsqrt_big_eB_a #3\Z {#2}{#1}{#3}%
}%
\def\XINT_flsqrt_big_eB_a #1#2#3#4#5#6#7#8#9%
{%
    \XINT_flsqrt_big_eB_b {#1#2#3#4#5#6#7#8#9}%
}%
\def\XINT_flsqrt_big_eB_b #1#2\Z #3%
{%
    \expandafter\XINT_flsqrt_big_f
    \romannumeral0\XINT_flsqrt_small_e {#30001}{#1}%
}%
\def\XINT_flsqrt_small_e #1#2%
{%
   \expandafter\XINT_flsqrt_small_f\expandafter
   {\the\numexpr #1*#1-#2-\xint_c_i}{#1}%
}%
\def\XINT_flsqrt_small_f #1#2%
{%
   \expandafter\XINT_flsqrt_small_g\expandafter
   {\the\numexpr (#1+#2)/(2*#2)-\xint_c_i }{#1}{#2}%
}%
\def\XINT_flsqrt_small_g #1%
{%
    \ifnum #1>\xint_c_
       \expandafter\XINT_flsqrt_small_h
    \else
       \expandafter\XINT_flsqrt_small_end
    \fi
    {#1}%
}%
\def\XINT_flsqrt_small_h #1#2#3%
{%
    \expandafter\XINT_flsqrt_small_f\expandafter
    {\the\numexpr #2-\xint_c_ii*#1*#3+#1*#1\expandafter}\expandafter
    {\the\numexpr #3-#1}%
}%
\def\XINT_flsqrt_small_end #1#2#3%
{%
    \expandafter\space\expandafter
    {\the\numexpr \xint_c_i+#3*\xint_c_x^iv-
                      (#2*\xint_c_x^iv+#3)/(\xint_c_ii*#3)}%
}%
\def\XINT_flsqrt_big_f #1%
{%
    \expandafter\XINT_flsqrt_big_fa\expandafter 
    {\romannumeral0\xintisqr {#1}}{#1}%
}%
\def\XINT_flsqrt_big_fa #1#2#3#4%
{%
    \expandafter\XINT_flsqrt_big_fb\expandafter
    {\romannumeral-`0\XINT_dsx_addzerosnofuss 
                     {\numexpr #3-\xint_c_viii\relax}{#2}}%
    {\romannumeral0\xintisub
      {\XINT_dsx_addzerosnofuss 
           {\numexpr \xint_c_ii*(#3-\xint_c_viii)\relax}{#1}}{#4}}%
    {#3}%
}%
\def\XINT_flsqrt_big_fb #1#2%
{%
    \expandafter\XINT_flsqrt_big_g\expandafter {#2}{#1}%
}%
\def\XINT_flsqrt_big_g #1#2%
{%
    \expandafter\XINT_flsqrt_big_j
    \romannumeral0\xintidivision
    {#1}{\romannumeral0\XINT_dbl_pos #2\R\R\R\R\R\R\R\Z \W\W\W\W\W\W\W }{#2}%
}%
\def\XINT_flsqrt_big_j #1%
{%
    \ifcase\XINT_Sgn {#1}
        \expandafter \XINT_flsqrt_big_end_a
    \or \expandafter \XINT_flsqrt_big_k
    \fi {#1}%
}%
\def\XINT_flsqrt_big_k #1#2#3%
{%
    \expandafter\XINT_flsqrt_big_l\expandafter
    {\romannumeral0\XINT_sub_pre {#3}{#1}}%
    {\romannumeral0\xintiadd {#2}{\romannumeral0\XINT_sqr {#1}}}%
}%
\def\XINT_flsqrt_big_l #1#2%
{%
   \expandafter\XINT_flsqrt_big_g\expandafter
   {#2}{#1}%
}%
\def\XINT_flsqrt_big_end_a #1#2#3#4#5%
{%
   \expandafter\XINT_flsqrt_big_end_b\expandafter
   {\the\numexpr -#4+#5/\xint_c_ii\expandafter}\expandafter
   {\romannumeral0\xintisub 
    {\XINT_dsx_addzerosnofuss {#4}{#3}}%
    {\xintHalf{\xintiQuo{\XINT_dsx_addzerosnofuss {#4}{#2}}{#3}}}}%
}%
\def\XINT_flsqrt_big_end_b #1#2{#2[#1]}%
\XINT_frac_restorecatcodes_endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xintfrac>\relax
%\def<*xintseries>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xintfrac>
%<*xintseries>
% \section{Package \xintseriesname implementation}
% 
% The commenting is currently (\docdate) very sparse.
%
% \localtableofcontents
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
%
% The code for reload detection is copied from \textsc{Heiko
% Oberdiek}'s packages, and adapted here to check for previous
% loading of the \xintfracname package.
%
% The method for catcodes is slightly different, but still
% directly inspired by these packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \def\space { }%
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xintseries.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xintfrac.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintseries}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintseries.sty
      \ifx\w\relax % but xintfrac.sty not yet loaded.
         \y{xintseries}{Package xintfrac is required}%
         \y{xintseries}{Will try \string\input\space xintfrac.sty}%
         \def\z{\endgroup\input xintfrac.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xintfrac.sty not yet loaded.
            \y{xintseries}{Package xintfrac is required}%
            \y{xintseries}{Will try \string\RequirePackage{xintfrac}}%
            \def\z{\endgroup\RequirePackage{xintfrac}}%
          \fi
      \else
        \y{xintseries}{I was already loaded, aborting input}%
        \aftergroup\endinput
      \fi
    \fi
  \fi
\z%
%    \end{macrocode}
% \subsection{Confirmation of \xintfracname loading}
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \def\empty {}%
  \expandafter\let\expandafter\w\csname ver@xintfrac.sty\endcsname
  \ifx\w\relax % Plain TeX, user gave a file name at the prompt
      \y{xintseries}{Loading of package xintfrac failed, aborting input}%
      \aftergroup\endinput
  \fi
  \ifx\w\empty % LaTeX, user gave a file name at the prompt
      \y{xintseries}{Loading of package xintfrac failed, aborting input}%
      \aftergroup\endinput
  \fi
\endgroup%
%    \end{macrocode}
% \subsection{Catcodes}
%
% Perhaps catcodes have changed after the loading of \xintname and
% \xintfracname and prior to the current loading of \xintseriesname, 
% so we can not employ the |\XINT_restorecatcodes_endinput| in this style 
% file. But there is no problem using |\XINT_setcatcodes|.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode95=11   % _
  \def\x
  {%
      \endgroup
      \edef\XINT_series_restorecatcodes_endinput
      {%
        \catcode93=\the\catcode93   % ]
        \catcode91=\the\catcode91   % [
        \catcode94=\the\catcode94   % ^
        \catcode96=\the\catcode96   % `
        \catcode47=\the\catcode47   % /
        \catcode41=\the\catcode41   % )
        \catcode40=\the\catcode40   % (
        \catcode42=\the\catcode42   % *
        \catcode43=\the\catcode43   % +
        \catcode62=\the\catcode62   % >
        \catcode60=\the\catcode60   % <
        \catcode58=\the\catcode58   % :
        \catcode46=\the\catcode46   % .
        \catcode45=\the\catcode45   % -
        \catcode44=\the\catcode44   % ,
        \catcode35=\the\catcode35   % #
        \catcode95=\the\catcode95   % _
        \catcode125=\the\catcode125 % }
        \catcode123=\the\catcode123 % {
        \endlinechar=\the\endlinechar
        \catcode13=\the\catcode13   % ^^M
        \catcode32=\the\catcode32   % 
        \catcode61=\the\catcode61\relax   % =
        \noexpand\endinput
      }%
      \XINT_setcatcodes % defined in xint.sty
      \catcode91=12 % [
      \catcode93=12 % ]
  }%
\x
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\begingroup
  \catcode64=11 % @
  \catcode58=12 % :
  \expandafter\ifx\csname ProvidesPackage\endcsname\relax
    \def\x#1#2#3[#4]{\endgroup
      \immediate\write-1{Package: #3 #4}%
      \xdef#1{#4}%
    }%
  \else
    \def\x#1#2[#3]{\endgroup
      #2[{#3}]%
      \ifx#1\@undefined
        \xdef#1{#3}%
      \fi
      \ifx#1\relax
        \xdef#1{#3}%
      \fi
    }%
  \fi
\expandafter\x\csname ver@xintseries.sty\endcsname
\ProvidesPackage{xintseries}%
  [2013/06/14 v1.08b Expandable partial sums with xint package (jfB)]%
%    \end{macrocode}
% \subsection{\csh{xintSeries}}
% \lverb|&
% Modified in 1.06 to give the indices first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.
% 1.08a adds the forgotten optimization following that previous change.| 
%    \begin{macrocode}
\def\xintSeries {\romannumeral0\xintseries }%
\def\xintseries #1#2%
{%
    \expandafter\XINT_series\expandafter
    {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #2}%
}%
\def\XINT_series #1#2#3%
{%
   \ifnum #2<#1
      \xint_afterfi { 0/1[0]}%
   \else
      \xint_afterfi {\XINT_series_loop {#1}{0}{#2}{#3}}%
   \fi
}%
\def\XINT_series_loop #1#2#3#4%
{%
    \ifnum #3>#1 \else \XINT_series_exit \fi
    \expandafter\XINT_series_loop\expandafter
    {\the\numexpr #1+1\expandafter }\expandafter
    {\romannumeral0\xintadd {#2}{#4{#1}}}%
    {#3}{#4}%
}%
\def\XINT_series_exit \fi #1#2#3#4#5#6#7#8%
{%
    \fi\xint_gobble_ii #6%
}%
%    \end{macrocode}
% \subsection{\csh{xintiSeries}}
% \lverb|&
% Modified in 1.06 to give the indices first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.
% 1.08a adds the forgotten optimization following that previous change.| 
%    \begin{macrocode}
\def\xintiSeries {\romannumeral0\xintiseries }%
\def\xintiseries #1#2%
{%
    \expandafter\XINT_iseries\expandafter 
    {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #2}%
}%
\def\XINT_iseries #1#2#3%
{%
   \ifnum #2<#1
      \xint_afterfi { 0}%
   \else
      \xint_afterfi {\XINT_iseries_loop {#1}{0}{#2}{#3}}%
   \fi
}%
\def\XINT_iseries_loop #1#2#3#4%
{%
    \ifnum #3>#1 \else \XINT_iseries_exit \fi
    \expandafter\XINT_iseries_loop\expandafter
    {\the\numexpr #1+1\expandafter }\expandafter
    {\romannumeral0\xintiadd {#2}{#4{#1}}}%
    {#3}{#4}%
}%
\def\XINT_iseries_exit \fi #1#2#3#4#5#6#7#8%
{%
    \fi\xint_gobble_ii #6%
}%
%    \end{macrocode}
% \subsection{\csh{xintPowerSeries}}
% \lverb|&
% The 1.03 version was very lame and created a build-up of denominators.
% The Horner scheme for polynomial evaluation is used in 1.04, this
% cures the denominator problem and drastically improves the efficiency
% of the macro.
% Modified in 1.06 to give the indices first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.
% 1.08a adds the forgotten optimization following that previous change.| 
%    \begin{macrocode}
\def\xintPowerSeries {\romannumeral0\xintpowerseries }%
\def\xintpowerseries #1#2%
{%
    \expandafter\XINT_powseries\expandafter 
    {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #2}%
}%
\def\XINT_powseries #1#2#3#4%
{%
   \ifnum #2<#1
      \xint_afterfi { 0/1[0]}%
   \else
      \xint_afterfi
      {\XINT_powseries_loop_i {#3{#2}}{#1}{#2}{#3}{#4}}%
   \fi
}%
\def\XINT_powseries_loop_i #1#2#3#4#5%
{%
    \ifnum #3>#2 \else\XINT_powseries_exit_i\fi
    \expandafter\XINT_powseries_loop_ii\expandafter
    {\the\numexpr #3-1\expandafter}\expandafter
    {\romannumeral0\xintmul {#1}{#5}}{#2}{#4}{#5}%
}%
\def\XINT_powseries_loop_ii #1#2#3#4%
{%
   \expandafter\XINT_powseries_loop_i\expandafter
   {\romannumeral0\xintadd {#4{#1}}{#2}}{#3}{#1}{#4}%
}%
\def\XINT_powseries_exit_i\fi #1#2#3#4#5#6#7#8#9%
{%
    \fi \XINT_powseries_exit_ii  #6{#7}%
}%
\def\XINT_powseries_exit_ii #1#2#3#4#5#6%
{%
    \xintmul{\xintPow {#5}{#6}}{#4}%
}%
%    \end{macrocode}
% \subsection{\csh{xintPowerSeriesX}}
% \lverb|&
% Same as \xintPowerSeries except for the initial expansion of the x parameter.
% Modified in 1.06 to give the indices first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.
% 1.08a adds the forgotten optimization following that previous change.| 
%    \begin{macrocode}
\def\xintPowerSeriesX {\romannumeral0\xintpowerseriesx }%
\def\xintpowerseriesx #1#2%
{%
    \expandafter\XINT_powseriesx\expandafter 
    {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #2}%
}%
\def\XINT_powseriesx #1#2#3#4%
{%
   \ifnum #2<#1
      \xint_afterfi { 0/1[0]}%
   \else
      \xint_afterfi
      {\expandafter\XINT_powseriesx_pre\expandafter 
                  {\romannumeral-`0#4}{#1}{#2}{#3}%
      }%
   \fi
}%
\def\XINT_powseriesx_pre #1#2#3#4%
{%
    \XINT_powseries_loop_i {#4{#3}}{#2}{#3}{#4}{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintRationalSeries}}
% \lverb|&
% This computes F(a)+...+F(b) on the basis of the value of F(a) and the
% ratios F(n)/F(n-1). As in \xintPowerSeries we use an iterative scheme which
% has the great advantage to avoid denominator build-up. This makes exact
% computations possible with exponential type series, which would be completely
% inaccessible to \xintSeries. 
% #1=a, #2=b, #3=F(a), #4=ratio function
% Modified in 1.06 to give the indices first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.
% 1.08a adds the forgotten optimization following that previous change.| 
%    \begin{macrocode}
\def\xintRationalSeries {\romannumeral0\xintratseries }%
\def\xintratseries #1#2%
{%
    \expandafter\XINT_ratseries\expandafter 
    {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #2}%
}%
\def\XINT_ratseries #1#2#3#4%
{%
   \ifnum #2<#1
      \xint_afterfi { 0/1[0]}%
   \else
      \xint_afterfi
      {\XINT_ratseries_loop {#2}{1}{#1}{#4}{#3}}%
   \fi
}%
\def\XINT_ratseries_loop #1#2#3#4%
{%
    \ifnum #1>#3 \else\XINT_ratseries_exit_i\fi
    \expandafter\XINT_ratseries_loop\expandafter
    {\the\numexpr #1-1\expandafter}\expandafter
    {\romannumeral0\xintadd {1}{\xintMul {#2}{#4{#1}}}}{#3}{#4}%
}%
\def\XINT_ratseries_exit_i\fi #1#2#3#4#5#6#7#8%
{%
    \fi \XINT_ratseries_exit_ii  #6%
}%
\def\XINT_ratseries_exit_ii #1#2#3#4#5%
{%
    \XINT_ratseries_exit_iii #5%
}%
\def\XINT_ratseries_exit_iii #1#2#3#4%
{%
    \xintmul{#2}{#4}%
}%
%    \end{macrocode}
% \subsection{\csh{xintRationalSeriesX}}
% \lverb|&
% a,b,initial,ratiofunction,x$\
% This computes F(a,x)+...+F(b,x) on the basis of the value of F(a,x) and the
% ratios F(n,x)/F(n-1,x). The argument x is first expanded and it is the value
% resulting from this which is used then throughout. The initial term F(a,x)
% must be defined as one-parameter macro which will be given x. 
% Modified in 1.06 to give the indices first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.
% 1.08a adds the forgotten optimization following that previous change.|
%    \begin{macrocode}
\def\xintRationalSeriesX {\romannumeral0\xintratseriesx }%
\def\xintratseriesx #1#2%
{%
    \expandafter\XINT_ratseriesx\expandafter 
    {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #2}%
}%
\def\XINT_ratseriesx #1#2#3#4#5%
{%
   \ifnum #2<#1
      \xint_afterfi { 0/1[0]}%
   \else
      \xint_afterfi
      {\expandafter\XINT_ratseriesx_pre\expandafter 
                   {\romannumeral-`0#5}{#2}{#1}{#4}{#3}%
      }%
   \fi
}%
\def\XINT_ratseriesx_pre #1#2#3#4#5%
{%
    \XINT_ratseries_loop {#2}{1}{#3}{#4{#1}}{#5{#1}}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFxPtPowerSeries}}
% \lverb|&
% I am not two happy with this piece of code. Will make it more economical
% another day. 
% Modified in 1.06 to give the indices first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.
% 1.08a: forgot last time some optimization from the change to \numexpr.|
%    \begin{macrocode}
\def\xintFxPtPowerSeries {\romannumeral0\xintfxptpowerseries }%
\def\xintfxptpowerseries #1#2%
{%
    \expandafter\XINT_fppowseries\expandafter 
    {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #2}%
}%
\def\XINT_fppowseries #1#2#3#4#5%
{%
   \ifnum #2<#1
      \xint_afterfi { 0}%
   \else
      \xint_afterfi
        {\expandafter\XINT_fppowseries_loop_pre\expandafter
           {\romannumeral0\xinttrunc {#5}{\xintPow {#4}{#1}}}%
          {#1}{#4}{#2}{#3}{#5}%
        }%
   \fi
}%
\def\XINT_fppowseries_loop_pre #1#2#3#4#5#6%
{%
    \ifnum #4>#2 \else\XINT_fppowseries_dont_i \fi
    \expandafter\XINT_fppowseries_loop_i\expandafter 
    {\the\numexpr #2+\xint_c_i\expandafter}\expandafter
    {\romannumeral0\xintitrunc {#6}{\xintMul {#5{#2}}{#1}}}%
    {#1}{#3}{#4}{#5}{#6}%
}%
\def\XINT_fppowseries_dont_i \fi\expandafter\XINT_fppowseries_loop_i
    {\fi \expandafter\XINT_fppowseries_dont_ii }%
\def\XINT_fppowseries_dont_ii #1#2#3#4#5#6#7{\xinttrunc {#7}{#2[-#7]}}%
\def\XINT_fppowseries_loop_i #1#2#3#4#5#6#7%
{%
    \ifnum #5>#1 \else \XINT_fppowseries_exit_i \fi
    \expandafter\XINT_fppowseries_loop_ii\expandafter
    {\romannumeral0\xinttrunc {#7}{\xintMul {#3}{#4}}}%
    {#1}{#4}{#2}{#5}{#6}{#7}%
}%
\def\XINT_fppowseries_loop_ii #1#2#3#4#5#6#7%
{%
    \expandafter\XINT_fppowseries_loop_i\expandafter
    {\the\numexpr #2+\xint_c_i\expandafter}\expandafter
    {\romannumeral0\xintiadd {#4}{\xintiTrunc {#7}{\xintMul {#6{#2}}{#1}}}}%
    {#1}{#3}{#5}{#6}{#7}%
}%
\def\XINT_fppowseries_exit_i\fi\expandafter\XINT_fppowseries_loop_ii
    {\fi \expandafter\XINT_fppowseries_exit_ii }%
\def\XINT_fppowseries_exit_ii #1#2#3#4#5#6#7%
{%
    \xinttrunc {#7}
    {\xintiAdd {#4}{\xintiTrunc {#7}{\xintMul {#6{#2}}{#1}}}[-#7]}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFxPtPowerSeriesX}}
% \lverb|&
% a,b,coeff,x,D$\
% Modified in 1.06 to give the indices first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.
% 1.08a adds the forgotten optimization following that previous change.| 
%    \begin{macrocode}
\def\xintFxPtPowerSeriesX {\romannumeral0\xintfxptpowerseriesx }%
\def\xintfxptpowerseriesx #1#2%
{%
    \expandafter\XINT_fppowseriesx\expandafter 
    {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #2}%
}%
\def\XINT_fppowseriesx #1#2#3#4#5%
{%
   \ifnum #2<#1
      \xint_afterfi { 0}%
   \else
      \xint_afterfi
        {\expandafter \XINT_fppowseriesx_pre \expandafter
         {\romannumeral-`0#4}{#1}{#2}{#3}{#5}%
        }%
   \fi
}%
\def\XINT_fppowseriesx_pre #1#2#3#4#5%
{%
    \expandafter\XINT_fppowseries_loop_pre\expandafter
       {\romannumeral0\xinttrunc {#5}{\xintPow {#1}{#2}}}%
       {#2}{#1}{#3}{#4}{#5}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFloatPowerSeries}}
% \lverb|1.08a. I still have to re-visit \xintFxPtPowerSeries; temporarily I
% just adapted the code to the case of floats.|
%    \begin{macrocode}
\def\xintFloatPowerSeries {\romannumeral0\xintfloatpowerseries }%
\def\xintfloatpowerseries #1{\XINT_flpowseries_chkopt #1\Z }%
\def\XINT_flpowseries_chkopt #1%
{%
    \ifx [#1\expandafter\XINT_flpowseries_opt
       \else\expandafter\XINT_flpowseries_noopt
    \fi
    #1%
}%
\def\XINT_flpowseries_noopt  #1\Z #2%
{%
    \expandafter\XINT_flpowseries\expandafter 
    {\the\numexpr #1\expandafter}\expandafter
    {\the\numexpr #2}\XINT_digits 
}%
\def\XINT_flpowseries_opt [\Z #1]#2#3%
{%
    \expandafter\XINT_flpowseries\expandafter 
    {\the\numexpr #2\expandafter}\expandafter
    {\the\numexpr #3\expandafter}{\the\numexpr #1}%
}%
\def\XINT_flpowseries #1#2#3#4#5%
{%
   \ifnum #2<#1
      \xint_afterfi { 0.e0}%
   \else
      \xint_afterfi
        {\expandafter\XINT_flpowseries_loop_pre\expandafter
           {\romannumeral-`0\XINTinfloatpow [#3]{#5}{#1}}%
          {#1}{#5}{#2}{#4}{#3}%
        }%
   \fi
}%
\def\XINT_flpowseries_loop_pre #1#2#3#4#5#6%
{%
    \ifnum #4>#2 \else\XINT_flpowseries_dont_i \fi
    \expandafter\XINT_flpowseries_loop_i\expandafter 
    {\the\numexpr #2+\xint_c_i\expandafter}\expandafter
    {\romannumeral-`0\XINTinfloatmul [#6]{#5{#2}}{#1}}%
    {#1}{#3}{#4}{#5}{#6}%
}%
\def\XINT_flpowseries_dont_i \fi\expandafter\XINT_flpowseries_loop_i
    {\fi \expandafter\XINT_flpowseries_dont_ii }%
\def\XINT_flpowseries_dont_ii #1#2#3#4#5#6#7{\xintfloat [#7]{#2}}%
\def\XINT_flpowseries_loop_i #1#2#3#4#5#6#7%
{%
    \ifnum #5>#1 \else \XINT_flpowseries_exit_i \fi
    \expandafter\XINT_flpowseries_loop_ii\expandafter
    {\romannumeral-`0\XINTinfloatmul [#7]{#3}{#4}}%
    {#1}{#4}{#2}{#5}{#6}{#7}%
}%
\def\XINT_flpowseries_loop_ii #1#2#3#4#5#6#7%
{%
    \expandafter\XINT_flpowseries_loop_i\expandafter
    {\the\numexpr #2+\xint_c_i\expandafter}\expandafter
    {\romannumeral-`0\XINTinfloatadd [#7]{#4}%
                        {\XINTinfloatmul [#7]{#6{#2}}{#1}}}%
    {#1}{#3}{#5}{#6}{#7}%
}%
\def\XINT_flpowseries_exit_i\fi\expandafter\XINT_flpowseries_loop_ii
    {\fi \expandafter\XINT_flpowseries_exit_ii }%
\def\XINT_flpowseries_exit_ii #1#2#3#4#5#6#7%
{%
    \xintfloatadd [#7]{#4}{\XINTinfloatmul [#7]{#6{#2}}{#1}}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFloatPowerSeriesX}}
% \lverb|1.08a|
%    \begin{macrocode}
\def\xintFloatPowerSeriesX {\romannumeral0\xintfloatpowerseriesx }%
\def\xintfloatpowerseriesx #1{\XINT_flpowseriesx_chkopt #1\Z }%
\def\XINT_flpowseriesx_chkopt #1%
{%
    \ifx [#1\expandafter\XINT_flpowseriesx_opt
       \else\expandafter\XINT_flpowseriesx_noopt
    \fi
    #1%
}%
\def\XINT_flpowseriesx_noopt  #1\Z #2%
{%
    \expandafter\XINT_flpowseriesx\expandafter 
    {\the\numexpr #1\expandafter}\expandafter
    {\the\numexpr #2}\XINT_digits 
}%
\def\XINT_flpowseriesx_opt [\Z #1]#2#3%
{%
    \expandafter\XINT_flpowseriesx\expandafter 
    {\the\numexpr #2\expandafter}\expandafter
    {\the\numexpr #3\expandafter}{\the\numexpr #1}%
}%
\def\XINT_flpowseriesx #1#2#3#4#5%
{%
   \ifnum #2<#1
      \xint_afterfi { 0.e0}%
   \else
      \xint_afterfi
        {\expandafter \XINT_flpowseriesx_pre \expandafter
         {\romannumeral-`0#5}{#1}{#2}{#4}{#3}%
        }%
   \fi
}%
\def\XINT_flpowseriesx_pre #1#2#3#4#5%
{%
    \expandafter\XINT_flpowseries_loop_pre\expandafter
       {\romannumeral-`0\XINTinfloatpow [#5]{#1}{#2}}%
       {#2}{#1}{#3}{#4}{#5}%
}%
\XINT_series_restorecatcodes_endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xintseries>\relax
%\def<*xintcfrac>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xintseries>
%<*xintcfrac>
% \section{Package \xintcfracname implementation}
% 
% The commenting is currently (\docdate) very sparse.
%
% \localtableofcontents
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
%
% The code for reload detection is copied from \textsc{Heiko
% Oberdiek}'s packages, and adapted here to check for previous
% loading of the \xintfracname package.
%
% The method for catcodes is slightly different, but still
% directly inspired by these packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \def\space { }%
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xintcfrac.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xintfrac.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintcfrac}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintcfrac.sty
      \ifx\w\relax % but xintfrac.sty not yet loaded.
         \y{xintcfrac}{Package xintfrac is required}%
         \y{xintcfrac}{Will try \string\input\space xintfrac.sty}%
         \def\z{\endgroup\input xintfrac.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xintfrac.sty not yet loaded.
            \y{xintcfrac}{Package xintfrac is required}%
            \y{xintcfrac}{Will try \string\RequirePackage{xintfrac}}%
            \def\z{\endgroup\RequirePackage{xintfrac}}%
          \fi
      \else
        \y{xintcfrac}{I was already loaded, aborting input}%
        \aftergroup\endinput
      \fi
    \fi
  \fi
\z%
%    \end{macrocode}
% \subsection{Confirmation of \xintfracname loading}
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \def\empty {}%
  \expandafter\let\expandafter\w\csname ver@xintfrac.sty\endcsname
  \ifx\w\relax % Plain TeX, user gave a file name at the prompt
      \y{xintcfrac}{Loading of package xintfrac failed, aborting input}%
      \aftergroup\endinput
  \fi
  \ifx\w\empty % LaTeX, user gave a file name at the prompt
      \y{xintcfrac}{Loading of package xintfrac failed, aborting input}%
      \aftergroup\endinput
  \fi
\endgroup%
%    \end{macrocode}
% \subsection{Catcodes}
%
% Perhaps catcodes have changed after the loading of \xintname and
% \xintfracname and prior to the current loading of \xintcfracname, 
% so we can not employ the |\XINT_restorecatcodes_endinput| in this style 
% file. But there is no problem using |\XINT_setcatcodes|.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode95=11   % _
  \def\x
  {%
      \endgroup
      \edef\XINT_cfrac_restorecatcodes_endinput
      {%
        \catcode93=\the\catcode93   % ]
        \catcode91=\the\catcode91   % [
        \catcode94=\the\catcode94   % ^
        \catcode96=\the\catcode96   % `
        \catcode47=\the\catcode47   % /
        \catcode41=\the\catcode41   % )
        \catcode40=\the\catcode40   % (
        \catcode42=\the\catcode42   % *
        \catcode43=\the\catcode43   % +
        \catcode62=\the\catcode62   % >
        \catcode60=\the\catcode60   % <
        \catcode58=\the\catcode58   % :
        \catcode46=\the\catcode46   % .
        \catcode45=\the\catcode45   % -
        \catcode44=\the\catcode44   % ,
        \catcode35=\the\catcode35   % #
        \catcode95=\the\catcode95   % _
        \catcode125=\the\catcode125 % }
        \catcode123=\the\catcode123 % {
        \endlinechar=\the\endlinechar
        \catcode13=\the\catcode13   % ^^M
        \catcode32=\the\catcode32   % 
        \catcode61=\the\catcode61\relax   % =
        \noexpand\endinput
      }%
      \XINT_setcatcodes % defined in xint.sty
      \catcode91=12 % [
      \catcode93=12 % ]
  }%
\x
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\begingroup
  \catcode64=11 % @
  \catcode58=12 % :
  \expandafter\ifx\csname ProvidesPackage\endcsname\relax
    \def\x#1#2#3[#4]{\endgroup
      \immediate\write-1{Package: #3 #4}%
      \xdef#1{#4}%
    }%
  \else
    \def\x#1#2[#3]{\endgroup
      #2[{#3}]%
      \ifx#1\@undefined
        \xdef#1{#3}%
      \fi
      \ifx#1\relax
        \xdef#1{#3}%
      \fi
    }%
  \fi
\expandafter\x\csname ver@xintcfrac.sty\endcsname
\ProvidesPackage{xintcfrac}%
  [2013/06/14 v1.08b Expandable continued fractions with xint package (jfB)]%
%    \end{macrocode}
% \subsection{\csh{xintCFrac}}
%    \begin{macrocode}
\def\xintCFrac {\romannumeral0\xintcfrac }%
\def\xintcfrac #1%
{%
    \XINT_cfrac_opt_a #1\Z
}%
\def\XINT_cfrac_opt_a #1%
{% 
    \ifx[#1\XINT_cfrac_opt_b\fi \XINT_cfrac_noopt #1%
}%
\def\XINT_cfrac_noopt #1\Z
{%
    \expandafter\XINT_cfrac_A\romannumeral0\xintrawwithzeros {#1}\Z
    \relax\relax
}%
\def\XINT_cfrac_opt_b\fi\XINT_cfrac_noopt [\Z #1]%
{%
    \fi\csname XINT_cfrac_opt#1\endcsname
}%
\def\XINT_cfrac_optl #1%
{%
    \expandafter\XINT_cfrac_A\romannumeral0\xintrawwithzeros {#1}\Z
    \relax\hfill
}%
\def\XINT_cfrac_optc #1%
{%
    \expandafter\XINT_cfrac_A\romannumeral0\xintrawwithzeros {#1}\Z
    \relax\relax
}%
\def\XINT_cfrac_optr #1%
{%
    \expandafter\XINT_cfrac_A\romannumeral0\xintrawwithzeros {#1}\Z
    \hfill\relax
}%
\def\XINT_cfrac_A #1/#2\Z
{%
    \expandafter\XINT_cfrac_B\romannumeral0\xintidivision {#1}{#2}{#2}%
}%
\def\XINT_cfrac_B #1#2%
{%
    \XINT_cfrac_C #2\Z {#1}%
}%
\def\XINT_cfrac_C #1%
{%
    \xint_gob_til_zero #1\XINT_cfrac_integer 0\XINT_cfrac_D #1%
}%
\def\XINT_cfrac_integer 0\XINT_cfrac_D 0#1\Z #2#3#4#5{ #2}%
\def\XINT_cfrac_D #1\Z #2#3{\XINT_cfrac_loop_a {#1}{#3}{#1}{{#2}}}%  
\def\XINT_cfrac_loop_a 
{%
    \expandafter\XINT_cfrac_loop_d\romannumeral0\XINT_div_prepare
}%
\def\XINT_cfrac_loop_d #1#2%
{%
    \XINT_cfrac_loop_e #2.{#1}%
}%
\def\XINT_cfrac_loop_e #1%
{%
    \xint_gob_til_zero #1\xint_cfrac_loop_exit0\XINT_cfrac_loop_f #1%
}%
\def\XINT_cfrac_loop_f #1.#2#3#4%
{%
    \XINT_cfrac_loop_a {#1}{#3}{#1}{{#2}#4}%
}%
\def\xint_cfrac_loop_exit0\XINT_cfrac_loop_f #1.#2#3#4#5#6%
   {\XINT_cfrac_T #5#6{#2}#4\Z }%
\def\XINT_cfrac_T #1#2#3#4%
{%
  \xint_gob_til_Z #4\XINT_cfrac_end\Z\XINT_cfrac_T #1#2{#4+\cfrac{#11#2}{#3}}%
}%
\def\XINT_cfrac_end\Z\XINT_cfrac_T #1#2#3%
{%
    \XINT_cfrac_end_b #3%
}%
\def\XINT_cfrac_end_b \Z+\cfrac#1#2{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintGCFrac}}
%    \begin{macrocode}
\def\xintGCFrac {\romannumeral0\xintgcfrac }%
\def\xintgcfrac #1{\XINT_gcfrac_opt_a #1\Z }%
\def\XINT_gcfrac_opt_a #1%
{% 
    \ifx[#1\XINT_gcfrac_opt_b\fi \XINT_gcfrac_noopt #1%
}%
\def\XINT_gcfrac_noopt #1\Z
{%
    \XINT_gcfrac #1+\W/\relax\relax
}%
\def\XINT_gcfrac_opt_b\fi\XINT_gcfrac_noopt [\Z #1]%
{%
    \fi\csname XINT_gcfrac_opt#1\endcsname
}%
\def\XINT_gcfrac_optl #1%
{%
    \XINT_gcfrac #1+\W/\relax\hfill
}%
\def\XINT_gcfrac_optc #1%
{%
    \XINT_gcfrac #1+\W/\relax\relax
}%
\def\XINT_gcfrac_optr #1%
{%
    \XINT_gcfrac #1+\W/\hfill\relax
}%
\def\XINT_gcfrac 
{%
    \expandafter\XINT_gcfrac_enter\romannumeral-`0%
}%
\def\XINT_gcfrac_enter {\XINT_gcfrac_loop {}}%
\def\XINT_gcfrac_loop #1#2+#3/%
{%
    \xint_gob_til_W #3\XINT_gcfrac_endloop\W
    \XINT_gcfrac_loop {{#3}{#2}#1}%
}%
\def\XINT_gcfrac_endloop\W\XINT_gcfrac_loop #1#2#3%
{%
    \XINT_gcfrac_T #2#3#1\Z\Z
}%
\def\XINT_gcfrac_T #1#2#3#4{\XINT_gcfrac_U #1#2{\xintFrac{#4}}}%
\def\XINT_gcfrac_U #1#2#3#4#5%
{%
    \xint_gob_til_Z #5\XINT_gcfrac_end\Z\XINT_gcfrac_U 
              #1#2{\xintFrac{#5}%
               \ifcase\xintSgn{#4}
               +\or+\else-\fi
               \cfrac{#1\xintFrac{\xintAbs{#4}}#2}{#3}}%
}%
\def\XINT_gcfrac_end\Z\XINT_gcfrac_U #1#2#3%
{%
    \XINT_gcfrac_end_b #3%
}%
\def\XINT_gcfrac_end_b #1\cfrac#2#3{ #3}%
%    \end{macrocode}
% \subsection{\csh{xintGCtoGCx}}
%    \begin{macrocode}
\def\xintGCtoGCx {\romannumeral0\xintgctogcx }%
\def\xintgctogcx #1#2#3%
{%
    \expandafter\XINT_gctgcx_start\expandafter {\romannumeral-`0#3}{#1}{#2}%
}%
\def\XINT_gctgcx_start #1#2#3{\XINT_gctgcx_loop_a {}{#2}{#3}#1+\W/}%
\def\XINT_gctgcx_loop_a #1#2#3#4+#5/%
{%
    \xint_gob_til_W #5\XINT_gctgcx_end\W
    \XINT_gctgcx_loop_b {#1{#4}}{#2{#5}#3}{#2}{#3}%
}%
\def\XINT_gctgcx_loop_b #1#2%
{%
    \XINT_gctgcx_loop_a {#1#2}%
}%  
\def\XINT_gctgcx_end\W\XINT_gctgcx_loop_b #1#2#3#4{ #1}%
%    \end{macrocode}
% \subsection{\csh{xintFtoCs}}
%    \begin{macrocode}
\def\xintFtoCs {\romannumeral0\xintftocs }%
\def\xintftocs #1%
{%
    \expandafter\XINT_ftc_A\romannumeral0\xintrawwithzeros {#1}\Z
}%
\def\XINT_ftc_A #1/#2\Z
{%
    \expandafter\XINT_ftc_B\romannumeral0\xintidivision {#1}{#2}{#2}%
}%
\def\XINT_ftc_B #1#2%
{%
    \XINT_ftc_C #2.{#1}%
}%
\def\XINT_ftc_C #1%
{%
    \xint_gob_til_zero #1\XINT_ftc_integer 0\XINT_ftc_D #1%
}%
\def\XINT_ftc_integer 0\XINT_ftc_D 0#1.#2#3{ #2}%
\def\XINT_ftc_D #1.#2#3{\XINT_ftc_loop_a {#1}{#3}{#1}{#2,}}%  
\def\XINT_ftc_loop_a 
{%
    \expandafter\XINT_ftc_loop_d\romannumeral0\XINT_div_prepare
}%
\def\XINT_ftc_loop_d #1#2%
{%
    \XINT_ftc_loop_e #2.{#1}%
}%
\def\XINT_ftc_loop_e #1%
{%
    \xint_gob_til_zero #1\xint_ftc_loop_exit0\XINT_ftc_loop_f #1%
}%
\def\XINT_ftc_loop_f #1.#2#3#4%
{%
    \XINT_ftc_loop_a {#1}{#3}{#1}{#4#2,}%
}%
\def\xint_ftc_loop_exit0\XINT_ftc_loop_f #1.#2#3#4{ #4#2}%
%    \end{macrocode}
% \subsection{\csh{xintFtoCx}}
%    \begin{macrocode}
\def\xintFtoCx {\romannumeral0\xintftocx }%
\def\xintftocx #1#2%
{%
    \expandafter\XINT_ftcx_A\romannumeral0\xintrawwithzeros {#2}\Z {#1}%
}%
\def\XINT_ftcx_A #1/#2\Z
{%
    \expandafter\XINT_ftcx_B\romannumeral0\xintidivision {#1}{#2}{#2}%
}%
\def\XINT_ftcx_B #1#2%
{%
    \XINT_ftcx_C #2.{#1}%
}%
\def\XINT_ftcx_C #1%
{%
    \xint_gob_til_zero #1\XINT_ftcx_integer 0\XINT_ftcx_D #1%
}%
\def\XINT_ftcx_integer 0\XINT_ftcx_D 0#1.#2#3#4{ #2}%
\def\XINT_ftcx_D #1.#2#3#4{\XINT_ftcx_loop_a {#1}{#3}{#1}{#2#4}{#4}}%  
\def\XINT_ftcx_loop_a 
{%
    \expandafter\XINT_ftcx_loop_d\romannumeral0\XINT_div_prepare
}%
\def\XINT_ftcx_loop_d #1#2%
{%
    \XINT_ftcx_loop_e #2.{#1}%
}%
\def\XINT_ftcx_loop_e #1%
{%
    \xint_gob_til_zero #1\xint_ftcx_loop_exit0\XINT_ftcx_loop_f #1%
}%
\def\XINT_ftcx_loop_f #1.#2#3#4#5%
{%
    \XINT_ftcx_loop_a {#1}{#3}{#1}{#4{#2}#5}{#5}%
}%
\def\xint_ftcx_loop_exit0\XINT_ftcx_loop_f #1.#2#3#4#5{ #4{#2}}%
%    \end{macrocode}
% \subsection{\csh{xintFtoGC}}
%    \begin{macrocode}
\def\xintFtoGC {\romannumeral0\xintftogc }%
\def\xintftogc {\xintftocx {+1/}}%
%    \end{macrocode}
% \subsection{\csh{xintFtoCC}}
%    \begin{macrocode}
\def\xintFtoCC {\romannumeral0\xintftocc }%
\def\xintftocc #1%
{%
    \expandafter\XINT_ftcc_A\expandafter {\romannumeral0\xintrawwithzeros {#1}}%
}%
\def\XINT_ftcc_A #1%
{%
    \expandafter\XINT_ftcc_B
    \romannumeral0\xintrawwithzeros {\xintAdd {1/2[0]}{#1[0]}}\Z {#1[0]}%
}%
\def\XINT_ftcc_B #1/#2\Z 
{%
    \expandafter\XINT_ftcc_C\expandafter {\romannumeral0\xintiquo {#1}{#2}}%
}%
\def\XINT_ftcc_C #1#2%
{%
    \expandafter\XINT_ftcc_D\romannumeral0\xintsub {#2}{#1}\Z {#1}%
}%
\def\XINT_ftcc_D #1%
{%
    \xint_UDzerominusfork
      #1-\dummy \XINT_ftcc_integer
      0#1\dummy \XINT_ftcc_En
       0-\dummy {\XINT_ftcc_Ep #1}%
    \krof
}%
\def\XINT_ftcc_Ep #1\Z #2%
{%
    \expandafter\XINT_ftcc_loop_a\expandafter
    {\romannumeral0\xintdiv {1[0]}{#1}}{#2+1/}%
}%
\def\XINT_ftcc_En #1\Z #2%
{%
    \expandafter\XINT_ftcc_loop_a\expandafter
    {\romannumeral0\xintdiv {1[0]}{#1}}{#2+-1/}%
}%
\def\XINT_ftcc_integer #1\Z #2{ #2}%
\def\XINT_ftcc_loop_a #1%
{%
    \expandafter\XINT_ftcc_loop_b
    \romannumeral0\xintrawwithzeros {\xintAdd {1/2[0]}{#1}}\Z {#1}%
}%
\def\XINT_ftcc_loop_b #1/#2\Z
{%
    \expandafter\XINT_ftcc_loop_c\expandafter 
    {\romannumeral0\xintiquo {#1}{#2}}%
}%
\def\XINT_ftcc_loop_c #1#2%
{%
    \expandafter\XINT_ftcc_loop_d
    \romannumeral0\xintsub {#2}{#1[0]}\Z {#1}%
}%
\def\XINT_ftcc_loop_d #1%
{%
    \xint_UDzerominusfork
      #1-\dummy \XINT_ftcc_end
      0#1\dummy \XINT_ftcc_loop_N
       0-\dummy {\XINT_ftcc_loop_P #1}%
    \krof
}%
\def\XINT_ftcc_end #1\Z #2#3{ #3#2}%
\def\XINT_ftcc_loop_P #1\Z #2#3%
{%
    \expandafter\XINT_ftcc_loop_a\expandafter
    {\romannumeral0\xintdiv {1[0]}{#1}}{#3#2+1/}%
}%
\def\XINT_ftcc_loop_N #1\Z #2#3%
{%
    \expandafter\XINT_ftcc_loop_a\expandafter
    {\romannumeral0\xintdiv {1[0]}{#1}}{#3#2+-1/}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFtoCv}}
%    \begin{macrocode}
\def\xintFtoCv {\romannumeral0\xintftocv }%
\def\xintftocv #1%
{%
    \xinticstocv {\xintFtoCs {#1}}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFtoCCv}}
%    \begin{macrocode}
\def\xintFtoCCv {\romannumeral0\xintftoccv }%
\def\xintftoccv #1%
{%
    \xintigctocv {\xintFtoCC {#1}}%
}%
%    \end{macrocode}
% \subsection{\csh{xintCstoF}}
%    \begin{macrocode}
\def\xintCstoF {\romannumeral0\xintcstof }%
\def\xintcstof #1%
{%
    \expandafter\XINT_cstf_prep \romannumeral-`0#1,\W,%
}%
\def\XINT_cstf_prep
{%
    \XINT_cstf_loop_a 1001%
}%
\def\XINT_cstf_loop_a #1#2#3#4#5,%
{%
    \xint_gob_til_W #5\XINT_cstf_end\W
    \expandafter\XINT_cstf_loop_b
    \romannumeral0\xintrawwithzeros {#5}.{#1}{#2}{#3}{#4}%
}%
\def\XINT_cstf_loop_b #1/#2.#3#4#5#6%
{%
    \expandafter\XINT_cstf_loop_c\expandafter
    {\romannumeral0\XINT_mul_fork #2\Z #4\Z }%
    {\romannumeral0\XINT_mul_fork #2\Z #3\Z }%
    {\romannumeral0\xintiadd {\XINT_Mul {#2}{#6}}{\XINT_Mul {#1}{#4}}}%
    {\romannumeral0\xintiadd {\XINT_Mul {#2}{#5}}{\XINT_Mul {#1}{#3}}}%
}%
\def\XINT_cstf_loop_c #1#2%
{%
    \expandafter\XINT_cstf_loop_d\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_cstf_loop_d #1#2%
{%
    \expandafter\XINT_cstf_loop_e\expandafter {\expandafter{#2}#1}%
}%
\def\XINT_cstf_loop_e #1#2%
{%
    \expandafter\XINT_cstf_loop_a\expandafter{#2}#1%
}%
\def\XINT_cstf_end #1.#2#3#4#5{\xintrawwithzeros {#2/#3}[0]}%
%    \end{macrocode}
% \subsection{\csh{xintiCstoF}}
%    \begin{macrocode}
\def\xintiCstoF {\romannumeral0\xinticstof }%
\def\xinticstof #1%
{%
    \expandafter\XINT_icstf_prep \romannumeral-`0#1,\W,%
}%
\def\XINT_icstf_prep
{%
    \XINT_icstf_loop_a 1001%
}%
\def\XINT_icstf_loop_a #1#2#3#4#5,%
{%
    \xint_gob_til_W #5\XINT_icstf_end\W
    \expandafter
    \XINT_icstf_loop_b \romannumeral-`0#5.{#1}{#2}{#3}{#4}%
}%
\def\XINT_icstf_loop_b #1.#2#3#4#5%
{%
    \expandafter\XINT_icstf_loop_c\expandafter
    {\romannumeral0\xintiadd {#5}{\XINT_Mul {#1}{#3}}}%
    {\romannumeral0\xintiadd {#4}{\XINT_Mul {#1}{#2}}}%
    {#2}{#3}%
}%
\def\XINT_icstf_loop_c #1#2%
{%
    \expandafter\XINT_icstf_loop_a\expandafter {#2}{#1}%
}%
\def\XINT_icstf_end#1.#2#3#4#5{\xintrawwithzeros {#2/#3}[0]}%
%    \end{macrocode}
% \subsection{\csh{xintGCtoF}}
%    \begin{macrocode}
\def\xintGCtoF {\romannumeral0\xintgctof }%
\def\xintgctof #1%
{%
    \expandafter\XINT_gctf_prep \romannumeral-`0#1+\W/%
}%
\def\XINT_gctf_prep
{%
    \XINT_gctf_loop_a 1001%
}%
\def\XINT_gctf_loop_a #1#2#3#4#5+%
{%
    \expandafter\XINT_gctf_loop_b
    \romannumeral0\xintrawwithzeros {#5}.{#1}{#2}{#3}{#4}%
}%
\def\XINT_gctf_loop_b #1/#2.#3#4#5#6%
{%
    \expandafter\XINT_gctf_loop_c\expandafter
    {\romannumeral0\XINT_mul_fork #2\Z #4\Z }%
    {\romannumeral0\XINT_mul_fork #2\Z #3\Z }%
    {\romannumeral0\xintiadd {\XINT_Mul {#2}{#6}}{\XINT_Mul {#1}{#4}}}%
    {\romannumeral0\xintiadd {\XINT_Mul {#2}{#5}}{\XINT_Mul {#1}{#3}}}%
}%
\def\XINT_gctf_loop_c #1#2%
{%
    \expandafter\XINT_gctf_loop_d\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_gctf_loop_d #1#2%
{%
    \expandafter\XINT_gctf_loop_e\expandafter {\expandafter{#2}#1}%
}%
\def\XINT_gctf_loop_e #1#2%
{%
    \expandafter\XINT_gctf_loop_f\expandafter {\expandafter{#2}#1}%
}%
\def\XINT_gctf_loop_f #1#2/%
{%
    \xint_gob_til_W #2\XINT_gctf_end\W
    \expandafter\XINT_gctf_loop_g 
    \romannumeral0\xintrawwithzeros {#2}.#1%
}%
\def\XINT_gctf_loop_g #1/#2.#3#4#5#6%
{%
    \expandafter\XINT_gctf_loop_h\expandafter
    {\romannumeral0\XINT_mul_fork #1\Z #6\Z }%
    {\romannumeral0\XINT_mul_fork #1\Z #5\Z }%
    {\romannumeral0\XINT_mul_fork #2\Z #4\Z }%
    {\romannumeral0\XINT_mul_fork #2\Z #3\Z }%
}%
\def\XINT_gctf_loop_h #1#2%
{%
    \expandafter\XINT_gctf_loop_i\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_gctf_loop_i #1#2%
{%
    \expandafter\XINT_gctf_loop_j\expandafter {\expandafter{#2}#1}%
}%
\def\XINT_gctf_loop_j #1#2%
{%
    \expandafter\XINT_gctf_loop_a\expandafter {#2}#1%
}%
\def\XINT_gctf_end #1.#2#3#4#5{\xintrawwithzeros {#2/#3}[0]}%
%    \end{macrocode}
% \subsection{\csh{xintiGCtoF}}
%    \begin{macrocode}
\def\xintiGCtoF {\romannumeral0\xintigctof }%
\def\xintigctof #1%
{%
    \expandafter\XINT_igctf_prep \romannumeral-`0#1+\W/%
}%
\def\XINT_igctf_prep
{%
    \XINT_igctf_loop_a 1001%
}%
\def\XINT_igctf_loop_a #1#2#3#4#5+%
{%
    \expandafter\XINT_igctf_loop_b
    \romannumeral-`0#5.{#1}{#2}{#3}{#4}%
}%
\def\XINT_igctf_loop_b #1.#2#3#4#5%
{%
    \expandafter\XINT_igctf_loop_c\expandafter
    {\romannumeral0\xintiadd {#5}{\XINT_Mul {#1}{#3}}}%
    {\romannumeral0\xintiadd {#4}{\XINT_Mul {#1}{#2}}}%
    {#2}{#3}%
}%
\def\XINT_igctf_loop_c #1#2%
{%
    \expandafter\XINT_igctf_loop_f\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_igctf_loop_f #1#2#3#4/%
{%
    \xint_gob_til_W #4\XINT_igctf_end\W
    \expandafter\XINT_igctf_loop_g 
    \romannumeral-`0#4.{#2}{#3}#1%
}%
\def\XINT_igctf_loop_g #1.#2#3%
{%
    \expandafter\XINT_igctf_loop_h\expandafter
    {\romannumeral0\XINT_mul_fork #1\Z #3\Z }%
    {\romannumeral0\XINT_mul_fork #1\Z #2\Z }%
}%
\def\XINT_igctf_loop_h #1#2%
{%
    \expandafter\XINT_igctf_loop_i\expandafter {#2}{#1}%
}%
\def\XINT_igctf_loop_i #1#2#3#4%
{%
    \XINT_igctf_loop_a {#3}{#4}{#1}{#2}%
}%
\def\XINT_igctf_end #1.#2#3#4#5{\xintrawwithzeros {#4/#5}[0]}%
%    \end{macrocode}
% \subsection{\csh{xintCstoCv}}
%    \begin{macrocode}
\def\xintCstoCv {\romannumeral0\xintcstocv }%
\def\xintcstocv #1%
{%
    \expandafter\XINT_cstcv_prep \romannumeral-`0#1,\W,%
}%
\def\XINT_cstcv_prep
{%
    \XINT_cstcv_loop_a {}1001%
}%
\def\XINT_cstcv_loop_a #1#2#3#4#5#6,%
{%
    \xint_gob_til_W #6\XINT_cstcv_end\W
    \expandafter\XINT_cstcv_loop_b
    \romannumeral0\xintrawwithzeros {#6}.{#2}{#3}{#4}{#5}{#1}%
}%
\def\XINT_cstcv_loop_b #1/#2.#3#4#5#6%
{%
    \expandafter\XINT_cstcv_loop_c\expandafter
    {\romannumeral0\XINT_mul_fork #2\Z #4\Z }%
    {\romannumeral0\XINT_mul_fork #2\Z #3\Z }%
    {\romannumeral0\xintiadd {\XINT_Mul {#2}{#6}}{\XINT_Mul {#1}{#4}}}%
    {\romannumeral0\xintiadd {\XINT_Mul {#2}{#5}}{\XINT_Mul {#1}{#3}}}%
}%
\def\XINT_cstcv_loop_c #1#2%
{%
    \expandafter\XINT_cstcv_loop_d\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_cstcv_loop_d #1#2%
{%
    \expandafter\XINT_cstcv_loop_e\expandafter {\expandafter{#2}#1}%
}%
\def\XINT_cstcv_loop_e #1#2%
{%
    \expandafter\XINT_cstcv_loop_f\expandafter{#2}#1%
}%
\def\XINT_cstcv_loop_f #1#2#3#4#5%
{%
    \expandafter\XINT_cstcv_loop_g\expandafter 
    {\romannumeral0\xintrawwithzeros {#1/#2}}{#5}{#1}{#2}{#3}{#4}%
}%
\def\XINT_cstcv_loop_g #1#2{\XINT_cstcv_loop_a {#2{#1[0]}}}%
\def\XINT_cstcv_end #1.#2#3#4#5#6{ #6}%
%    \end{macrocode}
% \subsection{\csh{xintiCstoCv}}
%    \begin{macrocode}
\def\xintiCstoCv {\romannumeral0\xinticstocv }%
\def\xinticstocv #1%
{%
    \expandafter\XINT_icstcv_prep \romannumeral-`0#1,\W,%
}%
\def\XINT_icstcv_prep
{%
    \XINT_icstcv_loop_a {}1001%
}%
\def\XINT_icstcv_loop_a #1#2#3#4#5#6,%
{%
    \xint_gob_til_W #6\XINT_icstcv_end\W
    \expandafter
    \XINT_icstcv_loop_b \romannumeral-`0#6.{#2}{#3}{#4}{#5}{#1}%
}%
\def\XINT_icstcv_loop_b #1.#2#3#4#5%
{%
    \expandafter\XINT_icstcv_loop_c\expandafter
    {\romannumeral0\xintiadd {#5}{\XINT_Mul {#1}{#3}}}%
    {\romannumeral0\xintiadd {#4}{\XINT_Mul {#1}{#2}}}%
    {{#2}{#3}}%
}%
\def\XINT_icstcv_loop_c #1#2%
{%
    \expandafter\XINT_icstcv_loop_d\expandafter {#2}{#1}%
}%
\def\XINT_icstcv_loop_d #1#2%
{%
    \expandafter\XINT_icstcv_loop_e\expandafter
    {\romannumeral0\xintrawwithzeros {#1/#2}}{{#1}{#2}}%
}%
\def\XINT_icstcv_loop_e #1#2#3#4{\XINT_icstcv_loop_a {#4{#1[0]}}#2#3}%
\def\XINT_icstcv_end #1.#2#3#4#5#6{ #6}%
%    \end{macrocode}
% \subsection{\csh{xintGCtoCv}}
%    \begin{macrocode}
\def\xintGCtoCv {\romannumeral0\xintgctocv }%
\def\xintgctocv #1%
{%
    \expandafter\XINT_gctcv_prep \romannumeral-`0#1+\W/%
}%
\def\XINT_gctcv_prep
{%
    \XINT_gctcv_loop_a {}1001%
}%
\def\XINT_gctcv_loop_a #1#2#3#4#5#6+%
{%
    \expandafter\XINT_gctcv_loop_b
    \romannumeral0\xintrawwithzeros {#6}.{#2}{#3}{#4}{#5}{#1}%
}%
\def\XINT_gctcv_loop_b #1/#2.#3#4#5#6%
{%
    \expandafter\XINT_gctcv_loop_c\expandafter
    {\romannumeral0\XINT_mul_fork #2\Z #4\Z }%
    {\romannumeral0\XINT_mul_fork #2\Z #3\Z }%
    {\romannumeral0\xintiadd {\XINT_Mul {#2}{#6}}{\XINT_Mul {#1}{#4}}}%
    {\romannumeral0\xintiadd {\XINT_Mul {#2}{#5}}{\XINT_Mul {#1}{#3}}}%
}%
\def\XINT_gctcv_loop_c #1#2%
{%
    \expandafter\XINT_gctcv_loop_d\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_gctcv_loop_d #1#2%
{%
    \expandafter\XINT_gctcv_loop_e\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_gctcv_loop_e #1#2%
{%
    \expandafter\XINT_gctcv_loop_f\expandafter {#2}#1%
}%
\def\XINT_gctcv_loop_f #1#2%
{%
    \expandafter\XINT_gctcv_loop_g\expandafter
    {\romannumeral0\xintrawwithzeros {#1/#2}}{{#1}{#2}}%
}%
\def\XINT_gctcv_loop_g #1#2#3#4%
{%
    \XINT_gctcv_loop_h {#4{#1[0]}}{#2#3}%
}%
\def\XINT_gctcv_loop_h #1#2#3/%
{%
    \xint_gob_til_W #3\XINT_gctcv_end\W
    \expandafter\XINT_gctcv_loop_i
    \romannumeral0\xintrawwithzeros {#3}.#2{#1}%
}%
\def\XINT_gctcv_loop_i #1/#2.#3#4#5#6%
{%
    \expandafter\XINT_gctcv_loop_j\expandafter
    {\romannumeral0\XINT_mul_fork #1\Z #6\Z }%
    {\romannumeral0\XINT_mul_fork #1\Z #5\Z }%
    {\romannumeral0\XINT_mul_fork #2\Z #4\Z }%
    {\romannumeral0\XINT_mul_fork #2\Z #3\Z }%
}%
\def\XINT_gctcv_loop_j #1#2%
{%
    \expandafter\XINT_gctcv_loop_k\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_gctcv_loop_k #1#2%
{%
    \expandafter\XINT_gctcv_loop_l\expandafter {\expandafter{#2}#1}%
}%
\def\XINT_gctcv_loop_l #1#2%
{%
    \expandafter\XINT_gctcv_loop_m\expandafter {\expandafter{#2}#1}%
}%
\def\XINT_gctcv_loop_m #1#2{\XINT_gctcv_loop_a {#2}#1}%
\def\XINT_gctcv_end #1.#2#3#4#5#6{ #6}%
%    \end{macrocode}
% \subsection{\csh{xintiGCtoCv}}
%    \begin{macrocode}
\def\xintiGCtoCv {\romannumeral0\xintigctocv }%
\def\xintigctocv #1%
{%
    \expandafter\XINT_igctcv_prep \romannumeral-`0#1+\W/%
}%
\def\XINT_igctcv_prep
{%
    \XINT_igctcv_loop_a {}1001%
}%
\def\XINT_igctcv_loop_a #1#2#3#4#5#6+%
{%
    \expandafter\XINT_igctcv_loop_b
    \romannumeral-`0#6.{#2}{#3}{#4}{#5}{#1}%
}%
\def\XINT_igctcv_loop_b #1.#2#3#4#5%
{%
    \expandafter\XINT_igctcv_loop_c\expandafter
    {\romannumeral0\xintiadd {#5}{\XINT_Mul {#1}{#3}}}%
    {\romannumeral0\xintiadd {#4}{\XINT_Mul {#1}{#2}}}%
    {{#2}{#3}}%
}%
\def\XINT_igctcv_loop_c #1#2%
{%
    \expandafter\XINT_igctcv_loop_f\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_igctcv_loop_f #1#2#3#4/%
{%
    \xint_gob_til_W #4\XINT_igctcv_end_a\W
    \expandafter\XINT_igctcv_loop_g 
    \romannumeral-`0#4.#1#2{#3}%
}%
\def\XINT_igctcv_loop_g #1.#2#3#4#5%
{%
    \expandafter\XINT_igctcv_loop_h\expandafter
    {\romannumeral0\XINT_mul_fork #1\Z #5\Z }%
    {\romannumeral0\XINT_mul_fork #1\Z #4\Z }%
    {{#2}{#3}}%
}%
\def\XINT_igctcv_loop_h #1#2%
{%
    \expandafter\XINT_igctcv_loop_i\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_igctcv_loop_i #1#2{\XINT_igctcv_loop_k #2{#2#1}}%
\def\XINT_igctcv_loop_k #1#2%
{%
    \expandafter\XINT_igctcv_loop_l\expandafter
    {\romannumeral0\xintrawwithzeros {#1/#2}}%
}%
\def\XINT_igctcv_loop_l #1#2#3{\XINT_igctcv_loop_a {#3{#1[0]}}#2}%
\def\XINT_igctcv_end_a #1.#2#3#4#5%
{%
    \expandafter\XINT_igctcv_end_b\expandafter
    {\romannumeral0\xintrawwithzeros {#2/#3}}%
}%
\def\XINT_igctcv_end_b #1#2{ #2{#1[0]}}%
%    \end{macrocode}
% \subsection{\csh{xintCntoF}}
% \lverb|&
% Modified in 1.06 to give the N first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.|
%    \begin{macrocode}
\def\xintCntoF {\romannumeral0\xintcntof }%
\def\xintcntof #1%
{%
    \expandafter\XINT_cntf\expandafter {\the\numexpr #1}%
}%
\def\XINT_cntf #1#2%
{%
   \ifnum #1>\xint_c_
      \xint_afterfi {\expandafter\XINT_cntf_loop\expandafter 
                     {\the\numexpr #1-1\expandafter}\expandafter
                     {\romannumeral-`0#2{#1}}{#2}}%
   \else
      \xint_afterfi 
         {\ifnum #1=\xint_c_
              \xint_afterfi {\expandafter\space \romannumeral-`0#2{0}}%
          \else \xint_afterfi { 0/1[0]}%
          \fi}%
   \fi
}%
\def\XINT_cntf_loop #1#2#3%
{%
    \ifnum #1>\xint_c_ \else \XINT_cntf_exit \fi
    \expandafter\XINT_cntf_loop\expandafter
    {\the\numexpr #1-1\expandafter }\expandafter
    {\romannumeral0\xintadd {\xintDiv {1[0]}{#2}}{#3{#1}}}%
    {#3}%
}%
\def\XINT_cntf_exit \fi 
    \expandafter\XINT_cntf_loop\expandafter
    #1\expandafter #2#3%
{%
    \fi\xint_gobble_ii #2%
}%
%    \end{macrocode}
% \subsection{\csh{xintGCntoF}}
% \lverb|&
% Modified in 1.06 to give the N first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.|
%    \begin{macrocode}
\def\xintGCntoF {\romannumeral0\xintgcntof }%
\def\xintgcntof #1%
{%
    \expandafter\XINT_gcntf\expandafter {\the\numexpr #1}%
}%
\def\XINT_gcntf #1#2#3%
{%
   \ifnum #1>\xint_c_
      \xint_afterfi {\expandafter\XINT_gcntf_loop\expandafter 
                     {\the\numexpr #1-1\expandafter}\expandafter
                     {\romannumeral-`0#2{#1}}{#2}{#3}}%
   \else
      \xint_afterfi 
         {\ifnum #1=\xint_c_
              \xint_afterfi {\expandafter\space\romannumeral-`0#2{0}}%
          \else \xint_afterfi { 0/1[0]}%
          \fi}%
   \fi
}%
\def\XINT_gcntf_loop #1#2#3#4%
{%
    \ifnum #1>\xint_c_ \else \XINT_gcntf_exit \fi
    \expandafter\XINT_gcntf_loop\expandafter
    {\the\numexpr #1-1\expandafter }\expandafter
    {\romannumeral0\xintadd {\xintDiv {#4{#1}}{#2}}{#3{#1}}}%
    {#3}{#4}%
}%
\def\XINT_gcntf_exit \fi 
    \expandafter\XINT_gcntf_loop\expandafter
    #1\expandafter #2#3#4%
{%
    \fi\xint_gobble_ii #2%
}%
%    \end{macrocode}
% \subsection{\csh{xintCntoCs}}
% \lverb|&
% Modified in 1.06 to give the N first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.|
%    \begin{macrocode}
\def\xintCntoCs {\romannumeral0\xintcntocs }%
\def\xintcntocs #1%
{%
    \expandafter\XINT_cntcs\expandafter {\the\numexpr #1}%
}%
\def\XINT_cntcs #1#2%
{%
   \ifnum #1<0
      \xint_afterfi { 0/1[0]}%
   \else       
      \xint_afterfi {\expandafter\XINT_cntcs_loop\expandafter 
                     {\the\numexpr #1-1\expandafter}\expandafter
                     {\expandafter{\romannumeral-`0#2{#1}}}{#2}}%
   \fi
}%
\def\XINT_cntcs_loop #1#2#3%
{%
    \ifnum #1>-1 \else \XINT_cntcs_exit \fi
    \expandafter\XINT_cntcs_loop\expandafter
    {\the\numexpr #1-1\expandafter }\expandafter 
    {\expandafter{\romannumeral-`0#3{#1}},#2}{#3}%
}%
\def\XINT_cntcs_exit \fi 
    \expandafter\XINT_cntcs_loop\expandafter
    #1\expandafter #2#3%
{%
    \fi\XINT_cntcs_exit_b #2%
}%
\def\XINT_cntcs_exit_b #1,{ }%
%    \end{macrocode}
% \subsection{\csh{xintCntoGC}}
% \lverb|&
% Modified in 1.06 to give the N first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.|
%    \begin{macrocode}
\def\xintCntoGC {\romannumeral0\xintcntogc }%
\def\xintcntogc #1%
{%
    \expandafter\XINT_cntgc\expandafter {\the\numexpr #1}%
}%
\def\XINT_cntgc #1#2%
{%
   \ifnum #1<0
      \xint_afterfi { 0/1[0]}%
   \else       
      \xint_afterfi {\expandafter\XINT_cntgc_loop\expandafter 
                     {\the\numexpr #1-1\expandafter}\expandafter
                     {\expandafter{\romannumeral-`0#2{#1}}}{#2}}%
   \fi
}%
\def\XINT_cntgc_loop #1#2#3%
{%
    \ifnum #1>-1 \else \XINT_cntgc_exit \fi
    \expandafter\XINT_cntgc_loop\expandafter
    {\the\numexpr #1-1\expandafter }\expandafter 
    {\expandafter{\romannumeral-`0#3{#1}}+1/#2}{#3}%
}%
\def\XINT_cntgc_exit \fi 
    \expandafter\XINT_cntgc_loop\expandafter
    #1\expandafter #2#3%
{%
    \fi\XINT_cntgc_exit_b #2%
}%
\def\XINT_cntgc_exit_b #1+1/{ }%
%    \end{macrocode}
% \subsection{\csh{xintGCntoGC}}
% \lverb|&
% Modified in 1.06 to give the N first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.|
%    \begin{macrocode}
\def\xintGCntoGC {\romannumeral0\xintgcntogc }%
\def\xintgcntogc #1%
{%
    \expandafter\XINT_gcntgc\expandafter {\the\numexpr #1}%
}%
\def\XINT_gcntgc #1#2#3%
{%
   \ifnum #1<0
      \xint_afterfi { {0/1[0]}}%
   \else       
      \xint_afterfi {\expandafter\XINT_gcntgc_loop\expandafter 
                     {\the\numexpr #1-1\expandafter}\expandafter
                     {\expandafter{\romannumeral-`0#2{#1}}}{#2}{#3}}%
   \fi
}%
\def\XINT_gcntgc_loop #1#2#3#4%
{%
    \ifnum #1>-1 \else \XINT_gcntgc_exit \fi
    \expandafter\XINT_gcntgc_loop_b\expandafter
    {\expandafter{\romannumeral-`0#4{#1}}/#2}{#3{#1}}{#1}{#3}{#4}%
}%
\def\XINT_gcntgc_loop_b #1#2#3%
{%
    \expandafter\XINT_gcntgc_loop\expandafter
    {\the\numexpr #3-1\expandafter}\expandafter
    {\expandafter{\romannumeral-`0#2}+#1}%
}%
\def\XINT_gcntgc_exit \fi
    \expandafter\XINT_gcntgc_loop_b\expandafter #1#2#3#4#5%
{%
    \fi\XINT_gcntgc_exit_b #1%
}%
\def\XINT_gcntgc_exit_b #1/{ }%
%    \end{macrocode}
% \subsection{\csh{xintCstoGC}}
%    \begin{macrocode}
\def\xintCstoGC {\romannumeral0\xintcstogc }%
\def\xintcstogc #1%
{%
    \expandafter\XINT_cstc_prep \romannumeral-`0#1,\W,%
}%
\def\XINT_cstc_prep #1,{\XINT_cstc_loop_a {{#1}}}%
\def\XINT_cstc_loop_a #1#2,%
{%
    \xint_gob_til_W #2\XINT_cstc_end\W
    \XINT_cstc_loop_b {#1}{#2}%
}%
\def\XINT_cstc_loop_b #1#2{\XINT_cstc_loop_a {#1+1/{#2}}}%
\def\XINT_cstc_end\W\XINT_cstc_loop_b #1#2{ #1}%
%    \end{macrocode}
% \subsection{\csh{xintGCtoGC}}
%    \begin{macrocode}
\def\xintGCtoGC {\romannumeral0\xintgctogc }%
\def\xintgctogc #1%
{%
    \expandafter\XINT_gctgc_start \romannumeral-`0#1+\W/%
}%
\def\XINT_gctgc_start {\XINT_gctgc_loop_a {}}%
\def\XINT_gctgc_loop_a #1#2+#3/%
{%
    \xint_gob_til_W #3\XINT_gctgc_end\W
    \expandafter\XINT_gctgc_loop_b\expandafter
    {\romannumeral-`0#2}{#3}{#1}%
}%
\def\XINT_gctgc_loop_b #1#2%
{%
    \expandafter\XINT_gctgc_loop_c\expandafter
    {\romannumeral-`0#2}{#1}%
}%
\def\XINT_gctgc_loop_c #1#2#3%
{%
    \XINT_gctgc_loop_a {#3{#2}+{#1}/}%
}%
\def\XINT_gctgc_end\W\expandafter\XINT_gctgc_loop_b
{%
    \expandafter\XINT_gctgc_end_b
}%
\def\XINT_gctgc_end_b #1#2#3{ #3{#1}}%
\XINT_cfrac_restorecatcodes_endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xintcfrac>\relax
%\def<*xintexpr>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xintcfrac>
%<*xintexpr>
% \section{Package \xintexprname implementation}
% 
% The commenting is currently (\docdate) very sparse. I was greatly helped in
% the task of writing this expandable parser by the comments provided in
% |l3fp-parse.dtx|. One will recognize in particular the idea of the `until'
% macros; but I  have not looked into the actual |l3fp| code beyond the very
% useful comments provided in its documentation. My main hurdle was that my data
% has no a priori bound on its size; this led me to experiment with a technique
% of storing and retrieving data expandably as \emph{names} of control
% sequences. Also brace pairs have a special rôle related to the parsing of
% |A/B[n]| fractions; this is \emph{experimental} and perhaps I will opt for
% another solution at a later stage, 
% for example one where such fractions should be user-prefixed by some marker,
% for example |!| (which could not be confused there with its other use as
% postfix symbol for the factorial function). There are thus some essential
% differences of principle with the |l3fp| workplan. Of course, my task was
% on the other hand simplified by the fact that I do not implement boolean
% operators nor function names. To circumvent the potential hash-table impact I
% have provided the macro creators |\xintNewExpr| and |\xintNewFloatExpr|.
%
% Version |1.08b| tries to correct a problem originating in the attempt to
% attribute a special rôle to braces: expansion could be stopped by space
% tokens,  as various macros tried to expand without grabbing what came next.
% They now have a doubled |\romannumeral-`0|.
%
% \localtableofcontents
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
%
% The code for reload detection is copied from \textsc{Heiko
% Oberdiek}'s packages, and adapted here to check for previous
% loading of the \xintfracname package.
%
% The method for catcodes is slightly different, but still
% directly inspired by these packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \def\space { }%
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xintexpr.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xintfrac.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintexpr}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintexpr.sty
      \ifx\w\relax % but xintfrac.sty not yet loaded.
         \y{xintexpr}{Package xintfrac is required}%
         \y{xintexpr}{Will try \string\input\space xintfrac.sty}%
         \def\z{\endgroup\input xintfrac.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xintfrac.sty not yet loaded.
            \y{xintexpr}{Package xintfrac is required}%
            \y{xintexpr}{Will try \string\RequirePackage{xintfrac}}%
            \def\z{\endgroup\RequirePackage{xintfrac}}%
          \fi
      \else
        \y{xintexpr}{I was already loaded, aborting input}%
        \aftergroup\endinput
      \fi
    \fi
  \fi
\z%
%    \end{macrocode}
% \subsection{Confirmation of \xintfracname loading}
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \def\empty {}%
  \expandafter\let\expandafter\w\csname ver@xintfrac.sty\endcsname
  \ifx\w\relax % Plain TeX, user gave a file name at the prompt
      \y{xintexpr}{Loading of package xintfrac failed, aborting input}%
      \aftergroup\endinput
  \fi
  \ifx\w\empty % LaTeX, user gave a file name at the prompt
      \y{xintexpr}{Loading of package xintfrac failed, aborting input}%
      \aftergroup\endinput
  \fi
\endgroup%
%    \end{macrocode}
% \subsection{Catcodes}
%
% Perhaps catcodes have changed after the loading of \xintname and
% \xintfracname and prior to the current loading of \xintexprname, 
% so we can not employ the |\XINT_restorecatcodes_endinput| in this style 
% file. But there is no problem using |\XINT_setcatcodes|.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode95=11   % _
  \def\x
  {%
      \endgroup
      \edef\XINT_expr_restorecatcodes_endinput
      {%
        \catcode33=\the\catcode33   % !
        \catcode93=\the\catcode93   % ]
        \catcode91=\the\catcode91   % [
        \catcode94=\the\catcode94   % ^
        \catcode96=\the\catcode96   % `
        \catcode47=\the\catcode47   % /
        \catcode41=\the\catcode41   % )
        \catcode40=\the\catcode40   % (
        \catcode42=\the\catcode42   % *
        \catcode43=\the\catcode43   % +
        \catcode62=\the\catcode62   % >
        \catcode60=\the\catcode60   % <
        \catcode58=\the\catcode58   % :
        \catcode46=\the\catcode46   % .
        \catcode45=\the\catcode45   % -
        \catcode44=\the\catcode44   % ,
        \catcode35=\the\catcode35   % #
        \catcode95=\the\catcode95   % _
        \catcode125=\the\catcode125 % }
        \catcode123=\the\catcode123 % {
        \endlinechar=\the\endlinechar
        \catcode13=\the\catcode13   % ^^M
        \catcode32=\the\catcode32   % 
        \catcode61=\the\catcode61\relax   % =
        \noexpand\endinput
      }%
      \XINT_setcatcodes % defined in xint.sty
      \catcode91=12 % [
      \catcode93=12 % ]
      \catcode33=11 % !
  }%
\x
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\begingroup
  \catcode64=11 % @
  \catcode58=12 % :
  \expandafter\ifx\csname ProvidesPackage\endcsname\relax
    \def\x#1#2#3[#4]{\endgroup
      \immediate\write-1{Package: #3 #4}%
      \xdef#1{#4}%
    }%
  \else
    \def\x#1#2[#3]{\endgroup
      #2[{#3}]%
      \ifx#1\@undefined
        \xdef#1{#3}%
      \fi
      \ifx#1\relax
        \xdef#1{#3}%
      \fi
    }%
  \fi
\expandafter\x\csname ver@xintexpr.sty\endcsname
\ProvidesPackage{xintexpr}%
  [2013/06/14 v1.08b Expandable expression parser (jfB)]%
%    \end{macrocode}
% \subsection{Helper macros}
%    \begin{macrocode}
\def\xint_gob_til_dot #1.{}%
\def\xint_gob_til_dot_andstop #1.{ }%
\def\xint_gob_til_! #1!{}% ! of catcode 11
\def\XINT_expr_string {\expandafter\xint_gob_til_dot\string }%
\def\XINT_expr_unexpectedtoken {\xintError:ignored }% 
%    \end{macrocode}
% \subsection{\csh{xintexpr},~\csh{xinttheexpr},~\csh{xintthe}}
%    \begin{macrocode}
\def\xintexpr {\romannumeral0\xinteval }%
\def\xinteval
{%
    \expandafter\XINT_expr_until_end\romannumeral-`0%
    \expandafter\XINT_expr_checkifprefix_ii\romannumeral-`0%
    \XINT_expr_getnext
}%
\def\xinttheexpr {\romannumeral0\xinttheeval }%
\def\xinttheeval {\expandafter\XINT_expr_the\romannumeral0\xinteval }%
\def\XINT_expr_the #1#2#3{\xintraw{\XINT_expr_string #3}}% 
\def\xintthe #1{\ifx#1\xintexpr \expandafter\xinttheexpr
                \else\expandafter\xintthefloatexpr\fi}%
%    \end{macrocode}
% \subsection{Parenthesized expressions}
%    \begin{macrocode}
\def\XINT_expr_until_end #1%
{%
    \ifcase#1%
          \expandafter\xint_gobble_vi
    \or   
          \expandafter\XINT_expr_extra_closing_paren
    \fi
    \expandafter\XINT_expr_until_end\romannumeral-`0\romannumeral-`0%
}%
\def\XINT_expr_extra_closing_paren {\xintError:removed }%
\def\XINT_expr_endofexpr {!\XINT_illegaluse }%
\def\XINT_illegaluse
   {Illegal_here_use_xintthe\xintError:use_xintthe!\xint_gobble_i }%
\def\XINT_expr_oparen
{%
    \expandafter\XINT_expr_until_cparen\romannumeral-`0%
    \expandafter\XINT_expr_checkifprefix_ii\romannumeral-`0%
    \XINT_expr_getnext
}%    
\def\XINT_expr_until_cparen #1%
{%
    \ifcase#1%
          \expandafter\XINT_expr_missing_cparen
    \or 
    \else \xint_afterfi
    {\expandafter\XINT_expr_until_cparen\romannumeral-`0\romannumeral-`0}%
    \fi
}%
\def\XINT_expr_missing_cparen #1%
{%
    \xintError:inserted \xint_c_ \XINT_expr_endofexpr 
}%
%    \end{macrocode}
% \subsection{Infix operators, minus as prefix, scientific notation}
%    \begin{macrocode}
\def\xint_tmp_def #1#2#3%
{%
    \expandafter\xint_tmp_do_defs
    \csname XINT_expr_op_#1\expandafter\endcsname
    \csname XINT_expr_until_#1\expandafter\endcsname
    \csname XINT_expr_checkifprefix_#2\expandafter\endcsname 
    \csname XINT_expr_precedence_#1\expandafter\endcsname
    \csname xint_c_#2\expandafter\endcsname
    \csname xint#3\endcsname
}%
\def\xint_tmp_do_defs #1#2#3#4#5#6%
{%
    \def #1##1% \XINT_expr_op_?
    {%
        \expandafter #2\expandafter ##1\romannumeral-`0\expandafter
        #3\romannumeral-`0\XINT_expr_getnext 
    }%
    \def #2##1##2##3##4% \XINT_expr_until_?
    {%
      \ifnum ##2>#5%
        \xint_afterfi {\expandafter #2\expandafter ##1\romannumeral-`0##3##4}%
      \else
        \xint_afterfi 
        {\expandafter ##2\expandafter ##3%
         \csname .#6{\XINT_expr_string ##1}{\XINT_expr_string ##4}\endcsname }%
      \fi
    }%
    \let #4#5%
}%
\xint_tmp_def +{ii}{Add}%
\xint_tmp_def -{ii}{Sub}%
\xint_tmp_def *{iii}{Mul}%
\xint_tmp_def /{iii}{Div}%
\xint_tmp_def ^{iv}{Pow}%
\xint_tmp_def  e{v}{fE}%
\xint_tmp_def  E{v}{fE}%
\def\xint_tmp_def #1%
{%
    \expandafter\xint_tmp_do_defs
    \csname XINT_expr_checkifprefix_#1\expandafter\endcsname
    \csname XINT_expr_op_-#1\endcsname
}%
\def\xint_tmp_do_defs #1#2%
{%
    \def #1##1%
    {\xint_UDsignfork
        ##1\dummy #2%
          -\dummy ##1%
     \krof }%
}%
\xint_tmp_def {ii}%
\xint_tmp_def {iii}%
\xint_tmp_def {iv}%
\xint_tmp_def {v}%
\def\xint_tmp_def #1%
{%
    \expandafter\xint_tmp_do_defs
    \csname XINT_expr_op_-#1\expandafter\endcsname
    \csname XINT_expr_until_-#1\expandafter\endcsname
    \csname XINT_expr_checkifprefix_#1\expandafter\endcsname
    \csname xint_c_#1\endcsname
}%
\def\xint_tmp_do_defs #1#2#3#4%
{%
    \def #1% \XINT_expr_op_-ii,iii,iv,v
    {%
        \expandafter #2\romannumeral-`0\expandafter
        #3\romannumeral-`0\XINT_expr_getnext 
    }%
    \def #2##1##2##3% \XINT_expr_until_-ii,iii,iv,v
    {%
        \ifnum ##1>#4%
         \xint_afterfi {\expandafter #2\romannumeral-`0##2##3}%
        \else
         \xint_afterfi {\expandafter ##1\expandafter ##2%
                        \csname .\xintOpp{\XINT_expr_string ##3}\endcsname }%
        \fi
    }%
}%
\xint_tmp_def {ii}%
\xint_tmp_def {iii}%
\xint_tmp_def {iv}%
\xint_tmp_def {v}%
%    \end{macrocode}
% \subsection{Get next infix operator or closing parenthesis or factorial or
% expression end}
% \lverb|June 14 (1.08b): I add here a second \romannumeral-`0, as in
% \XINT_expr_getnext and other macros which are trying to expand the next token
% but without grabbing it.|
%    \begin{macrocode}
\def\XINT_expr_getop #1%
{%
    \expandafter\XINT_expr_getop_a\expandafter #1%
    \romannumeral-`0\romannumeral-`0%
}%
\def\XINT_expr_getop_a #1#2%
{%
    \ifcat #2\relax
        \ifx #2\relax 
             \expandafter\expandafter\expandafter
             \XINT_expr_foundendofexpr
        \else
             \XINT_expr_unexpectedtoken
             \expandafter\expandafter\expandafter
             \XINT_expr_getop
        \fi
    \else               
        \expandafter\XINT_expr_op_found\expandafter #2%
    \fi
    #1%
}%
\def\XINT_expr_foundendofexpr {\xint_c_ \XINT_expr_endofexpr }%
\def\XINT_expr_op_found #1%
{%
    \ifcsname XINT_expr_precedence_\string #1\endcsname
        \expandafter\xint_afterfi\expandafter 
        {\csname XINT_expr_precedence_\string #1\expandafter\endcsname
         \csname XINT_expr_op_\string #1\endcsname }%
    \else
        \XINT_expr_unexpectedtoken
        \expandafter\XINT_expr_getop
    \fi
}%
\expandafter\let\csname XINT_expr_precedence_)\endcsname \xint_c_i
\expandafter\let\csname XINT_expr_op_)\endcsname\XINT_expr_getop
\def\xint_tmp_def
{%  
    \expandafter\xint_tmp_do_defs
    \csname XINT_expr_precedence_!\expandafter\endcsname
    \csname XINT_expr_op_!\endcsname
}%
\def\xint_tmp_do_defs #1#2%
{%
    \def #1##1##2%
    {\ifx ##1#2%
         \expandafter\xint_firstoftwo
    \else\expandafter\xint_secondoftwo
    \fi{\expandafter\XINT_expr_getop}{\expandafter\XINT_flexpr_getop}%
    \csname .\xintFac{\XINT_expr_string ##2}/1[0]\endcsname }%
    \let#2\empty
}%
\xint_tmp_def
%    \end{macrocode}
% \subsection{Get next opening parenthesis or minus prefix or decimal number or
% braced fraction or sub-xintexpression}
% \lverb|June 14: 1.08b adds a second \romannumeral-`0 to \XINT_expr_getnext in
% an attempt to solve a problem with space tokens stopping the \romannumeral
% and thus preventing expansion of the following token. For example: 1+
% \the\cnta caused a problem, as `\the' was not expanded. I did not define
% \XINT_expr_getnext as a macro with parameter (which would have cured
% preventively this), precisely to try to recognize brace pairs. The second
% \romannumeral-`0 is added here for the same reason in other places:
% \XINT_expr_scannum_intpart_b, \XINT_expr_scannum_transition,
% \XINT_expr_scannum_decpart_b, and \XINT_expr_getop.|  
%    \begin{macrocode}
\def\XINT_expr_getnext 
{%
    \expandafter\XINT_expr_getnext_checkforbraced_a
    \romannumeral-`0\romannumeral-`0%
}%
\def\XINT_expr_getnext_checkforbraced_a #1%
{%
    \XINT_expr_getnext_checkforbraced_b #1\W\Z {#1}%
}%
\def\XINT_expr_getnext_checkforbraced_b #1#2%
{%
    \xint_UDwfork
       #1\dummy \XINT_expr_getnext_emptybracepair
       #2\dummy \XINT_expr_getnext_onetoken_perhaps
       \W\dummy \XINT_expr_getnext_gotbracedstuff
    \krof
}%
\def\XINT_expr_getnext_onetoken_perhaps\Z #1%
{%
    \expandafter\XINT_expr_getnext_checkforbraced_c\expandafter
    {\romannumeral-`0#1}%
}%
\def\XINT_expr_getnext_checkforbraced_c #1%
{%
    \XINT_expr_getnext_checkforbraced_d #1\W\Z {#1}%
}%
\def\XINT_expr_getnext_checkforbraced_d #1#2%
{%
    \xint_UDwfork
       #1\dummy \XINT_expr_getnext_emptybracepair
       #2\dummy \XINT_expr_getnext_onetoken_wehope
       \W\dummy \XINT_expr_getnext_gotbracedstuff
    \krof
}%
\def\XINT_expr_getnext_emptybracepair #1{\XINT_expr_getnext }%
\def\XINT_expr_getnext_gotbracedstuff #1\W\Z #2%
{%
    \expandafter\XINT_expr_getop\csname .#2\endcsname
}%
\def\XINT_expr_getnext_onetoken_wehope\Z #1%
{%
    \xint_gob_til_! #1\XINT_expr_subexpr !%
    \expandafter\XINT_expr_getnext_onetoken_fork\string #1%
}%
\def\XINT_expr_subexpr !#1!{\expandafter\XINT_expr_getop\xint_gobble_i }%
\begingroup
\lccode`*=`_
\lowercase{\endgroup
\def\XINT_expr_sixwayfork #1(-.+*\dummy #2#3\krof {#2}%
\def\XINT_expr_getnext_onetoken_fork #1%
{%
    \XINT_expr_sixwayfork
        #1-.+*\dummy   \XINT_expr_oparen
        (#1.+*\dummy   -%
        (-#1+*\dummy  {\XINT_expr_scannum_start\XINT_expr_scannum_decpart_b.}%
        (-.#1*\dummy   \XINT_expr_getnext%
         (-.+#1\dummy {\XINT_expr_scannum_start\XINT_expr_scannum_decpart_b*}%
         (-.+*\dummy  {\XINT_expr_scannum_check #1}%
    \krof
}}%
\def\XINT_expr_scannum_check #1%
{%
    \ifnum \xint_c_ix<1#1 
        \expandafter\XINT_expr_scannum_start
    \else
        \xint_afterfi{\XINT_expr_unexpectedtoken
                      \expandafter\XINT_expr_getnext\xint_gobble_ii}%
    \fi \XINT_expr_scannum_intpart_b #1%
}%
\def\XINT_expr_scannum_stopscan {!}% ! catcode 11
\def\XINT_expr_gathernum #1!%        ! with catcode 11 
{%
    \expandafter\space\csname .#1\endcsname
}%
\def\XINT_expr_scannum_start #1%
{%
    \expandafter\XINT_expr_getop
    \romannumeral-`0\expandafter\XINT_expr_gathernum
    \romannumeral-`0#1%
}%
\def\XINT_expr_scannum_intpart_a #1%
{%
    \ifnum \xint_c_ix<1\string#1
       \expandafter\expandafter\expandafter
          \XINT_expr_scannum_intpart_b
       \expandafter\string
    \else
       \if #1.% 
           \expandafter\expandafter\expandafter
           \XINT_expr_scannum_transition
       \else
           \expandafter\expandafter\expandafter
           \XINT_expr_scannum_stopscan
       \fi
    \fi
    #1%
}%
\def\XINT_expr_scannum_intpart_b #1%
{%
    \expandafter #1\romannumeral-`0\expandafter
    \XINT_expr_scannum_intpart_a\romannumeral-`0\romannumeral-`0%
}%
\def\XINT_expr_scannum_transition #1%
{%
    \expandafter.\romannumeral-`0\expandafter
    \XINT_expr_scannum_decpart_a\romannumeral-`0\romannumeral-`0%
}%
\def\XINT_expr_scannum_decpart_a #1%
{%
    \ifnum \xint_c_ix<1\string#1
       \expandafter\expandafter\expandafter
       \XINT_expr_scannum_decpart_b\expandafter\string
    \else
       \expandafter \XINT_expr_scannum_stopscan
    \fi
    #1%
}%
\def\XINT_expr_scannum_decpart_b #1%
{%
    \expandafter #1\romannumeral-`0\expandafter
    \XINT_expr_scannum_decpart_a\romannumeral-`0\romannumeral-`0%
}%
%    \end{macrocode}
% \subsection{\csh{xintfloatexpr},~\csh{xintthefloatexpr}}
% \lverb|1.08b: various doublings of \romannumeral-`0 to avoid some
% expansion/space token problems|
%    \begin{macrocode}
\def\xintfloatexpr {\romannumeral0\xintfloateval }%
\def\xintfloateval
{%
    \expandafter\XINT_expr_until_end\romannumeral-`0%
    \expandafter\XINT_flexpr_checkifprefix_ii\romannumeral-`0%
    \XINT_flexpr_getnext
}%
\def\xintthefloatexpr {\romannumeral0\xintthefloateval }%
\def\xintthefloateval 
    {\expandafter\XINT_flexpr_the\romannumeral0\xintfloateval }%
\def\XINT_flexpr_the #1#2#3{\xintfloat{\XINT_expr_string #3}}% 
\def\XINT_flexpr_oparen
{%
    \expandafter\XINT_expr_until_cparen\romannumeral-`0%
    \expandafter\XINT_flexpr_checkifprefix_ii\romannumeral-`0%
    \XINT_flexpr_getnext
}%    
\def\xint_tmp_def #1#2#3%
{%
    \expandafter\xint_tmp_do_defs
    \csname XINT_flexpr_op_#1\expandafter\endcsname
    \csname XINT_flexpr_until_#1\expandafter\endcsname
    \csname XINT_flexpr_checkifprefix_#2\expandafter\endcsname 
    \csname XINT_expr_precedence_#1\expandafter\endcsname
    \csname xint_c_#2\expandafter\endcsname
    \csname XINTinFloat#3\endcsname
}%
\def\xint_tmp_do_defs #1#2#3#4#5#6%
{%
    \def #1##1% \XINT_flexpr_op_?
    {%
        \expandafter #2\expandafter ##1\romannumeral-`0\expandafter
        #3\romannumeral-`0\XINT_flexpr_getnext 
    }%
    \def #2##1##2##3##4% \XINT_flexpr_until_?
    {%
      \ifnum ##2>#5%
        \xint_afterfi {\expandafter #2\expandafter ##1\romannumeral-`0##3##4}%
      \else
        \xint_afterfi 
        {\expandafter ##2\expandafter ##3%
         \csname .#6{\XINT_expr_string ##1}%
                    {\XINT_expr_string ##4}\endcsname }%
      \fi
    }%
}%
\xint_tmp_def +{ii}{Add}%
\xint_tmp_def -{ii}{Sub}%
\xint_tmp_def *{iii}{Mul}%
\xint_tmp_def /{iii}{Div}%
\xint_tmp_def ^{iv}{Power}%
\xint_tmp_def  e{v}{fE}%
\xint_tmp_def  E{v}{fE}%
\def\xint_tmp_def #1%
{%
    \expandafter\xint_tmp_do_defs
    \csname XINT_flexpr_checkifprefix_#1\expandafter\endcsname
    \csname XINT_flexpr_op_-#1\endcsname
}%
\def\xint_tmp_do_defs #1#2%
{%
    \def #1##1%
    {\xint_UDsignfork
        ##1\dummy #2%
          -\dummy ##1%
     \krof }%
}%
\xint_tmp_def {ii}%
\xint_tmp_def {iii}%
\xint_tmp_def {iv}%
\xint_tmp_def {v}%
\def\xint_tmp_def #1%
{%
    \expandafter\xint_tmp_do_defs
    \csname XINT_flexpr_op_-#1\expandafter\endcsname
    \csname XINT_expr_until_-#1\expandafter\endcsname
    \csname XINT_flexpr_checkifprefix_#1\expandafter\endcsname
    \csname xint_c_#1\endcsname
}%
\def\xint_tmp_do_defs #1#2#3#4%
{%
    \def #1% \XINT_flexpr_op_-ii,iii,iv,v
    {%
        \expandafter #2\romannumeral-`0\expandafter
        #3\romannumeral-`0\XINT_flexpr_getnext 
    }%
}%
\xint_tmp_def {ii}%
\xint_tmp_def {iii}%
\xint_tmp_def {iv}%
\xint_tmp_def {v}%
\let\xint_tmp_def\empty
\let\xint_tmp_do_defs\empty
\def\XINT_flexpr_getop #1%
{%
    \expandafter\XINT_flexpr_getop_a\expandafter #1%
    \romannumeral-`0\romannumeral-`0%
}%
\def\XINT_flexpr_getop_a #1#2%
{%
    \ifcat #2\relax
        \ifx #2\relax 
             \expandafter\expandafter\expandafter
             \XINT_expr_foundendofexpr
        \else
             \XINT_expr_unexpectedtoken
             \expandafter\expandafter\expandafter
             \XINT_flexpr_getop
        \fi
    \else               
        \expandafter\XINT_flexpr_op_found\expandafter #2%
    \fi
    #1%
}%
\def\XINT_flexpr_op_found #1%
{%
    \ifcsname XINT_expr_precedence_\string #1\endcsname
        \expandafter\xint_afterfi\expandafter 
        {\csname XINT_expr_precedence_\string #1\expandafter\endcsname
         \csname XINT_flexpr_op_\string #1\endcsname }%
    \else
        \XINT_expr_unexpectedtoken
        \expandafter\XINT_flexpr_getop
    \fi
}%
\expandafter\let\csname XINT_flexpr_op_)\endcsname\XINT_flexpr_getop
\def\XINT_flexpr_getnext 
{%
    \expandafter\XINT_flexpr_getnext_checkforbraced_a
    \romannumeral-`0\romannumeral-`0%
}%
\def\XINT_flexpr_getnext_checkforbraced_a #1%
{%
    \XINT_flexpr_getnext_checkforbraced_b #1\W\Z {#1}%
}%
\def\XINT_flexpr_getnext_checkforbraced_b #1#2%
{%
    \xint_UDwfork
       #1\dummy \XINT_flexpr_getnext_emptybracepair
       #2\dummy \XINT_flexpr_getnext_onetoken_perhaps
       \W\dummy \XINT_flexpr_getnext_gotbracedstuff
    \krof
}%
\def\XINT_flexpr_getnext_onetoken_perhaps\Z #1%
{%
    \expandafter\XINT_flexpr_getnext_checkforbraced_c\expandafter
    {\romannumeral-`0#1}%
}%
\def\XINT_flexpr_getnext_checkforbraced_c #1%
{%
    \XINT_flexpr_getnext_checkforbraced_d #1\W\Z {#1}%
}%
\def\XINT_flexpr_getnext_checkforbraced_d #1#2%
{%
    \xint_UDwfork
       #1\dummy \XINT_flexpr_getnext_emptybracepair
       #2\dummy \XINT_flexpr_getnext_onetoken_wehope
       \W\dummy \XINT_flexpr_getnext_gotbracedstuff
    \krof
}%
\def\XINT_flexpr_getnext_emptybracepair #1{\XINT_flexpr_getnext }%
\def\XINT_flexpr_getnext_gotbracedstuff #1\W\Z #2%
{%
    \expandafter\XINT_flexpr_getop\csname .#2\endcsname
}%
\def\XINT_flexpr_getnext_onetoken_wehope\Z #1%
{%
    \xint_gob_til_! #1\XINT_flexpr_subexpr !%
    \expandafter\XINT_flexpr_getnext_onetoken_fork\string #1%
}%
\def\XINT_flexpr_subexpr !#1!{\expandafter\XINT_flexpr_getop\xint_gobble_i }%
\begingroup
\lccode`*=`_
\lowercase{\endgroup
\def\XINT_flexpr_getnext_onetoken_fork #1%
{%
    \XINT_expr_sixwayfork
      #1-.+*\dummy   \XINT_flexpr_oparen
      (#1.+*\dummy   -%
      (-#1+*\dummy  {\XINT_flexpr_scannum_start\XINT_expr_scannum_decpart_b.}%
      (-.#1*\dummy   \XINT_flexpr_getnext%
      (-.+#1\dummy  {\XINT_flexpr_scannum_start\XINT_expr_scannum_decpart_b*}%
      (-.+*\dummy   {\XINT_flexpr_scannum_check #1}%
    \krof
}}%
\def\XINT_flexpr_scannum_check #1%
{%
    \ifnum \xint_c_ix<1#1 
        \expandafter\XINT_flexpr_scannum_start
    \else
        \xint_afterfi
       {\XINT_expr_unexpectedtoken
        \expandafter\XINT_flexpr_getnext\xint_gobble_ii}%
    \fi \XINT_expr_scannum_intpart_b #1%
}%
\def\XINT_flexpr_scannum_start #1%
{%
    \expandafter\XINT_flexpr_getop
    \romannumeral-`0\expandafter\XINT_expr_gathernum
    \romannumeral-`0#1%
}%
%    \end{macrocode}
% \subsection{\csh{xintNewExpr}}
%    \begin{macrocode}
\catcode`* 13
\def\xintNewExpr #1[#2]#3%
{%
    \begingroup
    \ifcase #2\relax
        \toks0 {\xdef #1}%
    \or \toks0 {\xdef #1##1}%
    \or \toks0 {\xdef #1##1##2}%
    \or \toks0 {\xdef #1##1##2##3}%
    \or \toks0 {\xdef #1##1##2##3##4}%
    \or \toks0 {\xdef #1##1##2##3##4##5}%
    \or \toks0 {\xdef #1##1##2##3##4##5##6}%
    \or \toks0 {\xdef #1##1##2##3##4##5##6##7}%
    \or \toks0 {\xdef #1##1##2##3##4##5##6##7##8}%
    \or \toks0 {\xdef #1##1##2##3##4##5##6##7##8##9}%
    \else 
       \immediate\write-1{Package xintexpr Error! illegal number of macro
         parameters.}% 
    \fi
        \def\xintAdd  {:xintAdd}%
        \def\xintSub  {:xintSub}%
        \def\xintMul  {:xintMul}%
        \def\xintDiv  {:xintDiv}%
        \def\xintPow  {:xintPow}%
        \def\xintFac  {:xintFac}%
        \def\xintOpp  {:xintOpp}%
        \def\xintfE   {:xintfE}%
        \def\xintraw  { :romannumeral0:xintraw}%
        \def\XINT_expr_the ##1##2##3%
           {\expandafter\xintraw
            \expandafter{\romannumeral-`0\XINT_expr_string ##3}}%
    \lccode`\*=`: \lowercase {\def*}{!noexpand!}%
    \catcode`: 13 
    \endlinechar -1 
    \everyeof {\noexpand }%
    \edef\xintNewExprtmp 
        {\scantokens
         \expandafter{\romannumeral0\xinttheeval #3\relax}}%
    \lccode`\*=`_ \lowercase {\def*}{####}%
    \catcode`_ 13  \catcode`! 0 \catcode`: 11 
    \the\toks0 {\scantokens\expandafter{\xintNewExprtmp }}%
\endgroup
}%    
%    \end{macrocode}
% \subsection{\csh{xintNewFloatExpr}}
%    \begin{macrocode}
\def\xintNewFloatExpr #1[#2]#3%
{%
    \begingroup
    \ifcase #2\relax
        \toks0 {\xdef #1}%
    \or \toks0 {\xdef #1##1}%
    \or \toks0 {\xdef #1##1##2}%
    \or \toks0 {\xdef #1##1##2##3}%
    \or \toks0 {\xdef #1##1##2##3##4}%
    \or \toks0 {\xdef #1##1##2##3##4##5}%
    \or \toks0 {\xdef #1##1##2##3##4##5##6}%
    \or \toks0 {\xdef #1##1##2##3##4##5##6##7}%
    \or \toks0 {\xdef #1##1##2##3##4##5##6##7##8}%
    \or \toks0 {\xdef #1##1##2##3##4##5##6##7##8##9}%
    \else 
       \immediate\write-1{Package xintexpr Error! illegal number of macro
         parameters.}% 
    \fi
        \def\XINTinFloatAdd   {:XINTinFloatAdd}%
        \def\XINTinFloatSub   {:XINTinFloatSub}%
        \def\XINTinFloatMul   {:XINTinFloatMul}%
        \def\XINTinFloatDiv   {:XINTinFloatDiv}%
        \def\XINTinFloatPower {:XINTinFloatPower}%
        \def\xintFac     {:xintFac}%
        \def\xintOpp     {:xintOpp}%
        \def\XINTinFloatfE    {:XINTinFloatfE}%
        \def\xintfloat  { :romannumeral0:xintfloat}%
        \def\XINT_flexpr_the ##1##2##3%
           {\expandafter\xintfloat
            \expandafter{\romannumeral-`0\XINT_expr_string ##3}}%
    \lccode`\*=`: \lowercase {\def*}{!noexpand!}%
    \catcode`: 13 
    \endlinechar -1 
    \everyeof {\noexpand }%
    \edef\xintNewExprtmp 
        {\scantokens
         \expandafter{\romannumeral0\xintthefloateval #3\relax}}%
    \lccode`\*=`_ \lowercase {\def*}{####}%
    \catcode`_ 13  \catcode`! 0 \catcode`: 11 
    \the\toks0 {\scantokens\expandafter{\xintNewExprtmp }}%
\endgroup
}%    
\XINT_expr_restorecatcodes_endinput%
%    \end{macrocode}
% \DeleteShortVerb{\|}
% \MakePercentComment
%</xintexpr>
%<*doc>
\CharacterTable
 {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
  Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
  Digits        \0\1\2\3\4\5\6\7\8\9
  Exclamation   \!     Double quote  \"     Hash (number) \#
  Dollar        \$     Percent       \%     Ampersand     \&
  Acute accent  \'     Left paren    \(     Right paren   \)
  Asterisk      \*     Plus          \+     Comma         \,
  Minus         \-     Point         \.     Solidus       \/
  Colon         \:     Semicolon     \;     Less than     \<
  Equals        \=     Greater than  \>     Question mark \?
  Commercial at \@     Left bracket  \[     Backslash     \\
  Right bracket \]     Circumflex    \^     Underscore    \_
  Grave accent  \`     Left brace    \{     Vertical bar  \|
  Right brace   \}     Tilde         \~}
\CheckSum{17408}
\makeatletter\check@checksum\makeatother
\Finale
%%
%% End of file `xint.dtx'.
