% -*- coding: iso-latin-1; time-stamp-format: "%02d-%02m-%:y at %02H:%02M:%02S %Z" -*-
% N.B.: this dtx file does NOT use \DocInput, only docstrip. The user manual
% latex source is NOT prefixed with percent characters.
%<*dtx>
\def\xintdtxtimestamp  {Time-stamp: <18-11-2015 19:20:47 CET>}
%</dtx>
%<*drv>
%% ---------------------------------------------------------------
\def\xintdocdate {2015/11/18}
\def\xintbndldate{2015/11/18}
\def\xintbndlversion {1.2d}
%</drv>
%<*dtx>
\iffalse % meta-comment
%</dtx>
%<readme>% README
%<changes>% CHANGE LOG
%<readme|changes>% xint v1.2d
%<readme|changes>% 2015/11/18
%<*readme|changes>

    Source:  xint.dtx v1.2d 2015/11/18 (doc 2015/11/18)
    Author:  Jean-Francois B.
    Info:    Expandable operations on big integers, decimals, fractions
    License: LPPL 1.3c

%</readme|changes>
%<*!readme&!changes&!dohtmlsh&!dopdfsh&!makefile>
%% ---------------------------------------------------------------
%% The xint bundle v1.2d 2015/11/18
%% Copyright (C) 2013-2015 by Jean-Francois B.
%<xintkernel>%% xintkernel: Paraphernalia for the xint packages
%<xinttools>%% xinttools: Expandable and non-expandable utilities
%<xintcore>%% xintcore: Expandable arithmetic on big integers
%<xint>%% xint: Expandable operations on big integers
%<xintfrac>%% xintfrac: Expandable operations on fractions
%<xintexpr>%% xintexpr: Expandable expression parser
%<xintbinhex>%% xintbinhex: Expandable binary and hexadecimal conversions
%<xintgcd>%% xintgcd: Euclidean algorithm with xint package
%<xintseries>%% xintseries: Expandable partial sums with xint package
%<xintcfrac>%% xintcfrac: Expandable continued fractions with xint package
%% ---------------------------------------------------------------
%</!readme&!changes&!dohtmlsh&!dopdfsh&!makefile>
%<*readme>
This `README` is also available as `README.pdf` and `README.html`.

Change log is to be found in `CHANGES.pdf` or `CHANGES.html`.

The user manual is `xint.pdf`, and the commented source code is
available as `sourcexint.pdf`.


Aim
===

The basic aim is provide *expandable* computations on big integers,
and also big fractions. For example
  
    \xinttheexpr reduce(37189719/183618963+11390170/17310720)^17\relax

will evaluate exactly the fraction (the result has 462 characters
including the fraction slash). One can also work with dummy
variables. For example
  
    \xinttheexpr mul(add(x(x+1)(x+2), x=y..y+15), y=171286,98762,9296)\relax

evaluates to `15979066346135829902328007959448563667099190784`.

It is possible to use the package with Plain as well as with LaTeX.

Sub-units `xintcore`, `xint` and `xintfrac` provide the underlying
macros, and `xintexpr` loads all of them and provides expandable
parsers allowing computations such as the above (and more). A more
light-weight package [bnumexpr](http://www.ctan.org/pkg/bnumexpr)
(LaTeX only) loads only `xintcore` and provides a parser which
handles only big integers, the four operations, the power operation
and the factorial (v1.2).


Usage
=====

## With LaTeX

    \usepackage{xint}       % expandable arithmetic with big integers
    \usepackage{xintfrac}   % decimal numbers, fractions, floats
    \usepackage{xintexpr}   % expressions with infix operators

Further packages: `xintbinhex`, `xintgcd`, `xintseries` and
`xintcfrac`. All dependencies are handled automatically. For example
`xintexpr` automatically loads `xintfrac` which itself loads `xint`.
Package `xintcore` is the subset of `xint` providing only the five
operations on big integers: `\xintiiAdd`, `\xintiiMul`,\ ...
There is also `xinttools` which is a separate package providing,
among others, expandable and non-expandable loops such as `\xintFor`.

## With TeX

One does for example:

    \input xintexpr.sty

Again, all dependencies are handled automatically. The packages may
be loaded in any catcode context such that letters, digits, `\` and
`%` have their standard catcodes.

`xintcore.sty` and `xinttools.sty` both import `xintkernel.sty`
which has the catcode handler and package identifier and defines a
few utilities such as `\oodef`, `\fdef`, or `\xint_dothis/\xint_orthat`.


Installation
============

## Method A: using the package manager of your TeX distribution

`xint` is included in [TeXLive](http://tug.org/texlive/) (hence also
[MacTeX](http://tug.org/mactex/)) and [MikTeX](http://www.miktex.org/).

There can be a few days of delay between apparition of a new version on
[CTAN](http://www.ctan.org/pkg/xint) and availability via the distribution
package manager.

## Method B: manual installation using `xint.tds.zip` and `unzip`

Assumes a GNU/Linux-like system (or Mac OS X).

1. obtain `xint.tds.zip` from CTAN:
  <http://mirror.ctan.org/install/macros/generic/xint.tds.zip>

2. cd to the download repertory and issue:

        unzip xint.tds.zip -d <TEXMF>

    where `<TEXMF>` is a suitable TDS-compliant destination repertory.
    For example, with TeXLive:

    - Linux, standard access rights, hence sudo is needed, installation
      into the "local" tree:

            sudo unzip xint.tds.zip -d /usr/local/texlive/texmf-local
            sudo texhash /usr/local/texlive/texmf-local

    - Mac OS X, installation into user home folder (no sudo needed,
      and it is recommended to not have a ls-R file there, hence no texhash):

            unzip xint.tds.zip -d  ~/Library/texmf

## Method C: manual installation using `Makefile` and `xint.dtx`

The Makefile automatizes rebuilding from `xint.dtx` all documentation
files as well as `xint.tds.zip`. It is for GNU/Linux-like (inc. Mac OS X)
systems, with a teTeX like installation such as TeXLive. Furthermore the
[Pandoc](http://johnmacfarlane.net/pandoc/) software is required.

1. obtain `xint.dtx` and `Makefile` from 
   <http://mirror.ctan.org/macros/generic/xint>.

2. put them in an otherwise empty working repertory, run `make` or
   equivalently `make help` for further instructions.

## Method D: installation starting with only `xint.dtx`

Run `"tex xint.dtx"` or `"etex xint.dtx"` to extract from `xint.dtx`
all packages as well as these files:

`README.md`
  : the current README with Markdown formatting.

`CHANGES.md`
  : the changes across successive releases.

`xint.tex`
  : used to generate `xint.pdf` via `"latex xint.tex"` (thrice) then
  `"dvipdfmx xint.dvi"`. It is also possible to compile `xint.tex` with
  `xelatex`, or with `pdflatex` (this latter option produces a bigger pdf).

  : For successful compilation, packages `newtxtt`, `newtxmath`, `etoc`,
  `mathastext` are needed. Inclusion of the source code is off by
  default, but the toggle can be set in `xint.tex`.

  : A third option is to generate `xint.pdf` via `xelatex xint.dtx` or
  `pdflatex xint.dtx`. Source code is then included by default (but some
  code comments in French use 8bit characters, hence for `xelatex` an a
  priori conversion of xint.dtx into utf-8 will give a better result).

`Makefile.mk`
  : this is for UNIX-like systems. Note: this file is only produced
  with `"etex xint.dtx"`, not with `"tex xint.dtx"`. Rename it to
  `Makefile` and run `make` on the command line for further help.

`doHTMLs.sh` and `doPDFs.sh`
  : these are scripts (for UNIX-like systems) which can be used to
  convert the `README.md` and `CHANGES.md` to HTML and PDF formats.
  They require [Pandoc](http://johnmacfarlane.net/pandoc/).

`pandoctpl.latex`
  : a Pandoc template used by `doPDFs.sh`.

Finishing the installation in a TDS hierarchy:

- move the style files to `TDS:tex/generic/xint/`

- `xint.dtx` goes to `TDS:source/generic/xint/`

- the documentation (xint.pdf, README.md,...) goes to `TDS:doc/generic/xint/`

Depending on the destination, it may then be necessary to refresh a
filename database.


License
=======

<div class="mono">
Copyright (C) 2013-2015 by Jean-Francois B.

This Work may be distributed and/or modified under the
conditions of the LaTeX Project Public License version 1.3c.
This version of this license is in

>   <http://www.latex-project.org/lppl/lppl-1-3c.txt>

and version 1.3 or later is part of all distributions of
LaTeX version 2005/12/01 or later.

This Work has the LPPL maintenance status `author-maintained`.

The Author of this Work is Jean-Francois B..

This Work consists of the source file xint.dtx and of its derived
files: xintkernel.sty, xintcore.sty, xint.sty, xintfrac.sty,
xintexpr.sty, xintbinhex.sty, xintgcd.sty, xintseries.sty,
xintcfrac.sty, xinttools.sty, xint.ins, xint.tex, README, README.md,
README.html, README.pdf, CHANGES.md, CHANGES.html, CHANGES.pdf,
pandoctpl.latex, doHTMLs.sh, doPDFs.sh, xint.dvi, xint.pdf,
Makefile.mk.</div>
%</readme>--------------------------------------------------------
%<*changes>-------------------------------------------------------
`1.2d (2015/11/18)`
----

 - bugfix in **xintcore**: release `1.2c` had inadvertently broken
   the `\xintiiDivRound` macro.
   
 - the function definitions done by `\xintdeffunc` et al., as well as
   the macro declarations by `\xintNewExpr` et al. now have only local
   scope.

 - tacit multiplication applies to more cases, for example (x+y)z, and
   always ties more than standard * infix operator, e.g. x/2y is like
   x/(2*y).

 - some documentation enhancements, particularly in the chapter on
   xintexpr.sty, and also in the code source comments.


`1.2c (2015/11/16)`
----

 - bugfix in **xintcore**: recent release `1.2` introduced a bug in the
   subtraction (happened when 00000001 was found under certain
   circumstances at certain mod 8 locations).
   
 - new macros `\xintdeffunc`, `\xintdefiifunc`, `\xintdeffloatfunc` and
   boolean `\ifxintverbose`.

 - on-going code improvements and documentation enhancements, but
   stopped in order to issue this bugfix release.


`1.2b (2015/10/29)`
----

 - bugfix in **xintcore**: recent release `1.2` introduced a bug in
   the division macros, causing a crash when the divisor started
   with 99999999 (it was attempted to use with 1+99999999 a
   subroutine expecting only 8-digits numbers).


`1.2a (2015/10/19)`
----

 - bugfix in **xintexpr**: recent release `1.2` introduced a bad bug
   in the parsing of decimal numbers and as a result `\xinttheexpr
   0.01\relax` expanded to `0` ! (sigh...)

 - added `\xintKeepUnbraced`, `\xintTrimUnbraced` (**xinttools**) and fixed
   documentation of `\xintKeep` and `\xintTrim` regarding brace stripping.

 - added `\xintiiMaxof/\xintiiMinof` (**xint**).

 - TeX hackers only: replaced all code uses of ``\romannumeral-`0``
   by the quicker ``\romannumeral`&&@`` (`^` being used as letter,
   had to find another character usable with catcode 7).


`1.2 (2015/10/10)`
----

 - the basic arithmetic implemented in **xintcore** has been entirely
   rewritten. The mathematics remains the elementary school one, but the
   `TeX` implementation achieves higher speed (except, regarding
   addition/subtraction, for numbers up to about thirty digits), the
   gains becoming quite significant for numbers with hundreds of digits.

 - the inputs must have less than 19959 digits. But computations with
   thousands of digits take time.

 - a previously standing limitation of `\xintexpr`, `\xintiiexpr`, and
   of `\xintfloatexpr` to numbers of less than 5000 digits has been
   lifted.

 - a *qint* function is provided to help the parser gather huge integers
   in one-go, as an exception to its normal mode of operation which
   expands token by token.

 - new `\xintFloatFac` macro for computing the factorials of integers as
   floating point numbers to a given precision. The `!` postfix operator
   inside `\xintfloatexpr` maps to this new macro rather than to the
   exact factorial as used by `\xintexpr` and `\xintiiexpr`.

 - the macros `\xintAdd`, `\xintSub`, ..., now require package
   **xintfrac**. With only **xintcore** or **xint** loaded, one _must_
   use `\xintiiAdd`, `\xintiiSub`, ..., or `\xintiAdd`, `\xintiSub`,
   etc...

 - there is more flexibility in the parsing done by the macros from
   **xintfrac** on fractional input: the decimal parts of both the
   numerator and the denominator may arise from a separate expansion via
   ``\romannumeral-`0``. Also the strict `A/B[N]` format is a bit
   relaxed: `N` may be empty or anything understood by `\numexpr`.

 - on the other hand an isolated dot `.` is not legal syntax anymore
   inside the expression parsers: there must be digits either before or
   after. It remains legal input for the macros of **xintfrac**.

 - added `\ht`, `\dp`, `\wd`, `\fontcharht`, etc... to the tokens
   recognized by the parsers and expanded by `\number`.

 - an obscure bug in package **xintkernel** has been fixed, regarding
   the sanitization of catcodes: under certain circumstances (which
   could not occur in a normal `LaTeX` context), unusual catcodes could
   end up being propagated to the external world.

 - an effort at randomly shuffling around various pieces of the
   documentation has been done.


`1.1c (2015/09/12)`
----

 - bugfix regarding macro `\xintAssign` from **xinttools** which did
   not behave correctly in some circumstances (if there was a space
   before `\to`, in particular).

 - very minor code improvements, and correction of some issues
   regarding the source code formatting in `sourcexint.pdf`, and
   minor issues in `Makefile.mk`.


`1.1b (2015/08/31)`
----

 - bugfix: some macros needed by the integer division routine from 
   **xintcore** had been left in **xint.sty** since release `1.1`. This
   for example broke the `\xintGCD` from **xintgcd** if package **xint**
   was not loaded.

 - Slight enhancements to the documentation, particularly in the 
   `Read this first` section.


`1.1a (2014/11/07)`
----

 - fixed a bug which prevented `\xintNewExpr` from producing correctly working
   macros from a comma separated replacement text.

 - new `\xintiiSqrtR` for rounded integer square root; former `\xintiiSqrt`
   already produced truncated integer square root; corresponding function
   `sqrtr` added to `\xintiiexpr..\relax` syntax.

 - use of straight quotes in the documentation for better legibility.

 - added `\xintiiIsOne`, `\xintiiifOne`, `\xintiiifCmp`, `\xintiiifEq`,
    `\xintiiifGt`, `\xintiiifLt`, `\xintiiifOdd`, `\xintiiCmp`, `\xintiiEq`,
    `\xintiiGt`, `\xintiiLt`, `\xintiiLtorEq`, `\xintiiGtorEq`, `\xintiiNeq`,
    mainly for efficiency of `\xintiiexpr`.

 - for the same reason, added `\xintiiGCD` and `\xintiiLCM`.

 - added the previously mentioned `ii` macros, and some others from `v1.1`, to
   the user manual. But their main usage is internal to `\xintiiexpr`, to skip
   unnecessary overheads.

 - various typographical fixes throughout the documentation, and a bit
   of clean up of the code comments. Improved `\Factors` example of nested
   `subs`, `rseq`, `iter` in `\xintiiexpr`. 

`1.1 (2014/10/28)`
----

bug fixes

:   - `\xintZapFirstSpaces` hence also `\xintZapSpaces` from package **xinttools**
        were buggy when used with  an argument either empty or containing only
        space tokens. 

    - `\xintiiexpr` did not strip leading zeroes, hence
      `\xinttheiiexpr 001+1\relax` did not obtain the expected result ...

    - `\xinttheexpr \xintiexpr 1.23\relax\relax` should have produced `1`,
    but it produced `1.23`

    - the catcode of `;` was not set at package launching time.

    - the `\XINTinFloatPrd:csv` macro name had a typo, hence `prd` was
      non-functional in `\xintfloatexpr`. 

breaking changes

:   - in `\xintiiexpr`, `/` does _rounded_ division, rather than the
    Euclidean division (for positive arguments, this is truncated division).
    The new `//` operator does truncated division,

    - the `:` operator for three-way branching is gone, replaced with `??`,

    - `1e(3+5)` is now illegal. The number parser identifies `e` and `E`
    in the same way it does for the decimal mark, earlier versions treated
    `e` as `E` rather as infix operators of highest precedence,

    - the `add` and `mul` have a new syntax, old syntax is with `` `+` `` and
    `` `*` `` (left quotes mandatory), `sum` and `prd` are gone,

    - no more special treatment for encountered brace pairs `{..}` by the
    number scanner, `a/b[N]` notation can be used without use of braces (the
    `N` will end up as is in a `\numexpr`, it is not parsed by the
    `\xintexpr`-ession scanner),
    
    -  although `&` and `|` are still available as Boolean operators the
    use of `&&` and `||` is strongly recommended. The single
    letter operators might be assigned some other meaning in later releases
    (bitwise operations, perhaps). Do not use them.

    - in earlier releases, place holders for `\xintNewExpr` could either
    be denoted `#1`, `#2`, ... or also `$1`, `$2`, ... 
    Only the usual `#` form is now accepted and the special cases previously
    treated via the second form are now managed via a `protect(...)` function.

**novelties :**

  * new package **xintcore** has been split off **xint**. It contains the
      core arithmetic macros. It is loaded by package **bnumexpr**,

  * neither **xint** nor **xintfrac** load **xinttools**. Only
      **xintexpr** does,
  
  * whenever some portion of code has been revised, often use has been made of
      the `\xint_dothis` and `\xint_orthat` pair of macros for expandably
      branching,

  * these tiny helpful macros, and a few others are in package
      **xintkernel** which contains also the catcode and loading order
      management code, initially inspired by code found in Heiko Oberdiek's
      packages,

  * the source code, which was suppressed from `xint.pdf` in release
      `1.09n`, is now compiled into a separate file `sourcexint.pdf`,

  * faster handling by `\xintAdd`, `\xintSub`, `\xintMul`, ... of the case
      where one of the arguments is zero,

  * the `\xintAdd` and `\xintSub` macros from package **xintfrac** check if
      one of the denominators is a multiple of the other, and only if this is
      not the case do they multiply the denominators. But systematic reduction
      would be too costly,

  * this naturally will be also the case for the `+` and `-` operations
      in `\xintexpr`,

  * new macros `\xintiiDivRound`, `\xintiiDivTrunc` and `\xintiiMod` for
      rounded and truncated division of big integers (now in **xintcore**),
      alongside the earlier `\xintiiQuo` and `\xintiiRem`,

  * with **xintfrac** loaded, the `\xintNum` macro does `\xintTTrunc`
      (which is truncation to an integer, same as `\xintiTrunc {0}`),

  * new macro `\xintMod` in **xintfrac** for modulo operation with
      fractional numbers,

  * `\xintiexpr`, `\xinttheiexpr` admit an optional argument within brackets
      `[d]`, they round the computation result (or results, if comma separated)
      to `d` digits after decimal mark, (the whole computation is done exactly,
      as in `xintexpr`),

  * `\xintfloatexpr`, `\xintthefloatexpr` similarly admit an optional
      argument which serves to keep only `d` digits of precision, getting rid
      of cumulated uncertainties in the last digits (the whole computation is
      done according to the precision set via `\xintDigits`),

  * `\xinttheexpr` and `\xintthefloatexpr` _pretty-print_ if possible, the
      former removing unit denominator or `[0]` brackets, the latter avoiding
      scientific notation if decimal notation is practical,

  * the `//` does truncated division and `/:` is the associated modulo,

  * multi-character operators `&&`, `||`, `==`, `<=`, `>=`, `!=`,
      `**`,

  * multi-letter infix binary words `'and'`, `'or'`, `'xor'`, `'mod'`
      (straight quotes mandatory),

  * functions `even`, `odd`, 

  * `\xintdefvar A3:=3.1415;` for variable definitions (non expandable,
    naturally), usable in subsequent expressions; variable names may contain
    letters, digits, underscores. They should not start with a digit, the `@`
    is reserved, and single lowercase and uppercase Latin letters are
    predefined to work as dummy variables (see next),

  * generation of comma separated lists `a..b`, `a..[d]..b`,

  * Python syntax-like list extractors `[list][n:]`, `[list][:n]`,
    `[list][a:b]` allowing negative indices, but no optional step argument,
    and `[list][n]` (`n=0` for the number of items in the list),

  * functions `first`, `last`, `reversed`,

  * itemwise operations on comma separated lists `a*[list]`, etc.., possible
    on both sides `a*[list]^b`, and obeying the same precedence rules as with
    numbers,

  * `add` and `mul` must use a dummy variable: `add(x(x+1)(x-1), x=-10..10)`,

  * variable substitutions with `subs`:
    `subs(subs(add(x^2+y^2,x=1..y),y=t),t=20)`,

  * sequence generation using `seq` with a dummy variable: `seq(x^3,
    x=-10..10)`,

  * simple recursive lists with `rseq`, with `@` given the last value,
     `rseq(1;2@+1,i=1..10)`,

  * higher recursion with `rrseq`, `@1`, `@2`, `@3`, `@4`, and `@@(n)`
     for earlier values, up to `n=K` where `K` is the number of terms of the
     initial stretch `rrseq(0,1;@1+@2,i=2..100)`,

  * iteration with `iter` which is like `rrseq` but outputs only the
     last `K` terms, where `K` was the number of initial terms,

  * inside `seq`, `rseq`, `rrseq`, `iter`, possibility to use `omit`,
     `abort` and `break` to control termination,

  * `n++` potentially infinite index generation for `seq`, `rseq`,
     `rrseq`, and `iter`, it is advised to use `abort` or `break(..)` at
     some point,

  * the `add`, `mul`, `seq`, ... are nestable,

  * `\xintthecoords` converts a comma separated list of an even number
     of items to the format expected by the `TikZ` `coordinates` syntax,

  * completely new version `\xintNewExpr`, `protect` function to handle
     external macros. The dollar sign
     `$` for place holders is not accepted anymore, only the standard macro
     parameter `#`. Not all constructs are compatible with `\xintNewExpr`.
% $ this docstripped line for emacs buffer fontification issues in doctex-mode

`1.09n (2014/04/01)`
----

  * the user manual does not include by default the source code
    anymore: the `\NoSourceCode` toggle in file `xint.tex` has to
    be set to 0 before compilation to get source code inclusion
    (later release `1.1` made source code available as `sourcexint.pdf`).

  * bug fix (**xinttools**) in `\XINT_nthelt_finish` (this bug was
    introduced in `1.09i` of `2013/12/18` and showed up when the index
    `N` was larger than the number of elements of the list).

`1.09m (2014/02/26)`
----

  * new in **xinttools**: `\xintKeep` keeps the first `N` or last
    `N` elements of a list (sequence of braced items); `\xintTrim`
    cuts out either the first `N` or the last `N` elements from a
    list.

  * new in **xintcfrac**: `\xintFGtoC` finds the initial partial
    quotients common to two numbers or fractions `f` and `g`;
    `\xintGGCFrac` is a clone of `\xintGCFrac` which however does not
    assume that the coefficients of the generalized continued
    fraction are numeric quantities. Some other minor changes.

`1.09kb (2014/02/13)`
----

  * bug fix (**xintexpr**): an aloof modification done by `1.09i` to
    `\xintNewExpr` had resulted in a spurious trailing space present
    in the outputs of all macros created by `\xintNewExpr`, making
    nesting of such macros impossible.

  * bug fix (**xinttools**): `\xintBreakFor` and `\xintBreakForAndDo`
    were buggy when used in the last iteration of an `\xintFor` loop.

  * bug fix (**xinttools**): `\xintSeq` from `1.09k` needed a `\chardef`
    which was missing from `xinttools.sty`, it was in `xint.sty`.

`1.09k (2014/01/21)`
----

  * inside `\xintexpr..\relax` (and its variants) tacit multiplication is
    implied when a number or operand is followed directly with an
    opening parenthesis,

  * the `"` for denoting (arbitrarily big) hexadecimal numbers is
    recognized by `\xintexpr` and its variants (package
    **xintbinhex** is required); a fractional hexadecimal part
    introduced by a dot `.` is allowed.

  * re-organization of the first sections of the user manual.

  * bug fix (**xinttools**, **xint**, ...): forgotten catcode check of
    `"` at loading time has been added.

`1.09j (2014/01/09)`
----

  * (**xint**) the core division routines have been re-written for some
    (limited) efficiency gain, more pronounced for small divisors. As a
    result the *computation of one thousand digits of $\pi$* is close
    to three times faster than with earlier releases.

  * some various other small improvements, particularly in the power
    routines.

  * (**xintfrac**) a new macro `\xintXTrunc` is designed to produce
    thousands or even tens of thousands of digits of the decimal
    expansion of a fraction. Although completely expandable it has its
    use limited to inside an `\edef`, `\write`, `\message`, \dots. It
    can thus not be nested as argument to another package macro.

  * (**xintexpr**) the tacit multiplication done in `\xintexpr..\relax`
    on encountering a count register or variable, or a `\numexpr`,
    while scanning a (decimal) number, is extended to the case of a sub
    `\xintexpr`-ession.

  * `\xintexpr` can now be used in an `\edef` with no `\xintthe` prefix;
    it will execute completely the computation, and the error message
    about a missing `\xintthe` will be inhibited. Previously, in the
    absence of `\xintthe`, expansion could only be a full one (with
    ``\romannumeral-`0``), not a complete one (with `\edef`). Note
    that this differs from the behavior of the non-expandable
    `\numexpr`: `\the` or `\number` (or `\romannumeral`) are needed
    not only to print but
    also to trigger the computation, whereas `\xintthe` is mandatory
    only for the printing step.

  * the default behavior of `\xintAssign` is changed, it now does not
    do any further expansion beyond the initial full-expansion which
    provided the list of items to be assigned to macros.

  * bug fix (**xintfrac**): `1.09i` did an unexplainable change to
    `\XINT_infloat_zero` which broke the floating point routines for
    vanishing operands =:(((

  * bug fix: the `1.09i` `xint.ins` file produced a buggy `xint.tex` file.

`1.09i (2013/12/18)`
----

  * (**xintexpr**) `\xintiiexpr` is a variant of `\xintexpr` which is
    optimized to deal only with (long) integers, `/` does a euclidean
    quotient.

  * `\xintnumexpr`, `\xintthenumexpr`, `\xintNewNumExpr` are renamed,
    respectively, `\xintiexpr`, `\xinttheiexpr`, `\xintNewIExpr`. The
    earlier denominations are kept but to be removed at some point.

  * it is now possible within `\xintexpr...\relax` and its variants to
    use count, dimen, and skip registers or variables without
    explicit `\the/\number`: the parser inserts automatically
    `\number` and a tacit multiplication is implied when a register
    or variable immediately follows a number or fraction. Regarding
    dimensions and `\number`, see the further discussion in
    *Dimensions*.

  * (**xintfrac**) new conditional `\xintifOne`; `\xintifTrueFalse`
    renamed to `\xintifTrueAelseB`; new macros `\xintTFrac`
    (`fractional part`, mapped to function `frac` in
    `\xintexpr`-essions), `\xintFloatE`.

  * (**xinttools**) `\xintAssign` admits an optional argument to
    specify the expansion type to be used: `[]` (none, default), `[o]`
    (once), `[oo]` (twice), `[f]` (full), `[e]` (`\edef`),... to define
    the macros

  * **xinttools** defines `\odef`, `\oodef`, `\fdef` (if the names have
    already been assigned, it uses `\xintoodef` etc...). These tools are
    provided for the case one uses the package macros in a non-expandable
    context. `\oodef` expands twice the macro replacement text, and `\fdef`
    applies full expansion. They are useful in situations where one does not
    want a full `\edef`. `\fdef` appears to be faster than `\oodef` in almost
    all cases (with less than thousand digits in the result), and even faster
    than `\edef` for expanding the package macros when the result has a few
    dozens of digits. `\oodef` needs that expansion ends up in thousands of
    digits to become competitive with the other two.

  * some across the board slight efficiency improvement as a result of
    modifications of various types to *fork macros* and *branching
    conditionals* which are used internally.

  * bug fix (**xint**): `\xintAND` and `\xintOR` inserted a space token
    in some cases and did not expand as promised in two steps `:-((`
    (bug dating back to `1.09a` I think; this bug was without
    consequences when using `&` and `|` in `\xintexpr-essions`, it
    affected only the macro form).

  * bug fix (**xintcfrac**): `\xintFtoCCv` still ended fractions with
    the `[0]`'s which were supposed to have been removed since release
    `1.09b`.

`1.09h (2013/11/28)`
----

  * parts of the documentation have been re-written or re-organized,
    particularly the discussion of expansion issues and of input and
    output formats.

  * the expansion types of macro arguments are documented in the margin
    of the macro descriptions, with conventions mainly taken over
    from those in the `LaTeX3` documentation.

  * a dependency of **xinttools** on **xint** (inside `\xintSeq`) has
    been removed.

  * (**xintgcd**) `\xintTypesetEuclideAlgorithm` and
    `\xintTypesetBezoutAlgorithm` have been slightly modified
    (regarding indentation).

  * (**xint**) macros `xintiSum` and `xintiPrd` are renamed to
    `\xintiiSum` and `\xintiiPrd`.

  * (**xinttools**) a count register used in `1.09g` in the `\xintFor`
    loops for parsing purposes has been removed and replaced by use of
    a `\numexpr`.

  * the few uses of `\loop` have been replaced by `\xintloop/\xintiloop`.

  * all macros of **xinttools** for which it makes sense are now declared
    `\long`.

`1.09g (2013/11/22)`
----

  * a package **xinttools** is detached from **xint**, to make tools such
    as `\xintFor`, `\xintApplyUnbraced`, and `\xintiloop` available
    without the **xint** overhead.

  * new expandable nestable loops `\xintloop` and `\xintiloop`.

  * bugfix: `\xintFor` and `\xintFor*` do not modify anymore the value of
    `\count 255`.

`1.09f (2013/11/04)`
----

  * (**xint**) new `\xintZapFirstSpaces`, `\xintZapLastSpaces`,
    `\xintZapSpaces`, `\xintZapSpacesB`, for expandably stripping away
    leading and/or ending spaces.

  * `\xintCSVtoList` by default uses `\xintZapSpacesB` to strip away
    spaces around commas (or at the start and end of the comma
    separated list).

  * also the `\xintFor` loop will strip out all spaces around commas and
    at the start and the end of its list argument; and similarly for
    `\xintForpair`, `\xintForthree`, `\xintForfour`.

  * `\xintFor` *et al.* accept all macro parameters from `#1` to
    `#9`.

  * for reasons of inner coherence some macros previously with one extra
    `i` in their names (e.g. `\xintiMON`) now have a doubled
    `ii` (`\xintiiMON`) to indicate that they skip the overhead of
    parsing their inputs via `\xintNum`. Macros with a *single*
    `i` such as `\xintiAdd` are those which maintain the
    non-**xintfrac** output format for big integers, but do parse
    their inputs via `\xintNum` (since release `1.09a`). They too may
    have doubled-`i` variants for matters of programming optimization
    when working only with (big) integers and not fractions or
    decimal numbers.

`1.09e (2013/10/29)`
----

  * (**xint**) new `\xintintegers`, `\xintdimensions`, `\xintrationals`
    for infinite `\xintFor` loops, interrupted with `\xintBreakFor` and
    `\xintBreakForAndDo`.

  * new `\xintifForFirst`, `\xintifForLast` for the `\xintFor` and
    `\xintFor*` loops,

  * the `\xintFor` and `xintFor*` loops are now `\long`, the
    replacement text and the items may contain explicit `\par`'s.

  * new conditionals `\xintifCmp`, `\xintifInt`, `\xintifOdd`.

  * bug fix (**xint**): the `\xintFor` loop (not `\xintFor*`) did
    not correctly detect an empty list.

  * bug fix (**xint**): `\xintiSqrt {0}` crashed. `:-((`

  * the documentation has been enriched with various additional examples,
    such as the *the quick sort algorithm
    illustrated* or the various ways of *computing prime numbers*.

  * the documentation explains with more details various expansion
    related issues, particularly in relation to conditionals.

`1.09d (2013/10/22)`
----

  * bug fix (**xint**): `\xintFor*` is modified to gracefully
    handle a space token (or more than one) located at the very end of
    its list argument (as the space before `\do` in `\xintFor* #1 in
    {{a}{b}{c}<space>} \do {stuff}`; spaces at other locations were
    already harmless). Furthermore this new version _f-expands_ the
    un-braced list items. After `\def\x{{1}{2}}` and `\def\y{{a}\x
    {b}{c}\x }`, `\y` will appear to `\xintFor*` exactly as if it had
    been defined as `\def\y{{a}{1}{2}{b}{c}{1}{2}}`.

  * same bug fix for `\xintApplyInline`.

`1.09c (2013/10/09)`
----

  * (**xintexpr**) added `bool` and `togl` to the `\xintexpr` syntax;
    also added `\xintboolexpr` and `\xintifboolexpr`.

  * added `\xintNewNumExpr` (now `\xintNewIExpr` and `\xintNewBoolExpr`),

  * the factorial `!` and branching `?`, `:`, operators (in
    `\xintexpr...\relax`) have now less precedence than a function
    name located just before,

  * (**xint**) `\xintFor` is a new type of loop, whose replacement text
    inserts the comma separated values or list items via macro
    parameters, rather than encapsulated in macros; the loops are
    nestable up to four levels (nine levels since `1.09f`) and their
    replacement texts are allowed to close groups as happens with the
    tabulation in alignments,

  * `\xintForpair`, `\xintForthree`, `\xintForfour` are experimental
    variants of `\xintFor`,

  * `\xintApplyInline` has been enhanced in order to be usable for
    generating rows (partially or completely) in an alignment,

  * new command `\xintSeq` to generate (expandably) arithmetic sequences
    of (short) integers,

  * again various improvements and changes in the documentation.

`1.09b (2013/10/03)`
----

  * various improvements in the documentation,

  * more economical catcode management and re-loading handling,

  * removal of all those `[0]`'s previously forcefully added at the end
    of fractions by various macros of **xintcfrac**,

  * `\xintNthElt` with a negative index returns from the tail of the
    list,

  * new macro `\xintPRaw` to have something like what `\xintFrac` does in
    math mode; i.e. a `\xintRaw` which does not print the denominator
    if it is one.

`1.09a (2013/09/24)`
----

  * (**xintexpr**) `\xintexpr..\relax` and `\xintfloatexpr..\relax`
    admit functions in their syntax, with comma separated values as
    arguments, among them `reduce, sqr, sqrt, abs, sgn, floor, ceil,
    quo, rem, round, trunc, float, gcd, lcm, max, min, sum, prd, add,
    mul, not, all, any, xor`.

  * comparison (`<`, `>`, `=`) and logical (`|`, `&`) operators.

  * the command `\xintthe` which converts `\xintexpr`essions into
    printable format (like `\the` with `\numexpr`) is more efficient,
    for example one can do `\xintthe\x` if `\x` was defined to be an
    `\xintexpr..\relax`:

        \def\x{\xintexpr 3^57\relax}
        \def\y{\xintexpr \x^(-2)\relax}
        \def\z{\xintexpr \y-3^-114\relax}
        \xintthe\z

  * `\xintnumexpr .. \relax` (now renamed `\xintiexpr`) is `\xintexpr
    round( .. ) \relax`.

  * `\xintNewExpr` now works with the standard macro parameter character
    `#`.

  * both regular `\xintexpr`-essions and commands defined by
    `\xintNewExpr` will work with comma separated lists of
    expressions,

  * new commands `\xintFloor`, `\xintCeil`, `\xintMaxof`, `\xintMinof`
    (package **xintfrac**), `\xintGCDof`, `\xintLCM`, `\xintLCMof`
    (package **xintgcd**), `\xintifLt`, `\xintifGt`, `\xintifSgn`,
    `\xintANDof`, ...

  * The arithmetic macros from package **xint** now filter their operands
    via `\xintNum` which means that they may use directly count
    registers and `\numexpr`-essions without having to prefix them by
    `\the`. This is thus similar to the situation holding previously
    already when **xintfrac** was loaded.

  * a bug (**xintfrac**) introduced in `1.08b` made `\xintCmp` crash
    when one of its arguments was zero. `:-((`

`1.08b (2013/06/14)`
----

  * (**xintexpr**) Correction of a problem with spaces inside
    `\xintexpr`-essions.

  * (**xintfrac**) Additional improvements to the handling of floating
    point numbers.

  * new section *Use of count registers* documenting how count
    registers may be directly used in arguments to the macros of
    **xintfrac**.

`1.08a (2013/06/11)`
----

  * (**xintfrac**) Improved efficiency of the basic conversion from
    exact fractions to floating point numbers, with ensuing speed gains
    especially for the power function macros `\xintFloatPow` and
    `\xintFloatPower`,

  * Better management by `\xintCmp`, `\xintMax`, `\xintMin` and
    `\xintGeq` of inputs having big powers of ten in them.

  * Macros for floating point numbers added to the **xintseries**
    package.

`1.08 (2013/06/07)`
----

  * (**xint** and **xintfrac**) Macros for extraction of square roots,
    for floating point numbers (`\xintFloatSqrt`), and integers
    (`\xintiSqrt`).

  * New package **xintbinhex** providing *conversion routines* to and from
    binary and hexadecimal bases.

`1.07 (2013/05/25)`
----

  * The **xintexpr** package is a new core constituent (which loads
    automatically **xintfrac** and **xint**) and implements the
    expandable expanding parser

        \xintexpr . . . \relax,

    and its variant

        \xintfloatexpr . . . \relax

    allowing on input formulas using the infix operators `+`, `-`, `*`,
    `/`, and `^`, and arbitrary levels of parenthesizing. Within a
    float expression the operations are executed according to the
    current value of `\xintDigits`. Within an `\xintexpr`-ession the
    binary operators are computed exactly.

    To write the `\xintexpr` parser I benefited from the commented
    source of the `l3fp` parser; the `\xintexpr` parser has its own
    features and peculiarities. *See its documentation*.

  * The floating point precision `D` is set (this is a local assignment
    to a `\mathchar` variable) with `\xintDigits := D;` and queried
    with `\xinttheDigits`. It may be set to anything up to
    `32767`.[^1] The macro incarnations of the binary operations
    admit an optional argument which will replace pointwise `D`; this
    argument may exceed the `32767` bound.

  * The **xintfrac** macros now accept numbers written in scientific
    notation, the `\xintFloat` command serves to output its argument
    with a given number `D` of significant figures. The value of `D`
    is either given as optional argument to `\xintFloat` or set with
    `\xintDigits := D;`. The default value is `16`.

[^1]: but values higher than 100 or 200 will presumably give too slow
evaluations.

`1.06b (2013/05/14)`
----

  * Minor code and documentation improvements. Everywhere in the source
   code, a more modern underscore has replaced the @ sign.

`1.06 (2013/05/07)`
----

  * Some code improvements, particularly for macros of **xint** doing loops.

  * New utilities in **xint** for expandable manipulations of lists:

        \xintNthElt, \xintCSVtoList, \xintRevWithBraces

  * The macros did only a double expansion of their arguments. They now
    fully expand them (using ``\romannumeral-`0``). Furthermore, in the
    case of arguments constrained to obey the TeX bounds they will be
    inserted inside a `\numexpr..\relax`, hence completely expanded, one
    may use count registers, even infix arithmetic operations, etc...

`1.05 (2013/05/01)`
----

Minor changes and additions to **xintfrac** and **xintcfrac**.

`1.04 (2013/04/25)`
----

  * New component **xintcfrac** devoted to continued fractions.

  * bug fix (**xintfrac**): `\xintIrr {0}` crashed.

  * faster division routine in **xint**, new macros to deal expandably with
    token lists.

  * `\xintRound` added.

  * **xintseries** has a new implementation of `\xintPowerSeries` based
on a Horner scheme, and new macro `\xintRationalSeries`. Both to help
deal with the *denominator buildup* plague.

  * `tex xint.dtx` extracts style files (no need for a `xint.ins`).

`1.03 (2013/04/14)`
----

  * new modules **xintfrac** (expandable operations on fractions) and
    **xintseries** (expandable partial sums with xint package).

  * slightly improved division and faster multiplication (the best
ordering of the arguments is chosen automatically).

  * added illustration of Machin algorithm to the documentation.

`1.0 (2013/03/28)`
----

Initial announcement:

>   The **xint** package implements with expandable TeX macros the basic
    arithmetic operations of addition, subtraction, multiplication
    and division, as applied to arbitrarily long numbers represented
    as chains of digits with an optional minus sign.

>  The **xintgcd** package provides implementations of the Euclidean
    algorithm and of its typesetting.

>  The packages may be used with Plain and with LaTeX.

%</changes>-------------------------------------------------------
%<*dtx>
\fi
\catcode`+ 0 \catcode`\\ 12 +iffalse
%</dtx>
%<*makefile>------------------------------------------------------
# This file: Makefile.mk (generated from xint.dtx)
# Tested on Mac OS X Mavericks with GNU Make 3.81,
# TeXLive 2014 and Pandoc 1.13.1.
# Either download the master Makefile from
#    http://mirror.ctan.org/macros/generic/xint
# or rename the present one as "Makefile".
# Then run "make" or equivalently "make help" to
# get instructions. Compilation of the complete
# documentation requires Pandoc.

# Note to myself: I wanted to use .RECIPEPREFIX = > but it is supported
# only with GNU Make 3.82 and later.

# this crazyness is to circumvent a problem with docstrip generation
# of the Makefile; we do not want two empty lines becoming only one
nullstring :=
define newline
$(nullstring)

endef
# will speed-up a little, I think.
newline := $(newline)

define helptext
==== INSTRUCTIONS

The Makefile is to automatize the extraction and compilation from
xint.dtx of package files and documentation files, and for producing
xint.tds.zip. It is for GNU/Linux like systems, with a teTeX like
installation such as TeXLive. Tested on Mac OS X Mavericks with TL2014.

For compiling the PDF files, packages newtx, newtxtt, etoc,... are used
and should be up-to-date (as of 2014/10). Conversion to plain, html and
pdf format of README.md and CHANGES.md (make PanPDF, make PanHTML)
require Pandoc software. (tested with Pandoc 1.13.1).

It is recommended to work with xint.dtx and Makefile in an otherwise
initially empty temporary repertory.

make help
    prints this help (using more). It will also have already extracted
    all files from xint.dtx.

make helpless
    prints this help (using less).

make xint.pdf
    extracts files and produces only xint.pdf, via latex+dvipdfmx.
    No Pandoc needed.

make sourcexint.pdf
    extracts files and produces only sourcexint.pdf, via latex+dvipdfmx.
    No Pandoc needed.

make PanPDF
    produces README.pdf and CHANGES.pdf, requires Pandoc.

make PanHTML
    produces README.html and CHANGES.html, requires Pandoc.

make doc
    produces all documentation.

make all
    produces all documentation, and creates xint.tds.zip.

make xint.tds.zip
    same as "make all"

make cleanall
    removes all generated files

==== INSTALLING

The following has been tested on a TeXLive installation:

make installhome
    creates xint.tds.zip, and unzips it in <TEXMFHOME>
        (it assumes there is no ls-R file there)

make installlocal
    creates xint.tds.zip, and unzips it in <TEXMFLOCAL>
        (and then does texhash <TEXMFLOCAL>)
    IT MIGHT BE NEEDED TO RUN IT AS "sudo make installlocal"
    This depends on how the access rights are configured.
    In case of doubt run first "make doc" and then "make
    installlocal". If the latter fails, "sudo make installlocal".

make uninstallhome
    removes all xint files and repertories from <TEXMFHOME>

make uninstalllocal
    removes all xint files and repertories from <TEXMFLOCAL>
        (and then does texhash <TEXMFLOCAL>)
    IT MIGHT BE NEEDED TO RUN IT AS "sudo make uninstalllocal"

endef

.PHONY: help helpless all extract doc PanPDF PanHTML clean cleanall\
        installhome uninstallhome installlocal uninstalllocal

# for printf with subst and \n, got it from
#     http://stackoverflow.com/a/5887751

# I could do the trick with := here, for \n substitution, but this would add
# tiny overhead to all other operations of make

help:
	@printf '$(subst $(newline),\n,$(helptext))' | more

helpless:
	@printf '$(subst $(newline),\n,$(helptext))' | less

# RM         = rm -f
JF_tmpdir  := $(shell mktemp -d jfbu_XXX)
TEXMF_local = $(shell kpsewhich -var-value TEXMFLOCAL)
TEXMF_home  = $(shell kpsewhich -var-value TEXMFHOME)
packages = xintkernel.sty xintcore.sty xint.sty xintfrac.sty xintexpr.sty\
             xintgcd.sty xintbinhex.sty xintseries.sty xintcfrac.sty\
             xinttools.sty
# Makefile.mk is not included in $(extracted). Its extraction rule is in
# master Makefile file. We can not extract Makefile from xint.dtx via
# docstrip, as .tex is always appended if a filename with no extension is
# specified. If "make -f Makefile.mk" is run, Makefile.mk will not be
# overwritten because tex xint.dtx does not extract it (etex xint.dtx does).
extracted  = $(packages) xint.tex xint.ins README.md CHANGES.md\
             doHTMLs.sh doPDFs.sh pandoctpl.latex
doc_pdf  = README.pdf CHANGES.pdf
doc_html = README.html CHANGES.html
filesfortex    = $(packages)
filesforsource = xint.dtx xint.ins Makefile
filesfordoc    = xint.pdf sourcexint.pdf README $(doc_pdf) $(doc_html)
auxiliaryfiles = xint.tex xint.dvi xint.aux xint.toc xint.log\
     sourcexint.dvi sourcexint.aux sourcexint.toc sourcexint.log\
     README.tex README.dvi README.aux README.toc README.out README.log\
     CHANGES.tex CHANGES.dvi CHANGES.aux CHANGES.toc CHANGES.out CHANGES.log
xint_cmd       = latex -interaction=nonstopmode xint
sourcexint_cmd = latex -interaction=nonstopmode -jobname=sourcexint\
                "\chardef\dosourcexint=1 \input{xint}"

all: $(extracted) doc xint.tds.zip
	@echo 'make all done.'

extract: $(extracted)

$(extracted): xint.dtx
	tex xint.dtx

doc: xint.pdf sourcexint.pdf README PanPDF PanHTML
	@echo 'make doc done.'

xint.pdf: xint.dtx xint.tex
	rm -f xint.aux xint.toc
	$(xint_cmd)
	$(xint_cmd)
	$(xint_cmd)
	dvipdfmx xint.dvi

sourcexint.pdf: xint.dtx xint.tex
	rm -f sourcexint.aux sourcexint.toc
	$(sourcexint_cmd)
	$(sourcexint_cmd)
	$(sourcexint_cmd)
	dvipdfmx sourcexint.dvi

README: README.md
	pandoc -t plain -o README README.md

PanPDF: $(doc_pdf)

$(doc_pdf): doPDFs.sh
	chmod u+x doPDFs.sh && ./doPDFs.sh

PanHTML: $(doc_html)

$(doc_html): doHTMLs.sh
	chmod u+x doHTMLs.sh && ./doHTMLs.sh

xint.tds.zip: $(filesfordoc) $(filesforsource) $(filesfortex)
	rm -fr $(JF_tmpdir)
	mkdir -p $(JF_tmpdir)/doc/generic/xint
	mkdir -p $(JF_tmpdir)/source/generic/xint
	mkdir -p $(JF_tmpdir)/tex/generic/xint
	chmod -R ugo+rwx $(JF_tmpdir)
	cp -a $(filesfordoc)    $(JF_tmpdir)/doc/generic/xint
	cp -a $(filesforsource) $(JF_tmpdir)/source/generic/xint
	cp -a $(filesfortex)    $(JF_tmpdir)/tex/generic/xint
	cd $(JF_tmpdir); chmod -R ugo+r doc source tex
	umask 0022 && cd $(JF_tmpdir) &&\
                zip -r xint.tds.zip doc source tex &&\
                mv -f xint.tds.zip ../
	rm -fr $(JF_tmpdir)
	@echo 'make xint.tds.zip done.'

xint.zip: $(filesfordoc) $(filesforsource) $(filesfortex) xint.tds.zip
	mkdir -p              $(JF_tmpdir)/xint
	chmod ugo+rwx         $(JF_tmpdir)/xint
	cp -a $(filesfordoc)    $(JF_tmpdir)/xint
	cp -a $(filesforsource) $(JF_tmpdir)/xint
	chmod -R ugo+r        $(JF_tmpdir)/xint
	mv xint.tds.zip       $(JF_tmpdir)/
	umask 0022 && cd $(JF_tmpdir) && zip -r xint.zip xint.tds.zip xint
	mv     $(JF_tmpdir)/xint.tds.zip ./
	mv -f  $(JF_tmpdir)/xint.zip ./
	rm -fr $(JF_tmpdir)
	@echo 'make xint.zip done.'

installhome: xint.tds.zip
	unzip xint.tds.zip -d $(TEXMF_home)

uninstallhome:
	cd $(TEXMF_home) && rm -fr  doc/generic/xint \
	                            source/generic/xint \
	                            tex/generic/xint

# cf http://stackoverflow.com/a/1909390
# as kpsewhich is very slow (.5s) I want to evaluate once only.
installlocal: xint.tds.zip
	$(eval $@_tmp := $(TEXMF_local))
	unzip xint.tds.zip -d $($@_tmp) && texhash $($@_tmp)

uninstalllocal:
	cd $(TEXMF_local) && rm -fr doc/generic/xint \
	                            source/generic/xint \
	                            tex/generic/xint && texhash .
clean:
	rm -f $(auxiliaryfiles)

cleanall: clean
	rm -f $(extracted) $(doc_pdf) $(doc_html)\
          README xint.pdf sourcexint.pdf xint.tds.zip
%</makefile>$------------------------------------------------------
%<*pandoctpl>-----------------------------------------------------
$if(dvipdfmx)$
{\csname @for\endcsname\x:=hyperref,graphicx,color,xcolor\do
    {\PassOptionsToPackage{dvipdfmx}\x}}
   \PassOptionsToPackage{dvipdfmx-outline-open}{hyperref}
   \PassOptionsToPackage{dvipdfm}{geometry}
$endif$
\documentclass[$papersize$,fontsize=$fontsize$]{scrartcl}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage{newtxtext}
\usepackage{newtxtt}
\usepackage{newtxmath}

\usepackage{upquote}

% pour les \texttt venant de la conversion par pandoc des `...`:
\begingroup\makeatletter
  \catcode`\'\active
  \catcode`\*\active
  \catcode`\`\active
\@firstofone {\endgroup
  \def\dostraightquotesandstar{% textcomp package is loaded by newtxtext
     \let`\textasciigrave 
     \let'\textquotesingle
     \edef*{\noexpand\raisebox{-.25\noexpand\height}{\string*}}%
     \catcode39\active % '
     \catcode96\active % `
     \catcode42\active }% *
}% for \texttt, let's just forget about math and italic correction things
\DeclareRobustCommand\texttt {\bgroup 
   \dostraightquotesandstar\afterassignment\ttfamily\let\next=}

$if(geometry)$
\usepackage[$for(geometry)$$geometry$$sep$,$endfor$]{geometry}
$endif$
$if(tables)$
\usepackage{longtable,booktabs}
$endif$
\usepackage[unicode=true,bookmarks]{hyperref}
\hypersetup{breaklinks=true,%
            pdfauthor={Jean-Fran\c cois B.},%
            pdftitle={$title$ $author$ $date$},%
            colorlinks=true,%
            citecolor=$if(citecolor)$$citecolor$$else$blue$endif$,%
            urlcolor=$if(urlcolor)$$urlcolor$$else$blue$endif$,%
            linkcolor=$if(linkcolor)$$linkcolor$$else$magenta$endif$,%
            pdfborder={0 0 0},%
            pdfstartview=FitH,%
            pdfpagemode=UseOutlines}
%%\urlstyle{same}  % don't use monospace font for urls

\setlength{\parindent}{0pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\usepackage{enumitem}
%% reduce LaTeX's insane vertical spacing around verbatim blocks
\setlength{\parskip}{\medskipamount}
\setlist[trivlist]{topsep=0pt,partopsep=0pt,itemsep=0pt,parsep=0pt}

$if(numbersections)$
\setcounter{secnumdepth}{5}
$else$
\setcounter{secnumdepth}{0}
$endif$

$if(etoc)$\usepackage{etoc}$endif$

\title{$title$}
\author{$author$}
\date{$date$}

$for(header-includes)$
$header-includes$
$endfor$

\begin{document}
$if(title)$
\maketitle
$endif$

$for(include-before)$
$include-before$

$endfor$

$if(toc)$
\setcounter{tocdepth}{$toc-depth$}
$if(etoc)$
\etocdefaultlines
\etocmulticolstyle[$etoc$]{}
$endif$
\tableofcontents
$endif$

$body$

$for(include-after)$
$include-after$

$endfor$
\end{document}
%</pandoctpl>-----------------------------------------------------
%<*dohtmlsh>------------------------------------------------------
#! /bin/sh
# produces README.html and CHANGES.html from README.md and CHANGES.md
# tested with pandoc 1.13.1

pandoc -o README.html -s --toc -V highlighting-css='    body{margin-left : 10%; margin-right : 15%; margin-top: 4ex; font-size: 14pt;}
    pre   {white-space: pre-wrap; }
    code  {white-space: pre-wrap; } 
    .mono {font-family: monospace;}' README.md

pandoc -o CHANGES.html -s --toc -V highlighting-css='    body{margin-left : 10%; margin-right : 15%; margin-top: 4ex; font-size: 14pt;}
    pre  {white-space: pre-wrap;}
    code {white-space: pre-wrap;}
    #TOC {float: right; position: relative; top: 100px; margin-bottom: 100px;}' CHANGES.md

%</dohtmlsh>------------------------------------------------------
%<*dopdfsh>-------------------------------------------------------
#! /bin/sh
# produces README.pdf and CHANGES.pdf from README.md and CHANGES.md
# via latex+dvipdfmx and custom pandoc latex template

pandoc -o README.tex --template=pandoctpl --toc -V papersize=a4paper -V fontsize=11pt -V dvipdfmx --variable=geometry:footskip=1cm,left=2.5cm,right=2.5cm,top=2cm,bottom=3cm -V etoc=1 README.md
rm -f README.aux README.toc README.out
latex -interaction=nonstopmode README
latex -interaction=nonstopmode README
latex -interaction=nonstopmode README
dvipdfmx README.dvi

pandoc -o CHANGES.tex --template=pandoctpl --toc -V papersize=a4paper -V fontsize=11pt -V dvipdfmx --variable=geometry:footskip=1cm,left=2.5cm,right=2.5cm,top=2cm,bottom=3cm -V etoc=2 CHANGES.md
rm -f CHANGES.aux CHANGES.toc CHANGES.out
latex -interaction=nonstopmode CHANGES
latex -interaction=nonstopmode CHANGES
latex -interaction=nonstopmode CHANGES
dvipdfmx CHANGES.dvi
%</dopdfsh>-------------------------------------------------------
%<*drv>-----------------------------------------------------------
%%
%% Run latex thrice on this file xint.tex then run dvipdfmx on 
%% xint.dvi to produce the documentation xint.pdf. Alternatively
%% run xelatex or pdflatex thrice on xint.tex.
%%
\NeedsTeXFormat{LaTeX2e}
\ProvidesFile{xint.tex}%
[\xintbndldate\space v\xintbndlversion\space driver file for xint documentation (jfB)]%
\PassOptionsToClass{a4paper,fontsize=10pt}{scrdoc}
\chardef\NoSourceCode 1 % set it to 0 if source code inclusion desired
\input xint.dtx
%%% Local Variables:
%%% mode: latex
%%% End:
%</drv>----------------------------------------------------------------------
%<*ins>-------------------------------------------------------------------------
%%
%% tex xint.ins extracts all package files from xint.dtx, as well as
%% xint.tex, README.md, CHANGES.md, doPDFs.sh, doHTMLs.sh. 
%%
%% etex xint.ins does the same plus extracts Makefile.mk.
%%
\input docstrip.tex
\askforoverwritefalse
\generate{\nopreamble\nopostamble
\file{README.md}{\from{xint.dtx}{readme}}
\file{CHANGES.md}{\from{xint.dtx}{changes}}
\file{doHTMLs.sh}{\from{xint.dtx}{dohtmlsh}}
\file{doPDFs.sh}{\from{xint.dtx}{dopdfsh}}
\ifx\numexpr\undefined\else\catcode9 11
            \file{Makefile.mk}{\from{xint.dtx}{makefile}}\fi
\usepreamble\defaultpreamble
\usepostamble\defaultpostamble
\file{pandoctpl.latex}{\from{xint.dtx}{pandoctpl}}
\file{xint.tex}{\from{xint.dtx}{drv}}
\file{xintkernel.sty}{\from{xint.dtx}{xintkernel}}
\file{xinttools.sty}{\from{xint.dtx}{xinttools}}
\file{xintcore.sty}{\from{xint.dtx}{xintcore}}
\file{xint.sty}{\from{xint.dtx}{xint}}
\file{xintbinhex.sty}{\from{xint.dtx}{xintbinhex}}
\file{xintgcd.sty}{\from{xint.dtx}{xintgcd}}
\file{xintfrac.sty}{\from{xint.dtx}{xintfrac}}
\file{xintseries.sty}{\from{xint.dtx}{xintseries}}
\file{xintcfrac.sty}{\from{xint.dtx}{xintcfrac}}
\file{xintexpr.sty}{\from{xint.dtx}{xintexpr}}}
\catcode32=13\relax% active space
\let =\space%
\Msg{************************************************************************}
\Msg{*}
\Msg{* To finish the installation you have to move the following}
\Msg{* files into a directory searched by TeX:}
\Msg{*}
\Msg{*     xintkernel.sty}
\Msg{*     xintcore.sty}
\Msg{*     xint.sty}
\Msg{*     xintbinhex.sty}
\Msg{*     xintgcd.sty}
\Msg{*     xintfrac.sty}
\Msg{*     xintseries.sty}
\Msg{*     xintcfrac.sty}
\Msg{*     xintexpr.sty}
\Msg{*     xinttools.sty}
\Msg{*}
\Msg{* To produce the documentation run latex thrice on xint.tex}
\Msg{* then dvipdfmx on xint.dvi. Edit xint.tex to get the code}
\Msg{* source included.}
\Msg{* dvipdfmx warnings may be ignored, but if the produced pdf}
\Msg{* has font problems, run rather pdflatex on xint.tex}
\Msg{*}
\Msg{* Happy TeXing!}
\Msg{*}
\Msg{************************************************************************}
\endbatchfile
%</ins>-------------------------------------------------------------------------
%<*dtx>
+fi % end of \iffalse block
+catcode`\ 0 \catcode`\+ 12
\chardef\noetex 0
\ifx\numexpr\undefined\chardef\noetex 1 \fi
\ifnum\noetex=1 \chardef\extractfiles 0 % extract files, then stop
\else
  \ifx\ProvidesFile\undefined
      \chardef\extractfiles 0 % no LaTeX2e: etex, xetex, ... on xint.dtx
  \else
      \ifx\NoSourceCode\undefined
        % latex/pdflatex/xelatex on xint.dtx, we will extract all files
        \chardef\extractfiles 1 % 1 = extract and typeset, 2 = only typeset
        \chardef\NoSourceCode 0 % 0 = include source code, 1 = do not
        \NeedsTeXFormat{LaTeX2e}%
        \PassOptionsToClass{a4paper,fontsize=10pt}{scrdoc}%
      \else
        % latex/pdflatex/xelatex on xint.tex
        \chardef\extractfiles 2 % no extractions, but typeset
        %  \NoSourceCode is set-up in xint.tex
      \fi
    \ProvidesFile{xint.dtx}[bundle source (\xintbndlversion, \xintbndldate) %
                             and documentation (\xintdocdate)]%
  \fi
\fi
\ifnum\extractfiles<2 % extract files
\def\MessageDeFin{\newlinechar10 \let\Msg\message
\Msg{^^J}%
\Msg{********************************************************************^^J}%
\Msg{*^^J}%
\Msg{* To finish the installation you have to move the following^^J}%
\Msg{* files into a directory searched by TeX:^^J}%
\Msg{*^^J}%
\Msg{*\space\space\space\space xintkernel.sty^^J}%
\Msg{*\space\space\space\space xintcore.sty^^J}%
\Msg{*\space\space\space\space xint.sty^^J}%
\Msg{*\space\space\space\space xintbinhex.sty^^J}%
\Msg{*\space\space\space\space xintgcd.sty^^J}%
\Msg{*\space\space\space\space xintfrac.sty^^J}%
\Msg{*\space\space\space\space xintseries.sty^^J}%
\Msg{*\space\space\space\space xintcfrac.sty^^J}%
\Msg{*\space\space\space\space xintexpr.sty^^J}%
\Msg{*\space\space\space\space xinttools.sty^^J}%
\Msg{*^^J}%
\Msg{* To produce the documentation run latex thrice on xint.tex^^J}
\Msg{* then dvipdfmx on xint.dvi. Edit xint.tex to get the code^^J}
\Msg{* source included.^^J}
\Msg{* dvipdfmx warnings may be ignored, but if the produced pdf^^J}
\Msg{* has font problems, run rather pdflatex on xint.tex^^J}
\Msg{*^^J}%
\Msg{* Happy TeXing!^^J}%
\Msg{*^^J}%
\Msg{********************************************************************^^J}%
}%
\begingroup
    \input docstrip.tex
    \askforoverwritefalse
    \catcode9 11 % do not kill TAB in producing Makefile.mk
    \generate{\nopreamble\nopostamble
    \file{README.md}{\from{xint.dtx}{readme}}
    \file{CHANGES.md}{\from{xint.dtx}{changes}}
    % pure tex will use ^^I notation for TAB character, don't want that.
    % there is a problem with xelatex, as it generates ^^I also.
    \ifnum\noetex=1 \else\ifx\XeTeXinterchartoks\undefined
        \file{Makefile.mk}{\from{xint.dtx}{makefile}}\fi\fi
    \file{doHTMLs.sh}{\from{xint.dtx}{dohtmlsh}}
    \file{doPDFs.sh}{\from{xint.dtx}{dopdfsh}}
    \usepreamble\defaultpreamble
    \usepostamble\defaultpostamble
    \file{pandoctpl.latex}{\from{xint.dtx}{pandoctpl}}
    \file{xint.ins}{\from{xint.dtx}{ins}}
    \file{xint.tex}{\from{xint.dtx}{drv}}
    \file{xintkernel.sty}{\from{xint.dtx}{xintkernel}}
    \file{xinttools.sty}{\from{xint.dtx}{xinttools}}
    \file{xintcore.sty}{\from{xint.dtx}{xintcore}}
    \file{xint.sty}{\from{xint.dtx}{xint}}
    \file{xintbinhex.sty}{\from{xint.dtx}{xintbinhex}}
    \file{xintgcd.sty}{\from{xint.dtx}{xintgcd}}
    \file{xintfrac.sty}{\from{xint.dtx}{xintfrac}}
    \file{xintseries.sty}{\from{xint.dtx}{xintseries}}
    \file{xintcfrac.sty}{\from{xint.dtx}{xintcfrac}}
    \file{xintexpr.sty}{\from{xint.dtx}{xintexpr}}}
\endgroup
\fi % end of file extraction (from etex/latex/pdflatex/... run on xint.dtx)
\ifnum\extractfiles=0 % no LaTeX, files now extracted. Stop.
  \MessageDeFin\expandafter\end
\fi
% From this point on, run is necessarily with e-TeX.
% Check if \MessageDeFin got defined, if yes put it at end of run.
\ifdefined\MessageDeFin\AtEndDocument{\MessageDeFin}\fi
%-------------------------------------------------------------------------------
\documentclass {scrdoc}
\ifdefined\dosourcexint % this toggle is set by a Makefile rule
    \chardef\NoSourceCode 0
\else
    \chardef\dosourcexint 0
\fi
\ifnum\NoSourceCode=1 \OnlyDescription\fi

% if latex, force output for dvipdfmx
\chardef\Withdvipdfmx 1 

\usepackage{ifpdf}
\ifpdf\chardef\Withdvipdfmx 0 \fi

\usepackage{ifxetex}
\ifxetex\chardef\Withdvipdfmx 0 \fi

\makeatletter
\ifnum\Withdvipdfmx=1
   \@for\@tempa:=hyperref,bookmark,graphicx,xcolor,pict2e\do
            {\PassOptionsToPackage{dvipdfmx}\@tempa}
   %
   \PassOptionsToPackage{dvipdfm}{geometry}
   \PassOptionsToPackage{bookmarks=true}{hyperref}
   \PassOptionsToPackage{dvipdfmx-outline-open}{hyperref}
   \PassOptionsToPackage{dvipdfmx-outline-open}{bookmark}
   %
   \def\pgfsysdriver{pgfsys-dvipdfm.def}
\else
   \PassOptionsToPackage{bookmarks=true}{hyperref}
\fi
\makeatother

\pagestyle{headings}
\makeatletter
\def\buggysectionmark #1{% KOMA 3.12 as released to CTAN December 2013
    \if@twoside\expandafter\markboth\else\expandafter\markright\fi
    {\MakeMarkcase{\ifnumbered{section}{\sectionmarkformat\fi}{}#1}}{}}
\ifx\buggysectionmark\sectionmark
\def\sectionmark #1{%
    \if@twoside\expandafter\markboth\else\expandafter\markright\fi
    {\MakeMarkcase{\ifnumbered{section}{\sectionmarkformat}{}#1}}{}}
\fi
\makeatother

\ifxetex
  %  noter cependant qu'il y a des diacritiques dans mes commentaires
  % de code, donc xelatex xint.dtx ncessiterait d'abord une conversion
  % en utf-8. Mais pour xelatex xint.tex sans le code source, ok.
\else
  \usepackage[T1]{fontenc}
  \usepackage[latin1]{inputenc}
\fi

\usepackage{multicol}

\usepackage{geometry}
% 11 octobre 2014
\AtBeginDocument {\ttzfamily
                  \newgeometry{textwidth=\dimexpr92\fontcharwd\font`X\relax,
                               vscale=0.75}}

\unless\ifnum\dosourcexint=1
\usepackage{xintexpr}
\usepackage{xintbinhex}
\usepackage{xintgcd}
\usepackage{xintseries}
\usepackage{xintcfrac}
\usepackage{amsmath} % for use of \cfrac in the documentation
\usepackage{pifont}  % pour la hollow star \ding{73}
\fi

\usepackage{xinttools}

\usepackage{enumitem}%  partir d'octobre 2014

\usepackage{varioref}
%\vrefwarning

\usepackage{etoolbox}
% Est-ce que je l'utilise vraiment? oui, \ifnumequal dans un \IsPrime

\usepackage{tocloft}% pour la TOC de la section locale du code pour
% xintexpr, il vaut mieux un look standard, mais je dois customiser la
% "numwidth", trop petite.


% 16 septembre 2015: j'ai oubli compltement pourquoi le | doit tre
% actif ici ...
\catcode`| \active
\usepackage{etoc}[2013/10/16] % I need \etocdepthtag.toc
\catcode`| 12

%---- USE OF ETOC FOR THE TABLES OF CONTENTS

\def\gobbletodot #1.{}

\newif\ifindescription % 1 avril 2014
\ifnum\dosourcexint=0
    \indescriptiontrue
\fi
\def\sectioncouleur{{cyan}}

\def\MARGEPAGENO {1.5em}% changera pour la partie implmentation

% 1er avril 2014, je fais un vrai style, un peu grossier cependant,
% alors qu'avant j'utilisais savedsectionline, par paresse.

% 12 octobre 2014, emploi \llap, \leftmargini et aussi de \MARGEPAGENO ici aussi
%     \leftmargini \dimexpr4\fontcharwd\font`X\relax
\etocsetstyle{section}{}
     {\normalfont}
     {\kern\bigskipamount
         \rightskip    \MARGEPAGENO\relax
         \parfillskip  -\MARGEPAGENO\relax
      \bfseries
         \leftskip \leftmargini
      \noindent\llap            %  \llap
      {\makebox[\leftmargini][l]%  et \leftmargini le 12/10/2014
              {\expandafter\textcolor\sectioncouleur {\etocnumber}}}%
      \strut\etocname
      \mdseries\nobreak\leaders\etoctoclineleaders\hfill\nobreak\strut
                             \makebox[\MARGEPAGENO][r]{\etocpage}\par
% pour les sous-sections (1 avril 2014)
      \let\ETOCsectionnumber\etocthenumber
      }%
     {}%

% Octobre 2014: emploi de \leftmargini et ajout de \parskip\z@skip.
%    \leftmargini \dimexpr4\fontcharwd\font`X\relax
%    \leftmarginii\dimexpr3\fontcharwd\font`X\relax
% Samedi 07 novembre 2015
% suite fusion, j'ai des numros de sous-sections plus longs.
% j'en profite aussi pour intervenir sur le filet central etc...
\newdimen\margegauchetoc
\AtBeginDocument{\margegauchetoc \dimexpr 5\fontcharwd\font`X\relax}
\makeatletter
\etocsetstyle{subsection}
    {\begingroup\normalfont
     \setlength{\premulticols}{0pt}%
     \setlength{\multicolsep}{0pt}%
     \setlength{\columnsep}{\leftmarginii}%
     \setlength{\columnseprule}{.4pt}% n'influence pas sparation colonnes
     % Octobre 2014 mes problmes d'alors taient lis  la glue dans \parskip
     \parskip\z@skip
     % j'avais seulement ceci avant, je laisse les deux
     \raggedcolumns
     \addvspace{\smallskipamount}%
     \begin{multicols}{2}
     \leftskip  \margegauchetoc % 12 octobre 2014
%     \rightskip \MARGEPAGENO plus 2em minus 1em % 18 octobre 2013
% finalement Samedi 07 novembre 2015
     \ifindescription
        \rightskip \MARGEPAGENO
     \else
        \rightskip \MARGEPAGENO plus 2em minus 1em 
     \fi
     \parfillskip -\MARGEPAGENO\relax
    }
    {}
    {\noindent
     \llap{\makebox[\margegauchetoc][l]{\ttzfamily\bfseries\etoclink
             {\ifindescription\expandafter\textcolor\sectioncouleur
               {\normalfont\bfseries\ETOCsectionnumber}\fi
              .\expandafter\gobbletodot\etocthenumber}}}%
     \strut\etocname\nobreak
     \unless\ifindescription\leaders\etoctoclineleaders\fi
     \hfill\nobreak
     \strut\makebox[\MARGEPAGENO][r]{\small\etocpage}\endgraf }
    {\end{multicols}\endgroup\addvspace{\smallskipamount}}%

% Septembre 2015, 
% je rajoute un style de subsubsection pour la local toc dans sourcexint.pdf
% pour xintcore.
%
% Dans le manuel pas de sous-sous-section dans les TOCs, et dans
% sourcexint.pdf il y avait dj celle de xintexpr, mais avec le style
% standard customis par tocloft.
% 
\etocsetstyle{subsubsection}
    {\begingroup\normalfont\small
     \leftskip  \dimexpr\leftmargini+1em\relax }
    {}
    {\noindent
     \llap{\makebox[\dimexpr\leftmargini+1em\relax][l]%
           {\ttzfamily\bfseries\etoclink
                    {.\expandafter\gobbletodot\etocthenumber}}}%
     \strut\etocname\nobreak
     \leaders\etoctoclineleaders
     \hfill\nobreak
     \strut\makebox[\MARGEPAGENO][r]{\small\etocpage}\endgraf }
    {\endgroup }%

\makeatother

\addtocontents{toc}{\protect\hypersetup{hidelinks}}

\usepackage[zerostyle=a,straightquotes,scaled=0.95]{newtxtt}
% j'ai essay zerostyle=e, finalement je reviens  =a
\usepackage{newtxmath}

\makeatletter

% I need also the font with a slashed zero, for verbatim code.

% Mardi 18 novembre 2014  09:06:44
% Test de newtxtt 1.05, 'q' pour uprightquotes
% (maintenant: straightquotes)

\DeclareFontFamily{T1}{newtxttb}{\hyphenchar\font\m@ne}

\DeclareFontShape{T1}{newtxttb}{m}{n}{
      <-> s*[\newtxtt@scale]newtxttbq
}{}
\DeclareFontShape{T1}{newtxttb}{b}{n}{
      <-> s*[\newtxtt@scale]newtxbttbq
}{}
\DeclareFontShape{T1}{newtxttb}{bx}{n}{
      <-> ssub * newtxttb/b/n
}{}
\DeclareFontShape{T1}{newtxttb}{m}{sl}{
     <-> s*[\newtxtt@scale]newtxttslbq
}{}
\DeclareFontShape{T1}{newtxttb}{m}{it}{
     <-> ssub * newtxttb/m/sl
}{}

\makeatother

% this is with a slashed 0 like the original txtt.
\newcommand\ttbfamily {\fontfamily{newtxttb}\selectfont }

% I will leave this old markup here for the time being, in case there
% is later some use to it. 
% 11 octobre, j'essaie couleur, YellowOrange, CadetBlue
% \def\digitstt {\bgroup \color[named]{OrangeRed}\let\next=}

% Mardi 18 novembre 2014  09:07:30
% test des old style figures par \textsc
% ATTENTION  cause emploi d'argument pouvant contenir des tokens comme \if 
% (cf lignes environ 5319)
% Finalement pour release doc du 7 mars 2015, je n'utilise pas old style
%\def\digitstt #1{\begingroup\color[named]{OrangeRed}%
%    \unless\ifmmode\scshape\fi #1\endgroup}
\def\digitstt #1{\begingroup\color[named]{OrangeRed}#1\endgroup}

\let\dtt\digitstt

\ifnum\dosourcexint=1
\else
% Septembre 2014 emploi de mathastext
\renewcommand\familydefault\ttdefault
\usepackage[noendash]{mathastext}% pas de endahs dans newtxtt
\fi
\renewcommand\familydefault\sfdefault % <-- sans-serif in footnotes, TOC,
                                % headers etc...

\usepackage{xspace}
\usepackage[dvipsnames]{xcolor}
\usepackage{framed}

% 14 octobre 2014
% copi de snugshade de framed.sty
\makeatletter
\newenvironment{snugframed}{%
% transfr ici 17 octobre 
  \fboxsep \dimexpr2\fontcharwd\font`X\relax
  \advance\linewidth-2\fboxsep
  \advance\csname @totalleftmargin\endcsname \fboxsep
  \def\FrameCommand##1{\hskip\@totalleftmargin
                       \hskip-\fboxsep
                       \fbox{##1}\hskip-\fboxsep
      % There is no \@totalrightmargin, so:
      \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
    \MakeFramed {\advance\hsize-\width \@totalleftmargin\z@ \linewidth\hsize
    \@setminipage}%
 }{\par\unskip\@minipagefalse\endMakeFramed}
\makeatother

\definecolor{joli}{RGB}{225,95,0}
\definecolor{JOLI}{RGB}{225,95,0}
\definecolor{BLUE}{RGB}{0,0,255}
\definecolor{niceone}{RGB}{38,128,192}

\usepackage[para]{footmisc}

\usepackage[english]{babel}
\usepackage[autolanguage,np]{numprint}
\AtBeginDocument{\npthousandsep{,\hskip .5pt plus .1pt minus .1pt}}

\usepackage[pdfencoding=pdfdoc]{hyperref}

\hypersetup{%
linktoc=all,%
breaklinks=true,%
colorlinks=true,%
urlcolor=niceone,%
linkcolor=blue,%
pdfauthor={Jean-Fran\c cois B.},%
pdftitle={The xint bundle},%
pdfsubject={Arithmetic with TeX},%
pdfkeywords={Expansion, arithmetic, TeX},%
pdfstartview=FitH,%
pdfpagemode=UseOutlines}

\ifnum\dosourcexint=1 
\hypersetup{pdftitle={The xint bundle source code}}
\fi

\usepackage{bookmark}

\usepackage{picture} % permet d'utiliser des units dans les dimensions de la
                     % picture et dans \put
\usepackage{graphicx}
\usepackage{eso-pic}

%---- \MyMarginNote: a simple macro for some margin notes with no fuss
% je m'aperois que je peux l'utiliser dans les footnotes...
\makeatletter
\def\MyMarginNote {\@ifnextchar[\@MyMarginNote{\@MyMarginNote[]}}%
% 18 janvier 2014, j'ai besoin d'un raccourci.
\let\inmarg\MyMarginNote
\def\@MyMarginNote [#1]#2{%
    \vadjust{\vskip-\dp\strutbox
             \smash{\hbox to 0pt
                       {\color[named]{PineGreen}\normalfont\small
                        \hsize 1.6cm\rightskip.5cm minus.5cm
                        \hss\vtop{\offinterlineskip #2}\ $\to$#1\ }}%
             \vskip\dp\strutbox }\strut{}}
\def\MyMarginNoteWithBrace #1{%
    \vadjust{\vskip-\dp\strutbox
             \smash{\hbox to 0pt
                       {\color[named]{PineGreen}%\normalfont\small
                        \hss #1\ $\bigg\{$\ }}%
             \vskip\dp\strutbox }\strut{}}
\def\IMPORTANT {\MyMarginNoteWithBrace 
   {\raisebox{-.5\height}{\resizebox{2\width}{!}{\ding{43}}}}}
% 26 novembre 2013:
\def\etype #1{%
    \vadjust{\vskip-\dp\strutbox
             \smash{\hbox to 0pt {\hss\color[named]{PineGreen}%
                    \itshape \xintListWithSep{\,}{#1}\ $\star$\quad }}%
             \vskip\dp\strutbox }\strut{}}
\def\retype #1{%
    \vadjust{\vskip-\dp\strutbox
             \smash{\hbox to 0pt {\hss\color[named]{PineGreen}%
                    \itshape \xintListWithSep{\,}{#1}\ \ding{73}\quad }}%
             \vskip\dp\strutbox }\strut{}}
\def\ntype #1{%
    \vadjust{\vskip-\dp\strutbox
             \smash{\hbox to 0pt {\hss\color[named]{PineGreen}%
                    \itshape \xintListWithSep{\,}{#1}\quad }}%
             \vskip\dp\strutbox }\strut{}}
%-------------------------------------------------------------------------------
\def\Numf {{\vbox{\halign{\hfil##\hfil\cr \footnotesize
    \upshape Num\cr
    \noalign{\hrule height 0pt \vskip1pt\relax}
    \itshape f\cr}}}}
\def\Ff {{\vbox{\halign{\hfil##\hfil\cr \footnotesize
    \upshape Frac\cr
    \noalign{\hrule height 0pt \vskip1pt\relax}
    \itshape f\cr}}}}
\def\numx {{\vbox{\halign{\hfil##\hfil\cr \footnotesize
    \upshape num\cr
    \noalign{\hrule height 0pt \vskip1pt\relax}
    \itshape x\cr}}}}
%-------------------------------------------------------------------------------
% 24 fvrier 2014. J'ai besoin de me dbarasser du \to
\def\NewWith #1{%
    \vadjust{\vskip-\dp\strutbox
             \smash{\hbox to 0pt {\hss\color[named]{PineGreen}%
                        \normalfont\small
                        \hsize 1.5cm\rightskip.5cm minus.5cm
                        \vtop{\noindent New with #1}\ }}%
             \vskip\dp\strutbox }\strut{}}

\makeatother

% \centeredline: OUR OWN LITTLE MACRO FOR CENTERING LINES
% =======================================================

% 7 mars 2013
% -----------
%
% This macro allows to conveniently center a line inside a paragraph and still
% allow use therein of \verb or other commands changing catcodes.
% A proposito, the \LaTeX \centerline uses \hsize and not \linewidth !
% (which in my humble opinion is bad)

% Actually my \centeredline works nicely in list environments.

% \ignorespaces ajout le 9 juin 2013.

% Note: \centeredline creates a group

\makeatletter
\newcommand*\centeredline {%
      \ifhmode \\\relax
        \def\centeredline@{\hss\egroup\hskip\z@skip\ignorespaces }%
      \else
        \def\centeredline@{\hss\egroup }%
      \fi
      \afterassignment\@centeredline
      \let\next=}
\def\@centeredline
    {\hbox to \linewidth \bgroup \hss \bgroup \aftergroup\centeredline@ }

% 12 octobre 2014
% ---------------
% 
% \centeredline-->\leftedline. 
% And I add colored background. I have more sophisticated approaches, but the
% mark-up was essentially already there, thus I just wanted to exploit the
% manual from 1.09n for the transition to 1.1.
%

\newif\ifinlefted

\newcommand*\leftedline {%
      \ifhmode \\\relax
        \def\leftedline@{\hss\egroup\hskip\z@skip\ignorespaces }%
      \else
        \def\leftedline@{\hss\egroup }%
      \fi
      \afterassignment\@leftedline
      \let\next=}
\def\@leftedline
    {\hbox to \linewidth \bgroup \inleftedtrue
                         \everbatimeverypar
                         \bgroup 
                         \aftergroup\leftedline@ }

\makeatother

% verbatim environments
% =====================
% 
% June 2013, then October 2014.
% -----------------------------
%
\makeatletter
\catcode`_ 11

% some of my verbatim environments do not make the space active (\lverb e.g.). Then
% \do@noligs must be modified, \char`#1 must be followed by a space token, else,
% the `#1 expansion will swallow one space.
\def\do@noligs #1{%
  \catcode`#1\active
  \begingroup
     \lccode`~`#1\relax
     \lowercase{%
  \endgroup\def~{\leavevmode\kern\z@\char`#1 }}%
}

%--- \lowast
\def\lowast{\raisebox{-.25\height}{*}}
\catcode`* 13
\def\makestarlowast {\let*\lowast\catcode`\*\active}%
\catcode`* 12

%--- straight quotes, added (finally...) Nov 2, 2014
%--- obsolete with use of newtxtt 1.05, late 2014

% \begingroup\makeatletter
%   \catcode`\'\active
%   \catcode`\`\active
% \@firstofone {\endgroup
%   \def\makequotesstraight{% assumes textcomp package
%      \let`\textasciigrave 
%      \let'\textquotesingle
%      \catcode39\active
%      \catcode96\active }%
% }
    
%--- for soft-wrapping. I will use discretionaries.

\DeclareFontFamily{U}{MdSymbolC}{}
\DeclareFontShape {U}{MdSymbolC}{m}{n}{<-> MdSymbolC-Regular}{}

\newbox\SoftWrapIcon
\colorlet {softwrapicon}{blue}

\def\SetSoftWrapIcon{%
    \setbox\SoftWrapIcon\hb@xt@\z@ 
    {\hb@xt@\fontdimen2\font
        {\hss{\color{softwrapicon}\usefont{U}{MdSymbolC}{m}{n}\char"97}\hss}%
     \hss}%
   }

\AtBeginDocument {\SetSoftWrapIcon }% ttzfamily dj fait

%--- \MacroFont, and a \MicroFont
% 
% Ne PAS mettre de changement de taille de police dans \MacroFont.

% 17/10/2014, essai avec CadetBlue aprs Purple. Puis Blue

\def\restoreMicroFont {\def\MicroFont {\ttbfamily\makestarlowast
    \ifinlefted\else\ifineverb\else\color[named]{Blue}\fi\fi}}
\restoreMicroFont

% Notice that \macrocode uses \macro@font which freezes \MacroFont
% at \begin{document}. But doc.sty verbatim uses \MacroFont which is not
% frozen. Comprenne qui pourra...

\def\restoreMacroFont {\def\MacroFont {\ttbfamily
    \ifinlefted\else\ifineverb\else\color[named]{Blue}\fi\fi}}
\restoreMacroFont

%--- straight quotes, also in macrocode (2014/11/04)
%
% There is no hook in \macrocode after \dospecials, which is done *after*
% \macro@font. Thus I will need to take the risk that some future evolution of
% doc.sty (or perhaps scrdoc) invalidates the following.
%
% Note: in contrast, \MacroFont in \verbatim is done *after* \dospecials (but
% before the space becomes active), thus I could use \MacroFont there. But as
% there is no verbatim environment anymore in xint.dtx, I don't need to take
% care of it.
%
% Actually, I should not at all rely on the doc class, I should do it all by
% myself. As I don't use at all \DocInput (which caused me loads of problems
% back then when I was trying to get a workflow satisfying my views on how
% .dtx files should be structured), there is not much rationale for using the
% doc class.
%

\def\macrocode{\macro@code
               \frenchspacing \@vobeyspaces
               \makestarlowast %\makequotesstraight
               \xmacro@code }


% ---- a new \verb

% Initially, June 2013, then Sep 9, 2014, and Oct 9-12 2014
%
% Initial motivation was simply that doc.sty and related classes \verb
% command is with a hard-coded \ttfamily. There were further issues.
%
% 1. with |stuff with space|, paragraph reformatting in the Emacs/AUCTeX
% buffer caused havoc. Thus I wanted to be able to have the input across
% lines.
%
% 2. Hence I did not want to have spaces obeyed, as often the
% reformatting added spaces at the beginning of a line.
%
% 3. Also I wanted to allow hyphenation on output, at least at some
% locations. I did a first version which treated spaces, \, {, and }
% specially.
%
% 4. at some point I wanted to add some colored background (I have
% dropped that since due to pdf file size increase).
%
% 5. and also I got fed up from the non-compatibility with footnotes due
% to catcode freeze.
%
% Because of 5. I opted for a \scantokens approach, hence for a macro
% with delimited argument. Here is what I do now, this is compatible
% with short verbs.

\def\verb
{%
  \relax \ifmmode\else\leavevmode\null\fi
  \bgroup
  \let\do\@makeother \dospecials
  %\makequotesstraight  % belatedly added for 1.1a release
  \MicroFont % change font, color, catcode hooks, ...
  \catcode 32 10
  \endlinechar 32
  \@@jfverb 
}% 
% Note (Oct 12, 2014): in the improbable situation a newlinechar is
% found in the ##1, \scantokens will convert this to an end of line in
% its "write" phase, which will be then ignored in its "read" phase due
% to \endlinechar-1. This also avoids possible creation of \par which
% would defeat \@@jfverb@@. Thus it is good.
\def\@@jfverb #1{%
   \ifcat\noexpand#1\noexpand~\catcode`#1\active\fi
% No problem with the EOL for the line where the short verb delimiter stands.
   \def\next ##1#1{%
            \@vobeyspaces\everyeof{\relax}\endlinechar\m@ne
            \expandafter\@@jfverb_a\scantokens\expandafter{##1}}%
% hack with \@empty to prevent brace stripping if catcodes have been
% frozen earlier, like in footnotes.
   \next \@empty
}

% We don't want a \discretionary at the very start.
% But then an empty argument is forbidden!
\def\@@jfverb_a #1{#1\@@jfverb_b }

\def\@@jfverb_b #1{\ifx\relax #1%
        \egroup
      \else
% \penalty\z@, or rather (Oct 11, 2014) but I then adjust the textwidth
% precisely: 
      \discretionary{\copy\SoftWrapIcon}{}{}%
        #1\expandafter\@@jfverb_b\fi 
}

\catcode`_ 8
\makeatother

% --- \lverb
% Dfinition de \lverb
\makeatletter
\long\def\lverb {%
  \relax\par\smallskip\noindent\null
  \begingroup
  \bgroup
    \aftergroup\@@par \aftergroup\endgroup \aftergroup\medskip
    \let\do\do@noligs  \verbatim@nolig@list
    \let\do\@makeother \dospecials
    %\makequotesstraight  % belatedly added for 1.1a release
    \catcode32 10 \catcode`\% 9 \catcode`\& 14 \catcode`\$ 0
  \MicroFont % sera donc en couleur.
    \@lverb
}

\def\@lverb #1{\catcode`#1\active
               \lccode`\~`#1\lowercase{\let~\egroup}}%
\makeatother
%--- everbatim environment
% October 13-14, 2014
% Verbatim with an \everypar hook, mainly to have background color, followed by
% execution of the code 

\makeatletter
\catcode`_ 11

\def\everbatimtop {\MacroFont\small }
\let\everbatimbottom\relax
\let\everbatimhook\relax

\newif\ifineverb

\def\everbatim {\s@everbatim\@everbatim }
\@namedef{everbatim*}{\s@everbatim\expandafter\@everbatimx\expandafter
                      {\the\newlinechar}}

\def\everbatimeverypar{\strut
                   {\color{yellow!5}\vrule\@width\linewidth }%
                   \kern-\linewidth
                   \kern\everbatimindent }
\def\everbatimindent {\z@}
% voir plus loin atbegindocument

\def\endeverbatim    {\if@newlist \leavevmode\fi\endtrivlist }
\expandafter\let\csname endeverbatim*\endcsname \endeverbatim

\def\s@everbatim {%
     \ineverbtrue
     \everbatimtop % put there size changes
       \topsep    \z@skip
       \partopsep \z@skip
       \itemsep   \z@skip
       \parsep    \z@skip
       \parskip   \z@skip
       \lineskip  \z@skip
     \let\do\@makeother \dospecials
     \let\do\do@noligs  \verbatim@nolig@list 
     \makestarlowast
     \everbatimhook
     \trivlist\item\relax
       \leftskip   \@totalleftmargin
       \rightskip  \z@skip
       \parindent  \z@
       \parfillskip\@flushglue
       \parskip    \z@skip
       \@@par
       \def\par{\leavevmode\null\@@par\pagebreak[1]}% 
       \everypar\expandafter{\the\everypar \unpenalty
                \everbatimeverypar 
                \everypar \expandafter{\the\everypar\everbatimeverypar}%
       }%
       \obeylines \@vobeyspaces 
}

\begingroup
\lccode`X 13
\catcode`X \active
\lccode`Y `* % this is because of \makestarlowast.
% I have to think whether this is useful: obviously if I were to provide
% everbatim and everbatim*  in a package I wouldn't do that.
\catcode`Y  \active
\catcode`| 0 \catcode`[ 1 \catcode`] 2 \catcode`* 12
\catcode`{ 12 \catcode`} 12 |catcode`\\ 12
|lowercase[|endgroup% both freezes catcodes and converts X to active ^^M
|def|@everbatim #1X#2\end{everbatim}%
  [#2|end[everbatim]|everbatimbottom ]
|def|@everbatimx #1#2X#3\end{everbatimY}]%
  {#3\end{everbatim*}%
     \everbatimbottom
     % No group here: this allows executed code to make macro
     % definitions which may reused in later uses of everbatim.
     % But the problem is with colors... j'ai visiblement un problme
     % avec le color stack pour dvipdfmx avec les \colorlet/\color
     \newlinechar 13
     % Indentation of next paragraph produced from execution of #3 is
     % suppressed, if #3 by itself or \everbatimbottom does no \par, 
     % from \@endparenv done by \endtrivlist
     \everbatimxprehook
     \scantokens {#3}% there will typically be an EOL space after this if one
                     % continues after \end{everbatim} on same line, which
                     % is allowed.
     \newlinechar #1\relax % restores \newlinechar to previous value.
     \everbatimxposthook
}%

% L'espace venant du endofline final mis par \scantokens sera inhib si #3 se
% termine par un % ou un \x, etc... 

% Mercredi 16 septembre 2015  19:40:28
% ENFIN! compris et rsolu mes problmes de color stack overflow !!!
% Je ne pouvais pas crer de groupes car je fais des dfinitions dans les
% everbatim*. Et je n'allais pas re-parcourir le source pour identifier
% tous les everbatim* faisant des dfinitions ...
\def\everbatimxprehook {\colorlet{everbsavedcolor}{.}\color[named]{OrangeRed}}
\def\everbatimxposthook {\color{everbsavedcolor}}
\ifpdf
% 17 septembre, je fais un essai, pour voir, cf pdftex.def/color.sty
% Pour dterminer la spcification, j'ai fait un
% \typeout{\meaning\current@color} dans un run de test
% a marche
   \def\everbatimxprehook 
      {\pdfcolorstack\@pdfcolorstack push{0 1 0.5 0 k 0 1 0.5 0 K}\relax}
   \def\everbatimxposthook
      {\pdfcolorstack\@pdfcolorstack pop\relax}
\else
\ifxetex
   \def\everbatimxprehook  {\special{color push cmyk 0 1 0.5 0}}
   \def\everbatimxposthook {\special{color pop}}
\else
\ifnum\Withdvipdfmx=1 % enfin problme rsolu pour dvipdfmx !!!
                      % et donc aprs idem pour xelatex (et mme pdf)
     \def\everbatimxprehook  {\special{pdf:bcolor  OrangeRed}}
     \def\everbatimxposthook {\special{pdf:ecolor}}
\fi\fi\fi

% MAIS ATTENTION: \normalcolor dans les everbatim du Quick Sort provoquait
% un terrible color leak pour dvipdfmx et AUSSI pour xelatex; pour ce dernier
% le color leak avec les \special plus haut tait terriblissime...
% >>> Mercredi 16 septembre 2015  20:51:49          <<<
% >>> MAIS MAINTENANT J'AI DONC LA SOLUTION COMPLTE <<<

% J'ai aussi vrifi que supprimer les deux \normalcolor ne rsolvait pas en
% soi le problme, il faut aussi les \special ci-dessus, sinon le color leak
% apparaissait certes plus loin mais il tait l. Il y a quelques autres
% \normalcolor dans les everbatim* j'ai pas essay en les supprimant tous.

% --- \everb
% Original was called \dverb and I did it in June 2013.
% Then after doing everbatim, I transformed \dverb, now called \everb
% for itself being as compatible as standard verbatim with list making
% surrounding environments.
% Supposed to be used as 
% \everb|@ this will be ignored
% stuff
% escape character: "
% | not necessarily starting a line.
% I chose @ as comment character, mainly for pretty-formatting of the
% source, this can be changed by \everbhook.

% " comme caractre d'chappement. Par exemple pour colorier des parties.
\def\restoreeverbhook{\def\everbhook{%
     \def\"{\begingroup\catcode123 1 \catcode 125 2 \everbescape }%
     \catcode`\" 0 \catcode`\@ 14
}}\restoreeverbhook

\def\everbescape #1;!{#1\endgroup }

\def\everb {%
    \bgroup
    \let\everbatimhook\everbhook
    \s@everbatim
    \@everb
}

\def\@everb #1{\catcode`#1\active
               \lccode`\~`#1%
               \lowercase{\def~{\if@newlist \leavevmode\fi
                                \endtrivlist 
                                \egroup
                                \@doendpe
                                \everbatimbottom }}%
              }%

\catcode`_8
\makeatother

%--- \csa, \csbxint, \csh, \csbh
% dates back to earliest versions of this manual, but I changed things a bit
% (back then for example @ was active throughout the document...)
% The mark-up being in place, I only have to use it here.

\DeclareRobustCommand\csa [1]
% attention que le \expandafter est ncessaire ici, sinon \scantokens n'agit
% pas sur ce que produit \detokenize. Par ailleurs \MicroFont fait
% \makestarlowast (et c'est seulement  cause de * que je fais \scantokens)
% Attention cependant aux _ maintenant dans les noms de macros
    {{\MicroFont\char92\endlinechar-1 \catcode`_ 11
                       \scantokens\expandafter{\detokenize{#1}}}}

\DeclareRobustCommand\csbnolk [1]
    {{\MicroFont\char92\endlinechar-1 \scantokens\expandafter{\detokenize{#1}}}}

\DeclareRobustCommand\csbxint [1]
        {\hyperref[\detokenize{xint#1}]%
          {{\ttzfamily\char92\mbox{xint}\-\endlinechar-1 \makestarlowast
                 \scantokens\expandafter{\detokenize{#1}}}}}

\newcommand\csh[1]
    {\texorpdfstring{\csa{#1}}{\textbackslash\detokenize{#1}}}
\newcommand\csbh[1]
    {\texorpdfstring{\csbnolk{#1}}{\textbackslash\detokenize{#1}}}

% --- \xintname, \xintnameimp etc... 

% 7 mars 2015, je rsous (non!) un problme de color stack overflow avec
% dvipdfmx qui venait au final des page headers, et  cause d'un brace
% stripping qui enlevait la protection de mes \color ci-dessous. Il a suffi de
% rajouter un \empty pour me dbarrasser finalement du problme.
%
% Bon c'est bizarre, en fait le problme n'est pas rsolu. Aprs avoir
% supprim fichiers auxiliaires et recompil, il revient.

% Problme finalement rsolu le 16 septembre 2015 
% cf \everbatimxprehook

%  noter que \hyperref fait un color, donc le color{joli} en fait un
% supplmentaire, difficile d'viter. Alourdit le dvi, mais bref.

\xintForpair #1#2 in
{(xintkernel,kernel),
 (xinttools,tools),
 (xintcore,core),(xint,xint),(xintbinhex,binhex),(xintgcd,gcd),%
 (xintfrac,frac),(xintseries,series),(xintcfrac,cfrac),(xintexpr,expr)}
\do
{%
 \expandafter\def\csname #1name\endcsname
   {\texorpdfstring
                  {\hyperref[sec:#2]%
                     {\relax{\color{joli}\ttzfamily #1}}}
                  {#1}%
    \xspace }%
 \expandafter\def\csname #1nameimp\endcsname
   {\texorpdfstring
                  {\hyperref[sec:#2imp]%
                    {\relax{\color[named]{RoyalPurple}\ttzfamily #1}}}
                  {#1}%
    \xspace }%
}%

%--- \printnumber
% new version, october 11, 2014
\catcode`_ 11
\makeatletter
\hyphenpenalty \z@

\def\allowsplits_a #1{\ifx \relax #1\xint_dothis\xint_gobble_i\fi
                    \if ,#1\xint_dothis {\discretionary{\rlap,}{}{,} }\fi
                    \xint_orthat{\discretionary
                           {\copy\SoftWrapIcon}%
                           {}%
                           {}#1}\allowsplits_a }%

\def\allowsplits #1{#1\allowsplits_a}% vite un discretionary au premier.

\def\printnumber #1{\expandafter\allowsplits \romannumeral-`0#1\relax }%

\makeatother
\catcode`_ 8

%--- counts used in particular in the samples from the documentation of the
%    xintseries.sty package
\newcount\cnta
\newcount\cntb
\newcount\cntc

%--- \fexpan 22 octobre 2013
\newcommand\fexpan {\textit{f}-expan}

\ifnum\dosourcexint=1
\else
% Dependency graph done using TikZ (manually)
  \usepackage{tikz}
  \usetikzlibrary{shapes,arrows}
\fi

\colorlet {codeboxbg}{yellow!10}
\colorlet {codeboxframe}{black!30}
\colorlet {execboxfringe}{black!10}

% 12 octobre 2014
\AtBeginDocument{%
    \leftmargini \dimexpr4\fontcharwd\font`X\relax
    \leftmarginii\dimexpr3\fontcharwd\font`X\relax
    \leftmarginiii \leftmarginii
    \leftmarginiv  \leftmarginii
    \parindent\dimexpr2\fontcharwd\font`X\relax
    \leftmargin\leftmargini % pourquoi pas 0?
% attention  un deuxime relax!
%\advance\linewidth\dimexpr-\everbatimindent-\everbatimindent\relax
% tait alors bogu! 
    \edef\everbatimindent{\the\dimexpr\leftmargini\relax\space }%
    \cftsubsecnumwidth    2\leftmarginii
    \cftsubsubsecnumwidth 2\leftmargini
    \cftsubsecindent 0pt
    \cftsubsubsecindent \cftsubsecnumwidth
}%

\frenchspacing
\renewcommand\familydefault\sfdefault

% Septembre 2015
\def\liiibigint{\href{http://latex-project.org/svnroot/experimental/trunk/l3trial/l3bigint}{l3bigint}}
% % pour accder  l'historique des commits:
% % https://github.com/latex3/latex3/tree/master/l3trial/l3bigint


% 20 octobre 2015 hier j'ai un peu rapidement remplac les \romannumeral-`0
% dans le code par de mystrieux \romannumeral`<character0catcode12>, en T1,
% newtxtt donne un ` pour le slot 0, les quelques occurrences de \meaning
% aprs \xintNewExpr dans la doc donne donc un bien mystrieux `` en output.

\makeatletter
\def\fixmeaning {\expandafter\fix@meaning\meaning}
\expandafter\edef\expandafter\fix@meaning
            \expandafter #\expandafter1\string\romannumeral#2#3%
            {#1\string\romannumeral`\string^\string^@}
\makeatother

% 2015/11/18:
\xintverbosetrue

\begin{document}\thispagestyle{empty}% \ttzfamily already done
\pdfbookmark[1]{Title page}{TOP}
% \makeatletter % @ n'est plus actif dans dtx 1.1, ouf!

{%
\normalfont\Large\parindent0pt \parfillskip 0pt\relax
 \leftskip 2cm plus 1fil \rightskip 2cm plus 1fil
\ifnum\dosourcexint=1
 The \xintnameimp source code\par
\else
 The \xintname bundle\par
\fi
}

{\centering
  \textsc{Jean-Fran\c cois B.}\par
  \footnotesize
  2589111+jfbu@users.noreply.github.com\par
  Package version: \xintbndlversion\ (\xintbndldate);
            documentation date: \xintdocdate.\par
  {From source file \texttt{xint.dtx}. \xintdtxtimestamp.}\par
}

\bigskip

% Mercredi 08 octobre 2014  22:03:19
% Skips safely.
\ifnum\dosourcexint=1
\catcode`+ 0 \catcode0 9 % n'importe quoi sauf 15 (car ^^@)
\catcode`\\ 12
+expandafter+iffalse+fi
\fi

% ---- 
% Fibonacci code
% December 7, 2013. Expandably computing a big Fibonacci number
% with the help of TeX+\numexpr+\xintexpr, (c) Jean-Franois B.
\catcode`_ 11
%
% ajout 7 janvier 2014 au xint.dtx pour 1.07j.
%
% Le 17 janvier je me dcide de simplifier l'algorithme car l'original ne tenait
% pas compte de la relation toujours vraie A=B+C dans les matrices symtriques
% utilises en sous-main [[A,B],[B,C]].
%
% la version ici est celle avec les * omis: car multiplication tacite devant les
% sous-expressions depuis 1.09j, et aussi devant les parenthses depuis 1.09k.
% (pour tester)
\def\Fibonacci #1{%
    \expandafter\Fibonacci_a\expandafter
        {\the\numexpr #1\expandafter}\expandafter
        {\romannumeral0\xintiieval 1\expandafter\relax\expandafter}\expandafter
        {\romannumeral0\xintiieval 1\expandafter\relax\expandafter}\expandafter
        {\romannumeral0\xintiieval 1\expandafter\relax\expandafter}\expandafter
        {\romannumeral0\xintiieval 0\relax}}
%
\def\Fibonacci_a #1{%
    \ifcase #1
          \expandafter\Fibonacci_end_i
    \or
          \expandafter\Fibonacci_end_ii
    \else
          \ifodd #1
              \expandafter\expandafter\expandafter\Fibonacci_b_ii
          \else
              \expandafter\expandafter\expandafter\Fibonacci_b_i
          \fi
    \fi {#1}%
}%
\def\Fibonacci_b_i #1#2#3{\expandafter\Fibonacci_a\expandafter
  {\the\numexpr #1/2\expandafter}\expandafter
  {\romannumeral0\xintiieval sqr(#2)+sqr(#3)\expandafter\relax\expandafter}\expandafter
  {\romannumeral0\xintiieval (2#2-#3)#3\relax}%
}% end of Fibonacci_b_i
\def\Fibonacci_b_ii #1#2#3#4#5{\expandafter\Fibonacci_a\expandafter
  {\the\numexpr (#1-1)/2\expandafter}\expandafter
  {\romannumeral0\xintiieval sqr(#2)+sqr(#3)\expandafter\relax\expandafter}\expandafter
  {\romannumeral0\xintiieval (2#2-#3)#3\expandafter\relax\expandafter}\expandafter
  {\romannumeral0\xintiieval #2#4+#3#5\expandafter\relax\expandafter}\expandafter
  {\romannumeral0\xintiieval #2#5+#3(#4-#5)\relax}%
}% end of Fibonacci_b_ii
\def\Fibonacci_end_i  #1#2#3#4#5{\xintthe#5}
\def\Fibonacci_end_ii #1#2#3#4#5{\xinttheiiexpr #2#5+#3(#4-#5)\relax}
\catcode`_ 8

\def\Fibo #1.{\Fibonacci {#1}}

% nice background added for 1.09j release, January 7, 2014.
% superbe, non? moi trs content!
% bon je peaufine ce background le 17 janvier, c'est hard-coded mais je ne veux
% pas y passer plus de temps (ce qui est amusant c'est que j'ai constat a
% posteriori qu'il y a 17 chiffres par lignes donc 1 chiffre avec son padding =
% 1cm...
% *\message{\xinttheexpr round(\dimexpr 8cm\relax/17,3)\relax}
% 877496.353
\def\specialprintone #1%
{%
    \ifx #1\relax \else \makebox[877496sp]{#1}\hskip 0pt plus 2sp\relax
    \expandafter\specialprintone\fi
}%
\def\specialprintnumber #1% first ``fully'' expands its argument.
{\expandafter\specialprintone \romannumeral-`0#1\relax }%

\AddToShipoutPicture*{%
    \put(10.5cm,14.85cm)
    {\makebox(0,0)
      {\resizebox{17cm}{!}{\vbox
       {\hsize 8cm\Huge\baselineskip.8\baselineskip\color{black!10}%
        \specialprintnumber{F(1250)=}%
                  \specialprintnumber{\Fibonacci{1250}}}\par}%
       }%
    }%
}

% Samedi 27 septembre 2014  16:04:52
\pdfbookmark[1]{Dependency graph}{DependencyGraph}

% modifi le Mercredi 16 septembre 2015  10:24:57
% car j'avais oubli la dpendance partielle de xintfrac sur xinttools,
% pour \xintXTrunc.

\tikzstyle{block} = [rectangle, draw,
    fill=codeboxbg,
    fill opacity=0.5,% fill opacity Octobre 2014
    draw=codeboxframe,
    line width=2pt,
    text width=6em, text centered, rounded corners, minimum height=4em]
\tikzstyle{line} = [draw, line width=1pt, color=codeboxframe]

\vspace{2\baselineskip}

\begin{figure}[ht!]
  \phantomsection\label{dependencygraph}
\centeredline{%
\begin{tikzpicture}[node distance = 2.5cm]
    % Place nodes
    \node [block] (kernel) {xintkernel};
    \node [left of=kernel] (A) {};
    \node [right of=kernel] (B) {};
    \node [block, below right of=B] (core) {\xintcorename};
    \node [block, below left of=A]  (tools) {\xinttoolsname};
    \node [block, right of=core, xshift=1cm]  (bnumexpr) {\href{http://www.ctan.org/pkg/bnumexpr}{bnumexpr}};
    \node [block, below of=core] (xint) {\xintname};
    \node [block, left of=xint, xshift=-.5cm] (binhex) {\xintbinhexname};
    \node [block, left of=binhex] (gcd) {\xintgcdname};
    \node [block, below of=xint] (frac) {\xintfracname};
    \node [block, below of=frac, yshift=-.5cm] (expr) {\xintexprname};
    \node [block, below right of=frac, xshift=1cm] (cfrac) {\xintcfracname};
    \node [block, right of=cfrac] (series) {\xintseriesname};
    % Draw edges
    \path [line] (kernel) -- (core);
    \path [line] (kernel) -- (tools);
    \path [line] (core) -- (bnumexpr);
    \path [line] (core) -- (gcd.north);
    \path [line] (core) -- (binhex.north);
    \path [line] (core) -- (xint);
    \path [line] (xint) -- (frac);
    \path [line] (frac) -- (expr);
    \path [line] (frac) -- (series.north);
    \path [line] (frac) -- (cfrac.north);
    \path [line,dashed] (binhex.south) -- (expr);
    \path [line,dashed] (gcd.south) -- (expr);
    \path [line,dashed] (tools) -- (gcd);
    \path [line,dashed] (tools) to [out=270,in=180] (frac);
    \path [line] (tools) to [out=270,in=180] (expr);
  \end{tikzpicture}}\bigskip
\end{figure}

\vspace{2\baselineskip}

\begin{addmargin}{2cm}
\normalfont\footnotesize Dependency graph for the
    \xintname bundle components: modules at the bottom import modules at the
    top when connected by a continuous line. No module will be loaded twice,
    this is managed internally under Plain as well as \LaTeX. Dashed lines
    indicate a partial dependency, and to enable the corresponding
    functionalities of the lower module it is necessary for the user to issue
    the suitable |\usepackage{top_module}| in the
    preamble (or |\input top_module.sty\relax| in Plain
    \TeX). The \href{http://ctan.org/pkg/bnumexpr}{bnumexpr} package is a
    separate package (\LaTeX{} only) by the author.\par
\end{addmargin}

\vfill

\clearpage

\etocsetlevel{toctobookmark}{6} % 9 octobre 2013, je fais des petits tricks.

% 18 novembre 2013, je n'inclus plus la TOC dtaille de xintexpr. Je
% reconfigure la TOC.

\etocsettocdepth {subsection}

\renewcommand*{\etocbelowtocskip}{0pt}
\renewcommand*{\etocinnertopsep}{0pt}
\renewcommand*{\etoctoclineleaders}
              {\hbox{\normalfont\normalsize\hbox to 1ex {\hss.\hss}}}
\etocmulticolstyle [1]{%
    \phantomsection\section* {Contents}
    \etoctoccontentsline*{toctobookmark}{Contents}{1}%
}
   \etocsettagdepth {description}{subsection}
   \etocsettagdepth   {commands} {none}
   \etocsettagdepth {implementation}{none}
\tableofcontents
\renewcommand*\etocabovetocskip{\bigskipamount}
\makeatletter
% modifi Samedi 07 novembre 2015
% y'en a un peu marre du style ol ol de la doc de multicols
% bon bref \columnsep donne la sparation indpendamment du filet vertical
% (logique, j'admets)
\etocmulticolstyle [2]{\parskip\z@skip\raggedcolumns 
    \setlength{\columnsep}{\leftmarginii}%
    \setlength{\columnseprule}{0pt}%
}%
\makeatother
   \etocsettagdepth {description}{none}
   \etocsettagdepth {commands}   {section}
\ifnum\NoSourceCode=1
   \etocsettagdepth {implementation}{none}
\else
   \etocsettagdepth {implementation}{section}
\fi
\tableofcontents

% pour la suite: [voir aussi juste avant la section Commandes de xint]
% 12 octobre 2014, je supprime tous les "Contents", maintenant que les
% TOC sont dplaces vers immdiatement aprs le titre de la section.
\etocignoredepthtags
\etocmulticolstyle [1]{%
    \phantomsection% \section* {Contents}
    \etoctoccontentsline*{toctobookmark}{Contents}{2}%
}

\etocdepthtag.toc {description}

\section{Read this first}\label{sec:quickintro}

This section provides recommended reading on first discovering the package.

% local TOC supprime 12 octobre 2014
% finalement non, car LaTeX laisse un norme vide au bas de la page  la
% place!!! Bon, je ne le mets que s'il y a la place.

\ifnum\NoSourceCode=1
{\etocdefaultlines\etocsettocstyle{}{}\localtableofcontents}
\fi

\subsection{The packages of the \xintname bundle}


\begin{framed}
  The \xintcorename and \xintname packages provide macros dedicated to
  \emph{expandable} computations on numbers exceeding the \TeX{} (and \eTeX{})
  limit of \dtt{\number"7FFFFFFF} (\emph{i.e.} on numbers of $10$ digits or
  more.)

\medskip

  With package \xintfracname also decimal numbers (with a dot \dtt{.} as
  decimal mark), numbers in scientific notation (with a lowercase \dtt{e}),
  and even fractions (with a forward slash \dtt{/}) are acceptable inputs.

\medskip

  Package \xintexprname handles expressions
  written with the standard infix notations, thus providing a more convenient
  interface. 
\begin{everbatim*}
\xinttheexpr (2981.279/.2662176e2-3.17127e2/3.129791)^3\relax
\end{everbatim*}\newline 
(the |A/B[n]| notation on output means $(A/B)\times 10^n$), or also:
\begin{everbatim*}
\xintthefloatexpr 1.23456789123456789^123456789\relax
\end{everbatim*} (<- notice the size of this exponent).

\smallskip

  Furthermore \xintexprname is also able since release |1.1| of |2014/10/28| to
  do computations with dummy variables, as in this example:
\begin{everbatim*}
\xinttheexpr seq(1+reduce(add(mul((x-i+1)/i,i=1..j),j=1..floor(x/2))),
                 x=10..20, 31, 51)\relax
\end{everbatim*}

\smallskip

  The reasonable range of use of the package arithmetics is with numbers of
  less than \emph{one hundred or perhaps two hundred digits.} Release |1.2|
  has significantly improved the speed of the basic operations for numbers
  with more than $50$ digits, the speed gains getting better for bigger
  numbers. Although numbers up to about \dtt{19950} digits are acceptable
  inputs, the package is not at his peak efficiency when confronted with such
  really big numbers having thousands of digits.\footnotemark
\end{framed}

\footnotetext{The maximal handled size for inputs to multiplication is
  \dtt{19959} digits. This limit is observed with the current default values
  of some parameters of the tex executable (input save stack size at 5000,
  maximal expansion depth at 10000). Nesting of macros will reduce it and it
  is best to restrain numbers to at most \dtt{19900} digits. The output, as
  naturally is the case with multiplication, may exceed the bound.}

The \eTeX{} extensions (dating back to 1999) must be enabled; this is the case
by default in modern distributions, except for the |tex| executable itself
which has to be the pure \textsc{D.~Knuth} software with no additions. The
name for the extended binary is |etex|. In |TL2014| for example |etex| is a
symbolic link to the |pdftex| executable which will then run in |DVI| output
mode, the \eTeX{} extensions being automatically active.

All components may be loaded with \LaTeX{} |\usepackage| or
|\RequirePackage| or, for any other format based on \TeX{}, directly via
\string\input{}, e.g. |\input xint.sty\relax|. There are no package
options.
Each package automatically loads those not already loaded it depends on (but
in a few rare cases there are some extra dependencies, for example the |gcd|
function in \xintexprname expressions requires explicit loading of package
\xintgcdname for its activation).\smallskip

%% \pdfbookmark[1]{Abstract}{ABSTRACT}

\begin{addmargin}{1cm}\small
  % \begin{center} \bfseries\large Description of the packages\par\smallskip
  % \end{center}\medskip
\makeatletter
\renewenvironment{description}
    {\list{}{\topsep\z@\partopsep\z@
              \parsep\z@ \labelwidth\z@ \itemindent-\leftmargin
             \let\makelabel\descriptionlabel}}
    {\endlist}
\makeatother
\begin{description}
\item[\xinttoolsname] provides utilities of independent interest such as
  expandable and non-expandable loops. It is \fbox{not}
  loaded automatically (nor needed) by the other bundle
  packages, apart from \xintexprname.

\item[\xintcorename] provides the
  expandable \TeX{} macros doing additions, subtractions, multiplications,
  divisions and powers on arbitrarily long numbers (loaded automatically by
  \xintname, and also by package \href{http://ctan.org/pkg/bnumexpr}{bnumexpr}
  in its default configuration).

\item[\xintname] extends \xintcorename with additional operations on big
  integers.

\item[\xintfracname] extends the scope of \xintname to decimal numbers, to
  numbers in scientific notation and also to fractions with arbitrarily
  long such numerators and denominators separated by a forward slash.

\item[\xintexprname] extends \xintfracname with expandable parsers doing
  algebra (exact or float, or limited to integers) on comma separated
  expressions using standard infix notations with parentheses, numbers in
  decimal notation, and scientific notation, comparison operators, Boolean
  logic, twofold and threefold way conditionals, sub-expressions, some
  functions with one or many arguments, user-definable variables, evaluation
  of sub-expressions over a dummy variable range, with possible recursion,
  omit, abort, break instructions, nesting.
\end{description}

Further modules:

\begin{description}
\item[\xintbinhexname] is for conversions to and from binary and
  hexadecimal bases.

\item[\xintseriesname] provides some basic functionality for computing in an
  expandable manner partial sums of series and power series with fractional
  coefficients.

\item[\xintgcdname] implements the Euclidean algorithm and its typesetting.

\item[\xintcfracname] deals with the computation of continued fractions.
\end{description}
\end{addmargin}

\subsection{Quick first overview (expressions with \xintexprname)}

This section gives a first few examples of using the expression parsers which
are provided by package \xintexprname. Loading \xintexprname automatically also
loads packages \xinttoolsname and \xintfracname. The latter loads \xintname
which loads \xintcorename. All three provide the macros which ultimately do the
computations associated in expressions with the various symbols like |+, *, ^,
!| and functions such as |max, sqrt, gcd| (the latter requires
explicit loading of \xintgcdname). The package
\xinttoolsname does not handle computations but provides some useful utilities.

There are three expression parsers and two subsidiary ones. They
all admit comma separated expressions, and will then output a comma
separated list of results.
\begin{itemize}[nosep]
\item \csbxint{theiiexpr}| ... \relax| does exact computations \emph{only on
    integers.} The forward slash \dtt{/} does the rounded integer division
  (\dtt{//} does truncated division, and \dtt{/:} is the associated modulo).
  There are two square root extractors \dtt{sqrt} and \dtt{sqrtr} for
  truncated and rounded square roots.
\item \csbxint{thefloatexpr}| ... \relax| does computations with a given
  precision \dtt{P}, as specified via a prior assignment |\xintDigits:=P;|. The
  default is \dtt{P=16} digits. An optional argument controls the precision on
  \emph{output} (this is not the precision of the computations themselves).
  The four basic operations realize \emph{correct rounding.}
\item \csbxint{theexpr}| ... \relax| handles integers, decimal numbers,
  numbers in scientific notation and fractions. The algebraic computations are
  done \emph{exactly.}
\end{itemize}

\begin{framed}
  Currently, the sole available non-algebraic function is the square root
  extraction \dtt{sqrt}. It is allowed in |\xintexpr..\relax| but naturally
  can't return an \emph{exact} value, hence computes as if it was in
  |\xintfloatexpr..\relax|. The power operator |^| (equivalently |**|) only
  works with integral powers (half-integers are not accepted, despite square
  root extraction having been implemented).
\end{framed}

Two derived parsers:
\begin{itemize}[nosep]
\item \csbxint{theiexpr}| ... \relax| does all computations like |\xinttheexpr
  ... \relax| but rounds the result to the nearest integer. With an optional
  positive argument |[D]|, the rounding is to the nearest fixed point number
  with |D| digits after the decimal mark.
\item \csbxint{theboolexpr}| ... \relax| does all computations like
  |\xinttheexpr ... \relax| but converts the result to $1$ if it is not zero
  (works also on comma separated expressions).
  See also the booleans \csbxint{ifboolexpr}, \csbxint{ifbooliiexpr},
  \csbxint{ifboolfloatexpr} (which do not handle comma separated expressions).
\end{itemize}

Here is a (partial) list of the recognized symbols:
\begin{itemize}[nosep]
\item the comma (to separate distinct computations or arguments to a
  function),
\item parentheses,
\item infix operators |+|, |-|, |*|, |/|, |^| (or |**|), 
% \item |//| and |/:| only in \csbxint{iiexpr}|..\relax|,
\item branching operators |(x)?{x non zero}{x zero}|, |(x)??{x<0}{x=0}{x>0}|,
\item boolean operators |!|, |&&| or |'and'|, \verb+||+ or |'or'|,
\item comparison operators |=| (or |==|), |<|, |>|, |<=|, |>=|, |!=|,
\item factorial post-fix operator |!|,
\item |"| for hexadecimal input (uppercase only; package \xintbinhexname
  must be loaded additionally to \xintexprname),
%\item |'| for octal input (\emph{not yet}),
\item functions \xintFor #1 in {num, reduce, abs, sgn, frac, floor, ceil, sqr, sqrt,
    sqrtr, float, round, trunc, mod, quo, rem, gcd, lcm,
    max, min, |`+`|, |`*`|, not, all, any, xor, if, ifsgn, even, odd, first,
    last, reversed, bool, togl}\do {\dtt{#1}, }
\item functions with dummy variables \xintFor #1 in {add, mul, seq, subs,
    rseq, rrseq, iter}\do {\dtt{#1}\xintifForLast{.}{, }}
\end{itemize}
See \autoref{ssec:syntax} for the complete syntax, as well as
\autoref{sec:expr11} which contains examples illustrating the features which
were introduced with \xintexprname |v1.1 2014/10/28|.

The normal mode of operation of the parsers is to unveil the parsed material
token by token. This means that all elements may arise from expansion of
encountered macros (or active characters). For example a closing parenthesis
does not have to be immediately visible, it may arise later from expansion.
This general behavior has exceptions, in particular constructs with dummy
variables need immediately visible balanced parentheses and commas. The
expansion stops only when the ending |\relax| has been found; it is then removed
from the token stream, and the final computation result is inserted.

Release |1.2| added the (pseudo) functions \dtt{qint}, \dtt{qfrac},
\dtt{qfloat} to allow swallowing in one-go all digits of a big number,
fraction, or float, skipping the token by token expansion.

\medskip
Here is an example of a computation:
\begin{everbatim*}
\xinttheexpr (31.567^2 - 21.56*52)^3/13.52^5\relax 
\end{everbatim*}
\newline The result is a bit frightening but illustrates that
|\xinttheexpr..\relax| does its computations \emph{exactly}. The same example
as a floating point evaluation:
\begin{everbatim*}
\xintthefloatexpr (31.567^2 - 21.56*52)^3/13.52^5\relax 
\end{everbatim*}

Again, all computations done by |\xinttheexpr..\relax| are completely exact.
Thus, very quickly very big numbers are created (and computation times
increase, not to say explode if one goes into handling numbers with thousands
of digits). To compute something like |1.23456789^10000| it is thus better to
opt for the floating point version:
\begin{everbatim*}
\xintthefloatexpr 1.23456789^10000\relax
\end{everbatim*}
\newline
(we can deduce that the exact value has |80000+916=80916| digits).
A bigger example (the scope of
the assignment to |\xintDigits| is limited by the braces):
\begin{everbatim*}
{\xintDigits:=24; \xintthefloatexpr 1.23456789123456789^123456789\relax }
\end{everbatim*}
(<- notice the size of the power of ten: this surely largely exceeds your pocket
calculator abilities).

It is also possible to do some (expandable...) computer algebra like
evaluations (only numerically though):
\begin{everbatim*}
\xinttheiiexpr add(i^5, i=100..200)\relax\par
\noindent\xinttheexpr reduce(add(x/(x+1), x = 1000..1014))\relax
\end{everbatim*}
\newline Were it not for the \dtt{reduce} function, the latter fraction would
not have been obtained in reduced terms:
\begin{framed}
  By default, the basic operations on fractions are not followed in an
  automatic manner by reduction to smallest terms: |A/B| multiplied by |C/D|
  returns |AC/BD|, |A/B| added to |C/D| returns |(AD+BC)/BD| except if either
  |B| divides |D| or |D| divides |B|.
% y rflchir
%  The command |\xintfracsetup{reduceall}|
\end{framed}

Make sure to read \autoref{ssec:userinterface}, \autoref{sec:expr11} and the
rest of \autoref{sec:expr}.

% \xintname has very few typesetting macros. \LaTeX{} users
% can do:
% \begin{everbatim*}
% \[\xintFrac{\xintthefloatexpr (31.567^2 - 21.56*52)^3/13.52^5\relax }\]
% \end{everbatim*}% <- il faudra que je vois a, sinon espace en dbut de ligne
% but it probably is better to use packages dedicated to the typesetting of
% numbers in scientific format (notice that the display above is not in
% scientific notation). However, when using |\xinttheexpr| rather than
% |\xintthefloatexpr| the result will
% typically be in |A/B[N]| format and this is unlikely to be understood by your
% favorite number formatting package.
 
% The computations are done expandably: you can put them in an |\edef| or a
% |\write| or even force complete expansion via |\romannumeral-`0| (if you don't
% understand the latter sentence, this doesn't matter; this manual should
% contain a description of expandability in \TeX, but this is yet to arise.)
% Let's just say that such expandable macros are maximally usable in almost all
% locations of \TeX{} code. However in contexts where \TeX{} expects an integer,
% it will naturally not be able to digest a number in scientific notation or a
% fraction. Fixed point decimal numbers however can be understood by \TeX{} in
% the context of manipulation of dimensions. 

% The underlying macros to which |\xinttheexpr ...\relax| and the other parsers
% map the infix operations are provided by packages \xintcorename, \xintname (for
% integers) and \xintfracname (for fractions, decimal numbers, and scientific
% numbers). They are nestable. For example to do something like |21+32*43|, the
% syntax would be (only \xintcorename is needed):
% \begin{everbatim*}
% \xintiiAdd{21}{\xintiiMul{32}{43}}\par
% \noindent\xintiiMul{21283978192739181739}{\xintiiSub {130938109831081320}{29810810281}}
% \end{everbatim*}

% Needless to say this quickly becomes a bit painful. One more example (needs
% \xintfracname):
% \begin{everbatim*}
% \xintIrr {\xintiiPrd{{128}{81}{125}}/\xintiiPrd{{32}{729}{100}}}\par
% \noindent\xintIrr{\xintAdd{31791327893/231938201832}{19831081392/189038013988310}}
% \end{everbatim*}


\subsection {Changes}

The initial \xintname (|2013/03/28|) was followed by \xintfracname
(|2013/04/14|) which handled exactly fractions and decimal numbers. Later came
\xintexprname (|2013/05/25|) and at the same time \xintfracname got extended
to handle floating point numbers. Later, \xinttoolsname was detached
(|2013/11/22|). The main focus of development during late 2013 and early 2014
was kept on \xintexprname. One year later it got a significant upgrade with
|1.1| of |2014/10/28|. The core integer routines remained essentially
unmodified during all this time (apart from a slight improvement of division
early 2014) until their complete rewrite with release
|1.2| from |2015/10/10|.

\begin{description}
\item [|1.2d (2015/11/18):|] 1) fixed |1.2c| which had inadvertently broken
  the \csbxint{iiDivRound} macro; 2) made local the function definitions by
  \csbxint{deffunc} et al., and the macro definitions by \csbxint{NewExpr}; 3)
  extended \hyperlink{item:tacit}{tacit multiplication} to cases such |(x+y)z|
  and now interprets |x/2y| as |x/(2*y)|. Also the documentation enhancements
  which had been initiated by |1.2c| were pushed further, especially in the
  \xintexprname chapter.
\item [|1.2c (2015/11/16):|] fixed one more bug introduced by |1.2|, this time
  regarding subtraction. For a change it also added some new features: the
  \csbxint{deffunc}, \csbxint{defiifunc}, \csbxint{deffloatfunc} macros whose
  purpose is to define functions recognized as such by the \xintexprname
  parsers.
\item [|1.2b (2015/10/29):|] fixed another bug introduced by |1.2|, this time
  regarding division.
\item [|1.2a (2015/10/19):|] fixed a bug introduced by |1.2| in the parsing of
  decimal numbers by \csbxint{expr}|...\relax|.
\item [|1.2 (2015/10/10):|] complete rewrite of the core arithmetic routines.
  The efficiency for numbers with less than $20$ or $30$ digits is slightly
  compromised (for addition/subtraction) but it is increased for bigger
  numbers. For multiplication and division the gains are there for almost all
  sizes, and become quite noticeable for numbers with hundreds of digits. The
  allowable inputs are constrained to have less than about $19950$ digits
  ($19968$ for addition, $19959$ for multiplication).
\item [|1.1 (2014/10/28):|] many extensions to package \xintexprname, such as
  the evaluation of expressions with dummy variables, possibly iteratively,
  with allowed nesting. See \autoref{sec:expr11} for a description of
  these new functionalities. Also worthy of attention:
\begin{enumerate}
\item |\xintiiexpr...\relax| associates |/| with the \emph{rounded}
  division (the |//| operator being provided for the \emph{truncated}
  division) to be in synchrony with the habits of |\numexpr|, 
\item the \xintfracname macro \csbxint{Add} (corresponding to |+| in
  expressions) does not anymore blindly multiply denominators but first checks
  if one is a multiple of the other. However doing systematic reduction to
  smallest terms, or systematically computing the |LCM| of the denominators
  would be too costly (I think).
\end{enumerate}
\xintname does not load \xinttoolsname
anymore (only \xintexprname does) and the core arithmetic macros are
moved to a new package \xintcorename (loaded automatically by
\xintname, itself loaded by \xintfracname, itself loaded by \xintexprname).

Package \href{http://www.ctan.org/pkg/bnumexpr}{bnumexpr} (which is \LaTeX{}
only) now also loads only \xintcorename.
\end{description}

There is a file |CHANGES.html| (also |CHANGES.pdf|) which provides the
detailed cumulative change log since the initial release. To access it, issue
on the command line |texdoc --list xint| (this works |TeXLive| and there is
probably an equivalent in |MikTeX|).

It is also available on \href{http://ctan.org}{CTAN} via
\href{http://mirrors.ctan.org/macros/generic/xint/CHANGES.html}{this link}.
Or, running |etex xint.dtx| in a working repertory will extract a |CHANGES.md|
file with Markdown syntax.

\subsection{Origins of the package}

|2013/03/28.| Package |bigintcalc| by \textsc{Heiko Oberdiek} already
provides expandable arithmetic operations on ``big integers'',
exceeding the \TeX{} limits (of $2^{31}-1$), so why another%
%
\footnote{this section was written before the \xintfracname package; the
  author is not aware of another package allowing expandable
  computations with arbitrarily big fractions.}
%
one?

I got started on this in early March 2013, via a thread on the
|c.t.tex| usenet group, where \textsc{Ulrich D\,i\,e\,z} used the
previously cited package together with a macro (|\ReverseOrder|)
which I had contributed to another thread.%
%
\footnote{the \csa{ReverseOrder} could be avoided in that circumstance,
  but it does play a crucial r\^ole here.}
%
What I had learned in this
other thread thanks to interaction with \textsc{Ulrich D\,i\,e\,z} and
\textsc{GL} on expandable manipulations of tokens motivated me to
try my hands at addition and multiplication.

I wrote macros \csa{bigMul} and \csa{bigAdd} which I posted to the
newsgroup; they appeared to work comparatively fast. These first
versions did not use the \eTeX{} \csa{numexpr} primitive, they worked
one digit at a time, having previously stored carry-arithmetic in
1200 macros.

I noticed that the |bigintcalc| package used \csa{numexpr}
if available, but (as far as I could tell) not
to do computations many digits at a time. Using \csa{numexpr} for
one digit at a time for \csa{bigAdd} and \csa{bigMul} slowed them
a tiny bit but avoided cluttering \TeX{} memory with the 1200
macros storing pre-computed digit arithmetic. I wondered if some speed
could be gained by using \csa{numexpr} to do four digits at a time
for elementary multiplications (as the maximal admissible number
for \csa{numexpr} has ten digits).

The present package is the result of this initial questioning.

\noindent|2015/10/10.| \xintname 1.2 also got its impulse from a fast
``reversing'' macro, which I wrote after my interest got awakened again as a
result of correspondance with Bruno \textsc{Le Floch} during September 2015:
this new reverse uses a \TeX nique which \emph{requires} the tokens to be
digits. I wrote a routine which works (expandably) in quasi-linear time, but a
less fancy |O(N^2)| variant which I developed concurrently proved to be faster
all the way up to perhaps $7000$ digits, thus I dropped the quasi-linear one.
The less fancy variant has the advantage that \xintname can handle numbers
with more than $19900$ digits (but not much more than $19950$). This is with
the current common values of the input save stack and maximal expansion depth:
$5000$ and $10000$ respectively.

\subsection{Installation instructions}
\label{ssec:install}

\xintname is made available under the
\href{http://www.latex-project.org/lppl/lppl-1-3c.txt}{LaTeX Project Public
  License 1.3c}. It is included in the major \TeX\ distributions, thus there
is probably no need for a custom install: just use the package manager to
update if necessary \xintname to the latest version available.

After installation, issuing in terminal |texdoc --list xint|, on installations
with a |"texdoc"| or similar utility, will offer the choice to display one of
the documentation files: |xint.pdf| (this file), |sourcexint.pdf| (source
code), |README|, |README.pdf|, |README.html|, |CHANGES.pdf|, and
|CHANGES.html|.

For manual installation, follow the instructions from the |README| file which
is to be found on \href{http://www.ctan.org/pkg/xint}{CTAN}; it is also
available there in PDF and HTML formats. The simplest method proposed is to
use the archive file \href{http://www.ctan.org/pkg/xint}{xint.tds.zip},
downloadable from the same location.

The next simplest one is to make use of the |Makefile|, which is also
downloadable from
\href{http://mirror.ctan.org/macros/generic/xint}{CTAN}. This is
for GNU/Linux systems and Mac OS X, and necessitates use of the command
line. If for some reason you have |xint.dtx| but no internet access,
you can recreate |Makefile| as a file with this name and the following
contents:

{\def\everbatimindent {0pt }%
\begin{everbatim}
include Makefile.mk
Makefile.mk: xint.dtx ; etex xint.dtx
\end{everbatim}}

Then run |make| in a working repertory where there is |xint.dtx| and the file
named |Makefile| and having only the two lines above. The |make| will extract
the package files from |xint.dtx| and display some further instructions.

If you have |xint.dtx|, no internet access and can not use the Makefile
method: |etex xint.dtx| extracts all files and among them the |README| as a
file with name |README.md|. Further help and options will be found therein.


\section{Introduction via examples}
\label{sec:examples}

The main goal is to allow expandable computations with integers and
fractions of arbitrary sizes.

\subsection{Printing big numbers on the page}\label{ssec:printnumber}

When producing very long numbers there is the question of printing them on
  the page, without going beyond the page limits. In this document, I have most
  of the time made use of these macros (not provided by the package:)

%
\everb|@
\def\allowsplits #1{\ifx #1\relax \else #1\hskip 0pt plus 1pt\relax
                    \expandafter\allowsplits\fi}%
\def\printnumber #1{\expandafter\allowsplits \romannumeral-`0#1\relax }%
% \printnumber thus first ``fully'' expands its argument.
|

It may be used like this:
%
\leftedline{|\printnumber {\xintiiQuo{\xintiiPow {2}{1000}}{\xintiFac{100}}}|}
%
or as |\printnumber\mybiginteger| or |\printnumber{\mybiginteger}| if
|\mybiginteger| was previously defined via a |\newcommand|, a |\def| or
an |\edef|.

An alternative is to suitably configure the thousand
separator with the \href{http://ctan.org/pkg/numprint}{numprint} package
(see \autoref{fn:np}. This will not allow linebreaks when used in math
mode; I also tried \href{http://ctan.org/pkg/siunitx}{siunitx} but even
in text mode could not get it to break numbers accross lines). Recently
I became aware of the \href{http://ctan.org/pkg/seqsplit}{seqsplit}
package%
%
\footnote{\url{http://ctan.org/pkg/seqsplit}} 
%
which can be used to achieve this splitting accross lines, and does work
in inline math mode (however it doesn't allow to separate digits by
groups of three, for example).\par

\subsection{Randomly chosen examples}

Here are some examples of use of the package macros. The first one uses only
the base module \xintname, the next one requires the \xintfracname package,
which deals with decimal numbers, scientific numbers (lowercase \dtt{e}), and
also fractions (it loads automatically \xintname). Then some examples with
expressions, which require the \xintexprname package (it loads automatically
\xintfracname). And finally some examples using \xintseriesname, \xintgcdname
which are among the extra packages included in the \xintname distribution.

The printing of the outputs will either use a custom |\printnumber| macro as
described in the previous section, or sometimes the |\np| command from the
\href{http://www.ctan.org/pkg/numprint}{numprint} package (see
\autoref{fn:np}).

\begin{itemize}
\item {$123456^{99}$: }\\
|\xintiiPow {123456}{99}|: 
\dtt{\printnumber{\xintiiPow {123456}{99}}}

\item {1234/56789 with 1500 digits after the decimal point: }\\
|\xintTrunc {1500}{1234/56789}\dots|:
\dtt{\printnumber {\xintTrunc {1500}{1234/56789}}\dots }

\item {$0.99^{-100}$ with 200 (+1) digits after the decimal point.}\\
  |\xinttheiexpr [201] .99^-100\relax|:
  \dtt{\printnumber{\xinttheiexpr [201] .99^-100\relax}}\\
  Notice that this is rounded, hence we asked |\xinttheiexpr| for one
  additional digit. To get a truncated result with 200 digits after the decimal
  mark, we should have issued
  |\xinttheexpr trunc(.99^-100,200)\relax|, rather.

\begin{snugframed}
  The fraction |0.99^-100|'s denominator is first evaluated \emph{exactly}
  (\emph{i.e.} the integer |99^100| is evaluated exactly and then used to
  divide the suitable power of ten to get the requested digits); for
  some longer inputs, such as for example |0.7123045678952^-243|, the
  exact evaluation before truncation would be costly, and it is more efficient
  to use floating point numbers:
%
\leftedline{|\xintDigits:=20;
               \np{\xintthefloatexpr .7123045678952^-243\relax}|}%
%
\leftedline{\xintDigits:=20;\dtt{\np{\xintthefloatexpr .7123045678952^-243\relax }}} 
%
\xintDigits:=16;%
%
Side note: the exponent |-243| didn't have to be put inside parentheses,
contrarily to what happens with some professional computational
software. |;-)|
% 6.342,022,117,488,416,127,3  10^35
% maple n'aime pas ^-243 il veut les parenthses, bon et il donne, en Digits
% = 24: 0.634202211748841612732270 10^36
\end{snugframed}

\item {$200!$:}\\
|\xinttheiiexpr 200!\relax|:
\dtt{\printnumber{\xinttheiiexpr 200!\relax}}

\item {$2000!$ as a float. As \xintexprname does not handle |exp/log| so far,
    the computation is done internally without the Stirling formula, 
    by repeated multiplications truncated suitably:}\\
  |\xintDigits:=50;|\newline |\xintthefloatexpr 2000!\relax|:
  {\xintDigits:=50;\dtt{\printnumber{\xintthefloatexpr 2000!\relax}}}

\item Just to show off (again), let's print 300 digits (after the decimal
  point) of the decimal expansion of $0.7^{-25}$:%
%
\footnote{the |\np| typesetting macro is from the |numprint| package.}
%
\begin{everbatim*}
% % in the preamble:
% \usepackage[english]{babel}
% \usepackage[autolanguage,np]{numprint}
% \npthousandsep{,\hskip 1pt plus .5pt minus .5pt}
% \usepackage{xintexpr}
% in the body:
\np {\xinttheexpr trunc(.7^-25,300)\relax}\dots
\end{everbatim*}

This computation is with \csbxint{theexpr} from package \xintexprname, which
allows to use standard infix notations and function names to access the package
macros, such as here |trunc| which corresponds to the \xintfracname macro
\csbxint{Trunc}. Regarding this computation, please keep in mind that
\csbxint{theexpr} computes \emph{exactly} the result before truncating. As
powers with fractions lead quickly to very big ones, it is good to know that
\xintexprname also provides \csbxint{thefloatexpr} which does computations
with floating point numbers.

\item Computation of a Bezout identity with  |7^200-3^200| and |2^200-1|:
(with \xintgcdname)\par
\everb|@
\xintAssign \xintBezout {\xinttheiiexpr 7^200-3^200\relax}
                       {\xinttheiiexpr 2^200-1\relax}\to\A\B\U\V\D
$\U\times(7^{200}-3^{200})+\xintiOpp\V\times(2^{200}-1)=\D$
|

\xintAssign \xintBezout {\xinttheiiexpr 7^200-3^200\relax}%
                            {\xinttheiiexpr 2^200-1\relax}\to\A\B\U\V\D
\dtt
{\printnumber\U$\times(7^{200}-3^{200})+{}$%
 \printnumber{\xintiOpp\V}$\times(2^{200}-1)={}$\printnumber\D}

% 11 octobre 2014, je modifie juste d'une unit le deuxime... plus joli.
\item The Euclide algorithm applied to \np{22206980239027589097} and
\np{8169486210102119257}: (with \xintgcdname)%
%
\footnote {this example is computed tremendously faster than the other
  ones, but we had to limit the space taken by the output hence picked
  up rather small big integers as input.}\par
\noindent\begingroup\parskip0pt\relax
|\xintTypesetEuclideAlgorithm {22206980239027589097}{8169486210102119257}|\par
\dtt
{\xintTypesetEuclideAlgorithm {22206980239027589097}{8169486210102119257}} 
\endgroup
\smallskip

\item $\sum_{n=1}^{500} (4n^2 - 9)^{-2}$ with each term rounded to twelve digits,
and the sum to nine digits:
\begin{everbatim*}
\def\coeff #1{\xintiRound {12}{1/\xintiiSqr{\the\numexpr 4*#1*#1-9\relax }[0]}}
\xintRound {9}{\xintiSeries {1}{500}{\coeff}[-12]}
\end{everbatim*}

The complete series, extended to
infinity, has value
$\frac{\pi^2}{144}-\frac1{162}={}$%
\dtt{\np{0.06236607994583659534684445}\dots}\,%
%
\footnote{\label{fn:np}This number is typeset using the
  \href{http://www.ctan.org/pkg/numprint}{numprint} package, with
  |\npthousandsep{,\hskip 1pt plus .5pt minus .5pt}|. But the breaking
  across lines works only in text mode. The number itself was (of
  course...) computed initially with \xintname, with 30 digits of $\pi$
  as input. See \hyperref[ssec:Machin]{{how {\xintname} may compute
      $\pi$ from scratch}}.}
%
I also used (this is a lengthier computation
than the one above) \xintseriesname to evaluate the sum with \np{100000} terms,
obtaining 16
correct decimal digits for the complete sum. The
coefficient macro must be redefined to avoid a |\numexpr| overflow, as
|\numexpr| inputs must not exceed $2^{31}-1$; my choice
was:
\everb|@
\def\coeff #1%
{\xintiRound {22}{1/\xintiiSqr{\xintiiMul{\the\numexpr 2*#1-3\relax}
                                         {\the\numexpr 2*#1+3\relax}}[0]}}
|

\restoreMacroFont
\edef\Temp {\xintFloatPow [24]{2}{999999999}}

\item {Computation of $2^{\np{999999999}}$ with |24| significant
  figures:}
%
\leftedline{|\numprint{\xintFloatPow [24]{2}{999999999}}|}
\leftedline{\dtt{\numprint{\Temp}}}
%
where the \href{http://www.ctan.org/pkg/numprint}{numprint} package was used
(\autoref{fn:np}), directly in text mode (it can also naturally be used from
inside math mode). \xintname provides a simple-minded \csbxint{Frac}
typesetting macro,%
%
\footnote{Plain \TeX{} users of \xintname have \csbxint{FwOver}.}
%
which is math-mode only:
%
\leftedline{|$\xintFrac{\xintFloatPow [24]{2}{999999999}}$|}
\leftedline{\dtt{$\xintFrac{\Temp}$}}
%
The exponent differs, but this is because
|\xintFrac| does not use a decimal mark in the significand of the output.
Admittedly most users will have the need of more powerful (and customizable)
number formatting macros than |\xintFrac|.
%
\footnote{There should be a |\xintFloatFrac|, but it is lacking.}
%
We have already mentioned
|\numprint| which is used above, there is also |\num| from package
\href{http://www.ctan.org/pkg/siunitx}{siunitx}. The raw output from
%
\leftedline{\detokenize{\xintFloatPow[24]{2}{999999999}}}
%
is $\Temp$.

\edef\x{\xintiiQuo{\xintiiPow {2}{1000}}{\xintiFac{100}}}
\edef\y{\xintLen{\x}}

\item As an example of nesting package macros, let us consider the following
code snippet within a file with filename |myfile.tex|:
\everb|@
\newwrite\outstream
\immediate\openout\outstream \jobname-out\relax
\immediate\write\outstream {\xintiiQuo{\xintiiPow{2}{1000}}{\xintiFac{100}}}
% \immediate\closeout\outstream
|
\noindent
The tex run creates a file |myfile-out.tex|, and then writes to it the
quotient from the euclidean division of $2^{1000}$ by $100!$. The number of
digits is |\xintLen{\xintiiQuo{\xintiiPow{2}{1000}}{\xintiFac{100}}}| which
expands (in two steps) and tells us that $[2^{1000}/100!]$ has \dtt{\y}
digits. This is not so many, let us print them here:
\dtt{\printnumber\x}.%
%
% \footnote{See \autoref{ssec:printnumber} and \hyperref[fn:np]{a previous
%     footnote}.} 

\end{itemize}

\subsection {More examples, some quite elaborate, within this document}
\label{sec:awesome}

\begin{itemize}
\item The utilities provided by \xinttoolsname (\autoref{sec:tools}), some
  completely expandable, others not, are of independent interest. Their use
  is illustrated through various examples: among those, it is shown in
  \autoref{ssec:quicksort} how to implement in a completely expandable way
  the \hyperlink{quicksort}{Quick Sort algorithm} and also how to illustrate
  it graphically. Other examples include some dynamically constructed
  alignments with automatically computed prime number cells: one using a
  completely expandable prime test and \csbxint{ApplyUnbraced}
  (\autoref{ssec:primesI}), another one with \csbxint{For*} (\autoref{ssec:primesIII}).

\item  One has also a \hyperref[edefprimes]{computation of primes within an
    \csa{edef}} (\autoref{xintiloop}), with the help of \csbxint{iloop}.
  Also with \csbxint{iloop} an
  \hyperref[ssec:factorizationtable]{automatically generated table of
    factorizations} (\autoref{ssec:factorizationtable}).

\item  The code for the title page fun with Fibonacci numbers is given in
  \autoref{ssec:fibonacci} with \csbxint{For*} joining the game.

\item  The computations of \hyperref[ssec:Machin]{ $\pi$ and $\log 2$}
  (\autoref{ssec:Machin}) using \xintname and the computation of the
  \hyperref[ssec:e-convergents]{convergents of $e$} with the further help of
  the \xintcfracname package are among further examples. 

\item There is also an
  example of an \hyperref[xintXTrunc]{interactive session}, where results
  are output to the log or to a file.

\item The new functionalities of \xintexprname are illustrated with various
  examples in \autoref{sec:expr11}.
\end{itemize}
Almost all of the computational results interspersed throughout the
documentation are not hard-coded in the source file of this document but are
obtained via the expansion of the package macros during the \TeX{}
run.%
%
\footnote{The CPU of my computer hates me for all those re-compilations
  after changing a single letter in the \LaTeX{} source, which require each
  time to do all the zillions of evaluations contained in this document\dots}
%
% on examples which were selected to not impact too much the compilation time of
% this documentation.

% Nevertheless, there are so many computations done that compilation time
% is significantly increased compared to a \LaTeX\ run on a typical
% document of about the same size.

\section{The \xintname bundle}

% \section{User interface}

% {\etocdefaultlines\etocsettocstyle{}{}\localtableofcontents}


\subsection{Characteristics}

\begin{framed}
  The main characteristics are:
  \begin{enumerate}
  \item exact algebra on arbitrarily big numbers, integers as well as
    fractions,
  \item floating point variants with user-chosen precision,
  \item implemented via macros compatible with expansion-only context,
  \item and with a parser of infix operations implementing features such as
    dummy variables, and coming in various incarnations depending on the kind
    of computation desired: purely on integers, on integers and fractions, or
    on floating point numbers.
  \end{enumerate}

  `Arbitrarily big' currently means with less than about \dtt{19950} digits: the
  maximal%
  \MyMarginNote[\kern\dimexpr\FrameSep+\FrameRule\relax]{Changed!}
  number of digits for addition is at \dtt{19968} digits,
  and it is \dtt{19959} for multiplication.
\end{framed}

Integers with only $10$ digits and starting with a $3$ already exceed the
\TeX{} bound; and \TeX{} does not have a native processing of floating point
numbers (multiplication by a decimal number of a dimension register is allowed
--- this is used for example by the
\href{http://mirror.ctan.org/graphics/pgf/base}{pgf} basic math engine.)

\TeX{} elementary operations on numbers are done via the non-expandable
\emph{\char92advance, \char92multiply, \emph{and} \char92divide} assignments.
This was changed with \eTeX{}'s |\numexpr| which does expandable computations
using standard infix notations with \TeX{} integers. But \eTeX{} did not
modify the \TeX{} bound on acceptable integers, and did not add floating point
support.

The \href{http://www.ctan.org/pkg/bigintcalc}{bigintcalc} package by
\textsc{Heiko Oberdiek} provided expandable operations (using some of |\numexpr|
possibilities, when available) on arbitrarily big integers, beyond the \TeX{}
bound. The present package does this again, using more of |\numexpr| (\xintname
requires the \eTeX{} extensions) for higher speed, and also on fractions, not
only integers. Arbitrary precision floating points operations are a derivative,
and not the initial design goal.%
%
\footnote{currently (|v1.08|), the only non-elementary operation
  implemented for floating point numbers is the square-root extraction;
  no signed infinities, signed zeroes, |NaN|'s, error traps\dots, have
  been implemented, only the notion of `scientific notation with a given
  number of significant figures'.}%
%
${}^{\text{,\,}}$%
%
\footnote{multiplication of two floats with |P=\xinttheDigits| digits is
  first done exactly then rounded to |P| digits, rather than using a
  specially tailored multiplication for floating point numbers which
  would be more efficient (it is a waste to evaluate fully the
  multiplication result with |2P| or |2P-1| digits.)}

The \LaTeX3 project has implemented expandably floating-point computations with
16 significant figures
(\href{http://www.ctan.org/pkg/l3kernel}{l3fp}), including
special functions such as exp, log, sine and cosine.\footnote{at the time of writing (2014/10/28) the
  \href{http://www.ctan.org/pkg/l3kernel}{l3fp} (exactly represented) floating
  point numbers have their exponents limited to $\pm$\dtt{9999}.}
%

More directly related to the \xintname bundle, there is the promising new
version of the \liiibigint{} package. It was still in development a.t.t.o.w
(2015/10/09, no division yet) and is part of the experimental trunk of the
\href{http://latex-project.org}{\LaTeX3 Project}. It is devoted to expandable
computations on big integers with an associated expression parser. Its author
(Bruno \textsc{Le Floch}) succeeded brilliantly into implementing expandably
the Karatsuba multiplication algorithm and he achieves \emph{sub-quadratic
  growth for the computation time}. This shows up very clearly with numbers
having more than one thousand digits (up to the maximum which a.t.t.o.w was at
$8192$ digits).

I report here briefly on a quick comparison, although as \liiibigint{} is work
in progress, the reported results could well have to be modified soon. The
test was on a comparison of |\bigint_eval:n {#1*#2}| from the \liiibigint{} as
available in September 2015, on one hand, and on the other hand
|\xinttheiiexpr #1*#2\relax| from \xintexprname 1.2 (rather than directly
|\xintiiMul|, to be fairer to the parsing time induced by use of
|\bigint_eval:n|) and the computations were done with
|#1=#2=9999888877999988877...repeated...|. I observed:
\begin{itemize}
\item \csbxint{iiexpr}'s multiplication appears slightly faster (about |1.5x|
  or |2x| to give an average order of magnitude) up to about
  $900$ digits,
\item at $1000$ digits, \liiibigint{} runs between |15%| and |20%| faster,
\item then its sub-quadratic growth shows up, and at $8000$ digits I observed
  it to be about |7.6x| faster (I tried on two computers and on my laptop the
  ratio was more like |8.5x--9x|). Its computation time increased from $1000$
  digits to $8000$ digits by a factor smaller than |30|, whereas for
  \csbxint{iiexpr} it was a factor only slightly inferior to |200| (|225| on
  my laptop) ...
  Karatsuba multiplication brilliantly pays off !
\item One observes the transition at the powers of two for the \liiibigint{}
  algorithm, for example I observed \liiibigint{} to be |3.5x--4x| faster at
  $4000$ digits but only |3x--3.5x| faster at $5000$ digits.
\end{itemize}

Once one accepts a small overhead, one can on the basis of the lengths decide
for the best algorithm to use, and it is tempting viewing the above to imagine
that some mixed approach could combine the best of both. But again all this is
a bit premature as both packages may still evolve further.

Anyhow, all this being said, even the superior multiplication implementation
from \liiibigint{} takes of the order of seconds on my laptop for a single
multiplication of two $5000$-digits numbers. Hence it is not possible to do
routinely such computations in a document. I have long been thinking that
without the expandability constraint much higher speeds could be achieved, but
perhaps I have not given enough thought to sustain that optimistic
stance.\footnote{The \href{http://www.ctan.org/pkg/apnum}{apnum} package
  implements non-expandably arbitrary precision arithmetic operations.}

I remain of the opinion that if one really wants to do computations with
\emph{thousands} of digits, one should drop the expandability requirement.
Indeed, as clearly demonstrated long ago by the
\href{http://www.ctan.org/pkg/pi}{pi computing file} by \textsc{D. Roegel} one
can program \TeX{} to compute with many digits at a much higher speed than
what \xintname achieves: but, direct access to memory storage in one form or
another seems a necessity for this kind of speed and one has to renounce at
the complete expandability.%
%
\footnote{2015/09/15: as I said the latest developments on the \liiibigint{}
  side do not really modify this conclusion, because the computations remain
  extremely slow compared to what one can do in other programming structures.
  Another remark one could do is that it would be tremendously easier to
  enhance \eTeX{} than it is to embark into writing hundreds of lines of
  sometimes very clever \TeX{} macro programming.}
%
\footnote{The Lua\TeX{} project possibly makes endeavours such as
  \xintname appear even more insane that they are, in truth.}

\subsection{Floating point evaluations}
\label{ssec:floatingpoint}

\emph{This documentation is currently undergoing revision and is provided here
  in some transient intermediate state.}


Floating point macros are provided by package \xintfracname to work with a
given arbitrary precision |P|. The default value is $P=16$ meaning that the
significands for non-zero numbers have $16$ decimal digits, the first one non
zero. The syntax to set the
precision to |P| is \centeredline{|\xintDigits:=P;|} To query the current
value use \csbxint{theDigits}.
\begin{everbatim*}
The current precision for floating point evaluations is \xinttheDigits.
{\xintDigits:=32;%
The current precision for floating point evaluations is \xinttheDigits.} 
The current precision for floating point evaluations is \xinttheDigits.
\end{everbatim*}
 
It is also possible to pass |P| as an optional argument within brackets to the
floating point macros such as \csbxint{FloatAdd}, \csbxint{FloatMul}, ...

\csbxint{thefloatexpr}|...\relax| also admits an optional argument |Q| within
brackets, but it has no influence on the precision |P| for the computations,
its use is only to specify a rounding precision on output, typically to clean
up the computation result from cumulated errors resulting from iterated
operations, which unavoidably make possibly invalid the last digits (compared
to an exact theoretical evaluation; I say \emph{theoretical} because no
computer has ever nor ever will compute exactly $\sqrt 2$ in base $10$.)

The maximal allowed value for |P| in a |\xintDigits:=P;| assignment is
\dtt{32767}. It was possible earlier to use even bigger |P|'s as optional
argument to \csbxint{Float} for a one-short conversion\MyMarginNote{Changed
  with 1.2} to a gigantic float. However since release |1.2| this can't work
in complete generality: a fractional input will trigger the division macro
which can't handle inputs with more than about \dtt{19900} digits. For example
(tested 2015/11/07 with |v1.2b|) |\message{\xintFloat [19942]{1/7}}| works but
not |\message{\xintFloat [19943]{1/7}}|. On the other hand |\xintFloat
[50000]{1}| does work (slowly..), but there isn't much one can do afterwards
with it...

More reasonably, working with significands of $24$, $32$, $48$, $64$, or even
$80$ digits is well within the reach of the package.

%\begin{framed}
Currently, the only non-elementary operation is the square root
(\csbxint{FloatSqrt}). The elementary transcendantal functions are not yet
implemented. The power function (\csbxint{FloatPow}, \csbxint{FloatPower})
accept only (positive or negative) integer exponents.
%\end{framed}


\begin{framed}
  Future releases of \xintname will have more extensive coverage of floating
  point operations, and document better what exactly is the achieved
  precision. The four basic operations always have and will achieve
  \emph{correct rounding}.
\end{framed}

The maximal theoretically allowed exponent is currently set at
\dtt{\number"7FFFFFFF} (the minimal exponent is its opposite) which is the
maximal number handled by \TeX. 

% We refer here to the exponent |e| in a
% representation
% \leftedline{$x=\pm \underbrace{ddd\dots ddd}_{P\ \mathrm{digits}}\times 10^e$}
% where the \dtt{P} digits are the significand. This means that the maximal
% theoretical exactly representable number should be:
% \dtt{$9.9\dots 9\times 10^{\number"7FFFFFFF+(P-1)}$}. However, with for
% example the default \dtt{P=16} value for the precision,
% \begin{everbatim}
% \xintFloat {9.999999999999999e2147483662}
% \end{everbatim}
% raises an error, because the \eTeX{} primitive |\numexpr| suffers an
% arithmetic overflow if used for example as |\numexpr -1+2147483648\relax|,
% hence it understandably can't handle the |2147483662|. Sadly, already
% \begin{everbatim}
% \xintFloat {9.999999999999999e2147483647}
% \end{everbatim}%
% also raises an error, due to some arithmetic overflow originating in
% \csbxint{Float} parsing. There is no error with:
% \begin{everbatim*}
% \xintRaw {9.999999999999999e2147483647}
% \end{everbatim*}%
% but some extra manipulations done by |\xintFloat| (to go
% again from the |\xintRaw| format to the float format) create the
% problem. The maximal exactly represented and acceptable input to |\xintFloat|
% is observed to be:
% \begin{everbatim*}
% \xintFloat {9.999999999999999e2147483632}
% \end{everbatim*} 
% With more |9|'s the number is still parsed but the output 
% and the minimal one is \dtt{$10^{\number"7FFFFFFF}$} 

Perhaps in the future this will be
reduced, for example to \dtt{2147400000}. It could even be envisioned that the
maximal |e|${}_{\mathrm{max}}$ and minimal |e|${}_{\mathrm{min}}$ exponents
would be user-specified.

% Suppose that the precision \dtt{P} has its default value \dtt{16}. Currently, attempting to subtract \dtt{1.0e-\the\numexpr\number"7FFFFFFF-15} from
% \dtt{1.1e-\the\numexpr\number"7FFFFFFF-15} by necessity leads to a low-level \eTeX{} error,
% because the result \dtt{1e-\xintiiPow2{31}} has a too big exponent in absolute
% value, thus necessarily somewhere an arithmetic overflow will occur. Actually,
% this overflow happens immediately during the parsing of
% \dtt{1.1e-\number"7FFFFFFF} because the very first parsing by \xintfracname
% will initially attempt to store the number as \dtt{11[-\xintiiPow2{31}]} and the
% arithmetic overflow will happen already at this stage.

% reasonable value), and also would make easier the implementation of denormal

Currently \xintfracname has no notion of |NaN|s or signed infinities or signed
zeroes. These notions are part of the
\href{https://en.wikipedia.org/wiki/IEEE_floating_point}{\texttt{IEEE
    754-2008}} standard for Floating-Point arithmetic (which initially regards
hardware floating point processing units but also has implications on
software)\footnote{The |IEEE 754-1985| was a binary standard with a specific
  value for the precision ($24$ for single precision, $53$ for double
  precision). The newer
  \href{https://en.wikipedia.org/wiki/IEEE_floating_point}{\texttt{IEEE
      754-2008}} normalizes five basic formats, three binaries and two
  decimals ($16$ and $34$ decimal digits) and discusses extended formats with
  higher precision.} and, together with signed infinities, signed zeroes,
exception handling are not implemented currently by the \xintfracname macros
dealing with ``floating-point numbers''.

\begin{framed}
  % Floating point multiplication of two numbers with |P| digits of precision
  % evaluates \emph{exactly} the exact product with |2P| or |2P-1| digits,
  % before rounding to |P| digits: obviously this is very wasteful when |P| is
  % large. But \xintname is initially an exact algebraic operator, not a
  % floating point one with a fixed maximal size for operands, and the author
  % hasn't yet had the opportunity to re-examine that point.
  But the |IEEE 754| requirement of \emph{correct rounding} for addition,
  subtraction, multiplication and division is achieved by \xintfracname and
  the \csbxint{thefloatexpr}|...\relax| parser: this means that for two
  operands of |P| digits the output coincides exactly with the rounding of an
  exact evaluation.

  The rounding mode is ``round to nearest, ties away from zero'', which is
  based on the rounding to integers which maps $(-0.5,0.5)$ to $0$,
  $[0.5, 1.5)$ to $1$, etc... and $(-1.5,-0.5]$ to $-1$ etc... It is not
  customizable.
\end{framed}

\medskip

\emph{Also the square root will provide correct rounding.}

% http://www.cse.msu.edu/~cse320/Documents/FloatingPoint.pdf
% https://en.wikipedia.org/wiki/IEEE_floating_point
% je n'ai pas cherch beaucoup mais je n'ai pas vu de lien gratuit
% pour rcuprer IEEE 754-2008. Mais je l'avais peut-tre dj rcupr il y a
% quelques mois.


The other float operations produce a value from which the exact result differs
by at most \dtt{0.6} ``units in the last place'' (of the significand of the
returned value). Thus the last digit may be wrong by at most one unit
(compared to the exact rounding of the exact theoretical value), but if it is
$0$ or $9$ also with it the next to last digit, etc... some macros may achieve
higher precision, check their documentations. Notice in particular that the
routines will return a zero value only if the theoretical exact evaluation
would have produced also zero (but as mentioned above a computation leading to
a floating point underflow or floating point overflow will at some point
inevitably raise a low-level \eTeX{} arithmetic overflow error).

What happens for inputs having more than \dtt{P} digits ? it is not the same
to correctly round a theoretical exact value obtained from the exact inputs or
correctly round the theoretical exact result obtained from rounded inputs. Up
to release |v1.2b| (\emph{|1.2c| hasn't changed anything yet.}), the four
basic operations first rounded the inputs to \dtt{P+2} digits of precision.
The power operation |A^B| first rounded |A| to a number of digits equal to the
precision \dtt{P} plus a certain quantity depending on the exponent |B|, for
example for squaring this gave a first rounding to \dtt{P+3} digits of
precision. But this meant that in some rare cases |x*x| or |x^2| could produce
slightly different values.

For example consider \leftedline{\dtt{x=1.772453850905516665}} which has 19
digits. We want its square correctly rounded to 16 digits. The exact value is
\leftedline{1.772453850905516665\string^2=3.141592653589795499056780930592722225}
whose rounding to 16
digits is \dtt{3.141592653589795}. But if we first round |x| to 18 digits, and
square, this gives 
\leftedline{1.77245385090551667\string^2=3.1415926535897955167813194396478889} whose
rounding to 16 digits is \dtt{3.141592653589796}.

Another example of a similar type (such examples are the exception rather than
the rule, but are not especially hard to find, if one understands where to
look): with \leftedline{\dtt{x=18587988557251906450}} which has 20 digits, we
compute |1/x| correctly rounded to 16 digits of precision, but after rounding
first |x| to either 20 (no alteration), 18, or 16 digits (and trailing
zeroes). We obtain three distinct values:
\leftedline{1/x=5.379818246175220e-20, 5.379818246175219e-20,
  5.379818246175218e-20}

A further topic is how the macros should handle fractional inputs |A/B|. If we
were to first round |A| and |B| to some precision \dtt{Q}, and then correctly
round the fraction to precision \dtt{P}, the process could give different
results for inputs |A/B| and |A'/B'| representing the same rational
number. As \xintfracname treats exactly fractions, this would be a very
disquieting situation. Consider for example the fraction:
\leftedline{1/1858798855725191=5379818246175218/\xintiiMul{1858798855725191}{5379818246175218}}
We mentioned already that the exact rounding to 16 digits is
\dtt{5.379818246175218e-16}. If however we treat the right hand side by first
rounding numerator and denominator to 16 digits, we are evaluating
\leftedline{5379818246175218/9999999999999999e15=\xintTrunc{24}{5379818246175218/9999999999999999}\dots
e-15}
and the result rounded to 16 digits is \dtt{5.379818246175219e-16}.

Thus, the float macros of \xintfracname have always treated fractional inputs
|A/B| \emph{exactly}, not doing any a priori rounding of numerator and
denominator, but rounding the \emph{exact} fraction before further
treatment (as stated above the basic operations did this initial rounding of
the inputs with \dtt{P+2} digits of kept precision). The possible alternative
could have been to systematically first reduce |A/B| to smallest terms, then
round numerator and denominator, but this was not the choice made, as it
raises issues of efficiency and accuracy.

In an \emph{expression} however \dtt{/} is an operator and if the parser sees
|A/B|, the arguments |A| and |B| will be treated as separate inputs and be
rounded separately first, before division; to avoid that one may
code |\xintexpr A/B\relax| inside the \csbxint{thefloatexpr}|...\relax|, or,
since |v1.2|, use the |qfloat(A/B)| syntax.

\subsection{Expansion matters}

\subsubsection{Generalities about expandability in \TeX}

\TeX{} is a macro language, and ``expansion'' is thus a crucial aspect, which
will be quite unfamiliar to most everyone with standard knowledge of the usual
programming languages. The whole of \xintname is about \emph{expandably}
implementing arithmetic computations. What does that mean ?

\LaTeX{} users are familiar with counters, and its command |\setcounter|. The
first argument is the name of the counter, the second argument is a number, or
more generally something which will expand to a number. For example:
\begin{everbatim}
\newcounter{Foo}
\newcommand{\Bar}{17}
\setcounter{Foo}{\Bar}
\addtocounter{Foo}{\Bar}
\arabic{Foo}
\end{everbatim}
works and produces |34|. But imagine we have some macro |\Double| which
accepts a numerical argument, multiply it by two, and produces the result. Can
we do this:
\begin{everbatim}
\setcounter{Foo}{\Double{\Bar}}    ?
\end{everbatim}
The answer depends on the \emph{expandability} of |\Double|. Perhaps |\Double|
will do a |\newcommand| internally? then it is \emph{not} expandable in this
context where \TeX{} is seeking to do a number assignment (which is
to what the \LaTeX{} |\setcounter| boils down in the end). This does not mean
that expansion does not apply, but something completely different: expansion
produces ``tokens'' which \TeX{} does not accept in such a context.

Some users of \LaTeX{} know about the \TeX{} primitive |\edef|. Another way to
test expandability of |\Double| is to try |\edef\test{\Double{\Bar}}|: the
criterion is that |\Double| will expand, do its stuff, and clean up everything
and only leave the result of its action on |\Bar|. Thus typically if |\Double|
does a |\newcommand| (or rather a |\def|), then this will not be the case. The
|\newcommand| or |\def| is simply \emph{not} executed inside an |\edef|! This
is not completely equivalent to the earlier context, because when \TeX{} seeks
to build a number it has special constructs, like |"| to prefix hexadecimal
inputs, and thus the behavior is not exactly the same in an |\edef|, but I am
just trying to give a gist here of what happens.

The little paradox is that \TeX{} from the start always required expandability
when doing assignments to count registers, or dimen registers, ..., but basic
arithmetic was provided via |\advance|, |\multiply|, and |\divide| primitives
which are \emph{not} expandable.%
%
\footnote{This is not to say that expandable arithmetic was not possible, it
  is possible and has been done via the recording of the carries of digit
  arithmetic in many macros and usage of some tools provided by the \TeX{}
  language, but this is very cumbersome and slow (even in the \TeX{}
  context).}
%
For example, something like
\begin{everbatim}
\setcounter{Foo}{\count0=\Bar\relax \multiply\count0 by 2 
                 \advance\count0 by 15 \the\count0 }
\end{everbatim}
although not creating errors produces only non-sense. 

Since 1999, \eTeX{} has extended \TeX{} with expandable arithmetic. Thus
nowadays%
%
\footnote{I do not discuss here the \href{http://www.ctan.org/pkg/calc}{calc}
  package. It does surgery inside |\setcounter| to make
  |\setcounter{Foo}{2*\Bar+15}| possible, but its parser is not expandable and
  is functional only inside macros |calc| knows about.} one would simply do
\begin{everbatim}
\setcounter{Foo}{\numexpr 2*\Bar+15\relax}
\end{everbatim}
But we can not do, for example, |98765*67890| inside |\numexpr|, because the
result \xintiiMul{98765}{67890} exceeds the \TeX{} bound of \number"7FFFFFFF.

\subsubsection{Full expansion of the first token}
\label{ssec:expansions}

The whole business of \xintname is to build upon |\numexpr| and handle
arbitrarily large numbers. Each basic operation is thus done via a macro:
\csbxint{iiAdd}, \csbxint{iiSub}, \csbxint{iiMul}, \csbxint{iiDivision}. In
order to handle more complex operations, it must be possible to nest these
macros.%
%
\footnote{Actually this would not be really needed if the goal was only
to implement the parsing of expressions: as the expression is scanned from
left to right, there is only at any given time one operation to be done, hence
it is not really absolutely mandatory for the macros implementing the basic
operations to be nestable. This is however the path followed initially by
\xintname.}
%
But we saw already that an expandable macro can not do a |\newcommand| or
|\def|, and it can't do either an |\edef|. But the macro must expand its
arguments to find the digits it is supposed to manipulate. \TeX{} provides a
tool to do the job of (expandable !) repeated expansion of the first token
found until hitting something non expandable, such as a digit, a |\def| token,
a brace, a |\count| token, etc... is found. A space token also will stop the
expansion (and be swallowed, contrarily to the non-expandable tokens).

By convention in this manual \fexpan sion (``full expansion'' or ``full first
expansion'') will be this \TeX{} process of expanding repeatedly the first
token seen. For those familiar with \LaTeX3 (which is not used by \xintname)
this is what is called in its documentation full expansion (whereas expansion
inside |\edef| would be described I think as ``exhaustive'' expansion).

Most of the package macros, and all those dealing with computations%
%
\footnote{except \csbxint{XTrunc}.},
%
are expandable in the strong sense that they expand to their final result via
this \fexpan sion. This will be signaled in their descriptions via a
\etype{}star in the margin.

These macros not only have this property of \fexpan dability, they all begin
by first applying \fexpan sion to their arguments. Again from \LaTeX3's
conventions this will be signaled by a%
%
\ntype{{\setbox0 \hbox{\Ff}\hbox to \wd0 {\hss f\hss}}}
%
margin annotation next to the description of the arguments. 

\subsubsection{Summary of important expandability aspects}

\begin{enumerate}
\item the macros \fexpan d their arguments, this means that they expand the
  first token seen (for each argument), then expand, etc..., until something
  un-expandable such as a\strut{} digit or a brace is hit against. This
  example
%
  \leftedline{|\def\x{98765}\def\y{43210}| |\xintiiAdd {\x}{\x\y}|} 
%
  is \emph{not} a legal construct, as the |\y| will remain untouched by
  expansion and not get converted into the digits which are expected by the
  sub-routines of |\xintiiAdd|. It is a |\numexpr| which will expand it and an
  arithmetic overflow will arise as |9876543210| exceeds the \TeX{} bounds.
  The same would hold for |\xintAdd|.

  \begingroup\slshape
  To the contrary \csbxint{theiiexpr} and others have no issues with
  things such as |\xinttheiiexpr \x+\x\y\relax|.\hfill
  \endgroup

\item\label{fn:expansions} using |\if...\fi| constructs \emph{inside} the
  package macro arguments requires suitably mastering \TeX niques
  (|\expandafter|'s and/or swapping techniques) to ensure that the \fexpan sion
  will indeed absorb the \csa{else} or closing \csa{fi}, else some error will
  arise in further processing. Therefore it is highly recommended to use the
  package provided conditionals such as \csbxint{ifEq}, \csbxint{ifGt},
  \csbxint{ifSgn}, \csbxint{ifOdd}\dots, or, for \LaTeX{} users and when dealing
  with short integers the
  \href{http://www.ctan.org/pkg/etoolbox}{etoolbox}%
%
\footnote{\url{http://www.ctan.org/pkg/etoolbox}}
  expandable conditionals (for small integers only) such as \texttt{\char92
    ifnumequal}, \texttt{\char92 ifnumgreater}, \dots . Use of
  \emph{non-expandable} things such as \csa{ifthenelse} is impossible inside the
  arguments of \xintname macros.

  \begingroup\slshape
  One can use naive |\if..\fi| things inside an \csbxint{theexpr}-ession
  and cousins,  as long as the test is
  expandable, for example\upshape
%
\leftedline{|\xinttheiexpr\ifnum3>2 143\else 33\fi
  0^2\relax|$\to$\dtt{\xinttheiexpr \ifnum3>2 143\else 33\fi 0^2\relax
    =1430\char`\^2}}
%
  \endgroup

\item after the definition |\def\x {12}|, one can not use
  {\color{blue}|-\x|} as input to one of the package macros: the \fexpan sion
  will act only on the minus sign, hence do nothing. The only way is to use the
  \csbxint{Opp} macro, or perhaps here rather \csbxint{iOpp} which does
    maintains integer format on output, as they  replace a number with
    its opposite.

  \begingroup\slshape
  Again, this is otherwise inside an \csbxint{theexpr}-ession or
  \csbxint{thefloatexpr}-ession. There, the
  minus sign may prefix macros which will expand to numbers (or parentheses
  etc...)
  \endgroup

\def\x {12}%
\def\AplusBC #1#2#3{\xintAdd {#1}{\xintMul {#2}{#3}}}%

\item \label{item:xpxp} With the definition 
%
\leftedline{|\def\AplusBC #1#2#3{\xintAdd {#1}{\xintMul {#2}{#3}}}|}
%
one obtains an
  expandable macro producing the expected result, not in two, but rather in
  three steps: a first expansion is consumed by the macro expanding to its
  definition. As the package macros expand their arguments until no more is
  possible (regarding what comes first), this |\AplusBC| may be used inside
  them: {|\xintAdd {\AplusBC {1}{2}{3}}{4}|} does work and returns
  \dtt{\xintAdd {\AplusBC {1}{2}{3}}{4}}.

  If, for some reason, it is important to create a macro expanding in two steps
  to its final value, one may either do:
%
\smallskip
%
\leftedline {|\def\AplusBC #1#2#3{\romannumeral-`0\xintAdd {#1}{\xintMul
      {#2}{#3}}}|}
%
or use the \emph{lowercase} form of \csa{xintAdd}: 
%
\smallskip
%
\leftedline {|\def\AplusBC #1#2#3{\romannumeral0\xintadd {#1}{\xintMul
      {#2}{#3}}}|}

  and then \csa{AplusBC} will share the same properties as do the
  other \xintname `primitive' macros.

\item
The |\romannumeral0| and |\romannumeral-`0| things above look like an invitation
to hacker's territory; if it is not important that the macro expands in two
steps only, there is no reason to follow these guidelines. Just chain
arbitrarily the package macros, and the new ones will be completely expandable
and usable one within the other.

Since release |1.07| the \csbxint{NewExpr} command automatizes the creation of
such expandable macros: 
%
\leftedline{|\xintNewExpr\AplusBC[3]{#1+#2*#3}|}
%
creates the |\AplusBC| macro doing the above and expanding in two expansion
steps.

\item In the expression parsers of \xintexprname such as
  \csbxint{expr}|..\relax|, \csbxint{floatexpr}|..\relax| the contents are
  expanded completely from left to right until the ending |\relax| is found
  and swallowed, and spaces and even (to some extent) catcodes do not matter.

\item For all variants, prefixing with \csbxint{the} allows to print the
  result or use it in other contexts. Shortcuts \csbxint{theexpr},
  \csbxint{thefloatexpr}, \csbxint{theiiexpr}, \dots\ are available.

\end{enumerate}

\subsection{Analogies and differences of \csbh{xintiiexpr} with \csbh{numexpr}}

\csbxint{iiexpr}|..\relax| is a parser of expressions knowing only (big)
integers. There are, besides the enlarged range of allowable inputs, some
important differences of syntax between |\numexpr| and |\xintiiexpr| and
variants:
\begin{itemize}
\item Contrarily to |\numexpr|, the |\xintiiexpr| parser will stop expanding
  only after having encountered (and swallowed) a \emph{mandatory} |\relax|
  token.
\item In particular, spaces between digits (and not only around infix
  operators or parentheses) do not stop |\xintiiexpr|, contrarily to the
  situation with |numexpr|: |\the\numexpr 7 + 3 5\relax| expands (in one step)
  to \dtt{\detokenize\expandafter{\the\numexpr 7 + 3 5\relax}\unskip}, whereas
  |\xintthe\xintiiexpr 7 + 3 5\relax| expands (in two steps) to
  \dtt{\detokenize\expandafter\expandafter\expandafter {\xintthe\xintiiexpr 7
      + 3 5\relax}}.
  \item Inside an |\edef|, expressions |\xintiiexpr...\relax| get fully
    evaluated, but to a private format which needs the prefix \csbxint{the} to
    get printed or used as arguments to some macros; on the other hand
    expansion of |\numexpr| in an |\edef| occurs only if prefixed with |\the|
    or |\number| (or |\romannumeral|, or the expression is included in a
    bigger |\numexpr| which will be the one to have to be prefixed\dots .)
  \item |\the\numexpr| or |\number\numexpr| expands in one step, but
    |\xintthe\xintiiexpr| needs two steps.
\item The \csbxint{the} prefix should not be applied to a sub
  |\xintiiexpr|ession, as this forces the parsers to gather again one by one
  the corresponding digits.
\item Also worth mentioning is the fact that |\numexpr -(1)\relax| is illegal.
  But |\xintiiexpr -(1)\relax| is perfectly legal and gives the expected
  result (what else ?).
\end{itemize}

\subsection{User interface}
\label{ssec:userinterface}

%{\etocdefaultlines\etocsettocstyle{}{}\localtableofcontents}

The next sections will explain the various inputs which are recognized by the
package macros and the format for their outputs. Inputs have mainly five
possible shapes:
\begin{enumerate}
\item expressions which will end up inside a |\numexpr..\relax|,

\item long integers in the strict format (no |+|, no leading zeroes, a count
  register or variable must be prefixed by |\the| or |\number|)

\item long integers in the general format allowing both |-| and |+| signs, then
  leading zeroes, and a count register or variable without prefix is allowed,

\item fractions with numerators and denominators as in the
  previous item, or also decimal numbers, possibly in scientific notation (with
  a lowercase |e|), and
  also optionally the semi-private |A/B[N]| format,

\item and finally expandable material understood by the |\xintexpr| parser.
\end{enumerate}
Outputs are mostly of the following types:
\begin{enumerate}
\item long integers in the strict format,

\item fractions in the |A/B[N]| format where |A| and |B| are both strict long
  integers, and |B| is positive,

\item numbers in scientific format (with a lowercase |e|),

\item the private |\xintexpr| format which needs the |\xintthe| prefix in order
  to end up on the printed page (or get expanded in the log)
  or be used as argument to the package macros.
\end{enumerate}

\subsection{No declaration of variables}

\begin{framed}
  There is no notion of a \emph{declaration of a variable}, which would be
  needed to use the arithmetic macros.\footnotemark{}
  To do a computation and assign its result to some macro |\z|, the user will employ the |\def|, |\edef|, or |\newcommand| (in \LaTeX)
  as usual, keeping in mind that two expansion steps are needed, thus |\edef|
  is initially the main tool: \IMPORTANT
%
\begin{everbatim*}
\def\x{1729728} \def\y{352827927} \edef\z{\xintiiMul {\x}{\y}}
\meaning\z
\end{everbatim*}
 
As an alternative to |\edef| the package provides |\oodef| which expands
exactly twice the replacement text, and |\fdef| which applies \fexpan sion to
the replacement text during the definition.
\begin{everbatim*}
\def\x{1729728} \def\y{352827927} \oodef\w {\xintiiMul\x\y} \fdef\z{\xintiiMul {\x}{\y}}
\meaning\w, \meaning\z
\end{everbatim*}

In practice |\oodef| is slower than |\edef|, except for computations ending in
very big final replacement texts (thousands of digits). On the other hand
|\fdef| appears to be slightly faster than |\edef| already in the case of
expansions leading to only a few dozen digits.
\end{framed}
\footnotetext{\xintexprname does provide an interface to
  declare and assign values to identifiers which can be used in expressions.
  See \hyperlink{item:defvar}{\string\xintdefvar}.}

% \begingroup % pour \z, \zz
% The \xintexprname package has a private internal
% representation for the evaluated computation result. With
% %
% \begin{everbatim*}
% \edef\z {\xintexpr 3.141^18\relax}
% \end{everbatim*}
% %
% the macro |\z| is already fully evaluated (two expansions were applied, and this
% is enough), and can be reused in other |\xintexpr|-essions, such as for example
% %
% \begin{everbatim*}
% \edef\zz {\xintexpr \z+1/\z\relax}
%   % (using short macro names such as \z and \zz is not too recommended in real
%   % life, some may have already definitions; I did it all in a group).
% \end{everbatim*}
% %
% But to print it, or to use it as argument to one of the package macros,
% it must be prefixed by |\xintthe| (a synonym for |\xintthe\xintexpr| is
% \csbxint{theexpr}). Application of this |\xintthe| prefix outputs the
% value in the \xintfracname semi-private internal format
% |A/B[N]|,\footnote{there is also the notion of \csbxint{floatexpr}, for
%   which the output format after the action of \csa{xintthe} is a number in
%   floating point scientific notation.} representing the fraction
% $(A/B)\times 10^N$. The |\zz| above produces a somewhat large output:
% \begin{everbatim*}
% \printnumber{\xintthe\zz }${}\approx{}$\xintFloat{\xintthe\zz}
% \end{everbatim*}
% \endgroup % pour \z, \zz

%   \begin{framed}
%     By default, computations done by the macros of \xintfracname or within
%     |\xintexpr..\relax| are exact. Inputs containing decimal points or
%     scientific parts do not make the package switch to a `floating-point' mode.
%     The inputs, however long, are converted into exact internal representations.
% %
%     % Floating point evaluations are done via special macros containing
%     % `Float' in their names, or inside |\xintfloatexpr|-essions.

%     Manipulating exactly big fractions quickly leads to \dots bigger fractions.
%     There is a command \csbxint{Irr} (or the function |reduce| in an expression)
%     to reduce to smallest terms, but it has to be explicitely requested. Prior
%     to release |1.1| addition and subtraction blindly multiplied denominators;
%     they now check if one is a multiple of the other.\IMPORTANT\ But systematic
%     reduction of the result to its smallest terms would be too
%     costly.\def\everbatimindent{0pt }
% \begin{everbatim*}
% \xinttheexpr 27/25+46/50\relax\ is a bit simpler than \xinttheexpr (27*50+25*46)/(25*50)\relax, 
% but less so than \xinttheexpr reduce(27/25+46/50)\relax. And \xinttheexpr 3/75+4/50+2/100\relax\
% looks weird, but systematically reducing fractions would be too costly. 
% \end{everbatim*}
%   \end{framed}

% %
% The |A/B[N]| shape is the output format of most \xintfracname macros, it
% benefits from accelerated parsing when used on input, compared to the normal
% user syntax which has no |[N]| part. An example of valid user input for a
% fraction is
% %
% \leftedline{|-123.45602e78/+765.987e-123|}
% %
% where both the decimal parts, the scientific exponent parts, and the whole
% denominator are optional components. The corresponding semi-private form in this
% case would be
% %
% \leftedline{\xintRaw{-123.45602e78/+765.987e-123}}
% %
% The forward slash |/| is simply a delimiter to separate numerator and
% denominator, in order to allow inputs having such denominators.

% Reduction to the irreducible form of the output must be asked for explicitely
% via the \csbxint{Irr} macro or the |reduce| function within
% |\xintexpr..\relax|. Elementary operations on fractions do very little of the
% simplifications which could be obvious to (some) human beings.

\subsection {Input formats}\label{sec:inputs}

Some macro arguments are by nature `short' integers,\ntype{\numx} \emph{i.e.}
less than (or equal to) in absolute value \np{\number "7FFFFFFF}. This is
generally the case for arguments which serve to count or index something. They
will be embedded in a |\numexpr..\relax| hence on input one may even use count
registers or variables and expressions with infix operators. Notice though that
|-(..stuff..)| is surprisingly not legal in the |\numexpr| syntax!

But \xintname is mainly devoted to big numbers;
the allowed input formats for `long numbers' and `fractions' are:
\begin{enumerate}
\item the strict format\ntype{f} is for some macros of \xintname which only
  \fexpan d their arguments. After this \fexpan sion the input should be a
  string of digits, optionally preceded by a unique minus sign. The first
  digit can be zero only if the number is zero. A plus sign is not accepted.
  |-0| is not legal in the strict format. A count register can serve as
  argument of such a macro only if prefixed by |\the| or |\number|. Macros of
  \xintname such as \csbxint{iiAdd} with a double |ii| require this `strict'
  format for the inputs. The macros such as \csbxint{iAdd} with a single |i|
  will apply the \csbxint{Num} normalizer described in the next item.

\item the macro \csbxint{Num} normalizes into strict format an input having
  arbitrarily many minus and plus signs, followed by a string of zeroes, then
  digits:%
  %
  \leftedline{|\xintNum
    {+-+-+----++-++----00000000009876543210}|\dtt{=\xintNum
      {+-+-+----++-++----0000000009876543210}}}
  %
  The extended integer format\ntype{\Numf} is thus for the arithmetic macros
  of \xintname which automatically parse their arguments via this
  \csbxint{Num}.%
%
\footnote{A
    \LaTeX{} |\value{countername}| is accepted as macro
    argument.}

\item the fraction format\ntype{\Ff} is what is expected on input by the
  macros of \xintfracname. It has two variants:
  \begin{description}
  \item[general:] these are inputs of the shape |A.BeC/D.EeF|. Example:
\begin{everbatim*}
\noindent\xintRaw{+--0367.8920280e17/-++278.289287e-15}\newline
\xintRaw{+--+1253.2782e++--3/---0087.123e---5}\par
\end{everbatim*}
    Notice that the input process does not reduce fractions to smallest terms.
    Here are the rules of the format:\footnote{Earlier releases were slightly
      more strict, the optional decimal parts |B|, |E| were not individually
      \fexpan ded.}
    \begin{itemize}
    \item everything is optional, absent numbers are treated as zero, here are
      some extreme cases:
\begin{everbatim*}
\xintRaw{}, \xintRaw{.}, \xintRaw{./1.e}, \xintRaw{-.e}, \xintRaw{e/-1}
\end{everbatim*}
    \item |AB| and |DE| may start with pluses and minuses, then leading
      zeroes, then digits.
    \item |C| and |F| will be given to |\numexpr| and can be anything
      recognized as such and not provoking arithmetic overflow (the lengths of
      |B| and |E| will also intervene to build the final exponent naturally
      which must obey the \TeX{} bound).
    \item the |/|, |.| (numerator and/or denominator) and |e|
      (numerator and/or denominator) are all optional components.
    \item each of |A|, |B|, |C|, |D|, |E| and |F| may arise from \fexpan sion
      of a macro.
    \item the whole thing may arise from \fexpan sion, however the |/|, |.|,
      and |e| should all come from this initial expansion. The |e| of
      scientific notation is mandatorily lowercased.
    \end{itemize}
  \item[restricted:] these are inputs either of the shape |A[N]| or |A/B[N]|
    (representing the fraction |A/B| times |10^N|) where the whole thing or
    each of |A|, |B|, |N| (but then not |/| or |[|) may arise from \fexpan
    sion, |A| (after expansion) \emph{must} have a unique optional minus sign
    and no leading zeroes, |B| (after expansion) if present \emph{must} be a
    positive integer with no signs and no leading zeroes, |N| (which may be
    empty) will be given to |\numexpr|. This format is parsed with smaller
    overhead than the general one, thus allowing more efficient nesting of
    macros as it is the one used on output (except for the floating macros).
    Any deviation from the rules above will result in errors.\footnote{With
      releases earlier than |1.2| the |N| could not be empty and had to be
      given as explicit digits, not some macro or expression expanded in
      |\numexpr|.}
  \end{description}
  Notice that |*|, |+| and |-| contrarily to the |/| (which is treated simply
  as a kind of delimiter) are not acceptable within arguments of this 
  type\ntype{\Ff}
  (see however \autoref{sec:useofcount} for some exceptions).

\item the \hyperref[xintexpr]{expression format} is for inclusion in an
  \csbxint{expr}|...\relax|, it uses infix notations, function names, complete
  expansion, recognizes decimal and scientific numbers, and is described in
  \autoref{sec:expr11} and \autoref{sec:expr}.%
%
\footnote{The isolated dot |"."| is not legal anymore\MyMarginNote{Changed!} in expressions with
  release |1.2|: there must be digits either before or after.}
\end{enumerate}

Generally speaking, there should be no spaces among the digits in the inputs
(in arguments to the package macros). Although most would be harmless in most
macros, there are some cases where spaces could break havoc.%
\footnote{The \csbxint{Num} macro does not remove spaces between digits beyond
  the first non zero ones; however this should not really alter the subsequent
  functioning of the arithmetic macros, and besides, since \xintcorename v1.2
  there is an initial parsing of the entire number, during which spaces will
  be gobbled. However I have not done a complete review of the legacy code to
  be certain of all possibilities after |v1.2| release. One thing to be aware
  of is that \csa{numexpr} stops on spaces between digits (although it
  provokes an expansion to see if an infix operator follows); the exponent for
  \csbxint{iiPow} or the argument of the factorial \csbxint{iFac} are only
  subjected to such a \csa{numexpr} (there are a few other macros with such
  input types in \xintname). If the input is given as, say |1 2\x| where
  \csa{x} is a macro, the macro \csa{x} will not be expanded by the
  \csa{numexpr}, and this will surely cause problems afterwards. Perhaps a
  later \xintname will force \csa{numexpr} to expand beyond spaces, but I
  decided that was not really worth the effort. Another immediate cause of
  problems is an input of the type |\xintiiAdd{<space>\x}{\y}|, because the
  space will stop the initial expansion; this will most certainly cause an
  arithmetic overflow later when the \csa{x} will be expanded in a
  \csa{numexpr}. Thus in conclusion, damages due to spaces are unlikely if
  only explicit digits are involved in the inputs, or arguments are single
  macros with no preceding space.}
%
% j'avais oubli que mon |...| savait grer les \ dans les footnote pas besoin
% de \char92 ou autre!
%
So the best is to avoid them entirely.

This is entirely otherwise inside an |\xintexpr|-ession, where spaces are
ignored (except when they occur inside arguments to some macros, thus
escaping the |\xintexpr| parser). See the \hyperref[sec:expr]{documentation}.

Arithmetic macros of \xintname which parse their arguments automatically through
\csbxint{Num} are signaled by a special
symbol%\ntype{\Numf{\unskip\kern\dimexpr\FrameSep+\FrameRule\relax}}
\ntype{\Numf} in the margin. This symbol also means that these arguments may
contain to some extent infix algebra with count registers, see the section
\hyperref[sec:useofcount]{Use of count registers}.

  With \xintfracname loaded the symbol \smash{\Numf} means that a fraction is
  accepted if it is a whole number in disguise; and for macros accepting the
  full fraction format with no restriction there is the corresponding symbol
  in the margin\ntype{\Ff}.
%

There are also some slighly more obscure expansion types: in particular, the
\csbxint{ApplyInline} and \csbxint{For*} macros from \xinttoolsname apply a
special iterated \fexpan sion, which gobbles spaces, to the non-braced items
(braced items are submitted to no expansion because the opening brace stops
it) coming from their list argument; this is denoted by a special
symbol\ntype{{\lowast f}} in the margin. Some other macros such as
\csbxint{Sum} from \xintfracname first do an \fexpan sion, then treat each
found (braced or not) item (skipping spaces between such items) via the
general fraction input parsing, this is signaled as
here\ntype{f{$\to$}{\lowast\Ff}} in the margin where the signification of the
\lowast{} is thus a bit different from the previous case.

A few macros from \xinttoolsname do not expand, or expand only once their
argument\ntype{n{{\color{black}\upshape, resp.}} o}. This is also
signaled in the margin with notations \`a la \LaTeX3.

As the computations are done by \fexpan dable macros which \fexpan d their
argument they may be chained up to arbitrary depths and still produce expandable
macros.

Conversely, wherever the package expects on input a ``big'' integers, or a
``fraction'', \fexpan sion of the argument \emph{must result in a complete
  expansion} for this argument to be acceptable.%
%
\footnote{this is not quite as
  stringent as claimed here, see \autoref{sec:useofcount} for more details.}
The
main exception is inside \csbxint{expr}|...\relax| where everything will be
expanded from left to right, completely.


\subsection{Output formats}

Package \xintcorename provides macros \csbxint{iiAdd}, \csbxint{iiSub},
\csbxint{iiMul}, \csbxint{iiPow}, which only \fexpan d their arguments and
\csbxint{iAdd}, \csbxint{iSub}, \csbxint{iMul}, \csbxint{iPow} which
normalize them first to strict format, thus have a bit of overhead. These
macros always produce integers on output.

With \xintfracname loaded \csbxint{iiAdd}, \csbxint{iiSub}, \csbxint{iiMul},
... are not modified, and \csbxint{iAdd}, \csbxint{iSub}, \csbxint{iMul}, ...
are only extended to the extent of accepting fraction inputs but they will be
truncated to integers.%
%
\footnote{the power function does not accept a fractional exponent. Or rather,
  does not expect, and errors will result if one is provided.}
%
The output will be an integer.

\begin{framed}
  The fraction handling macros from \xintfracname are called \csbxint{Add},
  \csbxint{Sub}, \csbxint{Mul}, etc... they are \emph{not} defined in the
  absence of \xintfracname.\MyMarginNote[\kern\dimexpr\FrameSep+\FrameRule\relax]{Changed!}

  They produce on output a fractional number |f=A/B[n]| (which stands for
  |(A/B)|$\times$|10^n|) where |A| and |B| are integers, with |B| positive,
  and |n| is a ``short'' integer (\emph{i.e} less in absolute value than
  \dtt{\number"7FFFFFFF}.)
 
  The output fraction is not reduced to smallest terms. The |A| and |B| may
  end in zeroes (\emph{i.e}, |n| does not represent all powers of ten). The
  denominator |B| is always strictly positive. There is no |+| sign on output
  but only possibly a |-| at the numerator. The output will be expressed as
  a fraction even if the inputs are both integers.
\end{framed}

\begin{itemize}
\item A macro \csbxint{Frac} is provided for the typesetting (math-mode
  only) of such a `raw' output. The command \csbxint{Frac} is not accepted as
  input to the package macros, it is for typesetting only (in math mode).

\item \csbxint{Raw} prints the fraction directly as its internal
  representation |A/B[n]|.
\begin{everbatim*}
$\xintRaw{273.3734e5/3395.7200e-2}=\xintFrac {273.3734e5/3395.7200e-2}$
\end{everbatim*}

\item \csbxint{PRaw} does the same but without printing the |[n]| if |n=0| and
  without printing |/1| if |B=1|.

\item \csbxint{Irr} reduces the fraction to its irreducible form |C/D|
  (without a trailing |[0]|), and it prints the |D| even if |D=1|.
\begin{everbatim*}
$\xintIrr{273.3734e5/3395.7200e-2}$
\end{everbatim*}

\item \csbxint{Num} from package \xintname becomes when \xintfracname is
  loaded a synonym to its macro \csbxint{TTrunc} (same as
  \csbxint{iTrunc}|{0}|) which truncates to the nearest integer.

\item See also the documentations of \csbxint{Trunc}, \csbxint{iTrunc},
\csbxint{XTrunc}, \csbxint{Round}, \csbxint{iRound} and \csbxint{Float}.

\item The \csbxint{iAdd}, \csbxint{iSub}, \csbxint{iMul}, \csbxint{iPow}
  macros and some others accept fractions on input which they truncate via
  \csbxint{TTrunc}. On output they still produce an integer with no fraction
  slash nor trailing |[n]|.

\item The \csbxint{iiAdd}, \csbxint{iiSub}, \csbxint{iiMul}, \csbxint{iiPow},
  and others with `\textcolor{blue}{ii}' in their names accept on input only
  integers in the strict format. They skip the overhead of the \csbxint{Num}
  parsing and naturally they output integers, with no fraction slash nor
  trailing |[n]|.

\end{itemize}

%\subsection{Multiple outputs}\label{sec:multout}

Some macros return a token list of two or more numbers or fractions; they are
then each enclosed in braces. Examples are \csbxint{iiDivision} which gives
first the quotient and then the remainder of euclidean division,
\csbxint{Bezout} from the \xintgcdname package which outputs five numbers,
\csbxint{FtoCv} from the \xintcfracname package which returns the list of the
convergents of a fraction, ... \autoref{sec:assign} and \autoref{sec:utils}
mention utilities, expandable or not, to cope with such outputs.

Another type of multiple number output is when using commas inside
\csbxint{expr}|..\relax|:
%
\leftedline{|\xinttheiexpr 10!,2^20,lcm(1000,725)\relax|%
     $\to$\dtt{\xinttheiexpr 10!,2^20,lcm(1000,725)\relax}}

This returns a comma separated list, with a space after each comma.

% \section{Use of \TeX{}registers and variables}

% {\etocdefaultlines\etocsettocstyle{}{}\localtableofcontents}

\subsection{Use of count registers}\label{sec:useofcount}

Inside |\xintexpr..\relax| and its variants, a count register or count control
sequence is automatically unpacked using |\number|, with tacit multiplication:
|1.23\counta| is like |1.23*\number\counta|. There
is a subtle difference between count \emph{registers} and count
\emph{variables}. In |1.23*\counta| the unpacked |\counta| variable defines a
complete operand thus |1.23*\counta 7| is a syntax error. But |1.23*\count0|
just replaces |\count0| by |\number\count0| hence |1.23*\count0 7| is like
|1.23*57| if |\count0| contains the integer value |5|.

Regarding now the package macros, there is first the case of arguments having to
be short integers: this means that they are fed to a |\numexpr...\relax|, hence
submitted to a \emph{complete expansion} which must deliver an integer, and
count registers and even algebraic expressions with them like
|\mycountA+\mycountB*17-\mycountC/12+\mycountD| are admissible arguments (the
slash stands here for the rounded integer division done by |\numexpr|). This
applies in particular to the number of digits to truncate or round with, to the
indices of a series partial sum, \dots

The macros allowing the extended format for long numbers or dealing with
fractions will \emph{to some extent} allow the direct use of count
registers and even infix algebra inside their arguments: a count
register |\mycountA| or |\count 255| is admissible as numerator or also as
denominator, with no need to be prefixed by |\the| or |\number|. It is possible
to have as argument an algebraic expression as would be acceptable by a
|\numexpr...\relax|, under this condition: \emph{each of the numerator and
  denominator is expressed with at most \emph{eight}
  tokens}.%
%
\footnote{Attention! there is no problem with a \LaTeX{}
  \csa{value}\texttt{\{countername\}} if if comes first, but if it comes later
  in the input it will not get expanded, and braces around the name will be
  removed and chaos\IMPORTANT{} will ensue inside a \csa{numexpr}. One should
  enclose the whole input in \csa{the}\csa{numexpr}|...|\csa{relax} in such
  cases.} 
%
The slash for rounded division in a |\numexpr| should be written with
braces |{/}| to not be confused with the \xintfracname delimiter between
numerator and denominator (braces will be removed internally). Example:
|\mycountA+\mycountB{/}17/1+\mycountA*\mycountB|, or |\count 0+\count
2{/}17/1+\count 0*\count 2|, but in the latter case the numerator has the
maximal allowed number of tokens (the braced slash counts for only one).
%
\leftedline{|\cnta 10 \cntb 35 \xintRaw
  {\cnta+\cntb{/}17/1+\cnta*\cntb}|\dtt{->\cnta 10 \cntb 35 \xintRaw
    {\cnta+\cntb{/}17/1+\cnta*\cntb}}} 
%
For longer algebraic expressions using
count registers, there are two possibilities:
\begin{enumerate}
\item encompass each of the numerator and denominator in |\the\numexpr...\relax|,
\item encompass each of the numerator and denominator in |\numexpr {...}\relax|.
\end{enumerate}
\everb|@
\cnta 100 \cntb 10 \cntc 1
\xintPRaw {\numexpr {\cnta*\cnta+\cntb*\cntb+\cntc*\cntc+
                    2*\cnta*\cntb+2*\cnta*\cntc+2*\cntb*\cntc}\relax/%
          \numexpr {\cnta*\cnta+\cntb*\cntb+\cntc*\cntc}\relax }
|
\cnta 100 \cntb 10 \cntc 1
%
\leftedline{\dtt{\xintPRaw {\numexpr
      {\cnta*\cnta+\cntb*\cntb+\cntc*\cntc+
                    2*\cnta*\cntb+2*\cnta*\cntc+2*\cntb*\cntc}\relax/%
          \numexpr {\cnta*\cnta+\cntb*\cntb+\cntc*\cntc}\relax }}}
%
The braces would not be accepted
      as regular
|\numexpr|-syntax: and indeed, they
        are removed at some point in the processing.

\subsection{Dimensions}
\label{sec:Dimensions}

\meta{dimen} variables can be converted into (short) integers suitable for the
\xintname macros by prefixing them with |\number|. This transforms a dimension
into an explicit short integer which is its value in terms of the |sp| unit
($1/65536$\,|pt|).
When |\number| is applied to a \meta{glue} variable, the stretch and shrink
components are lost.

For \LaTeX{} users: a length is a \meta{glue} variable, prefixing a
length command defined by \csa{newlength} with \csa{number} will thus discard
the |plus| and |minus| glue components and return the dimension component as
described above, and usable in the \xintname bundle macros.

This conversion is done automatically inside an
|\xintexpr|-essions, with tacit multiplication implied if prefixed by some
(integral or decimal) number.

One may thus compute areas or volumes with no limitations, in units of |sp^2|
respectively |sp^3|, do arithmetic with them, compare them, etc..., and possibly
express some final result back in another unit, with the suitable conversion
factor and a rounding to a given number of decimal places.

A \hyperref[tableofdimensions]{table of dimensions} illustrates that the
internal values used by \TeX{} do not correspond always to the closest rounding.
For example a millimeter exact value in terms of |sp| units is
\dtt{72.27/10/2.54*65536=\xinttheexpr trunc(72.27/10/2.54*65536,3)\relax
  ...} and \TeX{} uses internally \dtt{\number\dimexpr 1mm\relax}|sp| (it
thus appears that \TeX{} truncates to get an integral multiple of the |sp|
unit).

% impossible avec le \ignorespaces mis par LaTeX de faire \number\dimexpr
% idem  la fin avec \unskip, si je veux xinttheexpr
\begin{figure*}[ht!]
\phantomsection\label{tableofdimensions}
\begingroup\let\ignorespaces\empty
           \let\unskip\empty
           \def\T{\expandafter\TT\number\dimexpr}
           \def\TT#1!{\gdef\tempT{#1}}
           \def\E{\expandafter\expandafter\expandafter
                  \EE\xintexpr reduce(}
           \def\EE#1!{\gdef\tempE{#1}}
\centeredline{\begin{tabular}{%
                >{\bfseries\strut}c%
                c%
                >{\E}c<{)\relax!}@{}%
                >{\xintthe\tempE}r@{${}={}$}%
                >{\xinttheexpr trunc(\tempE,3)\relax...}l%
                >{\T}c<{!}@{}%
                >{\tempT}r%
                >{\xinttheexpr round(100*(\tempT-\tempE)/\tempE,4)\relax\%}c}
   \hline
   Unit&%
   definition&%
   \omit &%
   \multicolumn{2}{c}{Exact value in \texttt{sp} units\strut}&%
   \omit &%
   \omit\parbox{2cm}{\centering\strut\TeX's value in \texttt{sp} units\strut}&%
   \omit\parbox{2cm}{\centering\strut Relative error\strut}\\\hline
  cm&0.01 m&72.27/2.54*65536&&&1cm&&\\
  mm&0.001 m&72.27/10/2.54*65536&&&1mm&&\\
  in&2.54 cm&72.27*65536&&&1in&&\\
  pc&12 pt&12*65536&&&1pc&&\\
  pt&1/72.27 in&65536&&&1pt&&\\
  bp&1/72 in&72.27*65536/72&&&1bp&&\\
  \omit\hfil\llap{3}bp\hfil&1/24 in&72.27*65536/24&&&3bp&&\\
  \omit\hfil\llap{12}bp\hfil&1/6 in&72.27*65536/6&&&12bp&&\\
  \omit\hfil\llap{72}bp\hfil&1 in&72.27*65536&&&72bp&&\\
  dd&1238/1157 pt&1238/1157*65536&&&1dd&&\\
  \omit\hfil\llap{11}dd\hfil&11*1238/1157 pt&11*1238/1157*65536&&&11dd&&\\
  \omit\hfil\llap{12}dd\hfil&12*1238/1157 pt&12*1238/1157*65536&&&12dd&&\\
  sp&1/65536 pt&1&&&1sp&&\\\hline
  \multicolumn{8}{c}{\bfseries\large\TeX{} \strut dimensions}\\\hline
\end{tabular}}
\endgroup
\end{figure*}

There is something quite amusing with the Didot point. According to the \TeX
Book, $1157$\,|dd|=$1238$\,|pt|. The actual internal value of $1$\,|dd| in \TeX{} is $70124$\,|sp|. We can use \xintcfracname to display the list of
centered convergents of the fraction $70124/65536$:
%
\leftedline{|\xintListWithSep{, }{\xintFtoCCv{70124/65536}}|}
%
\xintFor* #1 in {\xintFtoCCv{70124/65536}}\do {$\printnumber{#1}$, }%
and we don't find
$1238/1157$ therein, but another approximant $1452/1357$!

And indeed multiplying $70124/65536$ by $1157$, and respectively $1357$, we find
the approximations (wait for more, later):
%
\leftedline{``$1157$\,|dd|''\dtt{=\xinttheexpr trunc(1157\dimexpr
    1dd\relax/\dimexpr 1pt\relax,12)\relax}\dots|pt|}
%
\leftedline{``$1357$\,|dd|''\dtt{=\xinttheexpr trunc(1357\dimexpr
    1dd\relax/\dimexpr 1pt\relax,12)\relax}\dots|pt|}
%
and we seemingly discover that $1357$\,|dd|=$1452$\,|pt| is \emph{far more
  accurate} than
the \TeX Book formula $1157$\,|dd|=$1238$\,|pt|~!
The formula to compute $N$\,|dd| was
%
\leftedline{|\xinttheexpr trunc(N\dimexpr 1dd\relax/\dimexpr
  1pt\relax,12)\relax}|}
%

What's the catch? The catch is that \TeX{} \emph{does not} compute $1157$\,|dd|
like we just did:%
%
\leftedline{$1157$\,|dd|=|\number\dimexpr 1157dd\relax/65536|%
      \dtt{=\xintTrunc{12}{\number\dimexpr 1157dd\relax/65536}}\dots|pt|}
%
\leftedline{$1357$\,|dd|=|\number\dimexpr 1357dd\relax/65536|%
      \dtt{=\xintTrunc{12}{\number\dimexpr 1357dd\relax/65536}}\dots|pt|}
%
We thus discover that \TeX{} (or rather here, e-\TeX{}, but one can check that
this works the same in \TeX82), uses indeed $1238/1157$ as a conversion
factor, and necessarily intermediate computations are done with more precision
than is possible with only integers less than $2^{31}$ (or $2^{30}$ for
dimensions). Hence the $1452/1357$ ratio is irrelevant, a misleading artefact
of the necessary rounding (or, as we see, truncating) for one |dd| as an
integral number of |sp|'s.

Let us now
use |\xintexpr| to compute the value of the Didot point in millimeters, if
the above rule is exactly verified: 
%
\leftedline{|\xinttheexpr
 trunc(1238/1157*25.4/72.27,12)\relax|%
  \dtt{=\xinttheexpr trunc(1238/1157*25.4/72.27,12)\relax}|...mm|} 
%
This fits very well with the possible values of the Didot point as listed in
the
\href{http://en.wikipedia.org/wiki/Point_%28typography%29#Didot}{Wikipedia Article}.
%
The value $0.376065$\,|mm| is said to be \emph{the traditional value in
  European printers' offices}. So the $1157$\,|dd|=$1238$\,|pt| rule refers to
this Didot point, or more precisely to the \emph{conversion factor} to be used
between this Didot and \TeX{} points.

The actual value in millimeters of exactly one Didot point as implemented in
\TeX{} is
%
\leftedline {|\xinttheexpr trunc(\dimexpr
  1dd\relax/65536/72.27*25.4,12)\relax|} 
%
\leftedline{\dtt{=\xinttheexpr trunc(\dimexpr
    1dd\relax/65536/72.27*25.4,12)\relax}|...mm|}
%
The difference of circa $5$\AA\ is arguably tiny!

% 543564351/508000000

By the way the \emph{European printers' offices \emph{(dixit Wikipedia)}
  Didot} is thus exactly
%
\leftedline{|\xinttheexpr reduce(.376065/(25.4/72.27))\relax|%
   \dtt{=\xinttheexpr reduce(.376065/(25.4/72.27))\relax}\,|pt|}
%
and the centered convergents of this fraction are \xintFor* #1 in
{\xintFtoCCv{543564351/508000000}}\do {\dtt{\printnumber{#1}}\xintifForLast{.}{, }} We do
recover the $1238/1157$ therein!

% As a final comment on the \hyperref[tableofdimensions]{table of dimensions}, we
% conclude that the ``Relative Error'' column is misleading as these relative
% errors by necessity decrease for integer multiples of the given dimension units.
% This was already indicated by the \textbf{72bp} row.

% To conclude our comments on the
% \hyperref[tableofdimensions]{table of dimensions}, the big point, now known as
% \emph{Desktop Publishing Point} is less accurately implemented in \TeX{} than
% other units. Let us test for example the relation $1$\,|in|$=72$\,|bp|, the difference is
% %
% \centeredline{|\number\numexpr\dimexpr1in\relax-72*\dimexpr1bp\relax\relax|%
% \dtt{=\number\numexpr\dimexpr1in\relax-72*\dimexpr1bp\relax\relax}\,|sp|}
% \centeredline{|\number\dimexpr1in-72bp\relax|%
% \dtt{=\number\dimexpr1in-72bp\relax}\,|sp|}
% on the other hand
% \centeredline{|\xinttheexpr reduce(\dimexpr1in\relax-72.27*\dimexpr1pt\relax)\relax|}
% \centeredline
% \dtt{=\xinttheexpr reduce(\dimexpr1in\relax-72.27*\dimexpr1pt\relax)\relax}\,|sp|=$-0.72$\,|sp|}
% \centeredline
% {\dtt{=\number\dimexpr1in-72.27pt\relax}\,|sp|=$-0.72$\,|sp|}

\subsection{\csh{ifcase}, \csh{ifnum}, ... constructs}\label{sec:ifcase}

When using things such as |\ifcase \xintSgn{\A}| one has to make sure to leave
a space after the closing brace for \TeX{} to
stop its scanning for a number: once \TeX{} has finished expanding
|\xintSgn{\A}| and has so far obtained either |1|, |0|, or |-1|, a
space (or something `unexpandable') must stop it looking for more
digits. Using |\ifcase\xintSgn\A| without the braces is very dangerous,
because the blanks (including the end of line) following |\A| will be
skipped and not serve to stop the number which |\ifcase| is looking for.
%
\begin{everbatim*}
\begin{enumerate}[nosep]\def\A{1}
\item \ifcase \xintSgn\A 0\or OK\else ERROR\fi
\item \ifcase \xintSgn\A\space 0\or OK\else ERROR\fi
\item \ifcase \xintSgn{\A} 0\or OK\else ERROR\fi
\end{enumerate}
\end{everbatim*}

In order to use successfully |\if...\fi| constructions either as arguments to
the \xintname bundle expandable macros, or when building up a completely
expandable macro of one's own, one needs some \TeX nical expertise (see also
\autoref{fn:expansions} on page~\pageref{fn:expansions}).

It is thus much to be recommended to opt rather for already existing expandable
branching macros, such as the ones which are provided by
\xintname/\xintfracname: among them
\csbxint{SgnFork}, \csbxint{ifSgn}, \csbxint{ifZero}, \csbxint{ifOne},
\csbxint{ifNotZero}, \csbxint{ifTrueAelseB}, \csbxint{ifCmp}, \csbxint{ifGt},
\csbxint{ifLt}, \csbxint{ifEq}, \csbxint{ifOdd}, and \csbxint{ifInt}. See their
respective documentations. All these conditionals always have either two or
three branches, and empty brace pairs |{}| for unused branches should not be
forgotten.

If these tests are to be applied to standard \TeX{} short integers, it is more
efficient to use (under \LaTeX{}) the equivalent conditional tests from the
\href{http://www.ctan.org/pkg/etoolbox}{etoolbox}%
%
\footnote{\url{http://www.ctan.org/pkg/etoolbox}}
package.

\subsection{Expandable implementations of mathematical algorithms}

It is possible to chain |\xintexpr|-essions with |\expandafter|'s, like experts
do with |\numexpr| to compute multiple things at once. See
\autoref{ssec:fibonacci} for an example devoted to Fibonacci numbers (this
section provides the code which was used on the title page for the
\dtt{$F(1250)$} evaluation.) Notice that the $47$th Fibonacci number is
\dtt{\Fibonacci {47}} thus already too big for \TeX{} and \eTeX{}. 

The |\Fibonacci| macro found in \autoref{ssec:fibonacci} is completely
expandable, (it is even \fexpan dable in the sense previously explained) hence
can be used for example within |\message| to write to the log and terminal.

\begingroup
  \def\A {1859}\def\B {1573}
  \edef\C {\xintiiGCD\A\B}
  \edef\X {\Fibonacci\A}
  \edef\Y {\Fibonacci\B}

%
Also, one can thus use it as argument to the \xintname macros: for example if
we are interested in knowing how many digits $F(1250)$ has, it suffices to
issue |\xintLen {\Fibonacci {1250}}| (which expands to \dtt{\xintLen
  {\Fibonacci {1250}}}). Or if we want to check the formula
$gcd(F(1859),F(1573))=F(gcd(1859,1573))=F(143)$, we only need%
%
\footnote{The
  \csa{xintiiGCD} macro is provided by the \xintgcdname package.}
%
\leftedline{|$\xintiiGCD{\Fibonacci{1859}}{\Fibonacci{1573}}=\Fibonacci{\xintiiGCD{1859}{1573}}$|}
%
which outputs:
%
\leftedline{$\dtt{\xintiiGCD{\X}{\Y}}=\dtt{\Fibonacci{\C}}$}

The |\Fibonacci| macro expanded its |\xintiiGCD{1859}{1573}| argument via the
services of |\numexpr|: this step allows only things obeying the \TeX{} bound,
naturally! (but \dtt{F(\xintiiPow2{31}}) would be rather big anyhow...). 

In practice, whenever one typesets things, one has left the expansion only
contexts; hence there is no objection to, on the contrary it is recommended,
assign the result of earlier computations to macros via an |\edef| (or an
|\fdef|, see \ref{fdef}), for later use. The above could thus be coded
\begin{everbatim}
\begingroup
  \def\A {1859}  \def\B {1573}  \edef\C {\xintiiGCD\A\B}
  \edef\X {\Fibonacci\A}  \edef\Y {\Fibonacci\B}
The identity $\gcd(F(\A),F(\B))=F(\gcd(\A,\B))$ can be checked via evaluation
of both sides: $\gcd(F(\A),F(\B))=\gcd(\printnumber\X,\printnumber\Y)=
\printnumber{\xintiiGCD\X\Y} = F(\gcd(\A,\B))$.\par
          % some further computations involving \A, \B, \C, \X, \Y
\endgroup % closing the group removes assignments to \A, \B, ...
% or choose longer names less susceptible to overwriting something. Note that there
% is no LaTeX \newecommand which would be to \edef like \newcommand is to \def
\end{everbatim}
The identity $\gcd(F(\A),F(\B))=F(\gcd(\A,\B))$ can be checked via evaluation
of both sides:
$\gcd(F(\A),F(\B))=\gcd(\dtt{\printnumber\X{\normalcolor,}\printnumber\Y})=
\dtt{\printnumber{\xintiiGCD\X\Y}} = F(\C) = F(\gcd(\A,\B))$.\par


\endgroup
One may thus legitimately ask the author: why expandability to such extremes,
for things such as big fractions or floating point numbers (even
continued fractions...) which anyhow can not be used directly
within \TeX's primitives such as |\ifnum|? the answer is that the author
chose, seemingly, at some point back in his past to waste from then on his time
on such useless things!

\subsection{Possible syntax errors to avoid}

\edef\x{\xintMul {3}{5}/\xintMul{7}{9}}

Here is a list of imaginable input errors. Some will cause compilation errors,
others are more annoying as they may pass through unsignaled.
\begin{itemize}
\item using |-| to prefix some macro: |-\xintiSqr{35}/271|.%
%
\footnote{to the
    contrary, this \emph{is}
    allowed inside an |\xintexpr|-ession.}
\item using one pair of braces too many |\xintIrr{{\xintiPow {3}{13}}/243}| (the
  computation goes through with no error signaled, but the result is completely
  wrong).
\item things like |\xintiiAdd { \x}{\y}| as the space will cause \csa{x} to be
  expanded later, most probably within a |\numexpr| thus provoking possibly an
  arithmetic overflow.
\item using |[]| and decimal points at the same time |1.5/3.5[2]|, or with a
  sign in the denominator |3/-5[7]|. The scientific notation has no such
  restriction, the two inputs |1.5/-3.5e-2| and |-1.5e2/3.5| are equivalent:
  |\xintRaw{1.5/-3.5e-2}|\dtt{=\xintRaw{1.5/-3.5e-2}},
  |\xintRaw{-1.5e2/3.5}|\dtt{=\xintRaw{-1.5e2/3.5}}.
% \item specifying numerators and
%   denominators with macros producing fractions when \xintfracname is loaded:
%   |\edef\x{|\allowbreak|\xintMul {3}{5}/\xintMul{7}{9}}|. This expands to
%   \texttt{\x} which is
%   invalid on input. Using this |\x| in a fraction macro will most certainly
%   cause a compilation error, with its usual arcane and undecipherable
%   accompanying message. The fix here would be to use |\xintiMul|. The simpler
%   alternative with package \xintexprname:
%   |\xinttheexpr 3*5/(7*9)\relax|.
\item generally speaking, using in a context expecting an integer (possibly
  restricted to the \TeX{} bound) a macro or expression which returns a
  fraction: |\xinttheexpr 4/2\relax| outputs \dtt{\xinttheexpr 4/2\relax},
  not $2$. Use |\xintNum {\xinttheexpr 4/2\relax}| or |\xinttheiexpr 4/2\relax|
  (which rounds the result to the nearest integer, here, the result is already
  an integer) or |\xinttheiiexpr 4/2\relax|. Or, divide in your head |4| by
  |2| and insert the result directly in the \TeX{} source.
% trop technique
% \item use of square brackets |[|, |]| in |\xintexpr...\name| has some traps, see
%   \autoref{sec:expr}.
\end{itemize}

\subsection{Error messages}

In situations such as division by zero, the package will insert in the
\TeX{} processing an undefined control sequence (we copy this method
from the |bigintcalc| package). This will trigger the writing to the log
of a message signaling an undefined control sequence. The name of the
control sequence is the message. The error is raised \emph{before} the
end of the expansion so as to not disturb further processing of the
token stream, after completion of the operation. Generally the problematic
operation will output a zero. Possible such error message control
sequences:

% \the\parskip\par % attention 0pt plus 1pt

\begin{multicols}{2}\parskip0pt\relax
\begin{everbatim}
\xintError:ArrayIndexIsNegative
\xintError:ArrayIndexBeyondLimit
\xintError:FactorialOfNegativeNumber
\xintError:FactorialOfTooBigNumber
\xintError:DivisionByZero
\xintError:NaN
\xintError:FractionRoundedToZero
\xintError:NotAnInteger
\xintError:ExponentTooBig
\xintError:TooBigDecimalShift
\xintError:TooBigDecimalSplit
\xintError:RootOfNegative
\xintError:NoBezoutForZeros
\xintError:ignored
\xintError:removed
\xintError:inserted
\xintError:unknownfunction
\xintError:we_are_doomed
\xintError:missing_xintthe!
\end{everbatim}
\end{multicols}
% NOTES 12 octobre 2014
% J'ai voulu faire avec verbatim, mais bizarrement il met dans la
% colonne de gauche 10 et 8 dans celle de droite. Je n'ai pas russi 
% reproduire le problme sur un MWE, en tout cas un exemple naf ne
% reproduit pas le problme. Ensuite avec \everb c'est beaucoup mieux
% mais j'ai d mettre \raggedcolumns. J'ai essay avec \strut. Ah, mais
% le problme c'est \parskip. 

% par ailleurs il y a trop d'espace vertical avant le multicols, mais
% bon.

There are now a few more if for example one attempts to use |\xintAdd| without
having loaded \xintfracname (with only \xintname loaded, only |\xintiAdd| and
|\xintiiAdd| are legal).\MyMarginNote{Changed!}
\begin{multicols}{2}\parskip0pt\relax
\begin{everbatim}
\Did_you_mean_iiAbs?or_load_xintfrac
\Did_you_mean_iiOpp?or_load_xintfrac
\Did_you_mean_iiAdd?or_load_xintfrac
\Did_you_mean_iiSub?or_load_xintfrac
\Did_you_mean_iiMul?or_load_xintfrac
\Did_you_mean_iiPow?or_load_xintfrac
\Did_you_mean_iiSqr?or_load_xintfrac
\Did_you_mean_iiMax?or_load_xintfrac
\Did_you_mean_iiMin?or_load_xintfrac
\Did_you_mean_iMaxof?or_load_xintfrac
\Did_you_mean_iMinof?or_load_xintfrac
\Did_you_mean_iiSum?or_load_xintfrac
\Did_you_mean_iiPrd?or_load_xintfrac
\Did_you_mean_iiPrdExpr?or_load_xintfrac
\Did_you_mean_iiSumExpr?or_load_xintfrac
\end{everbatim}
\end{multicols}

Don't forget to set |\errorcontextlines| to at least |2| to get from \LaTeX\
more meaningful error messages. Errors occuring during the parsing of
|\xintexpr-essions| try to provide helpful information about the offending
token. 

Release |1.1| employs in some situations delimited macros and there is
the possibility in case of an ill-formed expression to end up beyond the
|\relax| end-marker. The errors inevitably arising could then lead to very
cryptic messages; but nothing unusual or especially traumatizing for the
daring experienced \TeX/\LaTeX\ user.


\subsection{Package namespace, catcodes}

% note: v1.2 dfinit \m@ne si ce count n'existe pas.

The bundle packages needs that the \csa{space} and \csa{empty} control
sequences are pre-defined with the identical meanings as in Plain \TeX{} or
\LaTeX2e.

Private macros of \xintkernelname, \xintcorename, \xinttoolsname,
\xintname, \xintfracname, \xintexprname, \xintbinhexname, \xintgcdname,
\xintseriesname, and \xintcfracname{} use one or more underscores |_| as
private letter, to reduce the risk of getting overwritten. They almost
all begin either with |\XINT_| or with |\xint_|, a handful of these
private macros such as \csa{XINTsetupcatcodes}, \csa{XINTdigits} and
those with names such as |\XINTinFloat...| or |\XINTinfloat...| do not
have any underscore in their names (for obscure legacy reasons).

\xinttoolsname provides \hyperref[odef]{|\odef|}, \hyperref[oodef]{|\oodef|},
\hyperref[fdef]{|\fdef|} (if macros with these names already exist
\xinttoolsname will not overwrite them but provide |\xintodef| etc... ) but
all other public macros from the \xintname bundle packages start with |\xint|.

For the good functioning of the macros, standard catcodes are assumed for the
minus sign, the forward slash, the square brackets, the letter `e'. These
requirements are dropped inside an |\xintexpr|-ession: spaces are gobbled,
catcodes mostly do not matter, the |e| of scientific notation may be |E| (on
input) \dots{} 

If a character used in the |\xintexpr| syntax is made active,
this will surely cause problems; prefixing it with |\string| is one option.
There is \csbxint{exprSafeCatcodes} and \csbxint{exprRestoreCatcodes} to
temporarily turn off potentially active characters (but setting catcodes is an
un-expandable action).

\begin{framed}
  For advanced \TeX\ users. At loading time of the packages the
  catcode configuration may be arbitrary as long as it satisfies the following
  requirements: the percent is of category code comment character, the
  backslash is of category code escape character, digits have category code
  other and letters have category code letter. Nothing else is assumed.
\end{framed}

\section{Some utilities from the \xinttoolsname package}

This is a first overview. Many examples combining these utilities with the
arithmetic macros of \xintname are to be found in \autoref{sec:tools}.

\subsection{Assignments}\label{sec:assign}

\xintAssign \xintBezout{357}{323}\to\tmpA\tmpB\tmpU\tmpV\tmpD

It might not be necessary to maintain at all times complete expandability. A
devoted syntax is provided to make these things more efficient, for example when
using the \csbxint{iDivision} macro which computes both quotient and remainder
at 
the same time:
%
\leftedline{\csbxint{Assign}
  |\xintiiDivision{\xintiiPow {2}{1000}}{\xintFac{100}}|\csbnolk{to}|\A\B|} 
%
give:
\xintAssign\xintiiDivision{\xintiPow {2}{1000}}{\xintFac{100}}\to\A\B
|\meaning\A|\dtt{: \printnumber{\meaning\A}\relax} and
|\meaning\B|\dtt{: \printnumber{\meaning\B}\relax}.
%
Another example (which uses \csbxint{Bezout} from the \xintgcdname package):
%
\leftedline{\csbxint{Assign}
%
    |\xintBezout{357}{323}|\csbnolk{to}|\A\B\U\V\D|} 
%
is equivalent to setting |\A| to \dtt{\tmpA}, |\B| to \dtt{\tmpB}, |\U| to
\dtt{\tmpU}, |\V| to \dtt{\tmpV}, and |\D| to \dtt{\tmpD}. And indeed
\dtt{(\tmpU)$\times$\tmpA-(\tmpV)$\times$\tmpB$=$%
  \xintiSub{\xintiMul\tmpU\tmpA}{\xintiMul\tmpV\tmpB}} is a Bezout Identity.

Thus, what |\xintAssign| does is to first apply an
\hyperref[ssec:expansions]{\fexpan sion} to what comes next; it then defines one
after the other (using |\def|; an optional argument allows to modify the
expansion type, see \autoref{xintAssign} for details), the macros found after
|\to| to correspond to the successive braced contents (or single tokens) located
prior to |\to|. In case the first token (after the
optional parameter within brackets, \emph{cf.} the \csbxint{Assign} detailed
document) is not an opening brace |{|, |\xintAssign| consider that there is
  only one macro to define, and that its replacement text should be all that
  follows until the |\to|.

\xintAssign
\xintBezout{3570902836026}{200467139463}\to\tmpA\tmpB\tmpU\tmpV\tmpD

\leftedline
{\csbxint{Assign}|\xintBezout{3570902836026}{200467139463}|%
    \csbnolk{to}|\A\B\U\V\D|}
\noindent
gives then |\U|\dtt{:
    \printnumber\tmpU},
  |\V|\dtt{:
    \printnumber\tmpV} and |\D|\dtt{=\tmpD}.

%
In situations when one does not know in advance the number of items, one has
\csbxint{AssignArray} or its synonym \csbxint{DigitsOf}:
%
\leftedline{\csbxint{DigitsOf}|\xintiPow{2}{100}|\csbnolk{to}\csa{DIGITS}}
%
This defines \csa{DIGITS} to be macro with one parameter, \csa{DIGITS}|{0}|
gives the size |N| of the array and \csa{DIGITS}|{n}|, for |n| from |1| to |N|
then gives the |n|th element of the array, here the |n|th digit of $2^{100}$,
from the most significant to the least significant. As usual, the generated
macro \csa{DIGITS} is completely expandable (in two steps). As it wouldn't make
much sense to allow indices exceeding the \TeX{} bounds, the macros created by
\csbxint{AssignArray} put their argument inside a \csa{numexpr}, so it is
completely expanded and may be a count register, not necessarily prefixed by
|\the| or |\number|. Consider the following code snippet:
%
\begin{everbatim*}
% \newcount\cnta
% \newcount\cntb
\begingroup
\xintDigitsOf\xintiPow{2}{100}\to\DIGITS
\cnta = 1
\cntb = 0
\loop
\advance \cntb \xintiSqr{\DIGITS{\cnta}}
\ifnum \cnta < \DIGITS{0}
\advance\cnta 1
\repeat

|2^{100}| (=\xintiPow {2}{100}) has \DIGITS{0} digits and the sum of their squares is \the\cntb.
These digits are, from the least to the most significant: \cnta = \DIGITS{0} \loop
\DIGITS{\cnta}\ifnum \cnta > 1 \advance\cnta -1 , \repeat.\endgroup
\end{everbatim*}

Warning: \csbxint{Assign}, \csbxint{AssignArray} and \csbxint{DigitsOf}
\emph{do not do any check} on whether the macros they define are already
defined.


\subsection{Utilities for expandable manipulations}\label{sec:utils}

The package now has more utilities to deal expandably with `lists of things',
which were treated un-expandably in the previous section with \csa{xintAssign}
and \csa{xintAssignArray}: \csbxint{ReverseOrder} and \csbxint{Length} since the
first release, \csbxint{Apply} and \csbxint{ListWithSep} since |1.04|,
\csbxint{RevWithBraces}, \csbxint{CSVtoList}, \csbxint{NthElt} since |1.06|,
\csbxint{ApplyUnbraced}, since |1.06b|, \csbxint{loop} and \csbxint{iloop} since
|1.09g|.%
%
\footnote{All these utilities, as well as \csbxint{Assign},
  \csbxint{AssignArray} and the \csbxint{For} loops are now available from the
  \xinttoolsname package, independently of the big integers facilities of
  \xintname.}

As an example the following code uses only expandable operations:
\begin{everbatim*}
$2^{100}$ (=\xintiPow {2}{100}) has \xintLen{\xintiPow {2}{100}} digits and the sum of their
  squares is \xintiiSum{\xintApply {\xintiSqr}{\xintiPow {2}{100}}}. These digits are, from the
  least to the most significant: \xintListWithSep {, }{\xintRev{\xintiPow {2}{100}}}. The thirteenth
  most significant digit is \xintNthElt{13}{\xintiPow {2}{100}}. The seventh least significant one
  is \xintNthElt{7}{\xintRev{\xintiPow {2}{100}}}.
\end{everbatim*}

It would be more efficient to do once and for all
|\edef\z{\xintiPow {2}{100}}|, and then use |\z| in place of
  |\xintiPow {2}{100}| everywhere as this would  spare the CPU some repetitions.

Expandably computing primes is done in \autoref{xintSeq}.

\subsection{A new kind of for loop}

As part of the \hyperref[sec:tools]{utilities} coming with the \xinttoolsname
package, there is a new kind of for loop, \csbxint{For}. Check it out
(\autoref{xintFor}).

\subsection{A new kind of expandable loop}

Also included in \xinttoolsname, \csbxint{iloop} is an expandable loop giving
access to an iteration index, without using count registers which would break
expandability. Check it out (\autoref{xintiloop}).


% Lundi 06 octobre 2014  22:02:44
% je dcide de ne plus inclure le README verbatim
% \begingroup
% \makeatletter\def\x{\baselineskip10pt
%                     \ttfamily
%                     %\settowidth\dimen@{X}%
%                     %\parindent \dimexpr.5\linewidth-33\dimen@\relax
%                     \parindent\z@
%                     \let\do\do@noligs\verbatim@nolig@list
%                     \let\do\@makeother\dospecials
%                     \def\par{\leavevmode \null\@@par\penalty\interlinepenalty}%
%                     \makestarlowast
%                     \@vobeyspaces\obeylines
%                     \noindent\kern\parindent\input README.md
% \endgroup }\x

\etocdepthtag.toc {commands}
\indescriptionfalse
\addtocontents{toc}{\gdef\string\sectioncouleur{{joli}}}

\renewcommand{\etocaftertochook}{\addvspace{\bigskipamount}}


\section{Commands of the \xintkernelname package}
\label{sec:kernel}

\localtableofcontents

The \xintkernelname package contains mainly the common code base for handling
the load-order of the bundle packages, the management of catcodes at loading
time, definition of common constants and macro utilities which are used
throughout the code etc ... it is automatically loaded by all packages of the
bundle.

It provides a few macros possibly useful in other contexts.

\subsection{\csbh{odef}, \csbh{oodef}, \csbh{fdef}}
\label{odef}
\label{oodef}
\label{fdef}

\csa{oodef}|\controlsequence {<stuff>}| does
\everb|@
    \expandafter\expandafter\expandafter\def
    \expandafter\expandafter\expandafter\controlsequence
    \expandafter\expandafter\expandafter{<stuff>}
|

This works only for a single
|\controlsequence|, with no parameter text, even without parameters. An
alternative would be:
\everb|@
\def\oodef #1#{\def\oodefparametertext{#1}%
               \expandafter\expandafter\expandafter\expandafter
               \expandafter\expandafter\expandafter\def
               \expandafter\expandafter\expandafter\oodefparametertext
               \expandafter\expandafter\expandafter }
|

\noindent
but it does not allow |\global| as prefix, and, besides, would have anyhow its
use (almost) limited to parameter texts without macro parameter tokens
(except if the expanded thing does not see them, or is designed to deal with
them).

There is a similar macro |\odef| with only one expansion of the replacement text
|<stuff>|, and |\fdef| which expands fully |<stuff>| using |\romannumeral-`0|.

% These tools are provided as it is sometimes wasteful (from the point of view
% of running time) to do an |\edef| when one knows that the contents expand in
% only two steps for example, as is the case with all (except \csbxint{loop}
% and \csbxint{iloop}) the expandable macros of the \xintname packages. Each
% will be defined only if \xintkernelname finds them currently undefined.

They can be prefixed with |\global|. It appears than |\fdef| is generally a bit
faster than |\edef| when expanding macros from the \xintname bundle, when the
result has a few dozens of digits. |\oodef| needs thousands of digits it seems
to become competitive.


\subsection{\csbh{xintReverseOrder}}\label{xintReverseOrder}

\csa{xintReverseOrder}\marg{list}\etype{n} does not do any expansion of its
argument and just reverses the order of the tokens in the \meta{list}. Braces
are removed once and the enclosed material, now unbraced, does not get
reversed. Unprotected spaces (of any character code) are gobbled.
%
\leftedline{|\xintReverseOrder{\xintDigitsOf\xintiPow {2}{100}\to\Stuff}|}
%
\leftedline{gives:
  \ttfamily{\string\Stuff\string\to1002\string\xintiPow\string\xintDigitsOf}}

\subsection{\csbh{xintLength}}\label{xintLength}

\csa{xintLength}\marg{list}\etype{n} does not do \emph{any} expansion of its
argument and just counts how many tokens there are (possibly none). So to use
it to count things in the replacement text of a macro one should do
|\expandafter\xintLength\expandafter{\x}|. One may also use it inside macros
as |\xintLength{#1}|. Things enclosed in braces count as one. Blanks between
tokens are not counted. See \csbxint{NthElt}|{0}| (from \xinttoolsname) for a
variant which first \fexpan ds its argument.
%
\leftedline{|\xintLength {\xintiPow {2}{100}}|\dtt{=\xintLength
    {\xintiPow{2}{100}}}}
%
\leftedline{${}\neq{}$|\xintLen {\xintiPow {2}{100}}|\dtt{=\xintLen
    {\xintiPow{2}{100}}}}

\section{Commands of the \xinttoolsname package}
\label{sec:tools}

\localtableofcontents

\def\n{|{N}|}
\def\m{|{M}|}
\def\x{|{x}|}

These utilities used to be provided within the \xintname package; since |1.09g|
(|2013/11/22|) they have been moved to an independently usable package
\xinttoolsname, which has none of the \xintname facilities regarding big
numbers. Whenever relevant release |1.09h| has made the macros |\long| so they
accept |\par| tokens on input.

First the  completely expandable utilities up to \csbxint{iloop}, then the non
expandable utilities.

This section contains various concrete examples and ends with a
\hyperref[ssec:quicksort]{completely expandable implementation of the Quick Sort
  algorithm} together with a graphical illustration of its action.

See also \ref{xintReverseOrder} and \ref{xintLength} which come with package
\xintkernelname, automatically loaded by \xinttoolsname.

\subsection{\csbh{xintRevWithBraces}}\label{xintRevWithBraces}

%{\small New in release |1.06|.\par}

\edef\X{\xintRevWithBraces{12345}}
\edef\y{\xintRevWithBraces\X}
\expandafter\def\expandafter\w\expandafter
     {\romannumeral0\xintrevwithbraces{{\A}{\B}{\C}{\D}{\E}}}

%
\csa{xintRevWithBraces}\marg{list}\etype{f} first does the \fexpan sion of its
argument then it reverses the order of the tokens, or braced material, it
encounters, maintaining existing braces and adding a brace pair around each
naked token encountered. Space tokens (in-between top level braces or naked
tokens) are gobbled. This macro is mainly thought out for use on a \meta{list}
of such braced material; with such a list as argument the \fexpan sion will only
hit against the first opening brace, hence do nothing, and the braced stuff may
thus be macros one does not want to expand.
%
\leftedline{|\edef\x{\xintRevWithBraces{12345}}|}
%
\leftedline{|\meaning\x:|\dtt{\meaning\X}}
%
\leftedline{|\edef\y{\xintRevWithBraces\x}|}
%
\leftedline{|\meaning\y:|\dtt{\meaning\y}} 
%
The examples above could be defined with |\edef|'s because the braced material
did not contain macros. Alternatively:
%
\leftedline{|\expandafter\def\expandafter\w\expandafter|}
%
\leftedline{|{\romannumeral0\xintrevwithbraces{{\A}{\B}{\C}{\D}{\E}}}|}
%
\leftedline{|\meaning\w:|\dtt{\meaning\w}} 
%
The macro \csa{xintReverseWithBracesNoExpand}\etype{n} does the same job
without the initial expansion of its argument.


\subsection{\csbh{xintZapFirstSpaces}, \csbh{xintZapLastSpaces}, \csbh{xintZapSpaces}, \csbh{xintZapSpacesB}}
\label{xintZapFirstSpaces}
\label{xintZapLastSpaces}
\label{xintZapSpaces}
\label{xintZapSpacesB}
%{\small New with release |1.09f|.\par}

\csa{xintZapFirstSpaces}\marg{stuff}\etype{n} does not do \emph{any} expansion
of its argument, nor brace removal of any sort, nor does it alter \meta{stuff}
in anyway apart from stripping away all \emph{leading} spaces.

This macro will be mostly of interest to programmers who will know what I will
now be talking about. \emph{The essential points, naturally, are the complete
  expandability and the fact that no brace removal nor any other alteration is
  done to the input.}

\TeX's input scanner already converts consecutive blanks into single space
tokens, but |\xintZapFirstSpaces| handles successfully also inputs with
consecutive multiple space tokens.
However, it is assumed that \meta{stuff} does not contain (except inside braced
sub-material) space tokens of character code distinct from $32$.

It expands in two steps, and if the goal is to apply it to the
expansion text of |\x| to define |\y|, then one should do:
|\expandafter\def\expandafter\y\expandafter
        {\romannumeral0\expandafter\xintzapfirstspaces\expandafter{\x}}|.

Other use case: inside a macro as |\edef\x{\xintZapFirstSpaces {#1}}| assuming
naturally that |#1| is compatible with such an |\edef| once the leading spaces
have been stripped.

\begingroup
\def\x {  \a {  \X } {  \b  \Y }  }
%
\leftedline{|\xintZapFirstSpaces {  \a {  \X } {  \b  \Y }  }->|%
\dtt{\color{magenta}{}\expandafter\detokenize\expandafter
{\romannumeral0\expandafter\xintzapfirstspaces\expandafter{\x}}}+++}
\endgroup

\medskip

\noindent\csbxint{ZapLastSpaces}\marg{stuff}\etype{n}  does not do \emph{any} expansion of
its argument, nor brace removal of any sort, nor does it alter \meta{stuff} in
anyway apart from stripping away all \emph{ending} spaces. The same remarks as
for \csbxint{ZapFirstSpaces} apply.

% ATTENTION  l'\ignorespaces fait par \color!
\begingroup
\def\x {  \a {  \X } {  \b  \Y }  }
%
\leftedline{|\xintZapLastSpaces {  \a {  \X } {  \b  \Y }  }->|%
\dtt{\color{magenta}{}\expandafter\detokenize\expandafter
{\romannumeral0\expandafter\xintzaplastspaces\expandafter{\x}}}+++}
\endgroup

\medskip

\noindent\csbxint{ZapSpaces}\marg{stuff}\etype{n}  does not do \emph{any}
expansion of its
argument, nor brace removal of any sort, nor does it alter \meta{stuff} in
anyway apart from stripping away all \emph{leading} and all \emph{ending}
spaces. The same remarks as for \csbxint{ZapFirstSpaces} apply.

\begingroup
\def\x {  \a {  \X } {  \b  \Y }  }
%
\leftedline{|\xintZapSpaces {  \a {  \X } {  \b  \Y }  }->|%
\dtt{\color{magenta}{}\expandafter\detokenize\expandafter
{\romannumeral0\expandafter\xintzapspaces\expandafter{\x}}}+++}
\endgroup

\medskip

\noindent\csbxint{ZapSpacesB}\marg{stuff}\etype{n}  does not do \emph{any}
expansion of
its argument, nor does it alter \meta{stuff} in anyway apart from stripping away
all leading and all ending spaces and possibly removing one level of braces if
\meta{stuff} had the shape |<spaces>{braced}<spaces>|. The same remarks as for
\csbxint{ZapFirstSpaces} apply.

\begingroup
\def\x {  \a {  \X } {  \b  \Y }  }
%
\leftedline{|\xintZapSpacesB {  \a {  \X } {  \b  \Y }  }->|%
\dtt{\color{magenta}{}\expandafter\detokenize\expandafter
{\romannumeral0\expandafter\xintzapspacesb\expandafter{\x}}}+++}
\def\x {  { \a {  \X } {  \b  \Y } }  }
%
\leftedline{|\xintZapSpacesB {  { \a {  \X } {  \b  \Y } }  }->|%
\dtt{\color{magenta}{}\expandafter\detokenize\expandafter
{\romannumeral0\expandafter\xintzapspacesb\expandafter{\x}}}+++}
\endgroup
 The spaces here at the start and end of the output come from the braced
 material, and are not removed (one would need a second application for that;
 recall though that the \xintname zapping macros do not expand their argument).

\subsection{\csbh{xintCSVtoList}}
\label{xintCSVtoList}
\label{xintCSVtoListNoExpand}

% {\small New with release |1.06|. Starting with |1.09f|, \fbox{\emph{removes
%     spaces around commas}!}\par}

\csa{xintCSVtoList}|{a,b,c...,z}|\etype{f}  returns |{a}{b}{c}...{z}|. A
\emph{list} is by
convention in this manual simply a succession of tokens, where each braced thing
will count as one item (``items'' are defined according to the rules of \TeX{}
for fetching undelimited parameters of a macro, which are exactly the same rules
as for \LaTeX{} and command arguments [they are the same things]). The word
`list' in `comma separated list of items' has its usual linguistic meaning,
and then an ``item'' is what is delimited by commas.

So \csa{xintCSVtoList}takes on input a `comma separated list of items' and
converts it into a `\TeX{} list of braced items'. The argument to
|\xintCSVtoList| may be a macro: it will first be
\hyperref[ssec:expansions]{\fexpan ded}. Hence the item before the first comma,
if it is itself a macro, will be expanded which may or may not be a good thing.
A space inserted at the start of the first item serves to stop that expansion
(and disappears). The macro \csbxint{CSVtoListNoExpand}\etype{n} does the same
job without
the initial expansion of the list argument.

Apart from that no expansion of the items is done and the list items may thus be
completely arbitrary (and even contain perilous stuff such as unmatched |\if|
and |\fi| tokens).

Contiguous spaces and tab characters, are collapsed by \TeX{}
into single spaces. All such spaces around commas%
%
\footnote{and multiple space tokens are not a problem; but those at the
  top level (not hidden inside braces) \emph{must} be of character code
  |32|.}
%
\fbox{are removed}, as well as
the spaces at the start and the spaces at the end of the list.%
%
\footnote{let us recall that this is all done completely expandably...
  There is absolutely no alteration of any sort of the item apart from
  the stripping of initial and final space tokens (of character code
  |32|) and brace removal if and only if the item apart from intial and
  final spaces (or more generally multiple |char 32| space tokens) is
  braced.}
%
The items may contain explicit |\par|'s or
empty lines (converted by the \TeX{} input parsing into |\par| tokens).

\begingroup

\edef\X{\xintCSVtoList { 1 ,{ 2 , 3 , 4 , 5 }, a , {b,T} U , { c , d } , { {x ,
        y} } }}

%
\leftedline{|\xintCSVtoList { 1 ,{ 2 , 3 , 4 , 5 }, a , {b,T} U , { c , d } ,
    { {x , y} } }|}
%
\leftedline{|->|%
{\makeatletter\dtt{\expandafter\strip@prefix\meaning\X}}}

One sees on this example how braces protect commas from
sub-lists to be perceived as delimiters of the top list. Braces around an entire
item are removed, even when surrounded by spaces before and/or after. Braces for
sub-parts of an item are not removed.

We observe also that there is a slight difference regarding the brace stripping
of an item: if the braces were not surrounded by spaces, also the initial and
final (but no other) spaces of the \emph{enclosed} material are removed. This is
the only situation where spaces protected by braces are nevertheless removed.

From the rules above: for an empty argument (only spaces, no braces, no comma)
the output is
\dtt{\expandafter\detokenize\expandafter{\romannumeral0\xintcsvtolist { }}}
(a list with one empty item),
for ``|<opt. spaces>{}<opt.
spaces>|'' the output is
\dtt{\expandafter\detokenize\expandafter
   {\romannumeral0\xintcsvtolist { {} }}}
(again a list with one empty item, the braces were removed),
for ``|{ }|'' the output is
\dtt{\expandafter\detokenize\expandafter
 {\romannumeral0\xintcsvtolist {{ }}}}
(again a list with one empty item, the braces were removed and then
the inner space was removed),
for ``| { }|'' the output is
\dtt{\expandafter\detokenize\expandafter
{\romannumeral0\xintcsvtolist { { }}}} (again a list with one empty item, the initial space served only to stop the expansion, so this was like ``|{ }|'' as input, the braces were removed and the inner space was stripped),
for ``\texttt{\ \{\ \ \}\ }'' the output is
\dtt{\expandafter\detokenize\expandafter
{\romannumeral0\xintcsvtolist { {  } }}} (this time the ending space of the first
item meant that after brace removal the inner spaces were kept; recall though
that \TeX{} collapses on input consecutive blanks into one space token),
for ``|,|'' the output consists of two consecutive
empty items
\dtt{\expandafter\detokenize\expandafter{\romannumeral0\xintcsvtolist
    {,}}}. Recall that on output everything is braced, a |{}| is an ``empty''
item.
%
Most of the above is mainly irrelevant for every day use, apart perhaps from the
fact to be noted that an empty input does not give an empty output but a
one-empty-item list (it is as if an ending comma was always added at the end of
the input).

\def\y { \a,\b,\c,\d,\e}
\expandafter\def\expandafter\Y\expandafter{\romannumeral0\xintcsvtolist{\y}}
\def\t {{\if},\ifnum,\ifx,\ifdim,\ifcat,\ifmmode}
\expandafter\def\expandafter\T\expandafter{\romannumeral0\xintcsvtolist{\t}}

%
\leftedline{|\def\y{ \a,\b,\c,\d,\e} \xintCSVtoList\y->|%
  {\makeatletter\dtt{\expandafter\strip@prefix\meaning\Y}}}
%
\leftedline{|\def\t {{\if},\ifnum,\ifx,\ifdim,\ifcat,\ifmmode}|} 
%
\leftedline
{|\xintCSVtoList\t->|\makeatletter\dtt{\expandafter\strip@prefix\meaning\T}}
%
The results above were automatically displayed using \TeX's primitive
\csa{meaning}, which adds a space after each control sequence name. These spaces
are not in the actual braced items of the produced lists. The first items |\a|
and |\if| were either preceded by a space or braced to prevent expansion. The
macro \csa{xintCSVtoListNoExpand} would have done the same job without the
initial expansion of the list argument, hence no need for such protection but if
|\y| is defined as |\def\y{\a,\b,\c,\d,\e}| we then must do:
%
\leftedline{|\expandafter\xintCSVtoListNoExpand\expandafter {\y}|} Else, we
may have direct use: %
%
\leftedline{|\xintCSVtoListNoExpand
 {\if,\ifnum,\ifx,\ifdim,\ifcat,\ifmmode}|}
%
% ATTENTION 18 novembre TEST DE newtxtt 1.05 PAS POSSIBLE \textsc DANS \dtt
% mais on peut avec \scshape. Finalement je n'utilise pas les old style figures.
\leftedline{|->|\dtt{\expandafter\detokenize\expandafter
    {\romannumeral0\xintcsvtolistnoexpand
      {\if,\ifnum,\ifx,\ifdim,\ifcat,\ifmmode}}}}
%
Again these spaces are an artefact from the use in the source of the document of
\csa{meaning} (or rather here, \csa{detokenize}) to display the result of using
\csa{xintCSVtoListNoExpand} (which is done for real in this document
source).

For the similar conversion from comma separated list to braced items list, but
without removal of spaces around the commas, there is
\csa{xintCSVtoListNonStripped}\etype{f} and
\csa{xintCSVtoListNonStrippedNoExpand}\etype{n}.

\endgroup

\subsection{\csbh{xintNthElt}}\label{xintNthElt}

% {\small New in release |1.06|. With |1.09b| negative indices count from the tail.\par}

\def\macro #1{\the\numexpr 9-#1\relax}

\csa{xintNthElt\x}\marg{list}\etype{\numx f} gets (expandably) the |x|th braced
item of the \meta{list}. An unbraced item token will be returned as is. The list
itself may be a macro which is first \fexpan ded.

\leftedline{|\xintNthElt {3}{{agh}\u{zzz}\v{Z}}| is
    \texttt{\xintNthElt {3}{{agh}\u{zzz}\v{Z}}}}
%
\leftedline{|\xintNthElt {3}{{agh}\u{{zzz}}\v{Z}}| is
    \texttt{\expandafter\expandafter\expandafter
      \detokenize\expandafter\expandafter\expandafter {\xintNthElt
        {3}{{agh}\u{{zzz}}\v{Z}}}}}
%
\leftedline{|\xintNthElt {2}{{agh}\u{{zzz}}\v{Z}}| is
    \texttt{\expandafter\expandafter\expandafter
      \detokenize\expandafter\expandafter\expandafter {\xintNthElt
        {2}{{agh}\u{{zzz}}\v{Z}}}}}
%
\leftedline{|\xintNthElt {37}{\xintFac {100}}|\dtt{=\xintNthElt
      {37}{\xintFac {100}}} is the thirty-seventh digit of $100!$.}
%
\leftedline{|\xintNthElt {10}{\xintFtoCv
      {566827/208524}}|\dtt{=\xintNthElt {10}{\xintFtoCv
        {566827/208524}}}}
\leftedline{is the tenth convergent of $566827/208524$ (uses \xintcfracname
  package).} 
%
\leftedline{|\xintNthElt {7}{\xintCSVtoList {1,2,3,4,5,6,7,8,9}}|%
    \dtt{=\xintNthElt {7}{\xintCSVtoList {1,2,3,4,5,6,7,8,9}}}}
%
\leftedline{|\xintNthElt {0}{\xintCSVtoList {1,2,3,4,5,6,7,8,9}}|%
    \dtt{=\xintNthElt {0}{\xintCSVtoList {1,2,3,4,5,6,7,8,9}}}}
%
\leftedline{|\xintNthElt {-3}{\xintCSVtoList {1,2,3,4,5,6,7,8,9}}|%
    \dtt{=\xintNthElt {-3}{\xintCSVtoList {1,2,3,4,5,6,7,8,9}}}}

If |x=0|,
the macro returns the \emph{length} of the expanded list: this is not equivalent
to \csbxint{Length} which does no pre-expansion. And it is different from
\csbxint{Len} which is to be used only on integers or fractions.

If |x<0|, the macro returns the \verb+|x|+th element from the end of the list.
%
\leftedline {|\xintNthElt {-5}{{{agh}}\u{zzz}\v{Z}}| is
  \texttt{\expandafter\expandafter\expandafter \detokenize
  \expandafter\expandafter\expandafter{\xintNthElt {-5}{{{agh}}\u{zzz}\v{Z}}}}}

The macro \csa{xintNthEltNoExpand}\etype{\numx n} does the same job but without
first expanding the list argument: |\xintNthEltNoExpand {-4}{\u\v\w T\x\y\z}| is
\xintNthEltNoExpand {-4}{\a\b\c\u\v\w T\x\y\z}.

In cases where |x| is larger (in absolute value) than the length of the list
then |\xintNthElt| returns nothing.

\subsection{\csbh{xintKeep}}\label{xintKeep}

\csa{xintKeep\x}\marg{list}\etype{\numx f} expands the token list argument and
returns a new list containing only the first |x| items. If |x<0| the macro
returns the last \verb+|x|+ elements (in the same order as in the initial
list). If \verb+|x|+ equals or exceeds the length of the list, the list (as
arising from expansion of the second argument) is returned. For |x=0| the
empty list is returned.

If |x>0| the (non space) items from the original end up braced in the
output: if one later wants to remove all brace pairs (either added to a naked
token, or initially present), one may use \csbxint {ListWithSep} with an empty
separator.

On the other hand, if |x<0| the macro acts by suppressing items from the head
of the list, and no brace pairs are added to the kept elements from the tail
(originally present ones are not removed).\MyMarginNote{\noindent Description
  corrected in 1.2a doc}

\csa{xintKeepNoExpand} does the same without first \fexpan ding its list
argument.
%
\begin{everbatim*}
\fdef\test {\xintKeep {17}{\xintKeep {-69}{\xintSeq {1}{100}}}}\meaning\test\par
\noindent\fdef\test {\xintKeep {7}{{1}{2}{3}{4}{5}{6}{7}{8}{9}}}\meaning\test\par
\noindent\fdef\test {\xintKeep {-7}{{1}{2}{3}{4}{5}{6}{7}{8}{9}}}\meaning\test\par
\noindent\fdef\test {\xintKeep {7}{123456789}}\meaning\test\par
\noindent\fdef\test {\xintKeep {-7}{123456789}}\meaning\test\par
\end{everbatim*}
%

\subsection{\csbh{xintKeepUnbraced}}\label{xintKeepUnbraced}

Sames as \csbxint{Keep} but no brace pairs are added around the kept items
from the head of the list. Each item will lose one level of brace pairs. For
|x<0| is not different from \csbxint{Keep}.\NewWith{1.2a}

\csa{xintKeepUnbracedNoExpand} does the same without first \fexpan ding its list
argument.
%
\begin{everbatim*}
\fdef\test {\xintKeepUnbraced {10}{\xintSeq {1}{100}}}\meaning\test\par
\noindent\fdef\test {\xintKeepUnbraced {7}{{1}{2}{3}{4}{5}{6}{7}{8}{9}}}\meaning\test\par
\noindent\fdef\test {\xintKeepUnbraced {-7}{{1}{2}{3}{4}{5}{6}{7}{8}{9}}}\meaning\test\par
\noindent\fdef\test {\xintKeepUnbraced {7}{123456789}}\meaning\test\par
\noindent\fdef\test {\xintKeepUnbraced {-7}{123456789}}\meaning\test\par
\end{everbatim*}

\subsection{\csbh{xintTrim}}\label{xintTrim}

\csa{xintTrim\x}\marg{list}\etype{\numx f} expands the list argument and
gobbles its first |x| elements. The remaining ones are left as they are (no
brace pairs added). If |x<0| the macro gobbles the last \verb+|x|+
elements, and the kept elements from the head of the list end up braced in the
output. If \verb+|x|+ equals or exceeds the length
of the list, the empty list is returned. For |x=0| the full list is returned.

\csa{xintTrimNoExpand} does the same without first \fexpan ding its list
argument.
\begin{everbatim*}
\fdef\test {\xintTrim {17}{\xintTrim {-69}{\xintSeq {1}{100}}}}\meaning\test\par
\noindent\fdef\test {\xintTrim {7}{{1}{2}{3}{4}{5}{6}{7}{8}{9}}}\meaning\test\par
\noindent\fdef\test {\xintTrim {-7}{{1}{2}{3}{4}{5}{6}{7}{8}{9}}}\meaning\test\par
\noindent\fdef\test {\xintTrim {7}{123456789}}\meaning\test\par
\noindent\fdef\test {\xintTrim {-7}{123456789}}\meaning\test\par
\end{everbatim*}

\subsection{\csbh{xintTrimUnbraced}}\label{xintTrimUnbraced}

Same as \csbxint{Trim} but in case of a negative |x| (cutting items from
the tail), the kept items from the head are not enclosed in brace pairs. They
will lose one level of braces.\NewWith{1.2a}

\csa{xintTrimUnbracedNoExpand} does the same without first \fexpan ding its list
argument.

\begin{everbatim*}
\fdef\test {\xintTrimUnbraced {-90}{\xintSeq {1}{100}}}\meaning\test\par
\noindent\fdef\test {\xintTrimUnbraced {7}{{1}{2}{3}{4}{5}{6}{7}{8}{9}}}\meaning\test\par
\noindent\fdef\test {\xintTrimUnbraced {-7}{{1}{2}{3}{4}{5}{6}{7}{8}{9}}}\meaning\test\par
\noindent\fdef\test {\xintTrimUnbraced {7}{123456789}}\meaning\test\par
\noindent\fdef\test {\xintTrimUnbraced {-7}{123456789}}\meaning\test\par
\end{everbatim*}

\subsection{\csbh{xintListWithSep}}\label{xintListWithSep}

%{\small New with release |1.04|.\par}

\def\macro #1{\the\numexpr 9-#1\relax}

\csa{xintListWithSep}|{sep}|\marg{list}\etype{nf} inserts the given separator
|sep| in-between all items of the given list of braced items: this separator may
be a macro (or multiple tokens) but will not be expanded. The second argument
also may be itself a macro: it is \fexpan ded. Applying \csa{xintListWithSep}
removes the braces from the list items (for example |{1}{2}{3}| turns into
\dtt{\xintListWithSep,{123}} via |\xintListWithSep{,}{{1}{2}{3}}|). An
empty input gives an empty output, a singleton gives a singleton, the separator
is used starting with at least two elements. Using an empty separator has the
net effect of unbracing the braced items constituting the \meta{list} (in such
cases the new list may thus be longer than the original).
%
\leftedline{|\xintListWithSep{:}{\xintFac
    {20}}|\dtt{=\xintListWithSep{:}{\xintFac {20}}}}

The  macro \csa{xintListWithSepNoExpand}\etype{nn} does the same
job without the initial expansion.

\subsection{\csbh{xintApply}}\label{xintApply}

%{\small New with release |1.04|.\par}

\def\macro #1{\the\numexpr 9-#1\relax}

\csa{xintApply}|{\macro}|\marg{list}\etype{ff} expandably applies the one
parameter command |\macro| to each item in the \meta{list} given as second
argument and returns a new list with these outputs: each item is given one after
the other as parameter to |\macro| which is expanded at that time (as usual,
\emph{i.e.} fully for what comes first), the results are braced and output
together as a succession of braced items (if |\macro| is defined to start with a
space, the space will be gobbled and the |\macro| will not be expanded; it is
allowed to have its own arguments, the list items serve as last arguments to
|\macro|). Hence |\xintApply{\macro}{{1}{2}{3}}| returns
|{\macro{1}}{\macro{2}}{\macro{3}}| where all instances of |\macro| have been
already \fexpan ded.

Being expandable, |\xintApply| is useful for example inside alignments where
implicit groups make standard loops constructs usually fail. In such situation
it is often not wished that the new list elements be braced, see
\csbxint{ApplyUnbraced}. The |\macro| does not have to be expandable:
|\xintApply| will try to expand it, the expansion may remain partial.

The \meta{list} may
itself be some macro expanding (in the previously described way) to the list of
tokens to which the command |\macro| will be applied. For example, if the
\meta{list} expands to some positive number, then each digit will be replaced by
the result of applying |\macro| on it. %
%
\leftedline{|\def\macro #1{\the\numexpr
    9-#1\relax}|} %
%
\leftedline{|\xintApply\macro{\xintFac
 {20}}|\dtt{=\xintApply\macro{\xintFac {20}}}}

The macro \csa{xintApplyNoExpand}\etype{fn} does the same job without the first
initial expansion which gave the \meta{list} of braced tokens to which |\macro|
is applied.

\subsection{\csbh{xintApplyUnbraced}}\label{xintApplyUnbraced}

%{\small New in release |1.06b|.\par}

\csa{xintApplyUnbraced}|{\macro}|\marg{list}\etype{ff} is like \csbxint{Apply}.
The difference is that after having expanded its list argument, and applied
|\macro| in turn to each item from the list, it reassembles the outputs without
enclosing them in braces. The net effect is the same as doing
%
\leftedline{|\xintListWithSep {}{\xintApply {\macro}|\marg{list}|}|} This is
useful for preparing a macro which will itself define some other macros or make
assignments, as the scope will not be limited by brace pairs.
%
\begin{everbatim*}
\def\macro #1{\expandafter\def\csname myself#1\endcsname {#1}}
\xintApplyUnbraced\macro{{elta}{eltb}{eltc}}
\begin{enumerate}[nosep,label=(\arabic{*})]
\item \meaning\myselfelta
\item \meaning\myselfeltb
\item \meaning\myselfeltc
\end{enumerate}
\end{everbatim*}

%
The macro \csa{xintApplyUnbracedNoExpand}\etype{fn} does the same job without
the first initial expansion which gave the \meta{list} of braced tokens to which
|\macro| is applied.

\subsection{\csbh{xintSeq}}\label{xintSeq}
%{\small New with release |1.09c|.\par}

\csa{xintSeq}|[d]{x}{y}|\etype{{{\upshape[\numx]}}\numx\numx} generates
expandably |{x}{x+d}...| up to and possibly including |{y}| if |d>0| or
down to and including |{y}| if |d<0|. Naturally |{y}| is omitted if
|y-x| is not a multiple of |d|. If |d=0| the macro returns |{x}|. If
|y-x| and |d| have opposite signs, the macro returns nothing. If the
optional argument |d| is omitted it is taken to be the sign of |y-x|
(beware that |\xintSeq {1}{0}| is thus not empty but |{1}{0}|, use
|\xintSeq [1]{1}{N}| if you want an empty sequence for |N| zero or
negative).

The current implementation is only for (short) integers; possibly, a future
variant could allow big integers and fractions, although one already has
access to similar
functionality using \csbxint{Apply} to get any arithmetic sequence of long
integers. Currently thus, |x| and |y| are expanded inside a
|\numexpr| so they may be count registers or a \LaTeX{} |\value{countername}|,
or arithmetic with such things.

%
\begin{everbatim*}
\xintListWithSep{,\hskip2pt plus 1pt minus 1pt }{\xintSeq {12}{-25}}
\end{everbatim*}
%
\begin{everbatim*}
\xintiiSum{\xintSeq [3]{1}{1000}}
\end{everbatim*}

\textbf{Important:} for reasons of efficiency, this macro, when not given the
optional argument |d|, works backwards, leaving in the token stream the already
constructed integers, from the tail down (or up). But this will provoke a
failure of \IMPORTANT{} the |tex| run if the number of such items exceeds the
input stack
limit; on my installation this limit is at $5000$.

However, when given the optional argument |d| (which may be $+1$ or
$-1$), the macro proceeds differently and does not put stress on the input stack
(but is significantly slower for sequences with thousands of integers,
especially if they are somewhat big). For
example: |\xintSeq [1]{0}{5000}| works and |\xintiiSum{\xintSeq [1]{0}{5000}}|
returns the correct value \dtt{\xintHalf{\xintiMul{5000}{5001}}}.

The produced integers are with explicit litteral digits, so if used in |\ifnum|
or other tests they should be properly terminated%
%
\footnote{a \csa{space} will
  stop the \TeX{} scanning of a number and be gobbled in the process,
  maintaining expandability if this is required; the \csa{relax} stops the
  scanning but is not gobbled and remains afterwards as a token.}.

\subsection{Completely expandable prime test}\label{ssec:primesI}

Let us now construct a completely expandable macro which returns $1$ if its
given input is prime and $0$ if not:
\everb|@
\def\remainder #1#2{\the\numexpr #1-(#1/#2)*#2\relax }
\def\IsPrime #1%
 {\xintANDof {\xintApply {\remainder {#1}}{\xintSeq {2}{\xintiSqrt{#1}}}}}
|

This uses \csbxint{iSqrt} and assumes its input is at least $5$. Rather than
\xintname's own \csbxint{iRem} we used a quicker |\numexpr| expression as we
are dealing with short integers. Also we used \csbxint{ANDof} which will
return $1$ only if all the items are non-zero. The macro is a bit
silly with an even input, ok, let's enhance it to detect an even input:
\everb|@
\def\IsPrime #1%
   {\xintifOdd {#1}
        {\xintANDof % odd case
            {\xintApply {\remainder {#1}}
                        {\xintSeq [2]{3}{\xintiSqrt{#1}}}%
            }%
        }
        {\xintifEq {#1}{2}{1}{0}}%
   }
|

We used the \xintname provided expandable tests (on big integers or fractions)
in oder for |\IsPrime| to be \fexpan dable.

Our integers are short, but without |\expandafter|'s with
%\makeatletter|\@firstoftwo|\catcode`@ \active, 
|\@firstoftwo|, % @ n'est plus actif dans le dtx 1.1 !
or some other related techniques,
direct use of |\ifnum..\fi| tests is dangerous. So to make the macro more
efficient we are going to use the expandable tests provided by the package
\href{http://ctan.org/pkg/etoolbox}{etoolbox}%
%
\footnote{\url{http://ctan.org/pkg/etoolbox}}.
%
The macro becomes:
%
\everb|@
\def\IsPrime #1%
   {\ifnumodd {#1}
    {\xintANDof % odd case
     {\xintApply {\remainder {#1}}{\xintSeq [2]{3}{\xintiSqrt{#1}}}}}
    {\ifnumequal {#1}{2}{1}{0}}}
|

In the odd case however we have to assume the integer is at least $7$, as
|\xintSeq| generates an empty list if |#1=3| or |5|, and |\xintANDof| returns
$1$ when supplied an empty list. Let us ease up a bit |\xintANDof|'s work by
letting it work on only $0$'s and $1$'s. We could use:
%
\everb|@
\def\IsNotDivisibleBy #1#2%
  {\ifnum\numexpr #1-(#1/#2)*#2=0 \expandafter 0\else \expandafter1\fi}
|
\noindent
where the |\expandafter|'s are crucial for this macro to be \fexpan dable and
hence work within the applied \csbxint{ANDof}. Anyhow, now that we have loaded
\href{http://ctan.org/pkg/etoolbox}{etoolbox}, we might as well use:
%
\everb|@
\newcommand{\IsNotDivisibleBy}[2]{\ifnumequal{#1-(#1/#2)*#2}{0}{0}{1}}
|
\noindent
Let us enhance our prime macro to work also on the small primes:
\everb|@
\newcommand{\IsPrime}[1] % returns 1 if #1 is prime, and 0 if not
  {\ifnumodd {#1}
    {\ifnumless {#1}{8}
      {\ifnumequal{#1}{1}{0}{1}}% 3,5,7 are primes
      {\xintANDof
         {\xintApply
        { \IsNotDivisibleBy {#1}}{\xintSeq [2]{3}{\xintiSqrt{#1}}}}%
        }}% END OF THE ODD BRANCH
    {\ifnumequal {#1}{2}{1}{0}}% EVEN BRANCH
}
|

The input is still assumed positive. There is a deliberate blank before
\csa{IsNotDivisibleBy} to use this feature of \csbxint{Apply}: a space stops the
expansion of the applied macro (and disappears). This expansion will be done by
\csbxint{ANDof}, which has been designed to skip everything as soon as it finds
a false (i.e. zero) input. This way, the efficiency is considerably improved.

We did generate via the \csbxint{Seq} too many potential divisors though. Later
sections give two variants: one with \csbxint{iloop} (\autoref{ssec:primesII})
which is still expandable and another one (\autoref{ssec:primesIII}) which is a
close variant of the |\IsPrime| code above but with the \csbxint{For} loop, thus
breaking expandability. The \hyperref[ssec:primesII]{xintiloop variant} does not
first evaluate the integer square root, the \hyperref[ssec:primesIII]{xintFor
  variant} still does. I did not compare their efficiencies.

% Hmm, if one really needs to compute primes fast, sure I do applaud using
% \xintname, but, well, there is some slight
% overhead\MyMarginNoteWithBrace{funny private joke} in using \TeX{} for these
% things (something like a factor $1000$? not tested\dots) compared to accessing
% to the |CPU| ressources via standard compiled code from a standard programming
% language\dots

Let us construct with this expandable primality test a table of the prime
numbers up to $1000$. We need to count how many we have in order to know how
many tab stops one shoud add in the last row.%
%
\footnote{although a tabular row may have less tabs than in the
  preamble, there is a problem with the \char`\|\space\space vertical
  rule, if one does that.}
%
There is some subtlety for this
last row. Turns out to be better to insert a |\\| only when we know for sure we
are starting a new row; this is how we have designed the |\OneCell| macro. And
for the last row, there are many ways, we use again |\xintApplyUnbraced| but
with a macro which gobbles its argument and replaces it with a tabulation
character. The \csbxint{For*} macro would be more elegant here.
%
\everb?@
\newcounter{primecount}
\newcounter{cellcount}
\newcommand{\NbOfColumns}{13}
\newcommand{\OneCell}[1]{%
    \ifnumequal{\IsPrime{#1}}{1}
     {\stepcounter{primecount}
      \ifnumequal{\value{cellcount}}{\NbOfColumns}
       {\\\setcounter{cellcount}{1}#1}
       {&\stepcounter{cellcount}#1}%
     } % was prime
  {}% not a prime, nothing to do
}
\newcommand{\OneTab}[1]{&}
\begin{tabular}{|*{\NbOfColumns}{r}|}
\hline
2  \setcounter{cellcount}{1}\setcounter{primecount}{1}%
   \xintApplyUnbraced \OneCell {\xintSeq [2]{3}{999}}%
   \xintApplyUnbraced \OneTab
      {\xintSeq [1]{1}{\the\numexpr\NbOfColumns-\value{cellcount}\relax}}%
    \\
\hline
\end{tabular}
There are \arabic{primecount} prime numbers up to 1000.
?

The table has been put in \hyperref[primesupto1000]{float} which appears
\vpageref{primesupto1000}.
We had to be careful to use in the last row \csbxint{Seq} with its optional
argument |[1]| so as to not generate a decreasing sequence from |1| to |0|, but
really an empty sequence in case the row turns out to already have all its
cells (which doesn't happen here but would with a number of columns dividing
$168$).
%
\newcommand{\IsNotDivisibleBy}[2]{\ifnumequal{#1-(#1/#2)*#2}{0}{0}{1}}

\newcommand{\IsPrime}[1]
   {\ifnumodd {#1}
        {\ifnumless {#1}{8}
          {\ifnumequal{#1}{1}{0}{1}}% 3,5,7 are primes
          {\xintANDof
             {\xintApply
                { \IsNotDivisibleBy {#1}}{\xintSeq [2]{3}{\xintiSqrt{#1}}}}%
            }}% END OF THE ODD BRANCH
        {\ifnumequal {#1}{2}{1}{0}}% EVEN BRANCH
}

\newcounter{primecount}
\newcounter{cellcount}
\newcommand{\NbOfColumns}{13}
\newcommand{\OneCell}[1]
     {\ifnumequal{\IsPrime{#1}}{1}
        {\stepcounter{primecount}
         \ifnumequal{\value{cellcount}}{\NbOfColumns}
            {\\\setcounter{cellcount}{1}#1}
            {&\stepcounter{cellcount}#1}%
        } % was prime
        {}% not a prime nothing to do
}
\newcommand{\OneTab}[1]{&}
\begin{figure*}[ht!]
  \centering
  \phantomsection\label{primesupto1000}
  \begin{tabular}{|*{\NbOfColumns}{r}|}
    \hline
    2\setcounter{cellcount}{1}\setcounter{primecount}{1}%
    \xintApplyUnbraced \OneCell {\xintSeq [2]{3}{999}}%
    \xintApplyUnbraced \OneTab
    {\xintSeq [1]{1}{\the\numexpr\NbOfColumns-\value{cellcount}\relax}}%
    \\
    \hline
  \end{tabular}
\smallskip
\centeredline{There are \arabic{primecount} prime numbers up to 1000.}
\end{figure*}

\subsection{\csbh{xintloop}, \csbh{xintbreakloop}, \csbh{xintbreakloopanddo}, \csbh{xintloopskiptonext}}
\label{xintloop}
\label{xintbreakloop}
\label{xintbreakloopanddo}
\label{xintloopskiptonext}
% {\small New with release |1.09g|. Release |1.09h|
%   makes them long macros.\par}

|\xintloop|\meta{stuff}|\if<test>...\repeat|\retype{} is an expandable loop
compatible with nesting. However to break out of the loop one almost always need
some un-expandable step. The cousin \csbxint{iloop} is \csbxint{loop} with an
embedded expandable mechanism allowing to exit from the loop. The iterated
commands may contain |\par| tokens or empty lines.

If a sub-loop is to be used all the material from the start of the main loop and
up to the end of the entire subloop should be braced; these braces will be
removed and do not create a group. The simplest to allow the nesting of one or
more sub-loops is to brace everything between \csa{xintloop} and \csa{repeat},
being careful not to leave a space between the closing brace and |\repeat|.

As this loop and \csbxint{iloop} will primarily be of interest to experienced
\TeX{} macro programmers, my description will assume that the user is
knowledgeable enough. Some examples in this document will be perhaps more
illustrative than my attemps at explanation of use.

One can abort the loop with \csbxint{breakloop}; this should not be used inside
the final test, and one should expand the |\fi| from the corresponding test
before. One has also \csbxint{breakloopanddo} whose first argument will be
inserted in the token stream after the loop; one may need a macro such as
|\xint_afterfi| to move the whole thing after the |\fi|, as a simple
|\expandafter| will not be enough.

One will usually employ some count registers to manage the exit test from the
loop; this breaks expandability, see \csbxint{iloop} for an expandable integer
indexed loop. Use in alignments will be complicated by the fact that cells
create groups, and also from the fact that any encountered unexpandable material
will cause the \TeX{} input scanner to insert |\endtemplate| on each encountered
|&| or |\cr|; thus |\xintbreakloop| may not work as expected, but the situation
can be resolved via |\xint_firstofone{&}| or use of |\TAB| with |\def\TAB{&}|.
It is thus simpler for alignments to use rather than \csbxint{loop} either the
expandable \csbxint{ApplyUnbraced} or the non-expandable but alignment
compatible \csbxint{ApplyInline}, \csbxint{For} or \csbxint{For*}.

As an example, let us suppose we have two macros |\A|\marg{i}\marg{j} and
|\B|\marg{i}\marg{j} behaving like (small) integer valued matrix entries, and we
want to define a macro |\C|\marg{i}\marg{j} giving the matrix product (|i| and
|j| may be count registers). We will assume that |\A[I]| expands to the number
of rows, |\A[J]| to the number of columns and want the produced |\C| to act in
the same manner. The code is very dispendious in use of |\count| registers, not
optimized in any way, not made very robust (the defined macro can not have the
same name as the first two matrices for example), we just wanted to quickly
illustrate use of the nesting capabilities of |\xintloop|.%
%
\footnote{for a more sophisticated implementation of matrix
  multiplication, inclusive of determinants, inverses, and display
  utilities, with entries big integers or decimal numbers or even
  fractions see \url{http://tex.stackexchange.com/a/143035/4686} from
  November 11, 2013.}
%

%\def\everbhook {\makeatother }

\begin{everbatim*}
\newcount\rowmax   \newcount\colmax   \newcount\summax
\newcount\rowindex \newcount\colindex \newcount\sumindex
\newcount\tmpcount
\makeatletter
\def\MatrixMultiplication #1#2#3{%
    \rowmax #1[I]\relax
    \colmax #2[J]\relax
    \summax #1[J]\relax
    \rowindex 1
    \xintloop % loop over row index i
    {\colindex 1
     \xintloop % loop over col index k
     {\tmpcount 0
      \sumindex 1
      \xintloop % loop over intermediate index j
      \advance\tmpcount \numexpr #1\rowindex\sumindex*#2\sumindex\colindex\relax
      \ifnum\sumindex<\summax
         \advance\sumindex 1
      \repeat }%
     \expandafter\edef\csname\string#3{\the\rowindex.\the\colindex}\endcsname
      {\the\tmpcount}%
     \ifnum\colindex<\colmax
         \advance\colindex 1
     \repeat }%
    \ifnum\rowindex<\rowmax
    \advance\rowindex 1
    \repeat
    \expandafter\edef\csname\string#3{I}\endcsname{\the\rowmax}%
    \expandafter\edef\csname\string#3{J}\endcsname{\the\colmax}%
    \def #3##1{\ifx[##1\expandafter\Matrix@helper@size
                    \else\expandafter\Matrix@helper@entry\fi #3{##1}}%
}%
\def\Matrix@helper@size #1#2#3]{\csname\string#1{#3}\endcsname }%
\def\Matrix@helper@entry #1#2#3%
   {\csname\string#1{\the\numexpr#2.\the\numexpr#3}\endcsname }%
\def\A #1{\ifx[#1\expandafter\A@size
            \else\expandafter\A@entry\fi {#1}}%
\def\A@size #1#2]{\ifx I#23\else4\fi}% 3rows, 4columns
\def\A@entry #1#2{\the\numexpr #1+#2-1\relax}% not pre-computed...
\def\B #1{\ifx[#1\expandafter\B@size
            \else\expandafter\B@entry\fi {#1}}%
\def\B@size #1#2]{\ifx I#24\else3\fi}% 4rows, 3columns
\def\B@entry #1#2{\the\numexpr #1-#2\relax}% not pre-computed...
\makeatother
\MatrixMultiplication\A\B\C \MatrixMultiplication\C\C\D 
\MatrixMultiplication\C\D\E \MatrixMultiplication\C\E\F
\begin{multicols}2
  \[\begin{pmatrix}
    \A11&\A12&\A13&\A14\\
    \A21&\A22&\A23&\A24\\
    \A31&\A32&\A33&\A34
  \end{pmatrix}
  \times
  \begin{pmatrix}
    \B11&\B12&\B13\\
    \B21&\B22&\B23\\
    \B31&\B32&\B33\\
    \B41&\B42&\B43
  \end{pmatrix}
  =
  \begin{pmatrix}
    \C11&\C12&\C13\\
    \C21&\C22&\C23\\
    \C31&\C32&\C33
  \end{pmatrix}\]
  \[\begin{pmatrix}
    \C11&\C12&\C13\\
    \C21&\C22&\C23\\
    \C31&\C32&\C33
  \end{pmatrix}^2 = \begin{pmatrix}
    \D11&\D12&\D13\\
    \D21&\D22&\D23\\
    \D31&\D32&\D33
  \end{pmatrix}\]
  \[\begin{pmatrix}
    \C11&\C12&\C13\\
    \C21&\C22&\C23\\
    \C31&\C32&\C33
  \end{pmatrix}^3 = \begin{pmatrix}
    \E11&\E12&\E13\\
    \E21&\E22&\E23\\
    \E31&\E32&\E33
  \end{pmatrix}\]
  \[\begin{pmatrix}
    \C11&\C12&\C13\\
    \C21&\C22&\C23\\
    \C31&\C32&\C33
  \end{pmatrix}^4 = \begin{pmatrix}
    \F11&\F12&\F13\\
    \F21&\F22&\F23\\
    \F31&\F32&\F33
  \end{pmatrix}\]
\end{multicols}
\end{everbatim*}

% \restoreeverbhook

\subsection{\csbh{xintiloop}, \csbh{xintiloopindex}, \csbh{xintouteriloopindex},
  \csbh{xintbreakiloop}, \csbh{xintbreakiloopanddo}, \csbh{xintiloopskiptonext},
\csbh{xintiloopskipandredo}}
\label{xintiloop}
\label{xintbreakiloop}
\label{xintbreakiloopanddo}
\label{xintiloopskiptonext}
\label{xintiloopskipandredo}
\label{xintiloopindex}
\label{xintouteriloopindex}
%{\small New with release |1.09g|.\par}

\csa{xintiloop}|[start+delta]|\meta{stuff}|\if<test> ... \repeat|\retype{} is a
completely expandable nestable loop. complete expandability depends naturally on
the actual iterated contents, and complete expansion will not be achievable
under a sole \fexpan sion, as is indicated by the hollow star in the margin;
thus the loop can be used inside an |\edef| but not inside arguments to the
package macros. It can be used inside an |\xintexpr..\relax|. The
|[start+delta]| is mandatory, not optional.

This loop benefits via \csbxint{iloopindex} to (a limited access to) the integer
index of the iteration. The starting value |start| (which may be a |\count|) and
increment |delta| (\emph{id.}) are mandatory arguments. A space after the
closing square bracket is not significant, it will be ignored. Spaces inside the
square brackets will also be ignored as the two arguments are first given to a
|\numexpr...\relax|. Empty lines and explicit |\par| tokens are accepted.

As with \csbxint{loop}, this tool will mostly be of interest to advanced users.
For nesting, one puts inside braces all the
material from the start (immediately after |[start+delta]|) and up to and
inclusive of the inner loop, these braces will be removed and do not create a
loop. In case of nesting, \csbxint{outeriloopindex} gives access to the index of
the outer loop. If needed one could write on its model a macro giving access to
the index of the outer outer loop (or even to the |nth| outer loop).

The \csa{xintiloopindex} and \csa{xintouteriloopindex} can not be used inside
braces, and generally speaking this means they should be expanded first when
given as argument to a macro, and that this macro receives them as delimited
arguments, not braced ones. Or, but naturally this will break expandability, one
can assign the value of \csa{xintiloopindex} to some |\count|. Both
\csa{xintiloopindex} and \csa{xintouteriloopindex} extend to the litteral
representation of the index, thus in |\ifnum| tests, if it comes last one has to
correctly end the macro with a |\space|, or encapsulate it in a
|\numexpr..\relax|.

When the repeat-test of the loop is, for example, |\ifnum\xintiloopindex<10
\repeat|, this means that the last iteration will be with |\xintiloopindex=10|
(assuming |delta=1|). There is also |\ifnum\xintiloopindex=10 \else\repeat| to
get the last iteration to be the one with |\xintiloopindex=10|.

One has \csbxint{breakiloop} and \csbxint{breakiloopanddo} to abort the loop.
The syntax of |\xintbreakiloopanddo| is a bit surprising, the sequence of tokens
to be executed after breaking the loop is not within braces but is delimited by
a dot as in:
%
\leftedline{|\xintbreakiloopanddo <afterloop>.etc.. etc... \repeat|}
%
The reason is that one may wish to use the then current value of
|\xintiloopindex| in |<afterloop>| but it can't be within braces at the time it
is evaluated. However, it is not that easy as |\xintiloopindex| must be expanded
before, so one ends up with code like this:
%
\leftedline
{|\expandafter\xintbreakiloopanddo\expandafter\macro\xintiloopindex.%|}
%
\leftedline{|etc.. etc.. \repeat|}
%
As moreover the |\fi| from the test leading to the decision of breaking out of
the loop must be cleared out of the way, the above should be
a branch of an expandable conditional test, else one needs something such
as:
%
\leftedline
{|\xint_afterfi{\expandafter\xintbreakiloopanddo\expandafter\macro\xintiloopindex.}%|}
%
\leftedline{|\fi etc..etc.. \repeat|}

There is \csbxint{iloopskiptonext} to abort the current iteration and skip to
the next, \hyperref[xintiloopskipandredo]{\ttfamily\hyphenchar\font45 \char92
  xintiloopskip\-and\-redo} to skip to the end of the current iteration and redo
it with the same value of the index (something else will have to change for this
not to become an eternal loop\dots ).

Inside alignments, if the looped-over text contains a |&| or a |\cr|, any
un-expandable material before a \csbxint{iloopindex} will make it fail because
of |\endtemplate|; in such cases one can always either replace |&| by a macro
expanding to it or replace it by a suitable |\firstofone{&}|, and similarly for
|\cr|.

\phantomsection\label{edefprimes}
As an example, let us construct an |\edef\z{...}| which will define |\z| to be a
list of prime numbers:
\begin{everbatim*}
\begingroup
\edef\z
{\xintiloop [10001+2]
  {\xintiloop [3+2]
   \ifnum\xintouteriloopindex<\numexpr\xintiloopindex*\xintiloopindex\relax
          \xintouteriloopindex,
          \expandafter\xintbreakiloop
   \fi
   \ifnum\xintouteriloopindex=\numexpr
        (\xintouteriloopindex/\xintiloopindex)*\xintiloopindex\relax
   \else
   \repeat
  }% no space here
 \ifnum \xintiloopindex < 10999 \repeat }%
\meaning\z\endgroup
\end{everbatim*}and we should have taken
some steps to not have a trailing comma, but 
the point was to show that one can do that in an |\edef|\,! See also
\autoref{ssec:primesII} which extracts from this code its way of testing
primality.

Let us create an alignment where each row will contain all divisors of its
first entry.
Here is the output, thus obtained without any count register:
\begin{everbatim*}
\begin{multicols}2
\tabskip1ex \normalcolor
\halign{&\hfil#\hfil\cr
    \xintiloop [1+1]
    {\expandafter\bfseries\xintiloopindex &
     \xintiloop [1+1]
     \ifnum\xintouteriloopindex=\numexpr
           (\xintouteriloopindex/\xintiloopindex)*\xintiloopindex\relax
     \xintiloopindex&\fi
     \ifnum\xintiloopindex<\xintouteriloopindex\space % CRUCIAL \space HERE
     \repeat \cr }%
    \ifnum\xintiloopindex<30
    \repeat
}
\end{multicols}
\end{everbatim*}
We wanted this first entry in bold face, but |\bfseries| leads to
unexpandable tokens, so the |\expandafter| was necessary for |\xintiloopindex|
and |\xintouteriloopindex| not to be confronted with a hard to digest
|\endtemplate|. An alternative way of coding:
%
\begin{everbatim}
\tabskip1ex
\def\firstofone #1{#1}%
\halign{&\hfil#\hfil\cr
  \xintiloop [1+1]
    {\bfseries\xintiloopindex\firstofone{&}%
    \xintiloop [1+1] \ifnum\xintouteriloopindex=\numexpr
    (\xintouteriloopindex/\xintiloopindex)*\xintiloopindex\relax
    \xintiloopindex\firstofone{&}\fi
    \ifnum\xintiloopindex<\xintouteriloopindex\space % \space is CRUCIAL
    \repeat \firstofone{\cr}}%
  \ifnum\xintiloopindex<30 \repeat }
\end{everbatim}


\subsection{Another completely expandable prime test}\label{ssec:primesII}

The |\IsPrime| macro from \autoref{ssec:primesI} checked expandably if a (short)
integer was prime, here is a partial rewrite using \csbxint{iloop}. We use the
|etoolbox| expandable conditionals for convenience, but not everywhere as
|\xintiloopindex| can not be evaluated while being braced. This is also the
reason why |\xintbreakiloopanddo| is delimited, and the next macro
|\SmallestFactor| which returns the smallest prime factor examplifies that. One
could write more efficient completely expandable routines, the aim here was only
to illustrate use of the general purpose \csbxint{iloop}. A little table giving
the first values of |\SmallestFactor| follows, its coding uses \csbxint{For},
which is described later; none of this uses count registers.
%

\begin{everbatim*}
\let\IsPrime\undefined \let\SmallestFactor\undefined % clean up possible previous mess
\newcommand{\IsPrime}[1] % returns 1 if #1 is prime, and 0 if not
  {\ifnumodd {#1}
    {\ifnumless {#1}{8}
      {\ifnumequal{#1}{1}{0}{1}}% 3,5,7 are primes
      {\if
       \xintiloop [3+2]
       \ifnum#1<\numexpr\xintiloopindex*\xintiloopindex\relax
           \expandafter\xintbreakiloopanddo\expandafter1\expandafter.%
       \fi
       \ifnum#1=\numexpr (#1/\xintiloopindex)*\xintiloopindex\relax
       \else
       \repeat 00\expandafter0\else\expandafter1\fi
      }%
    }% END OF THE ODD BRANCH
    {\ifnumequal {#1}{2}{1}{0}}% EVEN BRANCH
}%
\catcode`_ 11
\newcommand{\SmallestFactor}[1] % returns the smallest prime factor of #1>1
  {\ifnumodd {#1}
    {\ifnumless {#1}{8}
      {#1}% 3,5,7 are primes
      {\xintiloop [3+2]
       \ifnum#1<\numexpr\xintiloopindex*\xintiloopindex\relax
           \xint_afterfi{\xintbreakiloopanddo#1.}%
       \fi
       \ifnum#1=\numexpr (#1/\xintiloopindex)*\xintiloopindex\relax
           \xint_afterfi{\expandafter\xintbreakiloopanddo\xintiloopindex.}%
       \fi
       \iftrue\repeat
      }%
     }% END OF THE ODD BRANCH
   {2}% EVEN BRANCH
}%
\catcode`_ 8
{\centering
  \begin{tabular}{|c|*{10}c|}
    \hline
    \xintFor #1 in {0,1,2,3,4,5,6,7,8,9}\do {&\bfseries #1}\\
    \hline
    \bfseries 0&--&--&2&3&2&5&2&7&2&3\\
    \xintFor #1 in {1,2,3,4,5,6,7,8,9}\do
    {\bfseries #1%
      \xintFor #2 in {0,1,2,3,4,5,6,7,8,9}\do
      {&\SmallestFactor{#1#2}}\\}%
    \hline
  \end{tabular}\par
}
\end{everbatim*}

\subsection{A table of factorizations}
\label{ssec:factorizationtable}

As one more example with \csbxint{iloop} let us use an alignment to display the
factorization of some numbers. The loop will actually only play a minor r\^ole
here, just handling the row index, the row contents being almost entirely
produced via a macro |\factorize|. The factorizing macro does not use
|\xintiloop| as it didn't appear to be the convenient tool. As |\factorize| will
have to be used on |\xintiloopindex|, it has been defined as a delimited macro.

To spare some fractions of a second in the compilation time of this document
(which has many many other things to do), \number"7FFFFFED{} and
\number"7FFFFFFF, which turn out to be prime numbers, are not given to
|factorize| but just typeset directly; this illustrates use of
\csbxint{iloopskiptonext}.

The code next generates a \hyperref[floatfactorize]{table} which has
been made into a float appearing \vpageref{floatfactorize}. Here is now
the code for factorization; the conditionals use the package provided
|\xint_firstoftwo| and |\xint_secondoftwo|, one could have employed
rather \LaTeX{}'s own |\@firstoftwo| and |\@secondoftwo|, or, simpler
still in \LaTeX{} context, the |\ifnumequal|, |\ifnumless| \dots,
utilities from the package |etoolbox| which do exactly that under the
hood. Only \TeX{} acceptable numbers are treated here, but it would be
easy to make a translation and use the \xintname macros, thus extending
the scope to big numbers; naturally up to a cost in speed.

The reason for some strange looking expressions is to avoid arithmetic overflow.

\begin{everbatim*}
\catcode`_ 11
\def\abortfactorize #1\xint_secondoftwo\fi #2#3{\fi}

\def\factorize #1.{\ifnum#1=1 \abortfactorize\fi
          \ifnum\numexpr #1-2=\numexpr ((#1/2)-1)*2\relax
               \expandafter\xint_firstoftwo
          \else\expandafter\xint_secondoftwo
          \fi
         {2&\expandafter\factorize\the\numexpr#1/2.}%
         {\factorize_b #1.3.}}%

\def\factorize_b #1.#2.{\ifnum#1=1 \abortfactorize\fi
         \ifnum\numexpr #1-(#2-1)*#2<#2
                 #1\abortfactorize
         \fi
         \ifnum \numexpr #1-#2=\numexpr ((#1/#2)-1)*#2\relax
              \expandafter\xint_firstoftwo
         \else\expandafter\xint_secondoftwo
         \fi
         {#2&\expandafter\factorize_b\the\numexpr#1/#2.#2.}%
         {\expandafter\factorize_b\the\numexpr #1\expandafter.%
                                  \the\numexpr #2+2.}}%
\catcode`_ 8
\begin{figure*}[ht!]
\centering\phantomsection\label{floatfactorize}\normalcolor
\tabskip1ex
\centeredline{\vbox{\halign {\hfil\strut#\hfil&&\hfil#\hfil\cr\noalign{\hrule}
         \xintiloop ["7FFFFFE0+1]
         \expandafter\bfseries\xintiloopindex &
         \ifnum\xintiloopindex="7FFFFFED
              \number"7FFFFFED\cr\noalign{\hrule}
         \expandafter\xintiloopskiptonext
         \fi
         \expandafter\factorize\xintiloopindex.\cr\noalign{\hrule}
         \ifnum\xintiloopindex<"7FFFFFFE
         \repeat
         \bfseries \number"7FFFFFFF&\number "7FFFFFFF\cr\noalign{\hrule}
}}}
\centeredline{A table of factorizations}
\end{figure*}
\end{everbatim*}

\begin{framed}
  The next utilities are not compatible with expansion-only context.
\end{framed}

\subsection{\csbh{xintApplyInline}}\label{xintApplyInline}

% {\small |1.09a|, enhanced in |1.09c| to be usable within alignments, and
%   corrected in |1.09d| for a problem related to spaces at the very end of the
%   list parameter.\par}

\csa{xintApplyInline}|{\macro}|\marg{list}\ntype{o{\lowast f}} works non
expandably. It applies the one-parameter |\macro| to the first element of the
expanded list (|\macro| may have itself some arguments, the list item will be
appended as last argument), and is then re-inserted in the input stream after
the tokens resulting from this first expansion of |\macro|. The next item is
then handled.

This is to be used in situations where one needs to do some repetitive
things. It is not expandable and can not be completely expanded inside a
macro definition, to prepare material for later execution, contrarily to what
\csbxint{Apply} or \csbxint{ApplyUnbraced} achieve.

\begin{everbatim*}
\def\Macro #1{\advance\cnta #1 , \the\cnta}
\cnta 0
0\xintApplyInline\Macro {3141592653}.
\end{everbatim*}
The first argument |\macro| does not have to be an expandable macro.

\csa{xintApplyInline} submits its second, token list parameter to an
\hyperref[ssec:expansions]{\fexpan
sion}. Then, each \emph{unbraced} item will also be \fexpan ded. This provides
an easy way to insert one list inside another. \emph{Braced} items are not
expanded. Spaces in-between items are gobbled (as well as those at the start
or the end of the list), but not the spaces \emph{inside} the braced items.

\csa{xintApplyInline}, despite being non-expandable, does survive to
contexts where the executed |\macro| closes groups, as happens inside
alignments with the tabulation character |&|.
This tabular provides an example:\par
\begin{everbatim*}
\centerline{\normalcolor\begin{tabular}{ccc}
     $N$ & $N^2$ & $N^3$ \\ \hline
     \def\Row #1{ #1 & \xintiiSqr {#1} & \xintiiPow {#1}{3} \\ \hline }%
     \xintApplyInline \Row {\xintCSVtoList{17,28,39,50,61}}
\end{tabular}}\medskip
\end{everbatim*}

We see that despite the fact that the first encountered tabulation character in
the first row close a group and thus erases |\Row| from \TeX's memory,
|\xintApplyInline| knows how to deal with this.

Using \csbxint{ApplyUnbraced} is an alternative: the difference is that
this would have prepared all rows first and only put them back into the
token stream once they are all assembled, whereas with |\xintApplyInline|
each row is constructed and immediately fed back into the token stream: when
one does things with numbers having hundreds of digits, one learns that
keeping on hold and shuffling around hundreds of tokens has an impact on
\TeX{}'s speed (make this ``thousands of tokens'' for the impact to be
noticeable).

One may nest various |\xintApplyInline|'s. For example (see the
\hyperref[float]{table} \vpageref{float}):\par
\begin{everbatim*}
\begin{figure*}[ht!]
  \centering\phantomsection\label{float}
  \def\Row #1{#1:\xintApplyInline {\Item {#1}}{0123456789}\\ }%
  \def\Item #1#2{&\xintiPow {#1}{#2}}%
  \centeredline {\begin{tabular}{ccccccccccc} &0&1&2&3&4&5&6&7&8&9\\ \hline
      \xintApplyInline \Row {0123456789}
    \end{tabular}}
\end{figure*}
\end{everbatim*}

One could not move the definition of |\Item| inside the tabular,
as it would get lost after the first |&|. But this
works:
\everb|@
\begin{tabular}{ccccccccccc}
    &0&1&2&3&4&5&6&7&8&9\\ \hline
    \def\Row #1{#1:\xintApplyInline {&\xintiPow {#1}}{0123456789}\\ }%
    \xintApplyInline \Row {0123456789}
\end{tabular}
|

A limitation is that, contrarily to what one may have expected, the
|\macro| for an |\xintApplyInline| can not be used to define
the |\macro| for a nested sub-|\xintApplyInline|. For example,
this does not work:\par
\everb|@
  \def\Row #1{#1:\def\Item ##1{&\xintiPow {#1}{##1}}%
                 \xintApplyInline \Item {0123456789}\\ }%
  \xintApplyInline \Row {0123456789} % does not work
|
\noindent But see \csbxint{For}.

\subsection{\csbh{xintFor}, \csbh{xintFor*}}\label{xintFor}\label{xintFor*}
% {\small New with |1.09c|. Extended in |1.09e| (\csbxint{BreakFor},
%   \csbxint{integers}, \dots). |1.09f| version handles all macro parameters up
%   to
%   |#9| and removes spaces around commas.\par}

\csbxint{For}\ntype{on} is a new kind of for loop. Rather than using macros
for encapsulating list items, its behavior is more like a macro with parameters:
|#1|, |#2|, \dots, |#9| are used to represent the items for up to nine levels of
nested loops. Here is an example:
%
\everb|@
\xintFor #9 in {1,2,3} \do {%
  \xintFor #1 in {4,5,6} \do {%
    \xintFor #3 in {7,8,9} \do {%
      \xintFor #2 in {10,11,12} \do {%
      $$#9\times#1\times#3\times#2=\xintiiPrd{{#1}{#2}{#3}{#9}}$$}}}}
|
\noindent This example illustrates that one does not have to use |#1| as the
first one: 
the order is arbitrary. But each level of nesting should have its specific macro
parameter. Nine levels of nesting is presumably overkill, but I did not know
where it was reasonable to stop. |\par| tokens are accepted in both the comma
separated list and the replacement text.

\begin{framed}
  A macro |\macro| whose definition uses internally an \csbxint{For} loop may be
  used inside another \csbxint{For} loop even if the two loops both use the same
  macro parameter. Note: the loop definition inside |\macro| must double
  the character |#| as is the general rule in \TeX{} with definitions done
  inside macros.

  The macros \csa{xintFor} and \csa{xintFor*} are not expandable, one can not
  use them inside an |\edef|. But they may be used inside alignments (such as a
  \LaTeX{} |tabular|), as will be shown in examples.
\end{framed}

The spaces between the various declarative elements are all optional;
furthermore spaces around the commas or at the start and end of the list
argument are allowed, they will be removed. If an item must contain itself
commas, it should be braced to prevent these commas from being misinterpreted as
list separator. These braces will be removed during processing. The list
argument may be a macro |\MyList| expanding in one step to the comma separated
list (if it has no arguments, it does not have to be braced). It
will be expanded (only once) to reveal its comma separated items for processing,
comma separated items will not be expanded before being fed into the replacement
text as |#1|, or |#2|, etc\dots, only leading and trailing spaces are removed.

A starred variant \csbxint{For*}\ntype{{\lowast f}n} deals with lists of braced
items, rather than comma separated items. It has also a distinct expansion
policy, which is detailed below.

Contrarily to what happens in loops where the item is represented by a macro,
here it is truly exactly as when defining (in \LaTeX{}) a ``command'' with
parameters |#1|, etc... This may avoid the user quite a few troubles with
|\expandafter|s or other |\edef/\noexpand|s which one encounters at times when
trying to do things with \LaTeX's {\makeatother|\@for|} or other loops
which encapsulate the item in a macro expanding to that item.

\begin{framed}
  The non-starred variant \csbxint{For} deals with comma separated values
  (\emph{spaces before and after the commas are removed}) and the comma
  separated list may be a macro which is only expanded once (to prevent
  expansion of the first item |\x| in a list directly input as |\x,\y,...| it
  should be input as |{\x},\y,..| or |<space>\x,\y,..|, naturally all of that
  within the mandatory braces of the \csa{xintFor \#n in \{list\}} syntax). The
  items are not expanded, if the input is |<stuff>,\x,<stuff>| then |#1| will be
  at some point |\x| not its expansion (and not either a macro with |\x| as
  replacement text, just the token |\x|). Input such as |<stuff>,,<stuff>|
  creates an empty |#1|, the iteration is not skipped. An empty list does lead
  to the use of the replacement text, once, with an empty |#1| (or |#n|). Except
  if the entire list is represented as a single macro with no parameters,
  \fbox{it must be braced.}
\end{framed}

\begin{framed}
  The starred variant \csbxint{For*} deals with token lists (\emph{spaces
    between braced items or single tokens are not significant}) and
  \hyperref[ssec:expansions]{\fexpan ds} each \emph{unbraced} list item. This
  makes it easy to simulate concatenation of various list macros |\x|, |\y|, ...
  If |\x| expands to |{1}{2}{3}| and |\y| expands to |{4}{5}{6}| then |{\x\y}|
  as argument to |\xintFor*| has the same effect as |{{1}{2}{3}{4}{5}{6}}|%
  \stepcounter{footnote}%
  \makeatletter\hbox {\@textsuperscript {\normalfont \thefootnote
    }}\makeatother. Spaces at the start, end, or in-between items are gobbled
  (but naturally not the spaces which may be inside \emph{braced} items). Except
  if the list argument is a single macro with no parameters, \fbox{it must be
    braced.} Each item which is not braced will be fully expanded (as the |\x|
  and |\y| in the example above). An empty list leads to an empty result.
\end{framed}
\begingroup\makeatletter
\def\@footnotetext #1{\insert\footins {\reset@font \footnotesize \interlinepenalty \interfootnotelinepenalty \splittopskip \footnotesep \splitmaxdepth \dp \strutbox \floatingpenalty \@MM \hsize \columnwidth \@parboxrestore \color@begingroup \@makefntext {\rule \z@ \footnotesep \ignorespaces #1\@finalstrut \strutbox }\color@endgroup }}
\addtocounter{footnote}{-1}
\edef\@thefnmark {\thefootnote}
\@footnotetext{braces around single token items
    are optional so this is the same as \texttt{\{123456\}}.}
% \stepcounter{footnote}
% \edef\@thefnmark {\thefootnote}
% \@footnotetext{the \csa{space} will stop the \TeX{} scanning of a number and be
%   gobbled in the process; the \csa{relax} stops the scanning but is not
%   gobbled. Or one may do \csa{numexpr}\texttt{\#1}\csa{relax}, and then the
%   \csa{relax} is gobbled.}
\endgroup
%\addtocounter{Hfootnote}{2}
\addtocounter{Hfootnote}{1}

The macro \csbxint{Seq} which generates arithmetic sequences may only be used
with \csbxint{For*} (numbers from output of |\xintSeq| are braced, not separated
by commas). %
%
\leftedline{|\xintFor* #1 in {\xintSeq [+2]{-7}{+2}}\do {stuff
    with #1}|} will have |#1=-7,-5,-3,-1, and 1|. The |#1| as issued from the
list produced by \csbxint{Seq} is the litteral representation as would be
produced by |\arabic| on a \LaTeX{} counter, it is not a count register. When
used in |\ifnum| tests or other contexts where \TeX{} looks for a number it
should thus be postfixed with |\relax| or |\space|.

When nesting \csa{xintFor*} loops, using \csa{xintSeq} in the inner loops is
inefficient, as the arithmetic sequence will be re-created each time. A more
efficient style is:
%
\begin{everbatim}
    \edef\innersequence {\xintSeq[+2]{-50}{50}}%
    \xintFor* #1 in {\xintSeq {13}{27}} \do
        {\xintFor* #2 in \innersequence \do {stuff with #1 and #2}%
         .. some other macros .. }
\end{everbatim}

This is a general remark applying for any nesting of loops, one should avoid
recreating the inner lists of arguments at each iteration of the outer loop.
However, in the example above, if the |.. some other macros ..| part
closes a group which was opened before the |\edef\innersequence|, then
this definition will be lost. An alternative to |\edef|, also efficient,
exists when dealing with arithmetic sequences: it is to use the
\csbxint{integers} keyword (described later) which simulates infinite
arithmetic sequences; the loops will then be terminated via a test |#1|
(or |#2| etc\dots) and subsequent use of \csbxint{BreakFor}.

The \csbxint{For} loops are not completely expandable; but they may be nested
and used inside alignments or other contexts where the replacement text closes
groups. Here is an example (still using \LaTeX's tabular):

\begin{everbatim*}
\begin{tabular}{rccccc}
    \xintFor #7 in {A,B,C} \do {%
      #7:\xintFor* #3 in {abcde} \do {&($ #3 \to #7 $)}\\ }%
\end{tabular}
\end{everbatim*}

When
inserted inside a macro for later execution the |#| characters must be
doubled.%
%
\footnote{sometimes what seems to be a macro argument isn't really; in
  \csa{raisebox\{1cm\}\{}\csa{xintFor \#1 in \{a,b,c\} }\csa{do
    \{\#1\}\}} no doubling should be done.}
%
For example:
%
\begin{everbatim*}
\def\T{\def\z {}%
  \xintFor* ##1 in {{u}{v}{w}} \do {%
    \xintFor ##2 in {x,y,z} \do {%
      \expandafter\def\expandafter\z\expandafter {\z\sep (##1,##2)} }%
  }%
}%
\T\def\sep {\def\sep{, }}\z 
\end{everbatim*}

Similarly when the replacement text
of |\xintFor| defines a macro with parameters, the macro character |#| must be
doubled.

It is licit to use inside an \csbxint{For} a |\macro| which itself has
been defined to use internally some other \csbxint{For}. The same macro
parameter |#1| can be used with no conflict (as mentioned above, in the
definition of |\macro| the |#| used in the \csbxint{For} declaration must be
doubled, as is the general rule in \TeX{} with things defined inside other
things).

The iterated commands as well as the list items are allowed to contain explicit
|\par| tokens. Neither \csbxint{For} nor \csbxint{For*} create groups. The
effect is like piling up the iterated commands with each time |#1| (or |#2| ...)
replaced by an item of the list. However, contrarily to the completely
expandable \csbxint{ApplyUnbraced}, but similarly to the non completely
expandable \csbxint{ApplyInline} each iteration is executed first before looking
at the next |#1|%
%
\footnote{to be completely honest, both \csbxint{For} and
  \csbxint{For*} initially scoop up both the list and the iterated
  commands; \csbxint{For} scoops up a second time the entire comma
  separated list in order to feed it to \csbxint{CSVtoList}. The starred
  variant \csbxint{For*} which does not need this step will thus be a
  bit faster on equivalent inputs.}
%
(and
the starred variant \csbxint{For*} keeps on expanding each unbraced item it
finds, gobbling spaces).

\subsection{\csbh{xintifForFirst}, \csbh{xintifForLast}}
\label{xintifForFirst}\label{xintifForLast}
% {\small New in |1.09e|.\par}

\csbxint{ifForFirst}\,\texttt{\{YES branch\}\{NO branch\}}\etype{nn}
 and \csbxint{ifForLast}\,\texttt{\{YES
  branch\}\hskip 0pt plus 0.2em \{NO branch\}}\etype{nn} execute the |YES| or
|NO| branch
if the
\csbxint{For}
or \csbxint{For*} loop is currently in its first, respectively last, iteration.

Designed to work as expected under nesting. Don't forget an empty brace pair
|{}| if a branch is to do nothing. May be used multiple times in the replacement
text of the loop.

There is no such thing as an iteration counter provided by the \csa{xintFor}
loops; the user is invited to define if needed his own count register or
\LaTeX{} counter, for example with a suitable |\stepcounter| inside the
replacement text of the loop to update it.

\begin{framed}
  It is a known feature of these conditionals that they cease to function if
  put at a location of the |\xintFor| replacement text which has closed a
  group, for example in the last cell of an alignment created by the loop,
  assuming the replacement text of the |\xintFor| loop creates a row. The
  conditional must be used before the first cell is closed. This is not likely
  to change in future versions. It is not an intrinsic limitation as the
  branches of the conditional can be the complete rows, inclusive of all |&|'s
  and the tabular newline |\\|.
\end{framed}

\subsection{ \csbh{xintBreakFor}, \csbh{xintBreakForAndDo}}
\label{xintBreakFor}\label{xintBreakForAndDo}
%{\small New in |1.09e|.\par}

One may immediately terminate an \csbxint{For} or \csbxint{For*} loop with
\csbxint{BreakFor}. As the criterion for breaking will be decided on a
basis of some test, it is recommended to use for this test the syntax of
\href{http://ctan.org/pkg/ifthen}{ifthen}%
%
\footnote{\url{http://ctan.org/pkg/ifthen}}
%
or
\href{http://ctan.org/pkg/etoolbox}{etoolbox}%
%
\footnote{\url{http://ctan.org/pkg/etoolbox}}
%
or the \xintname own conditionals, rather than one of the various
|\if...\fi| of \TeX{}. Else (and this is without even mentioning all the various
pecularities of the
|\if...\fi| constructs), one has to carefully move the break after the closing
of
the conditional, typically with |\expandafter\xintBreakFor\fi|.%
%
\footnote{the difficulties here are similar to those mentioned in
  \autoref{sec:ifcase}, although less severe, as complete expandability
  is not to be maintained; hence the allowed use of
  \href{http://ctan.org/pkg/ifthen}{ifthen}.}

There is also \csbxint{BreakForAndDo}. Both are illustrated by various examples
in the next section which is devoted to ``forever'' loops.

\subsection{\csbh{xintintegers}, \csbh{xintdimensions}, \csbh{xintrationals}}
\label{xintegers}\label{xintintegers}
\label{xintdimensions}\label{xintrationals}
%{\small New in |1.09e|.\par}

If the list argument to \csbxint{For} (or \csbxint{For*}, both are equivalent in
this context) is \csbxint{integers} (equivalently \csbxint{egers}) or more
generally \csbxint{integers}|[||start|\allowbreak|+|\allowbreak|delta||]|
(\emph{the whole within braces}!)%
%
\footnote{the |start+delta| optional specification may have extra spaces
  around the plus sign of near the square brackets, such spaces are
  removed. The same applies with \csa{xintdimensions} and
  \csa{xintrationals}.},
%
then \csbxint{For} does an infinite iteration where
|#1| (or |#2|, \dots, |#9|) will run through the arithmetic sequence of (short)
integers with initial value |start| and increment |delta| (default values:
|start=1|, |delta=1|; if the optional argument is present it must contains both
of them, and they may be explicit integers, or macros or count registers). The
|#1| (or |#2|, \dots, |#9|) will stand for |\numexpr <opt sign><digits>\relax|,
and the litteral representation as a string of digits can thus be obtained as
\fbox{\csa{the\#1}} or |\number#1|. Such a |#1| can be used in an |\ifnum| test
with no need to be postfixed with a space or a |\relax| and one should
\emph{not} add them.

If the list argument is \csbxint{dimensions} or more generally
\csbxint{dimensions}|[||start|\allowbreak|+|\allowbreak|delta||]|  (\emph{within
  braces}!), then
\csbxint{For} does an infinite iteration where |#1| (or |#2|, \dots, |#9|) will
run through the arithmetic sequence of dimensions with initial value
|start| and increment |delta|. Default values: |start=0pt|, |delta=1pt|; if
the optional argument is present it must contain both of them, and they may
be explicit specifications, or macros, or dimen registers, or length commands
in \LaTeX{} (the stretch and shrink components will be discarded). The |#1|
will be |\dimexpr <opt sign><digits>sp\relax|, from which one can get the
litteral (approximate) representation in points via |\the#1|. So |#1| can be
used anywhere \TeX{} expects a dimension (and there is no need in conditionals
to insert a |\relax|, and one should \emph{not} do it), and to print its value
one uses \fbox{\csa{the\#1}}. The chosen representation guarantees exact
incrementation with no rounding errors accumulating from converting into
points at each step.

% original definitions, a bit slow.
%\def\DimToNum #1{\number\dimexpr #1\relax }
% cube
%\xintNewIExpr \FA [2] {protect(\DimToNum {#2})^3/protect(\DimToNum{#1})^2}
% square root
%\xintNewIExpr \FB [2] {sqrt (protect(\DimToNum {#2})*protect(\DimToNum {#1}))}
%\xintNewExpr \Ratio [2] {trunc(protect(\DimToNum {#2})/protect(\DimToNum{#1}),3)}

% improved faster code (4 four times faster)

\def\DimToNum #1{\the\numexpr \dimexpr#1\relax/10000\relax }
\def\FA #1#2{\xintDSH{-4}{\xintiQuo {\xintiPow {\DimToNum {#2}}{3}}{\xintiSqr
{\DimToNum{#1}}}}}
\def\FB #1#2{\xintDSH {-4}{\xintiSqrt
                          {\xintiMul {\DimToNum {#2}}{\DimToNum{#1}}}}}
\def\Ratio #1#2{\xintTrunc {2}{\DimToNum {#2}/\DimToNum{#1}}}

% a further 2.5 gain is made through using .25pt as horizontal step.
\begin{figure*}[ht!]
\phantomsection\hypertarget{graphic}{}%
\centeredline{%
\raisebox{-1cm}{\xintFor #1 in {\xintdimensions [0pt+.25pt]} \do
 {\ifdim #1>2cm \expandafter\xintBreakFor\fi
  {\color [rgb]{\Ratio {2cm}{#1},0,0}%
  \vrule width .25pt height \FB {2cm}{#1}sp depth -\FA {2cm}{#1}sp }%
  }% end of For iterated text
}%
\hspace{.5cm}%
\scriptsize\baselineskip8pt\relax
\begin{minipage}{\dimexpr\linewidth-2.5cm-\parindent\relax}\def\everbatimindent{0pt }%
\begin{everbatim}
\def\DimToNum #1{\number\dimexpr #1\relax }
\xintNewIExpr \FA [2] {protect(\DimToNum {#2})^3/protect(\DimToNum{#1})^2}     %cube
\xintNewIExpr \FB [2] {sqrt (protect(\DimToNum {#2})*protect(\DimToNum {#1}))} %sqrt
\xintNewExpr \Ratio [2] {trunc(protect(\DimToNum {#2})/protect(\DimToNum{#1}),3)}
\xintFor #1 in {\xintdimensions [0pt+.1pt]} \do
 {\ifdim #1>2cm \expandafter\xintBreakFor\fi
  {\color [rgb]{\Ratio {2cm}{#1},0,0}%
  \vrule width .1pt height \FB {2cm}{#1}sp depth -\FA {2cm}{#1}sp }%
 }% end of For iterated text
\end{everbatim}
\end{minipage}}
\end{figure*}

The\xintNewIExpr \FA [2] {protect(\DimToNum {#2})^3/protect(\DimToNum{#1})^2}
\hyperlink{graphic}{graphic}, with the code on its right%
%
\footnote{see \autoref{sssec:protect} for the significance of the |protect|'s:
  they are needed because the expression has macro parameters inside macros,
  and not only functions from the \csbxint{expr} syntax. The \csa{FA} turns
  out to have meaning \texttt{\fixmeaning\FA}. The \csa{romannumeral} part is
  only to ensure it expands in only two steps, and could be removed. The
  \expandafter|\string\xintRound::csv| and
  \expandafter|\string\xintSPRaw::csv| commands are used internally by
  \csbxint{iexpr} to round and pretty print its result (or comma separated
  results). See also the next footnote.},
%
is for illustration only, not
only because of pdf rendering artefacts when displaying adjacent rules (which do
\emph{not} show in |dvi| output as rendered by |xdvi|, and depend from your
viewer), but because not using anything but rules it is quite inefficient and
must do lots of computations to not confer a too ragged look to the borders.
With a width of |.5pt| rather than |.1pt| for the rules, one speeds up the
drawing by a factor of five, but the boundary is then visibly ragged.
\newbox\codebox
\begingroup\makeatletter
\def\x{%
     \parindent0pt
     \def\par{\@@par\leavevmode\null}%
     \let\do\do@noligs \verbatim@nolig@list
     \let\do\@makeother \dospecials
     \catcode`\@ 14 \makestarlowast
     \ttfamily \scriptsize\baselineskip 8pt \obeylines \@vobeyspaces
     \catcode`\|\active
     \lccode`\~`\|\lowercase{\let~\egroup}}%
\global\setbox\codebox \vbox\bgroup\x
\def\DimToNum #1{\the\numexpr \dimexpr#1\relax/10000\relax } % no need to be more precise!
\def\FA #1#2{\xintDSH {-4}{\xintiQuo {\xintiPow {\DimToNum {#2}}{3}}{\xintiSqr {\DimToNum{#1}}}}}
\def\FB #1#2{\xintDSH {-4}{\xintiSqrt {\xintiMul {\DimToNum {#2}}{\DimToNum{#1}}}}}
\def\Ratio #1#2{\xintTrunc {2}{\DimToNum {#2}/\DimToNum{#1}}}
\xintFor #1 in {\xintdimensions [0pt+.25pt]} \do
 {\ifdim #1>2cm \expandafter\xintBreakFor\fi
  {\color [rgb]{\Ratio {2cm}{#1},0,0}%
  \vrule width .25pt height \FB {2cm}{#1}sp depth -\FA {2cm}{#1}sp }%
 }% end of For iterated text
|%
\endgroup
\footnote{to tell the whole truth we cheated and divided by |10| the
  computation time through using the following definitions, together with a
  horizontal step of |.25pt| rather than |.1pt|. The displayed original code
  would make the slowest computation of all those done in this document using
  the \xintname bundle macros!\par\smallskip 
  \noindent\box \codebox\par }

If the list argument to \csbxint{For} (or \csbxint{For*}) is \csbxint{rationals}
or more generally
\csbxint{rationals}|[||start|\allowbreak|+|\allowbreak|delta||]| (\emph{within
  braces}!), then \csbxint{For} does an infinite iteration where |#1| (or |#2|,
\dots, |#9|) will run through the arithmetic sequence of \xintfracname fractions
with initial value |start| and increment |delta| (default values: |start=1/1|,
|delta=1/1|). This loop works \emph{only with \xintfracname loaded}. if the
optional argument is present it must contain both of them, and they may be given
in any of the formats recognized by \xintfracname (fractions, decimal
numbers, numbers in scientific notations, numerators and denominators in
scientific notation, etc...) , or as macros or count registers (if they are
short integers). The |#1| (or |#2|, \dots, |#9|) will be an |a/b| fraction
(without a |[n]| part), where
the denominator |b| is the product of the denominators of
|start| and |delta| (for reasons of speed |#1| is not reduced to irreducible
form, and for another reason explained later  |start| and |delta| are not put
either into irreducible form; the input may use explicitely \csa{xintIrr} to
achieve that).
\begin{everbatim*}
\begingroup\small
\noindent\parbox{\dimexpr\linewidth-3em}{\color[named]{OrangeRed}%
\xintFor #1 in {\xintrationals [10/21+1/21]} \do
{#1=\xintifInt {#1}
    {\textcolor{blue}{\xintTrunc{10}{#1}}}
    {\xintTrunc{10}{#1}}% display in blue if an integer
    \xintifGt {#1}{1.123}{\xintBreakFor}{, }%
  }}
\endgroup\smallskip
\end{everbatim*}

\smallskip The example above confirms that computations are done exactly, and
illustrates that the two initial (reduced) denominators are not multiplied when
they are found to be equal.  It is thus recommended to input |start| and |delta|
with a common smallest possible denominator, or as fixed point numbers with the
same numbers of digits after the decimal mark;  and this is also the reason why
|start| and |delta| are not by default made irreducible. As internally the
computations are done with numerators and denominators completely expanded, one
should be careful not to input numbers in scientific notation with exponents in
the hundreds, as they will get converted into as many zeroes.

\begin{everbatim*}
\noindent\parbox{\dimexpr.7\linewidth}{\raggedright
\xintFor #1 in {\xintrationals [0.000+0.125]} \do
{\edef\tmp{\xintTrunc{3}{#1}}%
 \xintifInt {#1}
    {\textcolor{blue}{\tmp}}
    {\tmp}%
    \xintifGt {#1}{2}{\xintBreakFor}{, }%
  }}\smallskip
\end{everbatim*}

We see here that \csbxint{Trunc} outputs (deliberately) zero as $0$, not (here)
$0.000$, the idea being not to lose the information that the truncated thing was
truly zero. Perhaps this behavior should be changed? or made optional? Anyhow
printing of fixed points numbers should be dealt with via dedicated packages
such as |numprint| or |siunitx|.\par

\subsection{Another table of primes}\label{ssec:primesIII}

As a further example, let us dynamically generate a tabular with the first $50$
prime numbers after $12345$. First we need a macro to test if a (short) number
is prime. Such a completely expandable macro was given in \autoref{xintSeq},
here we consider a variant which will be slightly more efficient. This new
|\IsPrime| has two parameters. The first one is a macro which it redefines to
expand to the result of the primality test applied to the second argument. For
convenience we use the \href{http://ctan.org/pkg/etoolbox}{etoolbox} wrappers to
various |\ifnum| tests, although here there isn't anymore the constraint of
complete expandability (but using explicit |\if..\fi| in tabulars has its
quirks); equivalent tests are provided by \xintname, but they have some overhead
as they are able to deal with arbitrarily big integers.

\def\IsPrime #1#2%
{\edef\TheNumber {\the\numexpr #2}% positive integer
 \ifnumodd {\TheNumber}
 {\ifnumgreater {\TheNumber}{1}
  {\edef\ItsSquareRoot{\xintiSqrt \TheNumber}%
    \xintFor ##1 in {\xintintegers [3+2]}\do
    {\ifnumgreater {##1}{\ItsSquareRoot}
               {\def#1{1}\xintBreakFor}
               {}%
     \ifnumequal {\TheNumber}{(\TheNumber/##1)*##1}
                 {\def#1{0}\xintBreakFor }
                 {}%
    }}
  {\def#1{0}}}% 1 is not prime
 {\ifnumequal {\TheNumber}{2}{\def#1{1}}{\def#1{0}}}%
}%

\everb|@
\def\IsPrime #1#2% """color[named]{PineGreen}#1=\Result, #2=tested number (assumed >0).;!
{\edef\TheNumber {\the\numexpr #2}%"""color[named]{PineGreen} hence #2 may be a count or \numexpr.;!
 \ifnumodd {\TheNumber}
 {\ifnumgreater {\TheNumber}{1}
  {\edef\ItsSquareRoot{\xintiSqrt \TheNumber}%
    \xintFor """color{red}##1;! in {"""color{red}\xintintegers;! [3+2]}\do
    {\ifnumgreater {"""color{red}##1;!}{\ItsSquareRoot} """color[named]{PineGreen}% "textcolor{red}{##1} is a \numexpr.;!
               {\def#1{1}\xintBreakFor}
               {}%
     \ifnumequal {\TheNumber}{(\TheNumber/##1)*##1}
                 {\def#1{0}\xintBreakFor }
                 {}%
    }}
  {\def#1{0}}}% 1 is not prime
 {\ifnumequal {\TheNumber}{2}{\def#1{1}}{\def#1{0}}}%
}
|

%\newcounter{primecount}
%\newcounter{cellcount}

As we used \csbxint{For} inside a macro we had to double the |#| in its |#1|
parameter. Here is now the code which creates the prime table (the table has
been put in a \hyperref[primes]{float}, which should be found on page
\pageref{primes}):

\everb?@
\newcounter{primecount}
\newcounter{cellcount}
\begin{figure*}[ht!]
  \centering
  \begin{tabular}{|*{7}c|}
  \hline
  \setcounter{primecount}{0}\setcounter{cellcount}{0}%
  \xintFor """color{red}#1;! in {"""color{red}\xintintegers;! [12345+2]} \do
"""color[named]{PineGreen}% "textcolor{red}{#1} is a \numexpr.;!
  {\IsPrime\Result{#1}%
   \ifnumgreater{\Result}{0}
   {\stepcounter{primecount}%
    \stepcounter{cellcount}%
    \ifnumequal {\value{cellcount}}{7}
       {"""color{red}\the#1;! \\\setcounter{cellcount}{0}}
       {"""color{red}\the#1;! &}}
   {}%
    \ifnumequal {\value{primecount}}{50}
     {\xintBreakForAndDo
      {\multicolumn {6}{l|}{These are the first 50 primes after 12345.}\\}}
     {}%
  }\hline
\end{tabular}
\end{figure*}
?

\begin{figure*}[ht!]
  \centering\phantomsection\label{primes}
  \begin{tabular}{|*{7}c|}
  \hline
  \setcounter{primecount}{0}\setcounter{cellcount}{0}%
  \xintFor #1 in {\xintintegers [12345+2]} \do
  {\IsPrime\Result{#1}%
   \ifnumgreater{\Result}{0}
   {\stepcounter{primecount}%
    \stepcounter{cellcount}%
    \ifnumequal {\value{cellcount}}{7}
       {\the#1 \\\setcounter{cellcount}{0}}
       {\the#1 &}}
   {}%
    \ifnumequal {\value{primecount}}{50}
     {\xintBreakForAndDo
      {\multicolumn {6}{l|}{These are the first 50 primes after 12345.}\\}}
     {}%
  }\hline
\end{tabular}
\end{figure*}

\subsection{Some arithmetic with Fibonacci numbers}
\label{ssec:fibonacci}

Here is the code employed on the title page to compute (expandably, of
course!) the 1250th Fibonacci number:

\begin{everbatim*}
\catcode`_ 11
\def\Fibonacci #1{%  \Fibonacci{N} computes F(N) with F(0)=0, F(1)=1.
    \expandafter\Fibonacci_a\expandafter
        {\the\numexpr #1\expandafter}\expandafter
        {\romannumeral0\xintiieval 1\expandafter\relax\expandafter}\expandafter
        {\romannumeral0\xintiieval 1\expandafter\relax\expandafter}\expandafter
        {\romannumeral0\xintiieval 1\expandafter\relax\expandafter}\expandafter
        {\romannumeral0\xintiieval 0\relax}}
%
\def\Fibonacci_a #1{%
    \ifcase #1
          \expandafter\Fibonacci_end_i
    \or
          \expandafter\Fibonacci_end_ii
    \else
          \ifodd #1
              \expandafter\expandafter\expandafter\Fibonacci_b_ii
          \else
              \expandafter\expandafter\expandafter\Fibonacci_b_i
          \fi
    \fi {#1}%
}% * signs are omitted from the next macros, tacit multiplications
\def\Fibonacci_b_i #1#2#3{\expandafter\Fibonacci_a\expandafter
  {\the\numexpr #1/2\expandafter}\expandafter
  {\romannumeral0\xintiieval sqr(#2)+sqr(#3)\expandafter\relax\expandafter}\expandafter
  {\romannumeral0\xintiieval (2#2-#3)#3\relax}%
}% end of Fibonacci_b_i
\def\Fibonacci_b_ii #1#2#3#4#5{\expandafter\Fibonacci_a\expandafter
  {\the\numexpr (#1-1)/2\expandafter}\expandafter
  {\romannumeral0\xintiieval sqr(#2)+sqr(#3)\expandafter\relax\expandafter}\expandafter
  {\romannumeral0\xintiieval (2#2-#3)#3\expandafter\relax\expandafter}\expandafter
  {\romannumeral0\xintiieval #2#4+#3#5\expandafter\relax\expandafter}\expandafter
  {\romannumeral0\xintiieval #2#5+#3(#4-#5)\relax}%
}% end of Fibonacci_b_ii
%         code as used on title page:
%\def\Fibonacci_end_i  #1#2#3#4#5{\xintthe#5}
%\def\Fibonacci_end_ii #1#2#3#4#5{\xinttheiiexpr #2#5+#3(#4-#5)\relax}
%         new definitions:
\def\Fibonacci_end_i  #1#2#3#4#5{{#4}{#5}}% {F(N+1)}{F(N)} in \xintexpr format
\def\Fibonacci_end_ii #1#2#3#4#5%
    {\expandafter
     {\romannumeral0\xintiieval #2#4+#3#5\expandafter\relax
      \expandafter}\expandafter
     {\romannumeral0\xintiieval #2#5+#3(#4-#5)\relax}}% idem.
% \FibonacciN returns F(N) (in encapsulated format: needs \xintthe for printing)
\def\FibonacciN {\expandafter\xint_secondoftwo\romannumeral-`0\Fibonacci }%
\catcode`_ 8
\end{everbatim*}

% ok
% \def\Fibo #1.{\xintthe\FibonacciN {#1}}% to use \xintiloopindex...
% \message{\xintiloop [0+1]
%          \expandafter\Fibo\xintiloopindex.,
%          \ifnum\xintiloopindex<49 \repeat \xintthe\FibonacciN{50}.}

I have modified the ending: we want not only one specific value |F(N)| but
a pair of successive values which can serve as starting point of another routine
devoted to compute a whole sequence |F(N), F(N+1), F(N+2),....|. This pair is,
for efficiency, kept in the encapsulated internal \xintexprname format.
|\FibonacciN| outputs the single |F(N)|, also as an |\xintexpr|-ession, and
printing it will thus need the |\xintthe| prefix.

\begingroup\footnotesize\sffamily\baselineskip 10pt
Here a code snippet which
checks the routine via a \string\message\ of the first $51$ Fibonacci
numbers (this is not an efficient way to generate a sequence of such
numbers, it is only for validating \csa{FibonacciN}).
%
\begin{everbatim}
\def\Fibo #1.{\xintthe\FibonacciN {#1}}%
\message{\xintiloop [0+1] \expandafter\Fibo\xintiloopindex., 
                          \ifnum\xintiloopindex<49 \repeat \xintthe\FibonacciN{50}.}
\end{everbatim}
\endgroup

The various |\romannumeral0\xintiieval| could very well all have been
|\xintiiexpr|'s but then we would have needed more |\expandafter|'s.
Indeed the order of expansion must be controlled for the whole thing to work,
and |\romannumeral0\xintiieval| is the first expanded form of |\xintiiexpr|.

The way we use |\expandafter|'s to chain successive |\xintexpr| evaluations is
exactly analogous to well-known expandable techniques made possible by
|\numexpr|.

\begin{framed}
  There is a difference though: |\numexpr| is \emph{NOT} expandable, and to
  force its expansion we must prefix it with |\the| or |\number|. On the other
  hand |\xintexpr|, |\xintiexpr|, ..., (or |\xinteval|, |\xintieval|, ...)
  expand fully when prefixed by |\romannumeral-`0|: the computation is fully
  executed and its result encapsulated in a private format.

  Using |\xintthe| as prefix is necessary to print the result (this is like
  |\the| for |\numexpr|), but it is not necessary to get the computation done
  (contrarily to the situation with |\numexpr|).

  And, starting with release |1.09j|, it is also allowed to expand a non
  |\xintthe| prefixed |\xintexpr|-ession inside an |\edef|: the private format
  is now protected, hence the error message complaining about a missing
  |\xintthe| will not be executed, and the integrity of the format will be
  preserved.

  This new possibility brings some efficiency gain, when one writes
  non-expandable algorithms using \xintexprname. If |\xintthe| is
  employed inside |\edef| the number or fraction will be un-locked into
  its possibly hundreds of digits and all these tokens will possibly
  weigh on the upcoming shuffling of (braced) tokens. The private
  encapsulated format has only a few tokens, hence expansion will
  proceed a bit faster.

  \indent see footnote\footnotemark
\end{framed}

\footnotetext{To be completely honest the examination by \TeX{} of all
  successive digits was not avoided, as it occurs already in the
  locking-up of the result, what is avoided is to spend time un-locking,
  and then have the macros shuffle around possibly hundreds of digit
  tokens rather than a few control words.}

Our |\Fibonacci| expands completely under \fexpan sion,
so we can use \hyperref[fdef]{\ttfamily\char92fdef} rather than |\edef| in a
situation such as %
\leftedline {|\fdef \X {\FibonacciN {100}}|} but for the
reasons explained above, it is as efficient to employ |\edef|. And if we want
%
\leftedline{|\edef \Y {(\FibonacciN{100},\FibonacciN{200})}|,} then |\edef| is
necessary.

Allright, so let's now give the code to generate a sequence of braced Fibonacci
numbers |{F(N)}{F(N+1)}{F(N+2)}...|, using |\Fibonacci| for the first
two and then using the standard recursion |F(N+2)=F(N+1)+F(N)|:

\catcode`_ 11
\def\FibonacciSeq #1#2{%#1=starting index, #2>#1=ending index
    \expandafter\Fibonacci_Seq\expandafter
    {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #2-1}%
}%
\def\Fibonacci_Seq #1#2{%
     \expandafter\Fibonacci_Seq_loop\expandafter
                {\the\numexpr #1\expandafter}\romannumeral0\Fibonacci {#1}{#2}%
}%
\def\Fibonacci_Seq_loop #1#2#3#4{% standard Fibonacci recursion
    {#3}\unless\ifnum #1<#4  \Fibonacci_Seq_end\fi
        \expandafter\Fibonacci_Seq_loop\expandafter
        {\the\numexpr #1+1\expandafter}\expandafter
        {\romannumeral0\xintiieval #2+#3\relax}{#2}{#4}%
}%
\def\Fibonacci_Seq_end\fi\expandafter\Fibonacci_Seq_loop\expandafter
    #1\expandafter #2#3#4{\fi {#3}}%
\catcode`_ 8

\begingroup\footnotesize\baselineskip10pt
\everb|@
\catcode`_ 11
\def\FibonacciSeq #1#2{%#1=starting index, #2>#1=ending index
    \expandafter\Fibonacci_Seq\expandafter
    {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #2-1}%
}%
\def\Fibonacci_Seq #1#2{%
     \expandafter\Fibonacci_Seq_loop\expandafter
                {\the\numexpr #1\expandafter}\romannumeral0\Fibonacci {#1}{#2}%
}%
\def\Fibonacci_Seq_loop #1#2#3#4{% standard Fibonacci recursion
    {#3}\unless\ifnum #1<#4  \Fibonacci_Seq_end\fi
        \expandafter\Fibonacci_Seq_loop\expandafter
        {\the\numexpr #1+1\expandafter}\expandafter
        {\romannumeral0\xintiieval #2+#3\relax}{#2}{#4}%
}%
\def\Fibonacci_Seq_end\fi\expandafter\Fibonacci_Seq_loop\expandafter
    #1\expandafter #2#3#4{\fi {#3}}%
\catcode`_ 8
|
\endgroup

Deliberately and for optimization, this |\FibonacciSeq| macro is
completely expandable but not \fexpan dable. It would be easy to modify
it to be so. But I wanted to check that the \csbxint{For*} does apply
full expansion to what comes next each time it fetches an item from its
list argument. Thus, there is no need to generate lists of braced
Fibonacci numbers beforehand, as \csbxint{For*}, without using any
|\edef|, still manages to generate the list via iterated full expansion.

I initially used only one |\halign| in a three-column |multicols|
environment, but |multicols| only knows to divide the page horizontally
evenly, thus I employed in the end one |\halign| for each column (I
could have then used a |tabular| as no column break was then needed).

\begin{figure*}[ht!]
  \phantomsection\label{fibonacci}
  \newcounter{index}
  \fdef\Fibxxx{\FibonacciN {30}}%
  \setcounter{index}{30}%
\centeredline{\tabskip 1ex
\vbox{\halign{\bfseries#.\hfil&#\hfil &\hfil #\cr
  \xintFor* #1 in {\FibonacciSeq {30}{59}}\do
  {\theindex &\xintthe#1 &
    \xintiRem{\xintthe#1}{\xintthe\Fibxxx}\stepcounter{index}\cr }}%
}\vrule
\vbox{\halign{\bfseries#.\hfil&#\hfil &\hfil #\cr
  \xintFor* #1 in {\FibonacciSeq {60}{89}}\do
  {\theindex &\xintthe#1 &
    \xintiRem{\xintthe#1}{\xintthe\Fibxxx}\stepcounter{index}\cr }}%
}\vrule
\vbox{\halign{\bfseries#.\hfil&#\hfil &\hfil #\cr
  \xintFor* #1 in {\FibonacciSeq {90}{119}}\do
  {\theindex &\xintthe#1 &
   \xintiRem{\xintthe#1}{\xintthe\Fibxxx}\stepcounter{index}\cr }}%
}}%
%
\centeredline{Some Fibonacci numbers together with their residues modulo
  |F(30)|\dtt{=\xintthe\Fibxxx}}
\end{figure*}

\begingroup\footnotesize\baselineskip10pt
\everb|@
\newcounter{index}
\tabskip 1ex
  \fdef\Fibxxx{\FibonacciN {30}}%
  \setcounter{index}{30}%
\vbox{\halign{\bfseries#.\hfil&#\hfil &\hfil #\cr
  \xintFor* #1 in {\FibonacciSeq {30}{59}}\do
  {\theindex &\xintthe#1 &
    \xintiRem{\xintthe#1}{\xintthe\Fibxxx}\stepcounter{index}\cr }}%
}\vrule
\vbox{\halign{\bfseries#.\hfil&#\hfil &\hfil #\cr
  \xintFor* #1 in {\FibonacciSeq {60}{89}}\do
  {\theindex &\xintthe#1 &
    \xintiRem{\xintthe#1}{\xintthe\Fibxxx}\stepcounter{index}\cr }}%
}\vrule
\vbox{\halign{\bfseries#.\hfil&#\hfil &\hfil #\cr
  \xintFor* #1 in {\FibonacciSeq {90}{119}}\do
  {\theindex &\xintthe#1 &
   \xintiRem{\xintthe#1}{\xintthe\Fibxxx}\stepcounter{index}\cr }}%
}%
|
\endgroup

This produces the Fibonacci numbers from |F(30)| to |F(119)|, and
computes also  all the
congruence classes modulo |F(30)|.  The output has
been put in a \hyperref[fibonacci]{float}, which appears
\vpageref[above]{fibonacci}. I leave to the mathematically inclined
readers the task to explain the visible patterns\dots |;-)|.

\subsection{\csbh{xintForpair}, \csbh{xintForthree}, \csbh{xintForfour}}\label{xintForpair}\label{xintForthree}\label{xintForfour}
% {\small New in |1.09c|. The \csa{xintifForFirst}
%   |1.09e| mechanism was missing and has been added for |1.09f|. The |1.09f|
%   version handles better spaces and admits all (consecutive) macro
%   parameters.\par}

The syntax\ntype{on} is illustrated in this
example. The notation is the usual one for |n|-uples, with parentheses and
commas. Spaces around commas and parentheses are ignored.
%
\begin{everbatim*}
{\centering\begin{tabular}{cccc}
    \xintForpair #1#2 in { ( A , a ) , ( B , b ) , ( C , c ) } \do {%
      \xintForpair #3#4 in { ( X , x ) , ( Y , y ) , ( Z , z ) } \do {%
        $\Biggl($\begin{tabular}{cc}
          -#1- & -#3-\\
          -#4- & -#2-\\
        \end{tabular}$\Biggr)$&}\\\noalign{\vskip1\jot}}%
\end{tabular}\\}
\end{everbatim*}

Only |#1#2|, |#2#3|, |#3#4|, \dots, |#8#9| are valid (no error check
is done on the input syntax, |#1#3| or similar all end up in errors).
One can nest with \csbxint{For}, for disjoint sets of macro parameters. There is
also \csa{xintForthree} (from |#1#2#3| to |#7#8#9|) and \csa{xintForfour} (from
|#1#2#3#4| to |#6#7#8#9|). |\par| tokens are accepted in both the comma
separated list and the replacement text.

% These three macros |\xintForpair|, |\xintForthree| and |\xintForfour| are to
% be considered in experimental status, and may be removed, replaced or
% substantially modified at some later stage.

\subsection{\csbh{xintAssign}}\label{xintAssign}
%\small{ |1.09i| adds optional parameter. |1.09j| has default optional
% parameter |[]| rather than |[e]|\par}

\csa{xintAssign}\meta{braced things}\csa{to}%
\meta{as many cs as they are things} %\ntype{{(f$\to$\lowast [x)}{\lowast N}}
%
defines (without checking if something gets overwritten) the control sequences
on the right of \csa{to} to expand to the successive tokens or braced items
found one after the other on the left of \csa{to}. It is not expandable.

A `full' expansion is first applied to the material in front of
\csa{xintAssign}, which may thus be a macro expanding to a list of braced items.

\xintAssign \xintiiPow {7}{13}\to\SevenToThePowerThirteen
\xintAssign \xintiiDivision{1000000000000}{133333333}\to\Q\R

Special case: if after this initial expansion no brace is found immediately
after \csa{xintAssign}, it is assumed that there is only one control sequence
following |\to|, and this control sequence is then defined via
|\def| to expand to the material between
\csa{xintAssign} and \csa{to}. Other types of expansions are specified through
an optional parameter to \csa{xintAssign}, see \emph{infra}.
%
\leftedline{|\xintAssign \xintiiDivision{1000000000000}{133333333}\to\Q\R|}
%
\leftedline{|\meaning\Q: |\dtt{\meaning\Q}, |\meaning\R:|
  \dtt{\meaning\R}} %
%
\leftedline{|\xintAssign \xintiiPow
  {7}{13}\to\SevenToThePowerThirteen|}
%
\leftedline{|\SevenToThePowerThirteen|\dtt{=\SevenToThePowerThirteen}}
%
\leftedline{(same as |\edef\SevenToThePowerThirteen{\xintiPow {7}{13}}|)}

\noindent\csa{xintAssign} admits since |1.09i| an
optional parameter, for example |\xintAssign [e]...| or |\xintAssign [oo]
...|. With |[f]| for example the definitions of the macros initially on the
right of |\to| will be made with \hyperref[fdef]{\ttfamily\char92fdef} which
\fexpan ds the replacement text. The default is simply to make the
definitions with |\def|, corresponding to an empty optional paramter |[]|.
Possibilities: |[], [g], [e], [x], [o], [go], [oo], [goo], [f], [gf]|.

In all cases, recall that |\xintAssign| starts with an \fexpan sion of what
comes next; this produces some list of tokens or braced items, and the
optional parameter only intervenes to decide the expansion type to be applied
then to each one of these items.

\emph{Note:} prior to release |1.09j|, |\xintAssign| did an |\edef| by
default, but it now does |\def|. Use the optional parameter |[e]| to force use
of |\edef|.

{\small \emph{Remark:} since |xinttools 1.1c|, \csa{xintAssign} is less picky
  and a stray space right before the |\to| causes no surprises, and the
  successive braced items may be separated by spaces, which will get
  discarded. In case the contents up to |\to| did not start with a brace a
  single macro is defined and it will contain the spaces. Contrarily to the
  earlier version, there is no problem if such contents do contain braces
  after the first non-brace token.
\par
}

%  This
% macro uses various \csa{edef}'s, thus is incompatible with expansion-only
% contexts.

\subsection{\csbh{xintAssignArray}}\label{xintAssignArray}
% {\small Changed in release |1.06| to let the defined macro pass its
%   argument through a |\numexpr...\relax|. |1.09i| adds optional
%   parameter. \par}

\xintAssignArray \xintBezout {1000}{113}\to\Bez

\csa{xintAssignArray}\meta{braced
  things}\csa{to}\csa{myArray} %\ntype{{(f$\to$\lowast x)}N}
%
first expands fully what comes immediately after |\xintAssignArray| and
expects to find a list of braced things |{A}{B}...| (or tokens). It then
defines \csa{myArray} as a macro with one parameter, such that \csa{myArray\x}
expands to give the |x|th braced thing of this original
list (the argument \texttt{\x} itself is fed to a |\numexpr| by |\myArray|,
and |\myArray| expands in two steps to its output). With |0| as parameter,
\csa{myArray}|{0}| returns the number |M| of elements of the array so that the
successive elements are \csa{myArray}|{1}|, \dots, \csa{myArray}|{M}|.
%
\leftedline{|\xintAssignArray \xintBezout {1000}{113}\to\Bez|} will set
|\Bez{0}| to \dtt{\Bez0}, |\Bez{1}| to \dtt{\Bez1}, |\Bez{2}| to
\dtt{\Bez2}, |\Bez{3}| to \dtt{\Bez3}, |\Bez{4}| to
\dtt{\Bez4}, and |\Bez{5}| to \dtt{\Bez5}:
\dtt{(\Bez3)${}\times{}$\Bez1${}-{}$(\Bez4)${}\times{}$\Bez2${}={}$\Bez5.}
This macro is incompatible with expansion-only contexts.

\csa{xintAssignArray} admits now an optional
parameter, for example |\xintAssignArray [e]...|. This means that the
definitions of the macros will be made with |\edef|. The default is
|[]|, which makes the definitions with |\def|. Other possibilities: |[],
[o], [oo], [f]|. Contrarily to \csbxint{Assign} one can not use the |g|
here to make the definitions global. For this, one should rather do
|\xintAssignArray| within a group starting with |\globaldefs 1|.

Note that prior to release |1.09j| each item (token or braced material) was
submitted to an |\edef|, but the default is now to use |\def|.

\subsection{\csbh{xintDigitsOf}}\label{xintDigitsOf}

This is a synonym for \csbxint{AssignArray},\ntype{fN} to be used to define
an array giving all the digits of a given (positive, else the minus sign will
be treated as first item) number.
\begingroup\xintDigitsOf\xintiPow {7}{500}\to\digits
%
\leftedline{|\xintDigitsOf\xintiPow {7}{500}\to\digits|}
\noindent $7^{500}$ has |\digits{0}=|\digits{0} digits, and the 123rd among them
(starting from the most significant) is
|\digits{123}=|\digits{123}.
\endgroup

\subsection{\csbh{xintRelaxArray}}\label{xintRelaxArray}

\csa{xintRelaxArray}\csa{myArray} %\ntype{N}
%
(globally) sets to \csa{relax} all macros which were defined by the previous
\csa{xintAssignArray} with \csa{myArray} as array macro.


\subsection{The Quick Sort algorithm illustrated}\label{ssec:quicksort}

First a completely expandable macro which sorts a list of numbers. The |\QSfull|
macro expands its list argument, which may thus be a macro; its items must
expand to possibly big integers (or also decimal numbers or fractions if using
\xintfracname), but if an item is expressed as a computation, this computation
will be redone each time the item is considered! If the numbers have many digits
(i.e. hundreds of digits...), the expansion of |\QSfull| is fastest if each
number, rather than being explicitely given, is represented as a single token
which expands to it in one step.

If the interest is only in \TeX{} integers, then one should replace the macros
|\QSMore|, |QSEqual|, |QSLess| with versions using the
\href{http://ctan.org/pkg/etoolbox}{etoolbox} (\LaTeX{} only) |\ifnumgreater|,
|\ifnumequal| and |\ifnumless| conditionals rather than \csbxint{ifGt},
\csbxint{ifEq}, \csbxint{ifLt}.

%% \makeatletter\let\check@percent\relax lorsque je faisais avec verbatim 
%% ne pas changer la taille dans \MacroFont
%% \def\MacroFont{\ttbfamily \small }
%% anciennement avec \dverb, puis \everb
%% \everb|"makeatletter"@gobble

\begin{everbatim*}
% THE QUICK SORT ALGORITHM EXPANDABLY
% \usepackage{xintfrac} in the preamble (latex), or \input xintfrac.sty (Plain)
\catcode`@ 11 % = \makeatletter
\def\QSMore  #1#2{\xintifGt {#2}{#1}{{#2}}{ }}
% the spaces stop the \romannumeral-`0 done by \xintapplyunbraced each time
% it applies its macro argument to an item
\def\QSEqual #1#2{\xintifEq {#2}{#1}{{#2}}{ }}
\def\QSLess  #1#2{\xintifLt {#2}{#1}{{#2}}{ }}
%
\def\QSfull {\romannumeral0\qsfull }
\def\qsfull   #1{\expandafter\qsfull@a\expandafter{\romannumeral-`0#1}}
\def\qsfull@a #1{\expandafter\qsfull@b\expandafter {\xintLength {#1}}{#1}}
\def\qsfull@b #1{\ifcase #1
                    \expandafter\qsfull@empty
                 \or\expandafter\qsfull@single
                 \else\expandafter\qsfull@c
                 \fi }
\def\qsfull@empty  #1{ }% the space stops the \QSfull \romannumeral0
\def\qsfull@single #1{ #1}
\def\qsfull@c #1{\qsfull@ci #1\undef {#1}}% we pick up the first as Pivot
\def\qsfull@ci #1#2\undef {\qsfull@d {#1}}
\def\qsfull@d #1#2{\expandafter\qsfull@e\expandafter
                   {\romannumeral0\qsfull {\xintApplyUnbraced {\QSMore {#1}}{#2}}}%
                   {\romannumeral0\xintapplyunbraced {\QSEqual {#1}}{#2}}%
                   {\romannumeral0\qsfull {\xintApplyUnbraced {\QSLess {#1}}{#2}}}%
}
\def\qsfull@e #1#2#3{\expandafter\qsfull@f\expandafter {#2}{#3}{#1}}
\def\qsfull@f #1#2#3{\expandafter\space #2#1#3}
\catcode`@ 12 % = \makeatother
% EXAMPLE
\begingroup
\edef\z {\QSfull {{1.0}{0.5}{0.3}{1.5}{1.8}{2.0}{1.7}{0.4}{1.2}{1.4}%
               {1.3}{1.1}{0.7}{1.6}{0.6}{0.9}{0.8}{0.2}{0.1}{1.9}}}
\printnumber{\meaning\z}

\def\a {3.123456789123456789}\def\b {3.123456789123456788}
\def\c {3.123456789123456790}\def\d {3.123456789123456787}
\expandafter\def\expandafter\z\expandafter
  {\romannumeral0\qsfull {{\a}\b\c\d}}% \a is braced to not be expanded
\printnumber{\meaning\z}
\endgroup
\end{everbatim*}

We then turn to a graphical illustration of the algorithm. For simplicity the
pivot is always chosen to be the first list item. We also show later how to
illustrate the  variant which picks up the last item of each unsorted
chunk as pivot.

\begin{everbatim*}
% in LaTeX preamble:
% \usepackage{xintfrac}
% \usepackage{color}
% or, when using Plain TeX:
% \input xintfrac.sty
% \input color.tex
%
% Color definitions
\definecolor{LEFT}{RGB}{216,195,88}
\definecolor{RIGHT}{RGB}{208,231,153}
\definecolor{INERT}{RGB}{199,200,194}
\definecolor{PIVOT}{RGB}{109,8,57}
% Start of macro defintions
\catcode`@ 11 % = \makeatletter in latex
\def\QSMore  #1#2{\xintifGt {#2}{#1}{{#2}}{ }}% space will be gobbled
\def\QSEqual #1#2{\xintifEq {#2}{#1}{{#2}}{ }}
\def\QSLess  #1#2{\xintifLt {#2}{#1}{{#2}}{ }}
%
\def\QS@a  #1{\expandafter \QS@b \expandafter {\xintLength {#1}}{#1}}
\def\QS@b  #1{\ifcase #1
                      \expandafter\QS@empty
                   \or\expandafter\QS@single
                 \else\expandafter\QS@c
                 \fi }
\def\QS@empty  #1{}
\def\QS@single #1{\QSIr {#1}}
\def\QS@c #1{\QS@d #1!{#1}}    % we pick up the first as pivot.
\def\QS@d #1#2!{\QS@e {#1}}    % #1 = first element, #3 = list
\def\QS@e #1#2{\expandafter\QS@f\expandafter
                   {\romannumeral0\xintapplyunbraced {\QSMore  {#1}}{#2}}%
                   {\romannumeral0\xintapplyunbraced {\QSEqual {#1}}{#2}}%
                   {\romannumeral0\xintapplyunbraced {\QSLess  {#1}}{#2}}}
\def\QS@f #1#2#3{\expandafter\QS@g\expandafter {#2}{#3}{#1}}
% #2= elements < pivot, #1 = elements = pivot, #3 = elements > pivot
% Here \QSLr, \QSIr, \QSr have been let to \relax, so expansion stops.
\def\QS@g #1#2#3{\QSLr {#2}\QSIr {#1}\QSRr {#3}}
%
\def\DecoLEFT   #1{\xintFor* ##1 in {#1} \do {\colorbox{LEFT}{##1}}}
\def\DecoINERT  #1{\xintFor* ##1 in {#1} \do {\colorbox{INERT}{##1}}}
\def\DecoRIGHT  #1{\xintFor* ##1 in {#1} \do {\colorbox{RIGHT}{##1}}}
\def\DecoPivot  #1{\begingroup\color{PIVOT}\advance\fboxsep-\fboxrule\fbox{#1}\endgroup}
\def\DecoLEFTwithPivot #1{%
     \xintFor* ##1 in {#1} \do {\xintifForFirst {\DecoPivot {##1}}{\colorbox{LEFT}{##1}}}}
\def\DecoRIGHTwithPivot #1{%
     \xintFor* ##1 in {#1} \do {\xintifForFirst {\DecoPivot {##1}}{\colorbox{RIGHT}{##1}}}}
%
\def\QSinitialize #1{\def\QS@list{\QSRr {#1}}\let\QSRr\DecoRIGHT
                     \par\centerline{\QS@list}}
\def\QSoneStep {\let\QSLr\DecoLEFTwithPivot \let\QSIr\DecoINERT \let\QSRr\DecoRIGHTwithPivot
    \centerline{\QS@list}%
                \def\QSLr {\noexpand\QS@a}\let\QSIr\relax\def\QSRr {\noexpand\QS@a}%
                    \edef\QS@list{\QS@list}%
                \let\QSLr\relax\let\QSRr\relax
                    \edef\QS@list{\QS@list}%
                \let\QSLr\DecoLEFT \let\QSIr\DecoINERT \let\QSRr\DecoRIGHT
    \centerline{\QS@list}}
\catcode`@ 12 % = \makeatother in latex
%% End of macro definitions.
%% Start of Example
\hypertarget{quicksort}{}
\begingroup\offinterlineskip
\small
\QSinitialize {{1.0}{0.5}{0.3}{1.5}{1.8}{2.0}{1.7}{0.4}{1.2}{1.4}%
               {1.3}{1.1}{0.7}{1.6}{0.6}{0.9}{0.8}{0.2}{0.1}{1.9}}
\QSoneStep\QSoneStep\QSoneStep\QSoneStep\QSoneStep
\endgroup
\end{everbatim*}

% 2015/09/16
% BORDEL, c'tait ceci qui faisait un terrible color leak en dvipdfmx
% si plus haut dans le verbatim !
% EN FAIT C'EST LE \normalcolor QUI FOUTAIT LA MERDE.
% 
% % The next line is for xint.pdf use only. 
% \normalcolor\phantomsection\label{quicksort}
%
% De toute faon je remplace par un hypertarget

If one wants rather to have the pivot from the end of the yet to sort chunks,
then one should use the following variants:

% 2015/09/16
% ICI AUSSI IL Y AVAIT UN \normalcolor QUI PROVOQUAIT LE COLOR LEAK
% (dans le contexte de mes \special {pdf:color OrangeRed}

% (j'avais commenc par doubler les {...} mais au final j'ai retir car bon
%  sans).

\begin{everbatim*}
\makeatletter
\def\QS@c #1{\expandafter\QS@e\expandafter {\romannumeral0\xintnthelt {-1}{#1}}{#1}}
\def\DecoLEFTwithPivot #1{%
    \xintFor* ##1 in {#1} \do {\xintifForLast {\DecoPivot {##1}}{\colorbox{LEFT}{##1}}}}
\def\DecoRIGHTwithPivot #1{%
    \xintFor* ##1 in {#1} \do{\xintifForLast {\DecoPivot {##1}}{\colorbox{RIGHT}{##1}}}}
\def\QSinitialize #1{\def\QS@list{\QSLr {#1}}\let\QSLr\DecoLEFT\par\centerline{\QS@list}}
\makeatother
\begingroup\offinterlineskip
\small
\QSinitialize {{1.0}{0.5}{0.3}{1.5}{1.8}{2.0}{1.7}{0.4}{1.2}{1.4}%
               {1.3}{1.1}{0.7}{1.6}{0.6}{0.9}{0.8}{0.2}{0.1}{1.9}}
\QSoneStep\QSoneStep\QSoneStep\QSoneStep\QSoneStep
\QSoneStep\QSoneStep\QSoneStep\QSoneStep\QSoneStep
\endgroup
\end{everbatim*}

It is possible to modify this code to let it do \csa{QSonestep} repeatedly and
stop automatically when the sort is finished.%
%
\footnote{\url{http://tex.stackexchange.com/a/142634/4686}}

\section{Commands of the \xintcorename package}
\label{sec:core}

\localtableofcontents

Prior to release |1.1| the macros which are now included in the separate
package \xintcorename were part of \xintname. Package \xintcorename is
automatically loaded by \xintname.\IMPORTANT\

\xintcorename provides the five basic arithmetic operations on big integers:
addition, subtraction, multiplication, division and powers. Division may be
either rounded (\csbxint{iiDivRound}) (the rounding of |0.5| is |1| and the
one of |-0.5| is |-1|) or Euclidean (\csbxint{iiQuo}) (which for positive
operands is the same as truncated division), or truncated (\csbxint{iiDivTrunc}).

In the description of the macros the \texttt{\n} and \texttt{\m} symbols stand
for explicit (big) integers within braces or more generally any control
sequence (possibly within braces) \hyperref[ssec:expansions]{\fexpan ding} to
such a big integer.

The macros with a single |i| in their names parse their arguments
automatically through \hyperref[xintiNum]{\string\xintNum}. This type of
expansion applied to an argument is signaled by a
\textcolor[named]{PineGreen}{\Numf} in the margin. The accepted input format
is then a sequence of plus and minus signs, followed by some string of zeroes,
followed by digits. 

If \xintfracname additionally to \xintcorename is loaded, \csbxint{Num}
becomes a synonym to \csbxint{TTrunc}; this means that
arbitrary fractions will be accepted as arguments of the
macros with a single |i| in their names, but get truncated to integers before
further processing. The format of the output will be as with only \xintname
loaded. The only extension is in allowing a wider variety of inputs.

The macros with |ii| in their names have arguments which will only be \fexpan
ded, but will not be parsed via \hyperref[xintiNum]{\string\xintNum}.
Arguments of this type are signaled by the margin annotation
\textcolor[named]{PineGreen}{\emph{f}}. For such big integers only one minus
sign and no plus sign, nor leading zeros, are accepted. |-0| is not valid in
this strict input format. Loading \xintfracname does not bring any
modification to these macros whether for input or output.

The letter \texttt{x} (with margin annotation
\textcolor[named]{PineGreen}{\numx}) stands for something which will be
inserted in-between a |\numexpr| and a |\relax|. It will thus be completely
expanded and must give an integer obeying the \TeX{} bounds. Thus, it may be
for example a count register, or itself a \csa{numexpr} expression, or just a
number written explicitely with digits or something like |4*\count 255 + 17|,
etc...

For the rules regarding direct use of count registers or \csa{numexpr}
expression, in the arguments to the package macros, see the
\hyperref[sec:useofcount]{Use of count} section.

\begin{framed}
  Earlier releases of \xintcorename also provided macros |\xintAdd|,
  |\xintMul|,\dots as synonyms to |\xintiAdd|, |\xintiMul|,\dots, destined to
  be re-defined by \xintfracname.\IMPORTANT{} It was announced some time ago
  that their usage was deprecated, because the output formats depended on
  whether \xintfracname was loaded or not. They now have been \fbox{removed.}
  \MyMarginNote[\kern\dimexpr\FrameSep+\FrameRule\relax]{Changed}

  % Due to this variability of the output format on whether the document uses
  % only \xintname or loads additionally \xintfracname, code using these macros
  % is fragile, because loading at some later date a package which itself loads
  % \xintfracname or \xintexprname will modify their output format, and this is
  % catastrophic for example in locations expanded by |\ifnum|, or even in
  % arguments to those other macros of \xintname with |ii| in their names.

  The macros \csbxint{iAdd}, \csbxint{iMul}, \dots, or \csbxint{iiAdd},
  \csbxint{iiMul}, \dots which come with \xintcorename are guaranteed to
  always output an integer without a trailing |/B[n]|. The latter have the
  lesser overhead, and the former do not complain, if \xintfracname is loaded,
  even if used with true fractions, as they will then truncate their arguments
  to integers. But their output format remains unmodified: integers with no
  fraction slash nor |[N]| thingy.
  % It was an error for the \xintname package (now \xintcorename) to provide
  % macros |\xintAdd|, |\xintMul|, |\xintSub| \dots. They should be used only
  % with \xintfracname loaded.
\end{framed}

The {\color[named]{PineGreen}$\star$}'s in the margin are there to remind of
the complete expandability, even \fexpan dability of the macros, as discussed
in \autoref{ssec:expansions}.


\subsection{\csbh{xintNum}, \csbh{xintiNum}}\label{xintiNum}

|\xintNum|\n\etype{f} removes chains of plus or minus signs, followed by
zeroes. %
%
\leftedline{|\xintNum{+---++----+--000000000367941789479}|\dtt
 {=\xintNum{+---++----+--000000000367941789479}}} 

All \xintname macros with a single |i| in their names, such as \csbxint{iAdd},
\csbxint{iMul} apply \csbxint{Num} to their arguments.

When \xintfracname is loaded, \csbxint{Num} becomes a synonym to
\csbxint{TTrunc}. And \csbxint{iNum} preserved the original integer only
meaning.

\subsection{\csbh{xintSgn}, \csbh{xintiiSgn}}\label{xintiiSgn}

|\xintiiSgn|\n\etype{f} returns 1 if the number is positive, 0 if it is zero
and -1 if it is negative. It skips the \csbxint{Num} overhead.

\csbxint{Sgn}\etype{\Numf} is the variant using \csbxint{Num} and getting
extended by \xintfracname to fractions.

\subsection{\csbh{xintiOpp}, \csbh{xintiiOpp}}\label{xintiOpp}\label{xintiiOpp}

|\xintiOpp|\n\etype{\Numf} return the opposite |-N| of the number |N|.
\csa{xintiiOpp} is the strict integer-only variant which skips
the \csbxint{Num} overhead.\etype{f}

\subsection{\csbh{xintiAbs}, \csbh{xintiiAbs}}\label{xintiAbs}\label{xintiiAbs}

|\xintiAbs|\n\etype{\Numf} returns the absolute value of the number.
\csa{xintiiAbs}
skips the \csbxint{Num} overhead.\etype{f}

\subsection{\csbh{xintiiFDg}}\label{xintFDg}\label{xintiiFDg}

|\xintiiFDg|\n\etype{f} returns the first digit (most significant) of the
decimal expansion. It skips the overhead of parsing via \csbxint{Num}. The
variant \csa{xintFDg}\etype{\Numf} uses |\xintNum| and gets extended by
\xintfracname. 

\subsection{\csbh{xintiiLDg}}\label{xintLDg}\label{xintiiLDg}

|\xintiiLDg|\n\etype{f} returns the least significant digit. When the number
is positive, this is the same as the remainder in the euclidean division by
ten. It skips the overhead of parsing via \csbxint{Num}. The variant
\csa{xintLDg}\etype{\Numf} uses |\xintNum| and gets extended by \xintfracname.

\subsection{\csbh{xintDouble}, \csbh{xintHalf}}
\label{xintDouble}
\label{xintHalf}
%{\small New with |1.08|.\par}

|\xintDouble|\n\etype{f} returns |2N| and |\xintHalf|\n is |N/2| rounded
towards zero. These macros remain integer-only, even with \xintfracname loaded.

\subsection{\csbh{xintInc}, \csbh{xintDec}}
\label{xintInc}
\label{xintDec}
%{\small New with |1.08|.\par}

|\xintInc|\n\etype{f} is |N+1| and |\xintDec|\n{} is |N-1|. These macros
remain integer-only, even with \xintfracname loaded. They skip the overhead
of parsing via \csbxint{Num}.

\subsection{\csbh{xintiAdd}, \csbh{xintiiAdd}}\label{xintiAdd}\label{xintiiAdd}

|\xintiAdd|\n\m\etype{\Numf\Numf} returns the sum of the two numbers.
\csa{xintiiAdd} skips the \csbxint{Num} overhead.\etype{ff}

\subsection{\csbh{xintiSub}, \csbh{xintiiSub}}\label{xintiSub}\label{xintiiSub}

|\xintiSub|\n\m\etype{\Numf\Numf} returns the difference |N-M|.
\csa{xintiiSub} skips the \csbxint{Num} overhead.\etype{ff}

\subsection{\csbh{xintiMul}, \csbh{xintiiMul}}\label{xintiMul}\label{xintiiMul}
%{\small Modified in release |1.03|.\par}

|\xintiMul|\n\m\etype{\Numf\Numf} returns the product of the two numbers.
\csa{xintiiMul} skips the \csbxint{Num} overhead.\etype{ff}

\subsection{\csbh{xintiSqr}, \csbh{xintiiSqr}}\label{xintiSqr}\label{xintiiSqr}

|\xintiSqr|\n\etype{\Numf} returns the square. \csa{xintiiSqr} skips the
\csbxint{Num} overhead.\etype{f}

\subsection{\csbh{xintiPow}, \csbh{xintiiPow}}\label{xintiPow}\label{xintiiPow}

|\xintiPow|\n\x\etype{\Numf\numx} returns |N^x|. When |x| is zero, this is 1.
If |N=0| and |x<0|, if \verb+|N|>1+ and |x<0|, an error is raised. There will
also be an error naturally if |x| exceeds the maximal \eTeX{} number
\dtt{\number"7FFFFFFF}, but the real limit for huge exponents comes from
either the computation time or the settings of some tex memory parameters.

\begin{framed}
  Indeed, the maximal power of $2$ which \xintname is able to compute
  explicitely is |2^(2^17)=2^131072| which has \dtt{39457} digits. This
  exceeds the maximal size on input for the \xintcorename multiplication, hence
  any |2^N| with a higher |N| will fail. On the other hand |2^(2^16)| has
  \dtt{19729} digits, thus it can be squared once to obtain |2^(2^17)| or
  multiplied by anything smaller, thus all exponents up to and including |2^17|
  are allowed (because the power operation works by squaring things and making
  products).
\end{framed}

Side remark: after all it does pay to think! I almost melted my CPU trying by
dichotomy to pin-point the exact maximal allowable |N| for |\xintiiPow 2{N}|
before finally making the reasoning above. Indeed, each such computation with
|N>130000| activates the fan of my laptop and results in so warm a keyboard
that I can hardly go on working on it! And it takes about 12 minutes for each
|\xintiiPow2{N}| with such |N|'s of the order of $130000$ (a.t.t.o.w.).

\csa{xintiiPow} is an integer only variant skipping the \csbxint{Num}
overhead\etype{f\numx}, it produces the same result as \csa{xintiPow} with
stricter assumptions on the inputs, and is thus a tiny bit faster.

\xintfracname also provides the floating variants \csbxint{FloatPow} (for
which the exponent must still obey the \TeX{} bound) and \csbxint{FloatPower}
(which has no restriction at all on the size of the exponent). Negative
exponents do not then raise errors anymore. The float version is able to deal
with things such as |2^999999999| without any problem.
\begin{everbatim*}
$\xintFloatPow[32]{2}{50000}<\xintFloatPow[32]{2}{999999999}$
\end{everbatim*}%
and both are computed swiftly!
% je ne sais plus ce qu'tait cette note de bas de page
%\footnote{see however \autoref{fn:floatpow}.}

Within an \csbxint{iiexpr}|..\relax| the infix operator |^| is mapped to
\csa{xintiiPow}; within an \csbxint{expr}-ession it is mapped to \csbxint{Pow}
(as extended by \xintfracname); in \csbxint{floatexpr}, it is mapped to
\csbxint{FloatPower}.

\subsection{\csbh{xintiDivision},
  \csbh{xintiiDivision}}\label{xintiDivision}\label{xintiiDivision}

% 17 octobre 2014: je supprime \xintDivision, seulement \xintiDivision.

|\xintiiDivision|\n\m\etype{ff} returns |{quotient Q}{remainder R}|. This is
euclidean division: |N = QM + R|, |0|${}\leq{}$\verb+R < |M|+. So the
remainder is always non-negative and the formula |N = QM + R| always holds
independently of the signs of |N| or |M|. Division by zero is an error (even
if |N| vanishes) and returns |{0}{0}|. It skips the overhead of parsing via
\csbxint{Num}.

|\xintiDivision|\etype{\Numf\Numf} submits its arguments to \csbxint{Num} and
is extended by \xintfracname to accept fractions on input, which it truncates
first, and is not to be confused with the \xintfracname macro \csbxint{Div}
which divides one fraction by another.

\subsection{\csbh{xintiQuo}, \csbh{xintiiQuo}}\label{xintiQuo}\label{xintiiQuo}

|\xintiiQuo|\n\m\etype{ff} returns the quotient from the euclidean division.
It skips the overhead of parsing via \csbxint{Num}. 

|\xintiQuo|\etype{\Numf\Numf}  submits its arguments to \csbxint{Num} and
is extended by \xintfracname to accept fractions on input, which it truncates
first.

Note: |\xintQuo| is the former name of |\xintiQuo|. Its use is deprecated.


\subsection{\csbh{xintiRem}, \csbh{xintiiRem}}\label{xintiRem}\label{xintiiRem}

|\xintiiRem|\n\m\etype{ff} returns the remainder from the euclidean
division. It skips the overhead of parsing via \csbxint{Num}.

|\xintiRem|\etype{\Numf\Numf}  submits its arguments to \csbxint{Num} and
is extended by \xintfracname to accept fractions on input, which it truncates
first.

Note: |\xintRem| is the former name of |\xintiRem|. Its use is deprecated.


\subsection{\csbh{xintiDivRound}, \csbh{xintiiDivRound}}
\label{xintiDivRound}\label{xintiiDivRound}

|\xintiiDivRound|\n\m\etype{ff} returns the rounded value of the algebraic
quotient $N/M$ of two big integers. The rounding of half integers is towards
the nearest integer of bigger absolute value. The macro skips the overhead of
parsing via \csbxint{Num}. The rounding is away from zero.
% si seulement j'avais mis ceci j'aurais vit l'incident stupide avec 1.2c
% qui avait cass \xintiiDivRound. Pas le temps maintenant de rajouter des
% exemples  toutes les macros.
\begin{everbatim*}
\xintiiDivRound {100}{3}, \xintiiDivRound {101}{3}
\end{everbatim*}

|\xintiDivRound|\etype{\Numf\Numf} submits its arguments to \csbxint{Num}. It
is extended by \xintfracname to accept fractions on input, which it truncates
first before computing the rounded quotient.

\subsection{\csbh{xintiDivTrunc}, \csbh{xintiiDivTrunc}}
\label{xintiDivTrunc}\label{xintiiDivTrunc}

|\xintiiDivTrunc|\n\m\etype{ff} computes the truncation towards zero of the
algebraic quotient $N/M$. It skips the overhead of parsing the operands with
\csbxint{Num}. For $M>0$ it is the same as \csbxint{iiQuo}.
\begin{everbatim*}
$\xintiiQuo {1000}{-57}, \xintiiDivRound {1000}{-57}, \xintiiDivTrunc {1000}{-57}$
\end{everbatim*}

|\xintiDivTrunc|\etype{\Numf\Numf} submits first its arguments to \csbxint{Num}.

\subsection{\csbh{xintiMod}, \csbh{xintiiMod}}
\label{xintiMod}\label{xintiiMod}

|\xintiiMod|\n\m\etype{ff} computes $N - M*t(N/M)$, where $t(N/M)$ is the
algebraic quotient truncated towards zero . The macro skips the overhead of parsing
the operands with \csbxint{Num}. For $M>0$ it is the same as \csbxint{iiRem}.
\begin{everbatim*}
$\xintiiRem {1000}{-57}, \xintiiMod {1000}{-57}, 
 \xintiiRem {-1000}{57}, \xintiiMod {-1000}{57}$
\end{everbatim*}

|\xintiMod|\etype{\Numf\Numf} submits first its arguments to \csbxint{Num}.

\section{Commands of the \xintname package}
\label{sec:xint}

\localtableofcontents

Version |1.0| was released |2013/03/28|. This is \texttt{\xintbndlversion} of
\texttt{\xintbndldate}. The core arithmetic macros have been
moved to separate package \xintcorename, which is
automatically loaded by \xintname. 

See the documentation of \xintcorename or \autoref{ssec:expansions} for the
significance of the \textcolor[named]{PineGreen}{\Numf},
\textcolor[named]{PineGreen}{\emph{f}}, \textcolor[named]{PineGreen}{\numx}
and \textcolor[named]{PineGreen}{$\star$} margin annotations and some
important background information.

\subsection{\csbh{xintReverseDigits}} \label{xintReverseDigits}

|\xintReverseDigits|\n\etype{f} will reverse the order of the digits of the
number, preserving an optional upfront minus sign. \csa{xintRev} is the former
denomination and is kept as an alias to it. Leading zeroes resulting from the
operation are not removed. Contrarily to \csbxint{ReverseOrder} this macro can
only be used with digits and it first expands its argument (but beware that
|-\x| will give an unexpected result as the minus sign immediately stops this
expansion; one can use |\xintiiOpp{\x}| as argument.)

This command has been rewritten for |1.2| and is faster for very long inputs.
It is (almost) not used internally by the \xintcorename code, but the use
of related routines explains to some extent the higher speed of release |1.2|.

\begingroup
\begin{everbatim*}
\fdef\x{\xintReverseDigits
  {-98765432109876543210987654321098765432109876543210}}\meaning\x\par
\noindent\fdef\x{\xintReverseDigits {\xintReverseDigits 
  {-98765432109876543210987654321098765432109876543210}}}\meaning\x\par
\end{everbatim*}
\endgroup

Notice that the output in this case with its leading zero is not in the strict
integer format expected by the `|ii|' arithmetic macros.

\subsection{\csbh{xintLen}}\label{xintiLen}

|\xintLen|\n\etype{\Numf} returns the length of the number, not counting the
sign. %
%
\leftedline{|\xintLen{-12345678901234567890123456789}|\dtt
 {=\xintLen{-12345678901234567890123456789}}} Extended by \xintfracname to
fractions: the length of |A/B[n]| is the length of |A| plus the
length of |B| plus the absolute value of |n| and minus one (an integer input as
|N| is internally represented in a form equivalent to |N/1[0]| so the minus one
means that the extended \csa{xintLen} behaves the same as the original for
integers). %
%
\leftedline{|\xintLen{-1e3/5.425}|\dtt
 {=\xintLen{-1e3/5.425}}} The length is computed on the |A/B[n]| which would
have been returned by \csbxint{Raw}: |\xintRaw {-1e3/5.425}|\dtt{=\xintRaw
  {-1e3/5.425}}.

Let's point out that the whole thing should sum up to
less than circa $2^{31}$, but this is a bit theoretical.

|\xintLen| is only for numbers or fractions. See also \csbxint{NthElt} from
\xinttoolsname. See also \csbxint{Length} from \xintkernelname for counting
tokens (or rather braced groups), more generally.

\subsection{\csbh{xintCmp}, \csbh{xintiiCmp}}

|\xintCmp|\n\m\etype{\Numf\Numf} returns \dtt{1} if |N>M|, \dtt{0} if |N=M|,
and \dtt{-1} if |N<M|. Extended by \xintfracname to fractions (its output
naturally still being either |1|, |0|, or |-1|).

\csa{xintiiCmp} skips the \csbxint{Num} overhead.\etype{ff}

\subsection{\csbh{xintEq}, \csbh{xintiiEq}}\label{xintEq}
%{\small New with release |1.09a|.\par}

|\xintEq|\n\m\etype{\Numf\Numf} returns 1 if |N=M|, 0 otherwise. Extended
by \xintfracname to fractions.

\csa{xintiiEq} skips the \csbxint{Num} overhead.\etype{ff}

\subsection{\csbh{xintNeq}, \csbh{xintiiNeq}}
%{\small New with release |1.09a|.\par}

|\xintNeq|\n\m\etype{\Numf\Numf} returns 0 if |N=M|, 1 otherwise. Extended
by \xintfracname to fractions.

\csa{xintiiNeq} skips the \csbxint{Num} overhead.\etype{ff}

\subsection{\csbh{xintGt}, \csbh{xintiiGt}}\label{xintGt}
%{\small New with release |1.09a|.\par}

|\xintGt|\n\m\etype{\Numf\Numf} returns 1 if |N|$>$|M|, 0 otherwise.
Extended by \xintfracname to fractions.

\csa{xintiiGt} skips the \csbxint{Num} overhead.\etype{ff}

\subsection{\csbh{xintLt}, \csbh{xintiiLt}}\label{xintLt}
%{\small New with release |1.09a|.\par}

|\xintLt|\n\m\etype{\Numf\Numf} returns 1 if |N|$<$|M|, 0 otherwise.
Extended by \xintfracname to fractions.

\csa{xintiiLt} skips the \csbxint{Num} overhead.\etype{ff}

\subsection{\csbh{xintLtorEq}, \csbh{xintiiLtorEq}}

|\xintLtorEq|\n\m\etype{\Numf\Numf} returns 1 if |N|$\leqslant$|M|, 0 otherwise.
Extended by \xintfracname to fractions.

\csa{xintiiLtorEq} skips the \csbxint{Num} overhead.\etype{ff}

\subsection{\csbh{xintGtorEq}, \csbh{xintiiGtorEq}}

|\xintGtorEq|\n\m\etype{\Numf\Numf} returns 1 if |N|$\geqslant$|M|, 0 otherwise.
Extended by \xintfracname to fractions.

\csa{xintiiGtorEq} skips the \csbxint{Num} overhead.\etype{ff}

\subsection{\csbh{xintIsZero}, \csbh{xintiiIsZero}}\label{xintIsZero}
%{\small New with release |1.09a|.\par}

|\xintIsZero|\n\etype{\Numf} returns 1 if |N=0|, 0 otherwise.
Extended by \xintfracname to fractions.

\csa{xintiiIsZero} skips the \csbxint{Num} overhead.\etype{f}

\subsection{\csbh{xintNot}}\label{xintNot}
%{\small New with release |1.09c|.\par}

\csa{xintNot}\etype{\Numf} is a synonym for \csa{xintIsZero}.

\subsection{\csbh{xintIsNotZero}, \csbh{xintiiIsNotZero}}\label{xintIsNotZero}
%{\small New with release |1.09a|.\par}

|\xintIsNotZero|\n\etype{\Numf} returns 1 if |N<>0|, 0 otherwise.
Extended by \xintfracname to fractions.

\csa{xintiiIsNotZero} skips the \csbxint{Num} overhead.\etype{f}

\subsection{\csbh{xintIsOne},
  \csbh{xintiiIsOne}}\label{xintIsOne}\label{xintiiIsOne} 
%{\small New with release |1.09a|.\par}

|\xintIsOne|\n\etype{\Numf} returns 1 if |N=1|, 0 otherwise.
Extended by \xintfracname to fractions.

\csa{xintiiIsOne} skips the \csbxint{Num} overhead.\etype{f}

\subsection{\csbh{xintAND}}\label{xintAND}
%{\small New with release |1.09a|.\par}

|\xintAND|\n\m\etype{\Numf\Numf} returns 1 if |N<>0| and |M<>0| and zero
otherwise. Extended by \xintfracname to fractions.

\subsection{\csbh{xintOR}}\label{xintOR}
%{\small New with release |1.09a|.\par}

|\xintOR|\n\m\etype{\Numf\Numf} returns 1 if |N<>0| or |M<>0| and zero
otherwise. Extended by \xintfracname to fractions.

\subsection{\csbh{xintXOR}}\label{xintXOR}
%{\small New with release |1.09a|.\par}

|\xintXOR|\n\m\etype{\Numf\Numf} returns 1 if exactly one of |N| or |M|
is true (i.e. non-zero). Extended by \xintfracname to fractions.

\subsection{\csbh{xintANDof}}\label{xintANDof}
%{\small New with release |1.09a|.\par}

\csa{xintANDof}|{{a}{b}{c}...}|\etype{f{$\to$}\lowast\Numf} returns 1 if all
are true (i.e. non zero) and zero otherwise. The list argument may be a macro,
it (or rather its first token) is \fexpan ded first (each item also is \fexpan
ded). Extended by \xintfracname to fractions.

\subsection{\csbh{xintORof}}\label{xintORof}
%{\small New with release |1.09a|.\par}

\csa{xintORof}|{{a}{b}{c}...}|\etype{f{$\to$}\lowast\Numf} returns 1 if at
least one is true (i.e. does not vanish). The list argument may be a macro, it
is \fexpan ded first. Extended by \xintfracname to fractions.

\subsection{\csbh{xintXORof}}\label{xintXORof}
%{\small New with release |1.09a|.\par}

\csa{xintXORof}|{{a}{b}{c}...}|\etype{f{$\to$}\lowast\Numf} returns 1 if an odd
number of them are true (i.e. does not vanish). The list argument may be a
macro, it is \fexpan ded first. Extended by \xintfracname to fractions.

\subsection{\csbh{xintGeq}}\label{xintiGeq}

|\xintGeq|\n\m\etype{\Numf\Numf} returns 1 if the \emph{absolute value}
of the first number is at least equal to the absolute value of the second
number. If \verb+|N|<|M|+ it returns 0. Extended by \xintfracname to fractions.
%(starting with release |1.07|)
Important: the macro compares \emph{absolute values}.

\subsection{\csbh{xintiMax}, \csbh{xintiiMax}}\label{xintiMax}\label{xintiiMax}

|\xintiMax|\n\m\etype{\Numf\Numf} returns the largest of the two in the sense
of the order structure on the relative integers (\emph{i.e.} the right-most
number if they are put on a line with positive numbers on the right):
|\xintiMax {-5}{-6}|\dtt{=\xintiMax{-5}{-6}}.

The |\xintiiMax| macro skips the overhead of parsing the operands with
\csbxint{Num}.\etype{ff}

\subsection{\csbh{xintiMin}, \csbh{xintiiMin}}\label{xintiMin}\label{xintiiMin}

|\xintiMin|\n\m\etype{\Numf\Numf} returns the smallest of the two in the
sense of the order structure on the relative integers (\emph{i.e.} the left-most
number if they are put on a line with positive numbers on the right): |\xintiMin
{-5}{-6}|\dtt{=\xintiMin{-5}{-6}}.

The |\xintiiMin| macro skips the overhead of parsing the operands with
\csbxint{Num}.\etype{ff}

\subsection{\csbh{xintiMaxof}, \csbh{xintiiMaxof}}\label{xintiMaxof}\label{xintiiMaxof}
%{\small New with release |1.09a|.\par}

\csa{xintiMaxof}|{{a}{b}{c}...}|\etype{f{$\to$}\lowast\Numf} returns the
maximum. The list argument may be a macro, it is \fexpan ded first. Each item
is submitted to |\xintNum| normalization.

\csa{xintiiMaxof} does the same, skips |\xintNum| normalization of
items.\NewWith {1.2a}

\subsection{\csbh{xintiMinof}, \csbh{xintiiMinof}}\label{xintiMinof}\label{xintiiMinof}
%{\small New with release |1.09a|.\par}

\csa{xintiMinof}|{{a}{b}{c}...}|\etype{f{$\to$}\lowast\Numf} returns the
minimum. The list argument may be a macro, it is \fexpan ded first. Each item
is submitted to |\xintNum| normalization.

\csa{xintiiMinof} does the same, skips |\xintNum| normalization of
items.\NewWith {1.2a}

\subsection{\csbh{xintiiSum}}\label{xintiiSum}

\csa{xintiiSum}\marg{braced things}\etype{{\lowast f}} after expanding its
argument expects to find a sequence of tokens (or braced material). Each is
\fexpan ded, and the sum of all these numbers is returned.
Note: the summands are \emph{not} parsed by \csbxint{Num}.

%
\leftedline{%
  \csa{xintiiSum}|{{123}{-98763450}{\xintFac{7}}{\xintiMul{3347}{591}}}|%
  \dtt{=\xintiiSum{{123}{-98763450}{\xintFac{7}}{\xintiMul{3347}{591}}}}}
%
\leftedline{\csa{xintiiSum}|{1234567890}|\dtt{=\xintiiSum{1234567890}}}
An empty sum is no error and returns zero: |\xintiiSum
{}|\dtt{=\xintiiSum {}}. A sum with only one term returns that
number: |\xintiiSum {{-1234}}|\dtt{=\xintiiSum {{-1234}}}.
Attention that |\xintiiSum {-1234}| is not legal input and will make the
\TeX{} run fail. On the other hand |\xintiiSum
{1234}|\dtt{=\xintiiSum{1234}}.

% retir de la doc le 22 octobre 2013
% \subsection{\csbh{xintSumExpr}}\label{xintiiSumExpr}

\subsection{\csbh{xintiiPrd}}\label{xintiiPrd}

\csa{xintiiPrd}\marg{braced things}\etype{{\lowast f}} after expanding its
argument expects to find a sequence of (of braced items or unbraced
single tokens). Each is
expanded (with the usual meaning), and the product of all these numbers is
returned. Note: the operands are \emph{not} parsed by \csbxint{Num}.
%
\leftedline{\csa{xintiiPrd}|{{-9876}{\xintFac{7}}{\xintiMul{3347}{591}}}|%
  \dtt{=%
    \xintiiPrd{{-9876}{\xintFac{7}}{\xintiMul{3347}{591}}}}}
%
\leftedline{\csa{xintiiPrd}|{123456789123456789}|\dtt{=%
    \xintiiPrd{123456789123456789}}} An empty product is no error and returns 1:
|\xintiiPrd {}|\dtt{=\xintiiPrd {}}. A product reduced to a single term
returns this number: |\xintiiPrd {{-1234}}=|\dtt{\xintiiPrd {{-1234}}}.
Attention that |\xintiiPrd {-1234}| is not legal input and will make the \TeX{}
compilation fail. On the other hand |\xintiiPrd {1234}|\dtt{=\xintiiPrd
  {1234}}. %
%
\begin{everbatim*}
$2^{200}3^{100}7^{100}=\printnumber
       {\xintiiPrd {{\xintiPow {2}{200}}{\xintiPow {3}{100}}{\xintiPow {7}{100}}}}$
\end{everbatim*}

With \xintexprname, this would be easier:
%
\leftedline {|\xinttheiiexpr 2^200*3^100*7^100\relax |}


% \subsection{\csbh{xintPrdExpr}}\label{xintiiPrdExpr}


\subsection{\csbh{xintSgnFork}}\label{xintSgnFork}
%{\small New with release |1.07|. See also \csbxint{ifSgn}.\par}

\csa{xintSgnFork}\verb+{-1|0|1}+\marg{A}\marg{B}\marg{C}\etype{xnnn}
expandably chooses to execute either the \meta{A}, \meta{B} or \meta{C} code,
depending on its first argument. This first argument should be anything
expanding to either |-1|, |0| or |1| in a non self-delimiting way (i.e. a
count register must be prefixed by |\the| and a |\numexpr...\relax| also must
be prefixed by |\the|). This utility is provided to help construct expandable
macros choosing depending on a condition which one of the package macros to
use, or which values to confer to their arguments.

\subsection{\csbh{xintifSgn}, \csbh{xintiiifSgn}}\label{xintifSgn}
%{\small New with release |1.09a|.\par}

Similar to \csa{xintSgnFork}\etype{\Numf nnn} except that the first argument may
expand to a (big) integer (or a fraction if \xintfracname is loaded), and it is
its sign which decides which of the three branches is taken. Furthermore this
first argument may be a count register, with no |\the| or |\number| prefix.

\csa{xintiiifSgn} skips the \csbxint{Num} overhead.\etype{f}

\subsection{\csbh{xintifZero}, \csbh{xintiiifZero}}\label{xintifZero}
%{\small New with release |1.09a|.\par}

\csa{xintifZero}\marg{N}\marg{IsZero}\marg{IsNotZero}\etype{\Numf nn} expandably
checks if the first mandatory argument |N| (a number, possibly a fraction if
\xintfracname is loaded, or a macro expanding to one such) is zero or not. It
then either executes the first or the second branch. Beware that both branches
must be present.

\csa{xintiiifZero} skips the \csbxint{Num} overhead.\etype{f}


\subsection{\csbh{xintifNotZero}, \csbh{xintiiifNotZero}}\label{xintifNotZero}
%{\small New with release |1.09a|.\par}

\csa{xintifNotZero}\marg{N}\marg{IsNotZero}\marg{IsZero}\etype{\Numf nn}
expandably checks if the first mandatory argument |N| (a number, possibly a
fraction if \xintfracname is loaded, or a macro expanding to one such) is not
zero or is zero. It then either executes the first or the second branch. Beware
that both branches must be present.

\csa{xintiiifNotZero} skips the \csbxint{Num} overhead.\etype{f}

\subsection{\csbh{xintifOne}, \csbh{xintiiifOne}}\label{xintifOne}
%{\small New with release |1.09i|.\par}

\csa{xintifOne}\marg{N}\marg{IsOne}\marg{IsNotOne}\etype{\Numf nn} expandably
checks if the first mandatory argument |N| (a number, possibly a fraction if
\xintfracname is loaded, or a macro expanding to one such) is one or not. It
then either executes the first or the second branch. Beware that both branches
must be present.

\csa{xintiiifOne} skips the \csbxint{Num} overhead.\etype{f}

\subsection{\csbh{xintifTrueAelseB}, \csbh{xintifFalseAelseB}}
\label{xintifTrueAelseB}
\label{xintifFalseAelseB}

%\label{xintifFalseTrue}
%{\small New with release |1.09c|, renamed in |1.09e|.\par}

\csa{xintifTrueAelseB}\marg{N}\marg{true branch}\marg{false branch}\etype{\Numf
  nn} is a synonym for \csbxint{ifNotZero}.

{\small
\noindent 1. with |1.09i|, the synonyms |\xintifTrueFalse| and |\xintifTrue| are
  deprecated
  and will be removed in next release.\par
\noindent 2. These macros have no lowercase versions, use |\xintifzero|,
|\xintifnotzero|.\par }

\csa{xintifFalseAelseB}\marg{N}\marg{false branch}\marg{true branch}\etype{\Numf
  nn} is a synonym for \csbxint{ifZero}.

\subsection{\csbh{xintifCmp}, \csbh{xintiiifCmp}}\label{xintifCmp}
%{\small New with release |1.09e|.\par}

\csa{xintifCmp}\marg{A}\marg{B}\marg{if A<B}\marg{if A=B}\marg{if
  A>B}\etype{\Numf\Numf nnn} compares
its arguments and chooses accordingly the correct branch.

\csa{xintiiifCmp} skips the \csbxint{Num} overhead.\etype{ff}

\subsection{\csbh{xintifEq}, \csbh{xintiiifEq}}\label{xintifEq}
%{\small New with release |1.09a|.\par}

\csa{xintifEq}\marg{A}\marg{B}\marg{YES}\marg{NO}\etype{\Numf\Numf nn}
checks equality of its two first arguments (numbers, or fractions if
\xintfracname is loaded) and does the |YES| or the |NO| branch.

\csa{xintiiifEq} skips the \csbxint{Num} overhead.\etype{ff}

\subsection{\csbh{xintifGt}, \csbh{xintiiifGt}}\label{xintifGt}
%{\small New with release |1.09a|.\par}

\csa{xintifGt}\marg{A}\marg{B}\marg{YES}\marg{NO}\etype{\Numf\Numf nn} checks if
$A>B$ and in that case executes the |YES| branch. Extended to fractions (in
particular decimal numbers) by \xintfracname.

\csa{xintiiifGt} skips the \csbxint{Num} overhead.\etype{ff}

\subsection{\csbh{xintifLt}, \csbh{xintiiifLt}}\label{xintifLt}
%{\small New with release |1.09a|.\par}

\csa{xintifLt}\marg{A}\marg{B}\marg{YES}\marg{NO}\etype{\Numf\Numf nn}
checks if $A<B$ and in that case executes the |YES| branch. Extended to
fractions (in particular decimal numbers) by \xintfracname.

\csa{xintiiifLt} skips the \csbxint{Num} overhead.\etype{ff}

\subsection{\csbh{xintifOdd}, \csbh{xintiiifOdd}}\label{xintifOdd}
%{\small New with release |1.09e|.\par}

\csa{xintifOdd}\marg{A}\marg{YES}\marg{NO}\etype{\Numf nn} checks if $A$ is and
odd integer and in that case executes the |YES| branch.

\csa{xintiiifOdd} skips the \csbxint{Num} overhead.\etype{f}

\begin{framed}
  The macros described next are all integer-only on input. Those with |ii| in
  their names skip the \csbxint{Num} parsing. The others, with \xintfracname
  loaded, can have fractions as arguments, which will get truncated to
  integers via \csbxint{TTrunc}. On output, the macros here always produce
  integers (with no |/B[N]|).
\end{framed}

\subsection{\csbh{xintiFac}}\label{xintiFac}

|\xintiFac|\x\etype{\numx} returns the factorial. It is an error on input if
the argument is negative.

\begin{framed}
  The macro will limit the acceptable inputs to a maximum of $9999$. However
  the maximal computation depends on the values of some memory parameters of
  the |tex| executable: with the the current default settings of TeXLive 2015,
  the maximal computable factorial (a.t.t.o.w. 2015/10/06) turns out to be
  $5971!$ which has $19956$ digits.%\footnotemark
\end{framed}
% \footnotetext{The computation with \xintname 1.2 of $5971!$ takes of the order
%   of 27 seconds on my laptop. And about half a second for the $2568$ digits of
%   $1000!$.}

Package \xintfracname provides \csbxint{FloatFac} which allows to evaluate
faster significant digits of big factorials and accepts (theoretically) inputs
up to $99999999$. See \autoref{sec:examples} for the example of $2000!$ with
$50$ significant digits.

% avant 1.09j c'tait 1000000.
% avant 1.2 c'tait 100000. (n'importe quoi!)

|\xintFac| is the variant applying |\xintNum| on his input and thus, when
\xintfracname is loaded, accepting a fraction on input (but it truncates it
first).

% avec xint1.2: 1000!, 2000!, 3000!
% Mercredi 07 octobre 2015  14:34:20
% (0.534s)
% 402387260077093773543702, 2568, 4.023872600770938e2567.
% (2.521s)
% 331627509245063324117539, 5736, 3.316275092450633e5735.
% (6.097s)
% 414935960343785408555686, 9131, 4.149359603437854e9130.

% ATTENTION TOTALEMENT MAIS TOTALEMENT OBSOLETE
% JE CONSERVE UNIQUEMENT POUR ME SOUVENIR DU PASS
% ---- obsolte, remonte au premier xint
% On my laptop $1000!$ (2568 digits)
% is computed in a little less than ten seconds, $2000!$ (5736
% digits) is computed in a little less than one hundred seconds, and
% $3000!$ (which has 9131 digits) needs close to seven minutes\dots
% I have no idea how much time $10000!$ would need (do rather
% $9999!$ if you can, the algorithm has some overhead at the
% transition from $N=9999$ to $10000$ and higher; $10000!$ has 35660
% digits). Not to mention $100000!$ which, from the Stirling formula,
% should have 456574 digits.
% ---- (je rvais  l'poque avec 100000! ... 
%
% Je me souviens qu'au tout dbut je ne m'attendais pas du tout  rencontrer
% de tels problmes ds des nombres de quelques milliers de chiffres, car je
% n'tais pas imprgn de la pnalit lie  parcourir par des macros
% dlimits de longues squences de tokens

\subsection{\csbh{xintiiMON}, \csbh{xintiiMMON}}
\label{xintMON}\label{xintMMON}\label{xintiiMON}\label{xintiiMMON}
%{\small New in version |1.03|.\par}

|\xintiiMON|\n\etype{f} returns |(-1)^N| and |\xintiiMMON|\n{} returns
|(-1)^{N-1}|. They skip the overhead of parsing via \csbxint{Num}.
%
\leftedline{|\xintiiMON {-280914019374101929}|\dtt{=\xintiiMON
    {280914019374101929}}, |\xintiiMMON
  {-280914019374101929}|\dtt{=\xintiiMMON {280914019374101929}}} 

The variants
\csa{xintMON}\etype{\Numf} and \csa{xintMMON} use |\xintNum| and get extended
to fractions by \xintfracname.

\subsection{\csbh{xintiiOdd}}\label{xintOdd}\label{xintiiOdd}

|\xintiiOdd|\n\etype{f} is 1 if the number is odd and 0 otherwise. It skips
the overhead of parsing via \csbxint{Num}. \csa{xintOdd}\etype{\Numf} is the
variant using |\xintNum| and extended to fractions by \xintfracname.

\subsection{\csbh{xintiiEven}}\label{xintEven}\label{xintiiEven}

|\xintiiEven|\n\etype{f} is 1 if the number is even and 0 otherwise. It skips
the overhead of parsing via \csbxint{Num}. \csa{xintEven}\etype{\Numf} is the
variant using |\xintNum| and extended to fractions by \xintfracname.

\subsection{\csbh{xintiSqrt}, \csbh{xintiiSqrt}, \csbh{xintiiSqrtR}, \csbh{xintiSquareRoot},
  \csbh{xintiiSquareRoot}}\label{xintiSqrt}\label{xintiiSqrt}\label{xintiiSqrtR}
\label{xintiSquareRoot}\label{xintiiSquareRoot}
%{\small New with |1.08|.\par}

\noindent|\xintiSqrt|\n\etype{\Numf} returns the largest integer whose square
is at most equal to |N|. |\xintiiSqrt| is the variant skipping the |\xintNum|
overhead.\etype{f} |\xintiiSqrtR| also skips the |\xintNum| overhead and it
returns the rounded, not truncated, square root.\etype{f}
\begin{everbatim*}
\begin{itemize}[nosep]
\item \xintiiSqrt  {3000000000000000000000000000000000000}
\item \xintiiSqrtR {3000000000000000000000000000000000000}
\item \xintiiSqrt  {\xintiiE {3}{100}}
\end{itemize}
\end{everbatim*}

|\xintiSquareRoot|\n\etype{\Numf} returns |{M}{d}| with |d>0|, |M^2-d=N| and
|M| smallest (hence |=1+\xintiSqrt{N}|). 

|\xintiiSquareRoot|\etype{f} is the variant  skipping the |\xintNum| overhead.

\begin{everbatim*}
\xintAssign\xintiiSquareRoot {17000000000000000000000000}\to\A\B
\xintiiSub{\xintiiSqr\A}\B=\A\string^2-\B
\end{everbatim*}

A rational approximation to $\sqrt{|N|}$ is $|M|-\frac{|d|}{|2M|}$ (this is a
majorant and the error is at most |1/2M|; if |N| is a perfect square |k^2|
then |M=k+1| and this gives |k+1/(2k+2)|, not |k|).

Package \xintfracname has \csbxint{FloatSqrt} for square
roots of floating point numbers.

\begin{framed}
  The macros described next are strictly for integer-only arguments. These
  arguments are \emph{not} filtered via \csbxint{Num}. The macros are not
  usable with fractions, even with \xintfracname loaded.
\end{framed}

\subsection{\csbh{xintDSL}}\label{xintDSL}

|\xintDSL|\n\etype{f} is decimal shift left, \emph{i.e.} multiplication by
ten.

\subsection{\csbh{xintDSR}}\label{xintDSR}

|\xintDSR|\n\etype{f} is decimal shift right, \emph{i.e.} it removes the last
digit (keeping the sign), equivalently it is the closest integer to |N/10| when
starting at zero.

\subsection{\csbh{xintDSH}}\label{xintDSH}

|\xintDSH|\x\n\etype{\numx f} is parametrized decimal shift. When |x| is
negative, it is like iterating \csa{xintDSL} \verb+|x|+ times (\emph{i.e.}
multiplication by $10^{-x}$). When |x| positive, it is like iterating
\csa{DSR} |x| times (and is more efficient), and for a non-negative |N| this is
thus the same as the quotient from the euclidean division by |10^x|.

\subsection{\csbh{xintDSHr}, \csbh{xintDSx}}\label{xintDSHr}\label{xintDSx}
%{\small New in release |1.01|.\par}

|\xintDSHr|\x\n\etype{\numx f} expects |x| to be zero or positive and it
returns then a value |R| which is correlated to the value |Q| returned by
|\xintDSH|\x\n{} in the following manner:
\begin{itemize}
\item if |N| is
  positive or zero, |Q| and |R| are the quotient and remainder in
  the euclidean division by |10^x| (obtained in a more efficient
  manner than using \csa{xintiDivision}),
\item if |N| is negative let
  |Q1| and |R1| be the quotient and remainder in the euclidean
  division by |10^x| of the absolute value of |N|. If |Q1|
  does not vanish, then |Q=-Q1| and |R=R1|. If |Q1| vanishes, then
  |Q=0| and |R=-R1|.
\item for |x=0|, |Q=N| and |R=0|.
\end{itemize}
So one has |N = 10^x Q + R| if |Q| turns out to be zero or
positive, and |N = 10^x Q - R| if |Q| turns out to be negative,
which is exactly the case when |N| is at most |-10^x|.

|\xintDSx|\x\n\etype{\numx f} for |x| negative is exactly as
|\xintDSH|\x\n, \emph{i.e.} multiplication by $10^{-|x|}$. For |x| zero or
positive it returns the two numbers |{Q}{R}| described above, each one within
braces. So |Q| is |\xintDSH|\x\n, and |R| is |\xintDSHr|\x\n, but computed
simultaneously.

    \xintAssign\xintDSx {-1}{-123456789}\to\M
\leftedline{|\xintAssign\xintDSx {-1}{-123456789}\to\M|}
\leftedline{|\meaning\M: |\dtt{\meaning\M}.}
    \xintAssign\xintDSx {-20}{1234567689}\to\M
\leftedline{|\xintAssign\xintDSx {-20}{123456789}\to\M|}
\leftedline{|\meaning\M: |\dtt{\meaning\M}.}
    \xintAssign\xintDSx{0}{-123004321}\to\Q\R
\leftedline{|\xintAssign\xintDSx {0}{-123004321}\to\Q\R|}
\leftedline{|\meaning\Q: |\dtt{\meaning\Q}, |\meaning\R:|\dtt{\meaning\R.}}
\leftedline{|\xintDSH {0}{-123004321}|\dtt{=\xintDSH {0}{-123004321}},
|\xintDSHr {0}{-123004321}|\dtt{=\xintDSHr {0}{-123004321}}}
    \xintAssign\xintDSx {6}{-123004321}\to\Q\R
\leftedline{|\xintAssign\xintDSx {6}{-123004321}\to\Q\R|}
\leftedline{|\meaning\Q: |\dtt{\meaning\Q},|\meaning\R: |\dtt{\meaning\R.}}
\leftedline{|\xintDSH {6}{-123004321}|\dtt{=\xintDSH {6}{-123004321}},
|\xintDSHr {6}{-123004321}|\dtt{=\xintDSHr {6}{-123004321}}}
    \xintAssign\xintDSx {8}{-123004321}\to\Q\R
\leftedline{|\xintAssign\xintDSx {8}{-123004321}\to\Q\R|}
\leftedline{|\meaning\Q: |\dtt{\meaning\Q},|\meaning\R: |\dtt{\meaning\R.}}
\leftedline{|\xintDSH {8}{-123004321}|\dtt{=\xintDSH {8}{-123004321}},
|\xintDSHr {8}{-123004321}|\dtt{=\xintDSHr {8}{-123004321}}}
    \xintAssign\xintDSx {9}{-123004321}\to\Q\R
\leftedline{|\xintAssign\xintDSx {9}{-123004321}\to\Q\R|}
\leftedline{|\meaning\Q: |\dtt{\meaning\Q},|\meaning\R: |\dtt{\meaning\R.}}
\leftedline{|\xintDSH {9}{-123004321}|\dtt{=\xintDSH {9}{-123004321}},
|\xintDSHr {9}{-123004321}|\dtt{=\xintDSHr {9}{-123004321}}}

\subsection{\csbh{xintDecSplit}}\label{xintDecSplit}

%{\small This has been modified in release |1.01|.\par}

|\xintDecSplit|\x\n\etype{\numx f} cuts the number into two pieces (each one
within a pair of enclosing braces). First the sign if present is \emph{removed}.
Then, for |x| positive or null, the second piece contains the |x| least
significant digits (\emph{empty} if |x=0|) and the first piece the remaining
digits (\emph{empty} when |x| equals or exceeds the length of |N|). Leading
zeroes in the second piece are not removed. When |x| is negative the first piece
contains the \verb+|x|+ most significant digits and the second piece the
remaining digits (\emph{empty} if $|x|$ equals or exceeds the length of |N|).
Leading zeroes in this second piece are not removed. So the absolute value of the
original number is always the concatenation of the first and second piece.

{\footnotesize This macro's behavior for |N| non-negative is final and will not
  change. I am still hesitant about what to do with the sign of a
  negative |N|.\par}

\xintAssign\xintDecSplit {0}{-123004321}\to\L\R
\leftedline{|\xintAssign\xintDecSplit {0}{-123004321}\to\L\R|}
\leftedline{|\meaning\L: |\dtt{\meaning\L}, |\meaning\R: |\dtt{\meaning\R.}}
\xintAssign\xintDecSplit {5}{-123004321}\to\L\R
\leftedline{|\xintAssign\xintDecSplit {5}{-123004321}\to\L\R|}
\leftedline{|\meaning\L: |\dtt{\meaning\L}, |\meaning\R: |\dtt{\meaning\R.}}
\xintAssign\xintDecSplit {9}{-123004321}\to\L\R
\leftedline{|\xintAssign\xintDecSplit {9}{-123004321}\to\L\R|}
\leftedline{|\meaning\L: |\dtt{\meaning\L}, |\meaning\R: |\dtt{\meaning\R.}}
\xintAssign\xintDecSplit {10}{-123004321}\to\L\R
\leftedline{|\xintAssign\xintDecSplit {10}{-123004321}\to\L\R|}
\leftedline{|\meaning\L: |\dtt{\meaning\L}, |\meaning\R: |\dtt{\meaning\R.}}
\xintAssign\xintDecSplit {-5}{-12300004321}\to\L\R
\leftedline{|\xintAssign\xintDecSplit {-5}{-12300004321}\to\L\R|}
\leftedline{|\meaning\L: |\dtt{\meaning\L}, |\meaning\R: |\dtt{\meaning\R.}}
\xintAssign\xintDecSplit {-11}{-12300004321}\to\L\R
\leftedline{|\xintAssign\xintDecSplit {-11}{-12300004321}\to\L\R|}
\leftedline{|\meaning\L: |\dtt{\meaning\L}, |\meaning\R: |\dtt{\meaning\R.}}
\xintAssign\xintDecSplit {-15}{-12300004321}\to\L\R
\leftedline{|\xintAssign\xintDecSplit {-15}{-12300004321}\to\L\R|}
\leftedline{|\meaning\L: |\dtt{\meaning\L}, |\meaning\R: |\dtt{\meaning\R.}}

\subsection{\csbh{xintDecSplitL}}\label{xintDecSplitL}

|\xintDecSplitL|\x\n\etype{\numx f} returns the first piece after the action
of \csa{xintDecSplit}.

\subsection{\csbh{xintDecSplitR}}\label{xintDecSplitR}

|\xintDecSplitR|\x\n\etype{\numx f} returns the second piece after the action
of \csa{xintDecSplit}.

\subsection{\csbh{xintiiE}}\label{xintiiE}

|\xintiiE|\n\x\etype{f\numx } serves to add zeros to the right of |N|.
\begin{everbatim*}
\xintiiE {123}{89}
\end{everbatim*}

%\pagebreak

\section{Commands of the \xintfracname package}
\label{sec:frac}

\localtableofcontents

\def\x{|{x}|}

This package was first included in release |1.03| (|2013/04/14|) of the
\xintname bundle. The general rule of the bundle that each macro first expands
(what comes first, fully) each one of its arguments applies.

|f|\ntype{\Ff} stands for an integer or a fraction (see \autoref{sec:inputs}
for the accepted input formats) or something which expands to an integer or
fraction. It is possible to use in the numerator or the denominator of |f| count
registers and even expressions with infix arithmetic operators, under some rules
which are explained in the previous \hyperref[sec:useofcount]{Use of count
  registers} section.

As in the \hyperref[sec:xint]{xint.sty} documentation, |x|\ntype{\numx}
stands for something which will internally be embedded in a \csa{numexpr}.
It
may thus be a count register or something like |4*\count 255 + 17|, etc..., but
must expand to an integer obeying the \TeX{} bound.

The fraction format on output is the scientific notation for the `float' macros,
and the |A/B[n]| format for all other fraction macros, with the exception of
\csbxint{Trunc}, {\color{blue}\string\xint\-Round} (which produce decimal
numbers) and \csbxint{Irr}, \csbxint{Jrr}, \csbxint{RawWithZeros} (which returns
an |A/B| with no trailing |[n]|, and prints the |B| even if it is |1|), and
\csbxint{PRaw} which does not print the |[n]| if |n=0| or the |B| if |B=1|.

To be certain to print an integer output without trailing |[n]| nor fraction
slash, one should use either |\xintPRaw {\xintIrr {f}}| or |\xintNum {f}| when
it is already known that |f| evaluates to a (big) integer. For example
|\xintPRaw {\xintAdd {2/5}{3/5}}| gives a perhaps disappointing
\dtt{\xintPRaw {\xintAdd {2/5}{3/5}}}
%
%
%
whereas |\xintPRaw {\xintIrr {\xintAdd
    {2/5}{3/5}}}| returns \dtt{\xintPRaw {\xintIrr {\xintAdd
    {2/5}{3/5}}}}. As we knew the result was an integer we could have used
|\xintNum {\xintAdd {2/5}{3/5}}=|\xintNum {\xintAdd {2/5}{3/5}}.

Some macros (such as \csbxint{iTrunc},
\csbxint{iRound}, and \csbxint{Fac}) always produce directly integers on output.

The macro \csbxint{XTrunc} uses \csbxint{iloop} from package \xinttoolsname,
hence there is a partial dependency of \xintfracname on
\xinttoolsname,\IMPORTANT{} and the latter must be required explicitely by the
user intending to use \csbxint{XTrunc}.

Refer to \autoref{ssec:floatingpoint} for general background information on
how floating point numbers and evaluations are implemented.

\subsection{\csbh{xintNum}}\label{xintNum}

The macro\etype{f} from \xintname is made a synonym to \csbxint{TTrunc}.%
%(\textcolor[named]{PineGreen}{Changed!})
\footnote{In earlier releases than
  |1.1|, \csbxint{Num} did \csbxint{Irr} and then complained if the
  denominator was not |1|, else, it silently removed the denominator.}

The original (which
normalizes big integers to strict format) is still available as
\csbxint{iNum}.
It is imprudent to apply \csa{xintNum} to numbers with a large
power of ten given either in scientific notation or with the |[n]| notation,
as the macro will according to its definition add all the needed zeroes to
produce an explicit integer in strict format.

\subsection{\csbh{xintifInt}}\label{xintifInt}
%{\small New with release |1.09e|.\par}

\csa{xintifInt}|{f}{YES branch}{NO branch}|\etype{\Ff nn} expandably chooses
the |YES| branch if |f| reveals itself after expansion and simplification to
be an integer. As with the other \xintname conditionals, both branches must be
present although one of the two (or both, but why then?) may well be an empty
brace pair |{}|. Spaces in-between the braced things do not matter, but a
space after the closing brace of the |NO| branch is significant.

\subsection{\csbh{xintLen}}\label{xintLen}

The original macro\etype{\Ff} is extended to accept a fraction on input.
%
\leftedline {|\xintLen {201710/298219}|\dtt{=\xintLen {201710/298219}},
|\xintLen {1234/1}|\dtt{=\xintLen {1234/1}}, |\xintLen {1234}|%
                    \dtt{=\xintLen {1234}}}

\subsection{\csbh{xintRaw}}\label{xintRaw}
%{\small New with release |1.04|.\par}
%{\small \color{red}MODIFIED IN |1.07|.\par}

This macro `prints' the\etype{\Ff}
fraction |f| as it is received by the package after its parsing and
expansion, in a form |A/B[n]| equivalent to the internal
representation: the denominator |B| is always strictly positive and is
printed even if it has value |1|.
%
\leftedline{|\xintRaw{\the\numexpr 571*987\relax.123e-10/\the\numexpr
    -201+59\relax e-7}=|}
%
\leftedline{\dtt{\xintRaw{\the\numexpr
      571*987\relax.123e-10/\the\numexpr -201+59\relax e-7}}}

\subsection{\csbh{xintPRaw}}\label{xintPRaw}
%{\small New in |1.09b|.\par}

|PRaw|\etype{\Ff} stands for ``pretty raw''. It does \emph{not} show the |[n]|
if |n=0| and does \emph{not} show the |B| if |B=1|. 
% %
%
\leftedline{|\xintPRaw {123e10/321e10}=|\dtt{\xintPRaw {123e10/321e10}}, %
|\xintPRaw {123e9/321e10}=|\dtt{\xintPRaw {123e9/321e10}}} 
% %
%
\leftedline{|\xintPRaw {\xintIrr{861/123}}=|\dtt{\xintPRaw{\xintIrr{861/123}}}\ vz.\ 
  |\xintIrr{861/123}=|\dtt{\xintIrr{861/123}}} 
% %
See also \csbxint{Frac} (or \csbxint{FwOver}) for math mode. As is examplified
above the \csbxint{Irr} macro which puts the fraction into irreducible form
does not remove the |/1| if the fraction is an integer. One can use
|\xintNum{f}| or |\xintPRaw{\xintIrr{f}}| which produces the same output only
if |f| is an integer (after simplication).

\subsection{\csbh{xintNumerator}}\label{xintNumerator}

This returns\etype{\Ff} the numerator corresponding to the internal
representation of a fraction, with positive powers of ten converted into zeroes
of this numerator: %
%
\leftedline{|\xintNumerator
 {178000/25600000[17]}|\dtt{=\xintNumerator {178000/25600000[17]}}}
%
\leftedline{|\xintNumerator {312.289001/20198.27}|%
  \dtt{=\xintNumerator {312.289001/20198.27}}}
%
\leftedline{|\xintNumerator {178000e-3/256e5}|\dtt{=\xintNumerator
    {178000e-3/256e5}}} %
%
\leftedline{|\xintNumerator
 {178.000/25600000}|\dtt{=\xintNumerator {178.000/25600000}}} As shown by
the examples, no simplification of the input is done. For a result uniquely
associated to the value of the fraction first apply \csa{xintIrr}.

\subsection{\csbh{xintDenominator}}\label{xintDenominator}

This returns\etype{\Ff} the denominator corresponding to the internal
representation of the fraction:%
%
\footnote{recall that the |[]| construct excludes
  presence of a decimal point.} 
%
\leftedline{|\xintDenominator
 {178000/25600000[17]}|\dtt{=\xintDenominator {178000/25600000[17]}}}
%
\leftedline{|\xintDenominator {312.289001/20198.27}|%
  \dtt{=\xintDenominator {312.289001/20198.27}}}
%
\leftedline{|\xintDenominator {178000e-3/256e5}|\dtt{=\xintDenominator
    {178000e-3/256e5}}} %
%
\leftedline{|\xintDenominator
 {178.000/25600000}|\dtt{=\xintDenominator {178.000/25600000}}} As shown
by the examples, no simplification of the input is done. The denominator looks
wrong in the last example, but the numerator was tacitly multiplied by $1000$
through the removal of the decimal point. For a result uniquely associated to
the value of the fraction first apply \csa{xintIrr}.

\subsection{\csbh{xintRawWithZeros}}\label{xintRawWithZeros}
%{\small New name in |1.07| (former name |\xintRaw|).\par}

This macro `prints'\etype{\Ff} the
fraction |f| (after its parsing and expansion) in |A/B| form, with |A|
as returned by \csa{xintNumerator}|{f}| and |B| as returned by
\csa{xintDenominator}|{f}|.
%
\leftedline{|\xintRawWithZeros{\the\numexpr 571*987\relax.123e-10/\the\numexpr
    -201+59\relax e-7}=|}
%
\leftedline{\dtt{\xintRawWithZeros{\the\numexpr
      571*987\relax.123e-10/\the\numexpr -201+59\relax e-7}}}

\subsection{\csbh{xintREZ}}\label{xintREZ}

This command\etype{\Ff} normalizes a fraction by removing the powers of ten from
its numerator and denominator: %
%
\leftedline{|\xintREZ
 {178000/25600000[17]}|\dtt{=\xintREZ {178000/25600000[17]}}}
%
\leftedline{|\xintREZ {1780000000000e30/2560000000000e15}|\dtt{=\xintREZ
    {1780000000000e30/2560000000000e15}}} As shown by the example, it does not
otherwise simplify the fraction.

\subsection{\csbh{xintFrac}}\label{xintFrac}

This is a \LaTeX{} only command,\etype{\Ff} to be used in math mode only. It
will print a fraction, internally represented as something equivalent to
|A/B[n]| as |\frac {A}{B}10^n|. The power of ten is omitted when |n=0|, the
denominator is omitted when it has value one, the number being separated from
the power of ten by a |\cdot|. |$\xintFrac {178.000/25600000}$| gives $\xintFrac
{178.000/25600000}$, |$\xintFrac {178.000/1}$| gives $\xintFrac {178.000/1}$,
|$\xintFrac {3.5/5.7}$| gives $\xintFrac {3.5/5.7}$, and |$\xintFrac {\xintNum
  {\xintFac{10}/|\allowbreak|\xintiSqr{\xintFac {5}}}}$| gives $\xintFrac
{\xintNum {\xintFac{10}/\xintiSqr{\xintFac {5}}}}$. As shown by the examples,
simplification of the input (apart from removing the decimal points and moving
the minus sign to the numerator) is not done automatically and must be the
result of macros such as |\xintIrr|, |\xintREZ|, or |\xintNum| (for fractions
being in fact integers.)

\subsection{\csbh{xintSignedFrac}}\label{xintSignedFrac}

%{\small New with release |1.04|.\par}

This is as \csbxint{Frac}\etype{\Ff} except that a negative fraction has the
sign put in front, not in the numerator. %
%
\leftedline{|\[\xintFrac
 {-355/113}=\xintSignedFrac {-355/113}\]|}
\[\xintFrac {-355/113}=\xintSignedFrac {-355/113}\]

\subsection{\csbh{xintFwOver}}\label{xintFwOver}

This does the same as \csa{xintFrac}\etype{\Ff} except that the \csa{over}
primitive is used for the fraction (in case the denominator is not one; and a
pair of braces contains the |A\over B| part). |$\xintFwOver {178.000/25600000}$|
gives $\xintFwOver {178.000/25600000}$, |$\xintFwOver {178.000/1}$| gives
$\xintFwOver {178.000/1}$, |$\xintFwOver {3.5/5.7}$| gives $\xintFwOver
{3.5/5.7}$, and |$\xintFwOver {\xintNum {\xintFac{10}/\xintiSqr{\xintFac
      {5}}}}$| gives $\xintFwOver {\xintNum {\xintFac{10}/\xintiSqr{\xintFac
      {5}}}}$.

\subsection{\csbh{xintSignedFwOver}}\label{xintSignedFwOver}

%{\small New with release |1.04|.\par}

This is as \csbxint{FwOver}\etype{\Ff} except that a negative fraction has the
sign put in front, not in the numerator. %
%
\leftedline{|\[\xintFwOver
 {-355/113}=\xintSignedFwOver {-355/113}\]|}
\[\xintFwOver {-355/113}=\xintSignedFwOver {-355/113}\]

\subsection{\csbh{xintIrr}}\label{xintIrr}

This puts the fraction\etype{\Ff} into its unique irreducible form:
%
\leftedline{|\xintIrr {178.256/256.178}|%
  \dtt{=\xintIrr {178.256/256.178}}${}=\xintFrac{\xintIrr
    {178.256/256.178}[0]}$}
%
Note that the current implementation does not cleverly first factor powers of 2
and 5, so input such as |\xintIrr {2/3[100]}| will make \xintfracname do the
Euclidean division of |2|\raisebox{.5ex}{|.|}|10^{100}| by |3|, which is a bit
stupid.

Starting with release |1.08|, \csa{xintIrr} does not remove the trailing |/1|
when the output is an integer. This was deemed better for various (stupid?)
reasons and thus the output format is now \emph{always} |A/B| with |B>0|. Use
\csbxint{PRaw} on top of \csa{xintIrr} if it is needed to get rid of a possible
trailing |/1|. For display in math mode, use rather |\xintFrac{\xintIrr {f}}| or
|\xintFwOver{\xintIrr {f}}|.

\subsection{\csbh{xintJrr}}\label{xintJrr}

This also puts the fraction\etype{\Ff} into its unique irreducible form:
%
\leftedline{|\xintJrr {178.256/256.178}|%
  \dtt{=\xintJrr {178.256/256.178}}}
%
This is faster than \csa{xintIrr} for fractions having some big common
factor in the numerator and the denominator.\par
{\centering |\xintJrr {\xintiPow{\xintFac {15}}{3}/\xintiiPrdExpr
{\xintFac{10}}{\xintFac{30}}{\xintFac{5}}\relax }|\dtt{=%
 \xintJrr {\xintiPow{\xintFac {15}}{3}/\xintiiPrdExpr
{\xintFac{10}}{\xintFac{30}}{\xintFac{5}}\relax }}\par} But to notice the
difference one would need computations with much bigger numbers than in this
example.
Starting with release |1.08|, \csa{xintJrr} does not remove the trailing |/1|
when the output is an integer.

\subsection{\csbh{xintTrunc}}\label{xintTrunc}

\csa{xintTrunc}|{x}{f}|\etype{\numx\Ff} returns the integral part, a dot, and
then the first |x| digits  of the decimal
expansion of the fraction |f|. The
argument |x| should be non-negative.

In the special case when |f| evaluates to $0$, the output is $0$ with no decimal
point nor decimal digits, else the post decimal mark digits are always printed.
A non-zero negative |f| which is smaller in absolute value than |10^{-x}| will
give $-0.000...$.
%
\leftedline{|\xintTrunc
  {16}{-803.2028/20905.298}|\dtt{=\xintTrunc {16}{-803.2028/20905.298}}}
%
\leftedline{|\xintTrunc {20}{-803.2028/20905.298}|\dtt{=\xintTrunc
    {20}{-803.2028/20905.298}}}
%
\leftedline{|\xintTrunc {10}{\xintPow {-11}{-11}}|\dtt{=\xintTrunc
    {10}{\xintPow {-11}{-11}}}}
%
\leftedline{|\xintTrunc {12}{\xintPow {-11}{-11}}|\dtt{=\xintTrunc
    {12}{\xintPow {-11}{-11}}}}
%
\leftedline{|\xintTrunc {12}{\xintAdd {-1/3}{3/9}}|\dtt{=\xintTrunc
    {12}{\xintAdd {-1/3}{3/9}}}} The digits printed are exact up to and
including the last one.

% The identity |\xintTrunc {x}{-f}=-\xintTrunc {x}{f}|
% holds.%
%
% \footnote{Recall that |-\string\macro| is not valid as argument to any
%   package macro, one must use |\string\xintOpp\string{\string\macro\string}| or
%   |\string\xintiOpp\string{\string\macro\string}|, except inside
%   |\string\xinttheexpr...\string\relax|.}

\subsection{\csbh{xintiTrunc}}\label{xintiTrunc}

\csa{xintiTrunc}|{x}{f}|\etype{\numx\Ff} returns the integer equal to |10^x|
times what \csa{xintTrunc}|{x}{f}| would produce.
%
\leftedline{|\xintiTrunc
  {16}{-803.2028/20905.298}|\dtt{=\xintiTrunc {16}{-803.2028/20905.298}}}
%
\leftedline{|\xintiTrunc {10}{\xintPow {-11}{-11}}|\dtt{=\xintiTrunc
    {10}{\xintPow {-11}{-11}}}}
%
\leftedline{|\xintiTrunc {12}{\xintPow {-11}{-11}}|\dtt{=\xintiTrunc
    {12}{\xintPow {-11}{-11}}}}
%
The difference between \csa{xintTrunc}|{0}{f}| and \csa{xintiTrunc}|{0}{f}| is
that the latter never has the decimal mark always present in the former except
for |f=0|. And \csa{xintTrunc}|{0}{-0.5}| returns ``\dtt{\xintTrunc
  0{-0.5}}'' whereas \csa{xintiTrunc}|{0}{-0.5}| simply returns
``\dtt{\xintiTrunc 0{-0.5}}''.

\subsection{\csbh{xintTTrunc}}\label{xintTTrunc}

\csa{xintTTrunc}|{f}|\etype{\Ff} truncates to an integer (truncation towards
zero). This is the same as |\xintiTrunc {0}{f}| and as \csbxint{Num}.

\subsection{\csbh{xintXTrunc}}\label{xintXTrunc}

%{\small New with release |1.09j|.\par}

\csa{xintXTrunc}|{x}{f}|\retype{\numx\Ff} is completely expandable but not
\fexpan dable, as is indicated by the hollow star in the margin. It can not be
used as argument to the other package macros, but is designed to be used inside
an |\edef|, or rather a |\write|. Here is an example session where the user
after some warming up checks that $1/66049=1/257^2$ has period $257*256=65792$
(it is also checked here that this is indeed the smallest period).

\begin{framed}
  To use \csa{xintXTrunc} the user must load \xinttoolsname, additionally to
  \xintfracname. The interactive session below does not show this because it
  was done at a time when \xintname (hence also \xintfracname) automatically
  loaded \xinttoolsname. This is not the case anymore. \csa{xintXTrunc} is the
  sole dependency of \xintfracname on \xinttoolsname.
\end{framed}
%
\begingroup\small
\everb|@
xxx:_xint $ etex -jobname worksheet-66049
This is pdfTeX, Version 3.1415926-2.5-1.40.14 (TeX Live 2013)
 restricted \write18 enabled.
**\relax
entering extended mode

*\input xintfrac.sty
(./xintfrac.sty (./xint.sty (./xinttools.sty)))
*\message{\xintTrunc {100}{1/71}}% Warming up!

0.01408450704225352112676056338028169014084507042253521126760563380281690140845
07042253521126760563380
*\message{\xintTrunc {350}{1/71}}% period is 35

0.01408450704225352112676056338028169014084507042253521126760563380281690140845
0704225352112676056338028169014084507042253521126760563380281690140845070422535
2112676056338028169014084507042253521126760563380281690140845070422535211267605
6338028169014084507042253521126760563380281690140845070422535211267605633802816
901408450704225352112676056338028169
*\edef\Z {\xintXTrunc  {65792}{1/66049}}% getting serious...

*\def\trim 0.{}\oodef\Z {\expandafter\trim\Z}% removing 0.

*\edef\W {\xintXTrunc {131584}{1/66049}}% a few seconds

*\oodef\W {\expandafter\trim\W}

*\oodef\ZZ {\expandafter\Z\Z}% doubling the period

*\ifx\W\ZZ \message{YES!}\else\message{BUG!}\fi % xint never has bugs...
YES!
*\message{\xintTrunc {260}{1/66049}}% check visually that 256 is not a period

0.00001514027464458205271843631243470756559523989765174340262532362337052794137
6856576178291874214598252812306015231116292449545034746930309315810988811337037
6538630410755651107511090251177156353616254598858423291798513225029902042423049
5541189117170585474420505
*\edef\X {\xintXTrunc {257*128}{1/66049}}% infix here ok, less than 8 tokens

*\oodef\X {\expandafter\trim\X}% we now have the first 257*128 digits

*\oodef\XX {\expandafter\X\X}% was 257*128 a period?

*\ifx\XX\Z \message{257*128 is a period}\else \message{257 * 128 not a period}\fi
257 * 128 not a period
*\immediate\write-1 {1/66049=0.\Z... (repeat)}

*\oodef\ZA {\xintNum {\Z}}% we remove the 0000, or we could use next \xintiMul

*\immediate\write-1 {10\string^65792-1=\xintiiMul {\ZA}{66049}}

*% This was slow :( I should write a multiplication, still completely

*% expandable, but not f-expandable, which could be much faster on such cases.

*\bye
No pages of output.
Transcript written on worksheet-66049.log.
xxx:_xint $ 
|
\endgroup

% \emph{Outdated note: Using |\xintTrunc| rather than |\xintXTrunc| would be
%   hopeless on such long outputs (and even |\xintXTrunc| needed of the order of
%   seconds to complete here). But it is not worth it to use |\xintXTrunc| for
%   less than hundreds of digits.}

\begin{framed}
  The |\xintiiMul {\ZA}{66049}| above can sadly \emph{not} be executed with
  \xintname 1.2, due to the new limitation to at most about $19950$ digits for
  multiplication. On the other hand |\edef\W {\xintXTrunc {131584}{1/66049}}|
  produces the $131584$ digits four times faster. The macro \csbxint{XTrunc}
  has not yet been adapted to the new integer model underlying the 1.2
  \xintcorename macros, and perhaps some future improvements are possible. So
  far it only benefits from a faster division routine, in that specific case
  for a divisor having more than four but less than nine digits.
\end{framed}

Fraction arguments to |\xintXTrunc| corresponding to a |A/B[N]| with a negative
|N| are treated somewhat less efficiently (additional memory impact) than for positive or zero |N|. This is because the algorithm tries to work with the
smallest denominator hence does not extend |B| with zeroes, and technical
reasons lead to the use of some tricks.%
%
\footnote{Technical note: I do not provide an |\xintXFloat|
  because this would almost certainly mean having to clone the entire
  core division routines into a ``long division'' variant. But this
  could have given another approach to the implementation of 
  |\xintXTrunc|, especially for the case of a negative |N|. Doing these
  things with \TeX{} is an effort. Besides an |\xintXFloat|
  would be interesting only if also for example the square root routine
  was provided in an |X| version (I have not given thought to that). If
  feasible |X| routines would be interesting in the |\xintexpr|
  context where things are expanded inside |\csname..\endcsname|.}

Contrarily to \csbxint{Trunc}, in the case of the second argument revealing
itself to be exactly zero, \csbxint{XTrunc} will output $0.000...$, not $0$.
Also, the first argument must be at least $1$.

\subsection{\csbh{xintRound}}\label{xintRound}

%{\small New with release |1.04|.\par}

\csa{xintRound}|{x}{f}|\etype{\numx\Ff} returns the start of the decimal
expansion of the fraction |f|, rounded to |x| digits precision after the decimal
point. The argument |x| should be non-negative. Only when |f| evaluates exactly
to zero does \csa{xintRound} return |0| without decimal point. When |f| is not
zero, its sign is given in the output, also when the digits printed are all
zero. %
%
\leftedline{|\xintRound {16}{-803.2028/20905.298}|\dtt{=\xintRound
    {16}{-803.2028/20905.298}}}
%
\leftedline{|\xintRound {20}{-803.2028/20905.298}|\dtt{=\xintRound
    {20}{-803.2028/20905.298}}}
%
\leftedline{|\xintRound {10}{\xintPow {-11}{-11}}|\dtt{=\xintRound
    {10}{\xintPow {-11}{-11}}}}
%
\leftedline{|\xintRound {12}{\xintPow {-11}{-11}}|\dtt{=\xintRound
    {12}{\xintPow {-11}{-11}}}}
%
\leftedline{|\xintRound {12}{\xintAdd {-1/3}{3/9}}|\dtt{=\xintRound
    {12}{\xintAdd {-1/3}{3/9}}}} The identity |\xintRound {x}{-f}=-\xintRound
{x}{f}| holds. And regarding $(-11)^{-11}$ here is some more of its expansion:
%
\leftedline{\dtt{\xintTrunc {50}{\xintPow {-11}{-11}}\dots}}

\subsection{\csbh{xintiRound}}\label{xintiRound}

%{\small New with release |1.04|.\par}

\csa{xintiRound}|{x}{f}|\etype{\numx\Ff} returns the integer equal to |10^x|
times what \csa{xintRound}|{x}{f}| would return. %
%
\leftedline{|\xintiRound
 {16}{-803.2028/20905.298}|\dtt{=\xintiRound {16}{-803.2028/20905.298}}}
%
\leftedline{|\xintiRound {10}{\xintPow {-11}{-11}}|\dtt{=\xintiRound
    {10}{\xintPow {-11}{-11}}}}
%
Differences between \csa{xintRound}|{0}{f}| and \csa{xintiRound}|{0}{f}|: the
former cannot be used inside integer-only macros, and the latter removes the
decimal point, and never returns |-0| (and removes all superfluous leading
zeroes.)

\subsection{\csbh{xintFloor}, \csbh{xintiFloor}}
\label{xintFloor}\label{xintiFloor}
%{\small New with release |1.09a|.\par}

|\xintFloor {f}|\etype{\Ff} returns the largest relative integer |N| with
|N|${}\leqslant{}$|f|. %
%
\leftedline{|\xintFloor {-2.13}|\dtt{=\xintFloor
    {-2.13}}, |\xintFloor {-2}|\dtt{=\xintFloor {-2}}, |\xintFloor
  {2.13}|\dtt{=\xintFloor {2.13}}
%
}

|\xintiFloor {f}|\etype{\Ff} does the same but without adding the
|/1[0]|. 
%
\leftedline{|\xintiFloor {-2.13}|\dtt{=\xintiFloor
    {-2.13}}, |\xintiFloor {-2}|\dtt{=\xintiFloor {-2}}, |\xintiFloor
  {2.13}|\dtt{=\xintiFloor {2.13}}}

\subsection{\csbh{xintCeil}, \csbh{xintiCeil}}
\label{xintCeil}\label{xintiCeil}
%{\small New with release |1.09a|.\par}

|\xintCeil {f}|\etype{\Ff} returns the smallest relative integer |N| with
|N|${}>{}$|f|. %
%
\leftedline{|\xintCeil {-2.13}|\dtt{=\xintCeil {-2.13}},
  |\xintCeil {-2}|\dtt{=\xintCeil {-2}}, |\xintCeil
  {2.13}|\dtt{=\xintCeil {2.13}}
%
}

|\xintiCeil {f}|\etype{\Ff} does the same but without adding the
|/1[0]|.


\subsection{\csbh{xintTFrac}}\label{xintTFrac}

\csa{xintTFrac}|{f}|\etype{\Ff} returns the fractional part,
|f=trunc(f)+frac(f)|. Thus if |f<0|, then |-1<frac(f)<=0| and if |f>0| one has
|0<= frac(f)<1|. The |T| stands for `Trunc', and there should exist also
similar macros associated respectively with `Round', `Floor', and `Ceil', each
type of rounding to an integer deserving arguably to be associated with a
fractional ``modulo''. By sheer laziness, the package currently implements
only the ``modulo'' associated with `Truncation'. Other types of modulo may be
obtained more cumbersomely via a combination of the rounding with a subsequent
subtraction from |f|.

Notice that the result is filtered through \csbxint{REZ}, and will thus be of
the form |A/B[N]|, where neither |A| nor |B| has trailing zeros. But the
output fraction is not reduced to smallest terms.\MyMarginNote{\noindent
  Do\-cu\-men\-ta\-tion updated.}

The function call in expressions (\csbxint{expr}, \csbxint{floatexpr}) is
|frac|. Inside |\xintexpr..\relax|, the function |frac| is mapped to
\csa{xintTFrac}. Inside |\xintfloatexpr..\relax|, |frac| first applies
\csa{xintTFrac} to its argument (which may be an exact fraction with more
digits than the floating point precision) and only in a second stage makes the
conversion to a floating point number with the precision as set by |\xintDigits|
(default is \dtt{16}).
%
\leftedline{|\xintTFrac {1235/97}|\dtt{=\xintTFrac {1235/97}}\quad
              |\xintTFrac {-1235/97}|\dtt{=\xintTFrac {-1235/97}}}
%
\leftedline{|\xintTFrac {1235.973}|\dtt{=\xintTFrac {1235.973}}\quad
              |\xintTFrac {-1235.973}|\dtt{=\xintTFrac {-1235.973}}}
%
\leftedline{|\xintTFrac {1.122435727e5}|%
       \dtt{=\xintTFrac {1.122435727e5}}}

\subsection{\csbh{xintE}}\label{xintE}
%{\small New with |1.07|.}

|\xintE {f}{x}|\etype{\Ff\numx} multiplies the fraction |f| by $10^x$. The
\emph{second} argument |x| must obey the \TeX{} bounds. Example:
%
\leftedline{|\count 255 123456789 \xintE {10}{\count 255}|\dtt{->\count
    255 123456789 \xintE {10}{\count 255}}} Be careful that for obvious reasons
such gigantic numbers should not be given to \csbxint{Num}, or added to
something with a widely different order of magnitude, as the package always
works to get the \emph{exact} result. There is \emph{no problem} using them for
\emph{float} operations:%
%
\leftedline{|\xintFloatAdd
 {1e1234567890}{1}|\dtt{=\xintFloatAdd {1e1234567890}{1}}}

\subsection{\csbh{xintAdd}}\label{xintAdd}

Computes the addition\etype{\Ff\Ff} of two fractions. To keep for integers the
integer format on output use \csbxint{iAdd}.

Checks if one denominator is a multiple of the other. Else multiplies the
denominators.

\subsection{\csbh{xintSub}}\label{xintSub}

Computes the difference\etype{\Ff\Ff} of two fractions (|\xintSub{F}{G}|
computes |F-G|). To keep for integers the integer format on output use
\csbxint{iSub}.

Checks if one denominator is a multiple of the other. Else multiplies the
denominators.

\subsection{\csbh{xintMul}}\label{xintMul}

Computes the product\etype{\Ff\Ff} of two fractions. To keep for integers the
integer format on output use \csbxint{iMul}.

No reduction attempted.

\subsection{\csbh{xintSqr}}\label{xintSqr}

Computes the square\etype{\Ff} of one fraction. To maintain for integer input
an integer format on output use \csbxint{iSqr}.

\subsection{\csbh{xintDiv}}\label{xintDiv}

Computes the algebraic quotient \etype{\Ff\Ff} of two fractions.
(|\xintDiv{F}{G}| computes |F/G|). To keep for integers the integer format on
output use \csbxint{iMul}.

No reduction attempted.

\subsection{\csbh{xintFac}}\label{xintFac}
%{\small Modified in |1.08b| (to allow fractions on input).\par}

The original\etype{\Numf} is extended to allow a fraction |f| which will be
truncated first to an integer |n|. See \csbxint{iFac} for a discussion of the
maximal allowed input.

Output format is an integer without trailing |/1[0]|.

The original macro\etype{\numx} (which parses its input via |\numexpr|) is
still available as \csbxint{iFac}.

\subsection{\csbh{xintPow}}\label{xintPow}

\csa{xintPow}{|{f}{g}|}:\etype{\Ff\Numf} computes |f^g| with |f| a fraction
and |g| possibly also, but |g| will first get truncated to an integer.

The output will now always be in the form |A/B[n]| (even when the exponent
vanishes: |\xintPow {2/3}{0}|\dtt{=\xintPow{2/3}{0}}).

The original
is available as \csbxint{iPow}.

%%%%% OBSOLETE
% The exponent (after truncation to an integer) will be checked to not exceed
% |100000|. Indeed |2^50000| already has \dtt{\xintLen {\xintFloatPow
%     [1]{2}{50000}}} digits, and squaring such a number would take hours (I
% think) with the expandable routine of \xintname.

\subsection{\csbh{xintSum}}\label{xintSum}\label{xintSumExpr}

% The original commands are extended to accept fractions on input and produce
% fractions on output. Their outputs will now always be in the form |A/B[n]|. The
% originals are available as \csa{xintiiSum} and \csa{xintiiSumExpr}.

This\etype{f{$\to$}{\lowast\Ff}} computes the sum of fractions. The output
will now always be in the form |A/B[n]|. The original, for big integers only
(in strict format), is available as \csa{xintiiSum}.

\begin{everbatim*}
\xintSum {{1282/2196921}{-281710/291927}{4028/28612}}
\end{everbatim*}

No simplification attempted. 

% \subsection{\csbh{xintPrd}, \csbh{xintPrdExpr}}\label{xintPrd}\label{xintPrdExpr}

\subsection{\csbh{xintPrd}}\label{xintPrd}\label{xintPrdExpr}

TThis\etype{f{$\to$}{\lowast\Ff}} computes the product of fractions. The output
will now always be in the form |A/B[n]|. The original, for big integers only
(in strict format), is available as \csa{xintiiPrd}.

\begin{everbatim*}
\xintPrd {{1282/2196921}{-281710/291927}{4028/28612}}
\end{everbatim*}

No simplification attempted. 

\subsection{\csbh{xintCmp}}\label{xintCmp}
%{\small Rewritten in |1.08a|.\par}

This\etype{\Ff\Ff} compares two fractions |F| and |G| and produces 
|-1|, |0|, or |1| according to |F<G|, |F=G|, |F>G|.

For choosing branches according to the result of comparing |f| and |g|, the
following syntax is recommended: |\xintSgnFork{\xintCmp{f}{g}}{code for
  f<g}{code for f=g}{code for f>g}|.

% Note that since release |1.08a| using this macro on inputs with large powers of
% tens does not take a quasi-infinite time, contrarily to the earlier, somewhat
% dumb version (the earlier version indirectly led to the creation of giant chains
% of zeroes in certain circumstances, causing a serious efficiency impact).

\subsection{\csbh{xintIsOne}}

This\etype{\Ff} returns |1| if the fraction is |1| and |0| if not.

\begin{everbatim*}
\xintIsOne {21921379213/21921379213} but \xintIsOne {1.00000000000000000000000000000001}
\end{everbatim*}

\subsection{\csbh{xintGeq}}\label{xintGeq}
%{\small Rewritten in |1.08a|.\par}

This\etype{\Ff\Ff} compares the \emph{absolute values} of two
fractions.|\xintGeq{f}{g}| returns |1| if {\catcode`| 12 $|f|\geqslant|g|$} and |0|
if not.

May be used for expandably branching as:
\verb+\xintSgnFork{\xintGeq{f}{g}}{}{code for |f|<|g|}{code for
  |f|+$\geqslant$\verb+|g|}+

\subsection{\csbh{xintMax}}\label{xintMax}
%{\small Rewritten in |1.08a|.\par}

The maximum of two fractions.\etype{\Ff\Ff} But now |\xintMax {2}{3}|
returns \dtt{\xintMax {2}{3}}. The original, for use with (possibly big)
integers only with no need of normalization, is available as \csbxint{iiMax}:
|\xintiiMax {2}{3}=|\dtt{\xintiMax {2}{3}}.\etype{ff}

There is also \csbxint{iMax}\etype{\Numf\Numf} which works with fractions but
first truncates them to integers.

\begin{everbatim*}
\xintMax {2.5}{7.2} but \xintiMax {2.5}{7.2}
\end{everbatim*}

\subsection{\csbh{xintMin}}\label{xintMin}
%{\small Rewritten in |1.08a|.\par}

The maximum of two fractions.\etype{\Ff\Ff}  The original, for use with (possibly big)
integers only with no need of normalization, is available as \csbxint{iiMin}:
|\xintiiMin {2}{3}=|\dtt{\xintiMin {2}{3}}.\etype{ff}

There is also \csbxint{iMin}\etype{\Numf\Numf} which works with fractions but first
truncates them to integers.

\begin{everbatim*}
\xintMin {2.5}{7.2} but \xintiMin {2.5}{7.2}
\end{everbatim*}

\subsection{\csbh{xintMaxof}}\label{xintMaxof}

The maximum of any number of fractions, each within braces, and the whole
thing within braces. \etype{f{$\to$}{\lowast\Ff}}

\begin{everbatim*}
\xintMaxof {{1.23}{1.2299}{1.2301}} and \xintMaxof {{-1.23}{-1.2299}{-1.2301}}
\end{everbatim*}

\subsection{\csbh{xintMinof}}\label{xintMinof}

The minimum of any number of fractions, each within braces, and the whole
thing within braces. \etype{f{$\to$}{\lowast\Ff}}

\begin{everbatim*}
\xintMinof {{1.23}{1.2299}{1.2301}} and \xintMinof {{-1.23}{-1.2299}{-1.2301}}
\end{everbatim*}

\subsection{\csbh{xintAbs}}\label{xintAbs}

The absolute value\etype{\Ff}. Note that |\xintAbs {-2}|\dtt{=\xintAbs {-2}}
whereas |\xintiAbs {-2}|\dtt{=\xintiAbs {-2}}.

\subsection{\csbh{xintSgn}}\label{xintSgn}

The sign of a fraction.\etype{\Ff} 

\subsection{\csbh{xintOpp}}\label{xintOpp}

The opposite of a fraction. Note that |\xintOpp {3}| now outputs \dtt{\xintOpp
  {3}} whereas |\xintiOpp {3}| returns \dtt{\xintiOpp {3}}.

\subsection{\csbh{xintDigits}, \csbh{xinttheDigits}}
\label{xintDigits}
\label{xinttheDigits}
%{\small New with release |1.07|.\par}

The syntax |\xintDigits := D;| (where spaces do not matter) assigns the
value of |D| to the number of digits to be used by floating point
operations. The default is |16|. The maximal value is |32767|. The macro
|\xinttheDigits|\etype{} serves to print the current value.

\subsection{\csbh{xintFloat}}\label{xintFloat}

%{\small New with release |1.07|.\par}

The macro |\xintFloat [P]{f}|\etype{{\upshape[\numx]}\Ff} has an optional argument |P| which replaces
the current value of |\xintDigits|. The (rounded truncation of the) fraction
|f| is then printed in scientific form, with |P| digits,
a lowercase |e| and an exponent |N|.  The first digit is from |1| to |9|, it is
preceded by an optional minus sign and
is followed by a dot and |P-1| digits, the trailing zeroes
are not trimmed. In the exceptional case where the
rounding went to the next power of ten, the output is |10.0...0eN|
(with a sign, perhaps). The sole exception is for a zero value, which then gets
output as |0.e0| (in an \csa{xintCmp} test it is the only possible output of
\csa{xintFloat} or one of the `Float' macros which will test positive for
equality with zero).
%
\leftedline{|\xintFloat[32]{1234567/7654321}|%
               \dtt{=\xintFloat[32]{1234567/7654321}}}
% \pdfresettimer
%
\leftedline{|\xintFloat[32]{1/\xintFac{100}}|%
               \dtt{=\xintFloat[32]{1/\xintFac{100}}}}
% \the\pdfelapsedtime
% 992: plus rapide que ce que j'aurais cru..

The argument to \csa{xintFloat} may be an |\xinttheexpr|-ession, like the
other macros; only its final evaluation is submitted to \csa{xintFloat}: the
inner evaluations of chained arguments are not at all done in `floating'
mode. For this one must use |\xintthefloatexpr|.

\subsection{\csbh{xintPFloat}}\label{xintPFloat}

The macro |\xintPFloat [P]{f}|\etype{{\upshape[\numx]}\Ff} is like
\csbxint{Float} but ``pretty-prints'' the output, in the sense of dropping the
scientific notation if possible. Here are the rules:
\begin{enumerate}
\item if it is possible to drop the scientific part and express the number as
  a decimal number with the same number of digits as in the significand and a
  decimal mark, it is done so,
\item if the number is less than one and at most four zeros need be inserted
  after the decimal mark to express it without scientific part, it is done
  so,
\item if the number is zero it is printed as \dtt{\xintPFloat{0}}. All other
  cases have either a decimal mark or a scientific part or both.
\item trailing zeros are not trimmed.
\end{enumerate}
\begin{everbatim*}
\begin{itemize}[noitemsep]
\item \xintPFloat {0}
\item \xintPFloat {123}
\item \xintPFloat {0.00004567}
\item \xintPFloat {0.000004567}
\item \xintPFloat {12345678e-12}
\item \xintPFloat {12345678e-13}
\item \xintPFloat {12345678.12345678}
\item \xintPFloat {123456789.123456789}
\item \xintPFloat {123456789123456789}
\item \xintPFloat {1234567891234567}
\end{itemize}
\end{everbatim*}

\subsection{\csbh{xintFloatE}}\label{xintFloatE}
%{\small New with |1.097|.}

|\xintFloatE [P]{f}{x}|\etype{{\upshape[\numx]}\Ff\numx} multiplies the input
|f| by $10^x$, and
converts it to float format according to the optional first argument or current
value of |\xintDigits|.
%
\leftedline{|\xintFloatE {1.23e37}{53}|\dtt{=\xintFloatE {1.23e37}{53}}}

\subsection{\csbh{xintFloatAdd}}\label{xintFloatAdd}

%{\small New with release |1.07|.\par}

|\xintFloatAdd [P]{f}{g}|\etype{{\upshape[\numx]}\Ff\Ff} first replaces |f| and
|g| with their float approximations, with 2 safety digits. It then adds exactly
and outputs in float format with precision |P| (which is optional) or
|\xintDigits| if |P| was absent, the result of this computation.

\subsection{\csbh{xintFloatSub}}\label{xintFloatSub}

%{\small New with release |1.07|.\par}

|\xintFloatSub [P]{f}{g}|\etype{{\upshape[\numx]}\Ff\Ff} first replaces |f| and
|g| with their float approximations, with 2 safety digits. It then subtracts
exactly and outputs in float format with precision |P| (which is optional), or
|\xintDigits| if |P| was absent, the result of this computation.

\subsection{\csbh{xintFloatMul}}\label{xintFloatMul}

%{\small New with release |1.07|.\par}

|\xintFloatMul [P]{f}{g}|\etype{{\upshape[\numx]}\Ff\Ff} first replaces |f| and
|g| with their float approximations, with 2 safety digits. It then multiplies
exactly and outputs in float format with precision |P| (which is optional), or
|\xintDigits| if |P| was absent, the result of this computation.

\begin{framed}
  It is obviously much needed that the author improves its algorithms to avoid
  going through the exact |2P| or |2P-1| digits (plus safety digits) before
  throwing to the waste-bin half of those digits !

  \xintname initially was purely an \emph{exact} arbitrary precision
  arithmetic machine, and the introduction of floating point numbers was an
  after-thought. I got it working in release |1.07 (2013/05/25)| and never had
  time to come back to it.
\end{framed}

\subsection{\csbh{xintFloatDiv}}\label{xintFloatDiv}

%{\small New with release |1.07|.\par}

|\xintFloatDiv [P]{f}{g}|\etype{{\upshape[\numx]}\Ff\Ff} first replaces |f| and
|g| with their float approximations, with 2 safety digits. It then divides
exactly and outputs in float format with precision |P| (which is optional), or
|\xintDigits| if |P| was absent, the result of this computation.

\subsection{\csbh{xintFloatFac}}\label{xintFloatFac}

\csa{xintFloatFac}|[P]{f}|\etype{{\upshape[\numx]}\Ff} returns the
factorial.
\begin{everbatim*}
$1000!\approx{}$\xintFloatFac [30]{1000}
\end{everbatim*}
The computation\NewWith{1.2 !} proceeds via doing explicitely the product, as
the Stirling formula cannot be used for lack so far of |exp/log|.
% \footnote{The computation of $100000!$ with $16$ digits of precision takes
%   about three or four seconds and for $1000000!$ it is about fifty seconds on
%   my laptop (2015/10/06).}
%
There is no a priori limit set on the |P| optional argument, thus the Stirling
approach would become complicated if that freedom was to be obeyed.

The macro |\xintFloatFac| chooses dynamically an appropriate number of
digits for the intermediate computations, large enough to achieve the desired
accuracy (hopefully).

\subsection{\csbh{xintFloatPow}}\label{xintFloatPow}
%{\small New with |1.07|.\par}

|\xintFloatPow [P]{f}{x}|\etype{{\upshape[\numx]}\Ff\numx} uses either the
optional argument |P| or the value of |\xintDigits|. It computes a floating
approximation to |f^x|. The precision |P| must be at least |1|, naturally.

The exponent |x| will be fed to a |\numexpr|, hence count registers are accepted
on input for this |x|. And the absolute value \verb+|x|+ must obey the \TeX{}
bound. For larger exponents use the slightly slower routine \csbxint{FloatPower}
which allows the exponent to be a fraction simplifying to an integer and does
not limit its size. This slightly slower routine is the one to which |^| is
mapped inside |\xintthefloatexpr...\relax|.

The macro |\xintFloatPow| chooses dynamically an appropriate number of
digits for the intermediate computations, large enough to achieve the desired
accuracy (hopefully).

%
\leftedline{|\xintFloatPow [8]{3.1415}{1234567890}|%
               \dtt{=\xintFloatPow [8]{3.1415}{1234567890}}}

\subsection{\csbh{xintFloatPower}}\label{xintFloatPower}
%{\small New with |1.07|.\par}

\csa{xintFloatPower}|[P]{f}{g}|\etype{{\upshape[\numx]}\Ff\Numf} computes a
floating point value |f^g| where the exponent |g| is not constrained to be at
most the \TeX{} bound \texttt{\number "7FFFFFFF}. It may even be a fraction
|A/B| but must simplify to a (possibly big) integer. The exponent of the
\emph{output} however \emph{must} at any rate obey the \TeX{}
\dtt{\number"7FFFFFFF} bound.
%
\leftedline{|\xintFloatPower [8]{1.000000000001}{1e12}|%
  \dtt{=\xintFloatPower [8]{1.000000000001}{1e12}}}
%
\leftedline{|\xintFloatPower [8]{3.1415}{3e9}|%
  \dtt{=\xintFloatPower [8]{3.1415}{3e9}}} Notice that |3e9>2^31|.

Here is another example:
%
\leftedline{|\xintFloatPower [48] {1.1547}{\xintiiPow {2}{35}}|}
%
computes $(1.1547)^{2^{35}}=(1.1547)^{\xintiiPow {2}{35}}$ to be
approximately
%
\leftedline{\dtt{\np{\xintFloatPower [48] {1.1547}{\xintiiPow {2}{35}}}}}
%
Again, $2^{35}$ exceeds \TeX's bound, but \csa{xintFloatPower} allows it, what
counts is the exponent of the result which, while dangerously close to
$2^{31}$ is not quite there yet.\footnote{The printing of the result was done
  via the |\numprint| command from the \url{http://ctan.org/pkg/numprint}
  package.}

Inside an |\xintfloatexpr|-ession, \csa{xintFloatPower} is the function to
which |^| is mapped. Thus the same computation as above can be done via the
non-expandable assignment |\xintDigits:=48;| and
%
\leftedline{|\xintthefloatexpr 1.1547^(2^35)\relax|}
%
There is a subtlety here that the |2^35| will be evaluated as a floating point
number but fortunately it only has \dtt{\xintLen{\xintiiPow{2}{35}}} digits,
hence the final evaluation is done with a correct exponent. It is safer, and
also more efficient to code the above rather as:
%
\leftedline{|\xintthefloatexpr 1.1547^\xintiiexpr 2^35\relax\relax|}
%
to guarantee no loss of digits in the exponent.

There is an important difference between |\xintFloatPower [Q]{X}{Y}| and
|\xintthefloatexpr [Q] X^Y \relax|: in the former case the computation is done
with |Q| digits or precision (but if |X| and |Y| themselves stand for some
floating point macros with arguments, their respective evaluations obey the
precision |\xinttheDigits| or as set optionally in the macro calls
themselves), whereas with \csbxint{thefloatexpr} the evaluation of the
expression proceeds with |\xinttheDigits| digits of precision, and the final
output is rounded to |Q| digits: thus this makes real sense only if used with
|Q<\xinttheDigits|.

The intermediate multiplications executed by |\xintFloatPower| are done with a
higher precision than |\xinttheDigits| or the optional |P| argument, in order
for the final result to have the desired accuracy.
% %
% \footnote{\label{fn:floatpow}%
%   Release |1.2| did not change a single line of code to these macros because
%   they don't access low-level entry points. There is some sure important
%   efficiency gains to be obtained in maintaining internally the best inner
%   format for the successive squarings and multiplications, but I decided to
%   postpone that, as the more urgent issue is to improve \csbxint{FloatMul} to
%   not compute exactly with all digits the product before keeping only the
%   required digits.}
\emph{This means that the error, compared to rounding an exact evaluation, is
  guaranteed to be strictly less than |0.6| floating point unit. The last
  digit may thus be wrong, and if it is |0| or |9| with it the next to last,
  etc... }
% ATTENTION A VERIFIER QUE JE FAIS BIEN CELA.

\subsection{\csbh{xintFloatSqrt}}\label{xintFloatSqrt}
%{\small New with |1.08|.\par}

\csa{xintFloatSqrt}|[P]{f}|\etype{{\upshape[\numx]}\Ff} computes a floating
point approximation of $\sqrt{|f|}$, either using the optional precision |P| or
the value of |\xintDigits|. The computation is done for a precision of at least
17 figures (and the output is rounded if the asked-for precision was smaller).
%
\leftedline{|\xintFloatSqrt [50]{12.3456789e12}|}
%
\leftedline{${}\approx{}$\dtt{\xintFloatSqrt [50]{12.3456789e12}}}
%
\leftedline{|\xintDigits:=50;\xintFloatSqrt {\xintFloatSqrt {2}}|}
%
\leftedline{${}\approx{}$\xintDigits:=50;\dtt{\xintFloatSqrt {\xintFloatSqrt
      {2}}}}

% maple: 0.351364182864446216166582311675807703715914271812431919843183 1O^7
%         3.5136418286444621616658231167580770371591427181243e6
% maple: 1.18920711500272106671749997056047591529297209246381741301900
%        1.1892071150027210667174999705604759152929720924638e0

\xintDigits:=16;

% removed from doc october 22

% \subsection{\csbh{xintSum}, \csbh{xintSumExpr}}\label{xintSum}
% \label{xintSumExpr}

\subsection{\csbh{xintiDivision}, \csbh{xintiQuo}, \csbh{xintiRem},
  \csbh{xintFDg}, \csbh{xintLDg}, \csbh{xintMON}, \csbh{xintMMON},
  \csbh{xintOdd}}

These macros\etype{\Ff\Ff} accept a fraction (or two) on input but will
truncate it (them) to an integer using \csbxint{Num} (which is the same as
\csbxint{TTrunc}). On output they produce integers without |/| nor |[N]|.

All have variants from package \xintname whose names start with |xintii|
rather than |xint|; these variants accept on input only integers in the strict
format (they do not use \csbxint{Num}). They thus have less overhead, and may
be used when one is dealing exclusively with (big) integers.

%
\leftedline{|\xintNum {1e80}|}
%
\leftedline{\dtt{\xintNum{1e80}}}

%\etocdepthtag.toc {xintexpr}

\section{Commands of the \xintexprname package}%
\label{sec:expr}

\localtableofcontents

The \xintexprname package was first released with version |1.07|
(|2013/05/25|) of the \xintname bundle. It was substantially enhanced with
release |1.1| from |2014/10/28|.

Release |1.2| removed a limitation to numbers of at most $5000$ digits, and
there is now a float variant of the factorial. Also the ``pseudo-functions''
|qint|, |qfrac|, |qfloat| (|'q'| for quick), were added to handle very big
inputs and avoid scanning it digit per digit.

The package loads automatically \xintfracname and \xinttoolsname (it is now
the only arithmetic package from the \xintname bundle which loads
\xinttoolsname).
\begin{itemize}
\item for using the |gcd| and |lcm| functions, it is necessary to load package
  \xintgcdname.
\begin{everbatim*}
\xinttheexpr lcm (2^5*7*13^10*17^5,2^3*13^15*19^3,7^3*13*23^2)\relax
\end{everbatim*}
\item for allowing hexadecimal numbers (uppercase letters) on input, it is necessary
  to load package \xintbinhexname.
  \begin{everbatim*}
\xinttheexpr "A*"B*"C*"D*"D*"F, "FF.FF, reduce("FF.FFF + 16^-3)\relax
\end{everbatim*}
\end{itemize}

\begin{framed}
  Despite some enhancements this documentation still has repetitions, is
  a.t.t.o.w generally speaking not well structured, mixes old explanations
  dating back to the first release and some more recent ones.
\end{framed}


\subsection{The \csbh{xintexpr} expressions}\label{xintexpr}%
\label{xinttheexpr}\label{xintthe}

An \xintexprname{}ession is a construct
\csbxint{expr}\meta{expandable\_expression}|\relax|\etype{x} where the
expandable expression is read and completely expanded from left to right.

% NOT THE GOOD LOCATION FOR THIS

% During this parsing, braced sub-content may appear as usual as a macro
% parameter, or as a branch to the |?| two-way and |??| three-way operators.
% Prior to release |1.1|, there were also some other usage, but this has been
% removed. It was mainly needed because there was no other way to feed the
% number parser directtly with fractions in the |A/B[N]| notation which is the
% output format of the \xintfracname macros. There was no real need to use such
% macros anyhow. If one really wants to, one can now directly:
% \begin{everbatim*}
% \xinttheexpr \xintAdd{3/5[2]}{7/13[2]}+199/13[1]\relax
% \end{everbatim*}

An |\xintexpr..\relax| \emph{must} end in a |\relax| (which will be absorbed).
Like a |\numexpr| expression, it is not printable as is, nor can it be directly
employed as argument to the other package macros. For this one must use one
of the two equivalent forms:
\begin{itemize}
\item \csbxint{theexpr}\meta{expandable\_expression}|\relax|\etype{x}, or
\item \csbxint{the}|\xintexpr|\meta{expandable\_expression}|\relax|.\etype{x}
\end{itemize}

The computations are done \emph{exactly}, and with no simplification of the
result. The result can be modified via the functions |round|, |trunc|, |float|,
or |reduce|.%
%
\footnote{In |round| and |trunc| the second optional parameter is the
  number of digits of the fractional part; in |float| it is the total
  number of digits of the mantissa.}
%
Here are some examples\par % DO BETTER EXAMPLES !!!!!!!!!!!!!!!
\leftedline{|\xinttheexpr 1/5!-1/7!-1/9!\relax|%
    \dtt{=\xinttheexpr 1/5!-1/7!-1/9!\relax}}
\leftedline{|\xinttheexpr round(1/5!-1/7!-1/9!,18)\relax|%
    \dtt{=\xinttheexpr round(1/5!-1/7!-1/9!,18)\relax}}
\leftedline{|\xinttheexpr float(1/5!-1/7!-1/9!,18)\relax|%
    \dtt{=\xinttheexpr float(1/5!-1/7!-1/9!,18)\relax}}
\leftedline{|\xinttheexpr reduce(1/5!-1/7!-1/9!)\relax|%
    \dtt{=\xinttheexpr reduce(1/5!-1/7!-1/9!)\relax}}
\leftedline{|\xinttheexpr 1.99^-2 - 2.01^-2 \relax|%
    \dtt{=\xinttheexpr 1.99^-2 - 2.01^-2 \relax}}
\leftedline{|\xinttheexpr round(1.99^-2 - 2.01^-2, 10)\relax|%
    \dtt{=\xinttheexpr round(1.99^-2 - 2.01^-2, 10) \relax}}\par

With |1.1| on has:
\leftedline{|\xinttheiexpr [10] 1.99^-2 - 2.01^-2\relax|%
    \dtt{=\xinttheiexpr [10] 1.99^-2 - 2.01^-2\relax}}


\begin{itemize}
\item the expression may contain arbitrarily many levels of nested parenthesized
  sub-expressions.
\item to let sub-contents evaluate as a sub-unit it should be either
   \begin{enumerate}
   \item parenthesized,
   \item or a sub-expression |\xintexpr...\relax|.
   \end{enumerate}
   When the parser scans a number and hits against either an opening
   parenthesis or a sub-expression it inserts tacitly a |*|.
 \item to either give an expression as argument to the other package macros,
   or more generally to macros which expand their arguments, one must use the
   |\xinttheexpr...\relax| or |\xintthe\xintexpr...\relax| forms. Similarly,
   printing the result itself must be done with these forms.
 \item one should not use |\xinttheexpr...\relax| as a sub-constituent of an
   |\xintexpr...\relax| but rather the |\xintexpr...\relax| form which will be
   more efficient.
 \item each \xintexprname{}ession, whether prefixed or not with |\xintthe|, is
   completely expandable and obtains its result in two expansion steps.
\end{itemize}

In an algorithm implemented non-expandably, one may define macros to
expand to infix expressions to be used within others. One then has the
choice between parentheses or |\xintexpr...\relax|: |\def\x {(\a+\b)}|
or |\def\x {\xintexpr \a+\b\relax}|. The latter is the better choice as
it allows also to be prefixed with |\xintthe|. Furthermore, if |\a| and
|\b| are already defined |\edef\x {\xintexpr \a+\b\relax}| will do the
computation on the spot.% Rather than |\edef| one can use |\oodef|.

\subsection{\csh{xintdefvar}, \csh{xintdeffunc}}
\label{xintdefvar}
\label{xintdefiivar}
\label{xintdeffloatvar}
\label{xintdeffunc}
\label{xintdefiifunc}
\label{xintdeffloatfunc}

It is possible to assign a variable name to let it be known to the parsers of \xintexprname.
\begin{everbatim*}
\xintdefvar Pi:=3.141592653589793238462643;
\xintthefloatexpr Pi^100\relax
\xintdefvar x_1 := 10;\xintdefvar x_2 := 20;\xintdefvar y@3 := 30;
\quad $x_1\cdot x_2\cdot y@3+1=\xinttheiiexpr x_1*x_2*y@3+1\relax$.
\end{everbatim*}
As |x_1x| is a licit variable name, as are |x_1x_| and |x_1x_2| and |x_1x_2y|
etc... we could not count on tacit multiplication being applied to something
like |x_1x_2|; the parser goes not go to the effort of tracing back its steps.
Hence we had to insert explicit |*| infix operators (one often falls into this
trap when playing with variables and counting too much on the divinatory
talents of \xintexprname...).

The variable definition is done with \csa{xintdefvar}, \csa{xintdefiivar}, or
with \csa{xintdeffloatvar}, the variable will be computed using respectively
\csbxint{theexpr}, \csbxint{theiiexpr} or \csbxint{thefloatexpr}. The variable
once defined can be used in the other parsers, except naturally that in
\csa{xintiiexpr} only integers are accepted.

Legal variable names are composed with letters, digits, |@| and |_| signs.
They must start with a letter.\footnote{this is for obvious reasons for digits;
  and names starting with |@| or |_| are reserved to the enjoyment of the
  package author; currently |@|, |@1|, |@2|, |@3|, |@4|, |@@|, |@@@|, |@@@@|
  have special meanings and the |@| and |_| are used internally; you will have
  been warned.} Single letter names |a..z| and |A..Z| are pre-declared by the
package for use as special type of variables called ``dummy variables''. Once
a Latin letter has been redefined by the user it is (currently) impossible to
``unassign'' it to let it be again usable as dummy letter. One can only
redeclare it with a new value.

Variable declarations are local.\IMPORTANT{}

Since release |1.2c| it is possible to also declare functions:
\begin{everbatim*}
\xintdeffunc 
  rump(x,y):=1335y^6/4+x^2(11x^2y^2-y^6-121y^4-2)+11y^8/2+x/2y;
\end{everbatim*}(notice the numerous tacit multiplications in this expression;
and that |x/2y| is interpreted as |x/(2y)|.) Let's try the famous
\textsc{Rump} test:
\begin{everbatim*}
\xinttheexpr rump(77617,33096)\relax.
\end{everbatim*}
Nothing problematic for an \emph{exact} evaluation, naturally !

\begin{framed}
  The names of the macros \csa{xintdeffunc}, \csa{xintdefiifunc},
  \csa{xintdeffloatfunc} (and those for variables) as well as their syntax
  (with |:=| and an ending |;|) will be set definitely only in next release.
  \footnotemark
\end{framed}
\footnotetext{with the current syntax, the |;| as used for |iter|, |rseq|,
  |rrseq| must be hidden as |{;}| to not be confused with the |;| ending the
  declaration.}

A function may be declared either via \csa{xintdeffunc}, \csa{xintdefiifunc},
\csa{xintdeffloatfunc}. It will then be known \emph{only} to the parser which
was used for its definition.

Thus to test the \textsc{Rump} polynomial (it is not quite a polynomial with
its |x/2y| final term) with floats, we \emph{must} also
declare |rump| as a function to be used there:
\begin{everbatim*}
\xintdeffloatfunc 
  rump(x,y):=333.75y^6+x^2(11x^2y^2-y^6-121y^4-2)+5.5y^8+x/2y;
\end{everbatim*}
(I used coefficients |333.75| and |5.5| rather than fractions only because this
is how I saw the polynomial defined in one computer class reference found on
internet; and for float operations this may matter on the rounding).

The numbers are scanned with the current precision, hence as here it is
\dtt{16}, they are scanned exactly in this case. We can then vary the
precision for the evaluation.
\begin{everbatim*}
\def\CR{\cr}
\halign  
{\tabskip1ex
\hfil\bfseries#&\xintDigits:=\xintiloopindex;\xintthefloatexpr rump(77617,33096)#\cr
\xintiloop [8+1]
\xintiloopindex &\relax\CR
\ifnum\xintiloopindex<40 \repeat
}
\end{everbatim*}

It is licit to overload a variable name (all Latin letters are predefined as
dummy variables) with a function name and vice versa. The parsers will decide
from the context if the function or variable interpretation must be used
(dropping various cases of tacit multiplication as normally applied).
\begin{everbatim*}
\xintdefiifunc f(x):=x^3;
\xinttheiiexpr add(f(f),f=100..120)\relax\newline
\xintdeffunc f(x,y):=x^2+y^2;
\xinttheexpr mul(f(f(f,f),f(f,f)),f=1..10)\relax
\end{everbatim*}

The mechanism for functions is identical with the one underlying the
\csbxint{NewExpr} command. A function once declared is a first class citizen,
its expression is entirely parsed and converted into a big nested \fexpan
dable macro. When used its action is via this defined macro.

Starting with |1.2d| the definitions made by \csbxint{NewExpr} have local
scope, hence this is also the case with the definitions made by
\csbxint{deffunc}.\IMPORTANT


As is the case for \csbxint{NewExpr}, there are some restrictions in the
allowed syntax. Particularly dummy variables may be used only with value lists
not depending upon the arguments of the function to be declared. For example
|\xintdeffunc f(x):=add(i^2,i=1..x);| is illegal (the definition of |f| goes
through, but the function generates low-level \TeX{} errors on use, because
the constructed underlying macro does not make sense). As an Ersatz, one may
in this case use the alternative syntax allowed by list operations:
\begin{everbatim*}
\xintdeffunc f(x):=`+`([1..x]^2);
\xinttheexpr seq(f(x), x=1..20)\relax
\end{everbatim*}\newline
The two syntaxes here are anyhow roughly equivalent: both first generate
explicitely the list of integers from one to |x|. Side remark: as the
|seq(f(x), x=1..10)| does many times the same computations, an |rseq| here
would be more efficient:\footnote{see the next section for the explanation of
  the syntax. Note that |omit| and |abort| are not usable in |add| or |mul|
  (currently).}
\begin{everbatim*}
\xinttheexpr rseq(1; (x>20)?{abort}{@+x^2}, x=2++)\relax
\end{everbatim*}
% . But
% |add((i>x)?{abort}{i^2}, i=1++)| can be used in an expression  but currently
% can't be converted into a function, simply because there is no available
% \fexpan dable macro in \xintexprname to do the job.
% il y a un problme je ne sais pas si c'est normal
% si c'est normal il n'y a pas de abort ou omit dans add/mul
% \begin{everbatim*}
% \xinttheexpr seq(add((i>x)?{abort}{i^2}, i=1++), x=1..10)\relax
% \end{everbatim*}

On the other hand a construct like |\xintdeffunc f(x):= add(x^i, i=1..10);|
has no such issue and works out of the box.
\begin{everbatim*}
\xintdefiifunc f(x):=add(x^i, i=0..10);
\xinttheiiexpr seq(f(n), n=0..10)\relax
\end{everbatim*}

%Sorry about the brevity of the documentation, it will be completed at a later
%date.

With |\xintverbosetrue| the values of the variables and the meaning of the
functions (or rather their associated macros) will be written to the log. For
example the first |rump| declaration above generates this in the log file:
\begin{everbatim}
    Function rump for \xintexpr parser associated to \XINT_expr_userfunc_rump w
ith meaning macro:#1,#2,->\romannumeral `^^@\xintAdd {\xintAdd {\xintAdd {\xint
Div {\xintMul {1335}{\xintPow {#2}{6}}}{4}}{\xintMul {\xintPow {#1}{2}}{\xintSu
b {\xintSub {\xintSub {\xintMul {\xintMul {11}{\xintPow {#1}{2}}}{\xintPow {#2}
{2}}}{\xintPow {#2}{6}}}{\xintMul {121}{\xintPow {#2}{4}}}}{2}}}}{\xintDiv {\xi
ntMul {11}{\xintPow {#2}{8}}}{2}}}{\xintDiv {#1}{\xintMul {2}{#2}}}
\end{everbatim}


\subsection{The syntax}\label{ssec:syntax}

An expression is enclosed between either \csbxint{expr}, or \csbxint{iexpr},
or \csbxint{iiexpr}, or \csbxint{floatexpr}, or \csbxint{boolexpr} and a
\emph{mandatory} ending |\relax|. An expression may be a sub-unit of another
one.

Apart from \csbxint{floatexpr} the evaluations of algebraic operations are
\emph{exact}. The variant \csbxint{iiexpr} does not know fractions and is
provided for integer-only calculations. The variant \csbxint{iexpr} is exactly
like \csbxint{expr} except that it either rounds the final result to an
integer, or in case of an optional parameter |[d]|, rounds to a fixed point
number with |d| digits after decimal mark. The variant \csbxint{floatexpr}
does float calculations according to the current value of the precision set by
|\xintDigits|.

The whole expression should be prefixed by |\xintthe| when it is destined to
be printed on the typeset page, or given as argument to a macro (assuming this
macro systematically expands its argument). As a shortcut to
|\xintthe\xintexpr| there is |\xinttheexpr|. One gets used to not forget the
two |t|'s.

|\xintexpr|-essions and |\xinttheexpr|-essions are completely expandable, in two steps.

\begin{itemize}[parsep=0pt, labelwidth=\leftmarginii,
  itemindent=0pt, listparindent=\leftmarginiii, leftmargin=\leftmarginii]
\item An expression is built the standard way with opening and closing
  parentheses, infix operators, and (big) numbers, with possibly a fractional
  part, and/or scientific notation (except for \csbxint{iiexpr} which only
  admits big integers). All variants work with comma separated expressions. On
  output each comma will be followed by a space. A decimal number must have
  digits either before or after the decimal mark.%\MyMarginNote{Changed!}

\item as everything gets expanded, the characters |.|, |+|, |-|, |*|, |/|, |^|,
  |!|, |&|, \verb+|+, |?|, |:|, |<|, |>|, |=|, |(|, |)|, |"|, |]|, |[|, |@|
  and the comma |,| should not (if used in the expression) be active. For
  example, the French language in |Babel| system, for pdf\LaTeX, activates |!|,
  |?|, |;| and |:|. Turn off the activity before the expressions.

  Alternatively the command \csbxint{exprSafeCatcodes} resets all
  characters potentially needed by \csbxint{expr} to their standard catcodes
  and \csbxint{exprRestoreCatcodes} restores the status prevailing at the time
  of the previous \csa{xintexprSafeCatcodes}.

\item The infix operators are |+|, |-|, |*|, |/|, |^| (or |**|) for exact or
  floating point algebra (only integer exponents for power operations), |&&|
  and \verb+||+ \footnote{with releases earlier than |1.1|, only single
    character operators |&| and \verb+|+ were available, because the parser
    did not handle multi-character operators. Their usage in this rle is now
    deprecated,\IMPORTANT{} as they may be assigned some new meaning in the
    future.} for combining ``true'' (non zero) and ``false'' (zero)
  conditions, as can be formed for example with the |=| (or |==|), |<|, |>|,
  |<=|, |>=|, |!=| comparison operators.

\item The |!| is either a
  function (the logical not) requiring an argument within parentheses, or a
  post-fix operator which does the factorial. In \csbxint{floatexpr} it is
  mapped to \csbxint{FloatFac}, else it computes the exact factorial.

\item The |?| may serve either as a function (the truth value) requiring an
  argument within parentheses), or as two-way post-fix branching operator
  |(cond)?{YES}{NO}|. The false branch will \emph{not} be evaluated. 

\item There is also |??| which branches according to the scheme
  |(x)??{<0}{=0}{>0}|.

\item Comma separated lists may be generated with |a..b| and |a..[d]..b| and
  they may be manipulated to some extent once put into bracket. There is no
  real concept of a list object, nor list operations, although itemwise
  manipulation are made possible as shown below via the |[..]| constructor.
  There is no notion of an ``nuple'' object. The variable |nil| is reserved,
  it represents an empty list.
  \begin{itemize}
  \item |a..b| constructs the \textbf{small} integers from $\lceil a\rceil$ to
    $\lfloor b\rfloor$ (possibly a decreasing sequence),
\begin{everbatim*}
\xinttheexpr 1.5..11.23\relax
\end{everbatim*}
  
   \item |a..[d]..b| allows big integers, or fractions, it proceeds by step of |d|.
\begin{everbatim*}
\xinttheexpr 1.5..[0.97]..11.23\relax
\end{everbatim*}

  \item |[list][n]| extracts the |n|th element, or give the number of items if
    |n=0|. If |n<0| it extracts from the tail.
\begin{everbatim*}
\xinttheiexpr \empty[1..10][6], [1..10][0], [1..10][-1], [1..10][23*18-22*19]\relax\
(and 23*18-22*19 has value \the\numexpr 23*18-22*19\relax).
\end{everbatim*}

See the frame coming next for the |\empty| token.
As shown, it is perfectly legal to do operations in the index parameter, which
will be handled by the parser as everything else. The same remark applies to
the next items. 

  \item |[list][:n]| extracts the first |n| elements if |n>0|, or suppresses
    the last \verb+|n|+ elements if |n<0|.
\begin{everbatim*}
\xinttheiiexpr [1..10][:6]\relax\ and \xinttheiiexpr [1..10][:-6]\relax
\end{everbatim*}
  \item |[list][n:]| suppresses the first |n| elements if |n>0|, or extracts
    the last \verb+|n|+ elements if |n<0|.
\begin{everbatim*}
\xinttheiiexpr [1..10][6:]\relax\ and \xinttheiiexpr [1..10][-6:]\relax
\end{everbatim*}
\item More generally, |[list][a:b]| works according to the Python ``slicing''
  rules (inclusive of negative indices). Notice though that there is no
  optional third argument for the step, which always defaults to |+1|.
\begin{everbatim*}
\xinttheiiexpr [1..20][6:13]\relax\ = \xinttheiiexpr [1..20][6-20:13-20]\relax
\end{everbatim*}
\item It is naturally possible to nest these things:
\begin{everbatim*}
\xinttheexpr [[1..50][13:37]][10:-10]\relax
\end{everbatim*}
\item itemwise operations either on the left or the right are possible:
\begin{everbatim*}
\xinttheiiexpr 123*[1..10]^2\relax
\end{everbatim*}

\begin{snugframed}
  As list operations are implemented using square brackets, it is
  necessary in |\xintiexpr| and |\xintfloatexpr| to insert something before
  the first bracket if it belongs to a list, to avoid confusion with the
  bracket of an optional parameter. We need something expandable which does
  not leave a trace: the |\empty| does the trick.\IMPORTANT{}

\begin{everbatim*}
\xinttheiexpr \empty [1,3,6,99,100,200][2:4]\relax
\end{everbatim*}

   An alternative is to use parentheses
\begin{everbatim*}
\xinttheiexpr ([1,3,6,99,100,200][2:4])\relax
\end{everbatim*}

   Notice though that |([1,3,6,99,100,200])[2:4]| would not work. It is
   mandatory for |][| and |][:| not to be interspersed with parentheses. On
   the other hand spaces are perfectly legal:
\begin{everbatim*}
\xinttheiiexpr [1..10 ]   [  :  7  ]\relax
\end{everbatim*}

Similarly all the |+[|, |*[|, \dots and |]**|, |]/|, \dots operators admit
spaces but nothing else in-between their constituent characters.
\begin{everbatim*}
\xinttheiiexpr [ 1 . . 1 0 ]  * *  1 1 \relax
\end{everbatim*}

  In an other vein, the parser will be confused by |1..[list][3]|, one must
  write |1..([list][3])|. Also things such as |[100,300,500,700][2]//11| will
  be confusing because the |]/| is an operator with higher priority than the
  |][|, and then there will a dangling |/11| which does not make sense. In
  fact even |[100,300,500,700][2]/11| is a syntax error: one must write
  |([100,300,500,700][2])//11|.
\end{snugframed}

\end{itemize}

\item count registers and |\numexpr|-essions are accepted (LaTeX{}'s counters
  can be inserted using |\value|) natively without |\the| or |\number| as
  prefix. Also dimen registers and control sequences, skip registers and
  control sequences (\LaTeX{}'s lengths), |\dimexpr|-essions,
  |\glueexpr|-essions are automatically unpacked using |\number|, discarding
  the stretch and shrink components and giving the dimension value in |sp|
  units ($1/65536$th of a \TeX{} point). Furthermore, tacit multiplication is
  implied, when the (count or dimen or glue) register or variable, or the
  (|\numexpr| or |\dimexpr| or |\glueexpr|) expression is immediately prefixed
  by a (decimal) number.

\item \hypertarget{item:tacit}{tacit multiplication} applies (insertion of a |*|) when the parser is
  currently scanning the digits of a number (or its decimal part or scientific
  part), or is looking
  for an infix operator, and: (1.)~\emph{encounters a register,
  count or dimen variable or \eTeX{} expression (as described in the previous
  item)}, or
  (2.)~\emph{encounters a sub-\csa{xintexpr}-ession}, or
  (3.)~\emph{encounters an opening parenthesis}, or
  (4.)~\emph{encounters a letter signaling the start of a variable or function
  name}.

  \begin{framed}
    In particular tacit multiplication in front of a letter applies also after
    a closing parenthesis, for example with inputs such as
    |(x+y)z|\MyMarginNote[\kern\dimexpr\FrameSep+\FrameRule\relax]{Changed}
    whereas earlier releases applied it in front of variables or functions
    only when a letter was encountered while gathering the digits of some
    number (the special |@|, |@1|, ... variables used by |iter|, |rseq|, ...
    already had this property now extended to all variable and function
    names).
  
    Furthermore starting with release
    |1.2d|,\MyMarginNote[\kern\dimexpr\FrameSep+\FrameRule\relax]{Changed}
    whenever tacit multiplication is applied it \emph{always} ``ties''
    more\IMPORTANT{} than normal multiplication or division, but still less
    than power. Thus |x/2y| is interpreted as |x/(2y)| and similarly for
    |x/2max(3,5)| but |x^2y| is still interpreted as |(x^2)*y| and |2n!| as
    |2*n!|.

\begin{everbatim*}
\xintdefvar x:=30;\xintdefvar y:=5;%
\xinttheexpr (x+y)x, x/2y, x^2y, x!, 2x!, x/2max(x,y)\relax
\end{everbatim*}

    The ``tye more'' rule applies to all cases of tacit multiplication:
\begin{everbatim*}
\xinttheexpr (1+2)/(3+4)(5+6), (1+1)^(3)(7)\relax
\end{everbatim*}

    The example above redeclared the |x| and |y| which thus can not be used as
    dummy variables anymore, but as this was done inside a \LaTeX{}
    environment (for the frame), they will have recovered their meanings after
    the frame. In the meantime we use letter |z| for next example. Beware that
    the ``tye more'' property of |1.2d| tacit multiplication has consequently
    impacted the way certain expressions are parsed. This definition
\begin{everbatim}
\xintdeffunc e(z):=1+z(1+z/2(1+z/3(1+z/4)));
\end{everbatim}will have been parsed as |1+z(1+z/(2*(1+z/(3*(1+z/4)))))| due to the new
    rule. Thus one should use (for the presumably expected result following
    from the left associativity rule in case of equal precedence):
\begin{everbatim}
\xintdeffunc e(z):=1+z(1+z/2*(1+z/3*(1+z/4)));
\end{everbatim}

    On the other hand, the following input would not have been legal syntax in
    \xintexprname |1.2c| or earlier, due to the missing |*|'s:
\begin{everbatim*}
\xintdeffunc 
     e(z):=(((((((((z/10+1)z/9+1)z/8+1)z/7+1)z/6+1)z/5+1)z/4+1)z/3+1)z/2+1)z+1;
\end{everbatim*}
     because no tacit multiplication happened in front of variables after a
     closing parenthesis. Perhaps you want to see the meaning of the
     associated macro ? Here it is:
\begin{everbatim}
    Function e for \xintexpr parser associated to \XINT_expr_userfunc_e with me
aning macro:#1,->\romannumeral `^^@\xintAdd {\xintMul {\xintAdd {\xintDiv {\xin
tMul {\xintAdd {\xintDiv {\xintMul {\xintAdd {\xintDiv {\xintMul {\xintAdd {\xi
ntDiv {\xintMul {\xintAdd {\xintDiv {\xintMul {\xintAdd {\xintDiv {\xintMul {\x
intAdd {\xintDiv {\xintMul {\xintAdd {\xintDiv {\xintMul {\xintAdd {\xintDiv {#
1}{10}}{1}}{#1}}{9}}{1}}{#1}}{8}}{1}}{#1}}{7}}{1}}{#1}}{6}}{1}}{#1}}{5}}{1}}{#1
}}{4}}{1}}{#1}}{3}}{1}}{#1}}{2}}{1}}{#1}}{1}
\end{everbatim}

     Attention! tacit multiplication after a closing parenthesis \emph{does
       not} apply in front of digits: |(1+1)5| is not legal. But
     |subs((1+1)x,x=5)| is, because in that case a variable is following the
     closing parenthesis.
  \end{framed}

\item when defining a macro to expand to an expression either via
  %
  \leftedline{|\def\x {\xintexpr \a + \b \relax}| or |\edef\x {\xintexpr
      \a+\b\relax}|}
  %
  one may then do |\xintthe\x|, either for printing the result on the page or
  to use it in some other macros expanding their arguments. The |\edef| does
  the computation but keeps it in an internal private format. Naturally, the
  |\edef| is only possible if |\a| and |\b| are already defined, either as
  macros expanding to legal syntax like |37^23*17| or themselves in the same
  way |\x| above was defined. Indeed in both cases (the `yet-to-be computed'
  and the `already computed') |\x| can then be inserted in other expressions,
  as for example
  %
  \leftedline {|\edef\y {\xintexpr \x^3\relax}|}
  %
  This would have worked also with |\x| defined as |\def\x {(\a+\b)}| but
  |\edef\x| would not have been an option then, and |\x| could have been used
  only inside an |\xintexpr|-ession, whereas the previous |\x| can also be
  used as |\xintthe\x| in any context triggering the expansion of |\xintthe|.

\item there is also \csbxint{boolexpr}| ... \relax| and
  \csbxint{theboolexpr}| ... \relax|. Same as |\xintexpr| with the final
  result converted to $1$ if it is not zero. See also
  \csbxint{ifboolexpr} (\autoref{xintifboolexpr}) and the
  \hyperlink{item:bool}{discussion} of the |bool| and |togl| functions
  in \autoref{sec:expr}. Here is an example:
\catcode`| 12 % \xintNewBoolExpr le fait mais a sera trop tard
                      % aprs le \scantokens qui aura redonn  | son
                      % caractre actif... avant j'utilisais ici \everb
                      % avec dlimiteur !
\begin{everbatim*}
\xintNewBoolExpr \AssertionA[3]{ #1 && (#2|#3) }
\xintNewBoolExpr \AssertionB[3]{ #1 || (#2&#3) }
\xintNewBoolExpr \AssertionC[3]{ xor(#1,#2,#3) }
{\centering\normalcolor\xintFor #1 in {0,1} \do {%
  \xintFor #2 in {0,1} \do {%
    \xintFor #3 in {0,1} \do {%
    #1 AND (#2 OR #3) is \textcolor[named]{OrangeRed}{\AssertionA {#1}{#2}{#3}}\hfil
    #1 OR (#2 AND #3) is \textcolor[named]{OrangeRed}{\AssertionB {#1}{#2}{#3}}\hfil
    #1 XOR #2 XOR #3  is \textcolor[named]{OrangeRed}{\AssertionC {#1}{#2}{#3}}\\}}}}
\end{everbatim*}\catcode`| 13

   This example used for efficiency \csbxint{NewBoolExpr}. See also the
   \autoref{xintNewExpr}. 

\item there is  \csbxint{floatexpr}| ... \relax| where the algebra is done
  in floating point approximation (also for each intermediate result). Use the
  syntax |\xintDigits:=N;| to set the precision. Default: $16$ digits.
  %
  \leftedline{|\xintthefloatexpr 2^100000\relax:| \dtt{\xintthefloatexpr
      2^100000\relax }} 
  %
  The square-root operation can be used in |\xintexpr|, it is computed
  as a float with the precision set by |\xintDigits| or by the optional
  second argument:
  %
\begin{everbatim*}
\xinttheexpr sqrt(2,60)\relax

Here the [60] is to avoid truncation to |\xintDigits| of precision on output.
\printnumber{\xintthefloatexpr [60] sqrt(2,60)\relax}
\end{everbatim*}
  
\item 
  Floats are quickly indispensable when using the power function (which
  can only have an integer exponent), as exact results will easily have
  hundreds, if not thousands, of digits.
  %
\begin{everbatim*}
\xintDigits:=48;\xintthefloatexpr 2^100000\relax
\end{everbatim*}

\item hexadecimal \TeX{} number denotations (\emph{i.e.}, with a |"| prefix)
  are recognized by the |\xintexpr| parser and its variants. \fbox{This
    requires \xintbinhexname}. Except in |\xintiiexpr|, a (possibly empty)
  fractional part with the dot |.| as ``hexadecimal'' mark is allowed.
  %
  \leftedline{|\xinttheexpr "FEDCBA9876543210\relax|$\to$\dtt{\xinttheexpr
    "FEDCBA9876543210\relax}}
  %
  \leftedline{|\xinttheiexpr
    16^5-("F75DE.0A8B9+"8A21.F5746+16^-5)\relax|$\to$\dtt{\xinttheiexpr
      16^5-("F75DE.0A8B9+"8A21.F5746+16^-5)\relax}}
  %
  Letters must be uppercased, as with standard \TeX{} hexadecimal
  denotations.
\end{itemize}


Note that |2^-10| is perfectly accepted input, no need for parentheses; and
that operators of power |^|, division |/|, and subtraction |-| are all
left-associative: |2^4^8| is evaluated as |(2^4)^8|. The minus sign as prefix
has various precedence levels: |\xintexpr -3-4*-5^-7\relax| evaluates as
|(-3)-(4*(-(5^(-7))))| and |-3^-4*-5-7| as |(-((3^(-4))*(-5)))-7|.

An exception to left associativity is applied in case of tacit multiplication
in front of a variable or function name: |x/2y| is interpreted as |x/(2y)|,
not as |(x/2)*y|.

If one uses directly macros within |\xintexpr..\relax|, rather than the
operators or the functions which are described next, one should obviously take
into account that the parser will \emph{not} see the macro arguments.

Here is, listed from the highest priority to the lowest, the complete list of
operators and functions. 

% \ctexttt is a remnant of 1.09n manual, don't have time to get rid of it now.

\newcommand\ctexttt [1]{\begingroup\color[named]{DarkOrchid}%\bfseries
                        #1\endgroup}

\begin{itemize}[parsep=0pt, labelwidth=\leftmarginii,
  itemindent=0pt, listparindent=\leftmarginiii,
  leftmargin=\leftmarginii]
\item
  Functions are at the same top level of priority. All functions even
  |?| and |!| (as prefix) require parentheses around their arguments.

    \begin{snugframed}
      \ctexttt{num, qint, qfrac, qfloat, reduce, abs, sgn, frac, floor, ceil,
        sqr, sqrt, sqrtr, float, round, trunc, mod, quo, rem, gcd, lcm, max,
        min, `+`, `*`, ?, !, not, all, any, xor, if, ifsgn, even, odd, first,
        last, reversed, bool, togl, add, mul, seq, subs, rseq, rrseq, iter}

      |quo|, |rem|, |even|, |odd|, |gcd| and |lcm| will first truncate their
      arguments to integers; the latter two require package \xintgcdname;
      |togl| requires the |etoolbox| package; |all|, |any|, |xor|, |`+`|,
      |`*`|, |max| and |min| are functions with arbitrarily many comma
      separated arguments.

      |bool|, |togl| use delimited macros to fetch their argument and the
      closing parenthesis which thus must be explicit, not arising from
      expansion.

      The same holds for |qint|, |qfrac|, |qfloat|.\NewWith{1.2} 

      Similarly |add|, |mul|, |subs|, |seq|, |rseq|, |rrseq|, |iter| use at
      some stages delimited macros. They work with \emph{dummy variables},
      represented as one Latin letter (lowercase or uppercase) followed by a
      mandatory |=| sign, then a comma separated list of values to assign in
      turn to the dummy variable, which will be substituted in the expression
      which was parsed as the first, comma delimited, argument to the
      function; additionally |rseq|, |rrseq| and |iter| have a mandatory
      initial comma separated list which is separated by a semi-colon from the
      expression to evaluate iteratively. |seq|, |rseq|, |rrseq|, |iter| but
      not |add|, |mul|, |subs| admit the |omit|, |abort|, and |break(..)|
      keywords, possibly but not necessarily in combination with a potentially
      infinite list generated by a |n++| expression.

      They may be nested.
    \end{snugframed}

\begin{description}[leftmargin=0pt]
  \item[functions with a single (numeric) argument] 
\noindent\par
\begin{description}
  \item[num] truncates to the nearest integer (truncation towards zero).
\begin{everbatim*}
\xinttheexpr num(3.1415^20)\relax
\end{everbatim*}

  \item[qint] skips the token by token parsing of the input. The ending
    parenthesis must be physically present rather than arising from
    expansion.\NewWith{1.2} The |q| stands for ``quick''. This ``function''
    handles the input exactly like do the |i| macros of \xintcorename, via
    \csbxint{iNum}. Hence leading signs and the leading zeroes (coming next)
    will be handled appropriately but spaces will not be systematically
    stripped. They should cause no harm and will be removed as soon as the
    number is used with one of the basic operators. This input form \emph{does
      not accept decimal part or scientific part}.
\begin{everbatim}
\def\x{....many many many ... digits}\def\y{....also many many many digits...}
\xinttheiiexpr qint(\x)*qint(\y)+qint(\y)^2\relax
\end{everbatim}

  \item[qfrac] does the same as \dtt{qint} excepts that it accepts fractions,
    decimal numbers, scientific numbers as they are understood by the macros of
    package\NewWith{1.2} \xintfracname. Not to be used within an
    |\xintiiexpr|-ession, except if hidden inside functions such as
    \dtt{round} or \dtt{trunc} which produce integers from fractions.

  \item[qfloat] does the same as \dtt{qfrac} and converts to a float with the
    precision given by the setting of |\xintDigits|.

  \item[reduce] reduces a fraction to smallest terms
\begin{everbatim*}
\xinttheexpr reduce(50!/20!/20!/10!)\relax
\end{everbatim*}

Recall that this is NOT done automatically, for example when adding fractions.
  \item[abs] absolute value
  \item[sgn] sign
  \item[frac] fractional part
\begin{everbatim*}
\xinttheexpr frac(-355/113), frac(-1129.218921791279)\relax
\end{everbatim*}

  \item[floor] floor function
  \item[ceil]  ceil function
  \item[sqr]   square
  \item[sqrt]  in |\xintiiexpr|, truncated square root; in |\xintexpr| or
    |\xintfloatexpr| this is the floating point square root, and there is an
    optional second argument for the precision. 
  \item[sqrtr] in |\xintiiexpr| only, rounded square root.
  \item[?] |?(x)| is the truth value, $1$ if non zero, $0$ if zero. Must use parentheses.
  \item[!] |!(x)| is logical not, $0$ if non zero, $1$ if zero. Must use parentheses.
  \item[not] logical not
  \item[even] evenness of the truncation
\begin{everbatim*}
\xinttheexpr seq((x,even(x)), x=-5/2..[1/3]..+5/2)\relax
\end{everbatim*}

  \item[odd] oddness of the truncation
\begin{everbatim*}
\xinttheexpr seq((x,odd(x)), x=-5/2..[1/3]..+5/2)\relax
\end{everbatim*}
\end{description}

\item[functions with an alphabetical argument]
\noindent\par
    \hypertarget{item:bool}{\ctexttt{bool,togl}}. |bool(name)| returns
    $1$ if the \TeX{} conditional |\ifname| would act as |\iftrue| and
    $0$ otherwise. This works with conditionals defined by |\newif| (in
    \TeX{} or \LaTeX{}) or with primitive conditionals such as
    |\ifmmode|. For example:
    %
    \leftedline{|\xintifboolexpr{25*4-if(bool(mmode),100,75)}{YES}{NO}|}
    %
    will return $\xintifboolexpr{25*4-if(bool(mmode),100,75)}{YES}{NO}$
    if executed in math mode (the computation is then $100-100=0$) and
    \xintifboolexpr{25*4-if(bool(mmode),100,75)}{YES}{NO} if not (the
    \ctexttt{if} conditional is described below; the
    \csbxint{ifboolexpr} test automatically encapsulates its first
    argument in an |\xintexpr| and follows the first branch if the
    result is non-zero (see \autoref{xintifboolexpr})).

    The alternative syntax |25*4-\ifmmode100\else75\fi| could have been
    used here, the usefulness of |bool(name)| lies in the availability
    in the |\xintexpr| syntax of the logic operators of conjunction
    |&&|, inclusive disjunction \verb+||+, negation |!| (or |not|), of
    the multi-operands functions |all|, |any|, |xor|, of the two
    branching operators |if| and |ifsgn| (see also |?| and |??|), which
    allow arbitrarily complicated combinations of various |bool(name)|.

    Similarly |togl(name)| returns $1$ if the \LaTeX{} package
    \href{http://www.ctan.org/pkg/etoolbox}{etoolbox}%
    %
    %
%
\footnote{\url{http://www.ctan.org/pkg/etoolbox}}
    %
    has been used to define a toggle named |name|, and this toggle is
    currently set to |true|. Using |togl| in an |\xintexpr..\relax|
    without having loaded
    \href{http://www.ctan.org/pkg/etoolbox}{etoolbox} will result in an
    error from |\iftoggle| being a non-defined macro. If |etoolbox| is
    loaded but |togl| is used on a name not recognized by |etoolbox|
    the error message will be of the type ``ERROR: Missing |\endcsname|
    inserted.'', with further information saying that |\protect| should
    have not been encountered (this |\protect| comes from the expansion
    of the non-expandable |etoolbox| error message).

    When |bool| or |togl| is encountered by the |\xintexpr| parser, the
    argument enclosed in a parenthesis pair is expanded as usual from
    left to right, token by token, until the closing parenthesis is
    found, but everything is taken literally, no computations are
    performed. For example |togl(2+3)| will test the value of a toggle
    declared to |etoolbox| with name |2+3|, and not |5|. Spaces are
    gobbled in this process. It is impossible to use |togl| on such
    names containing spaces, but |\iftoggle{name with spaces}{1}{0}|
    will work, naturally, as its expansion will pre-empt the
    |\xintexpr| scanner.

    There isn't in |\xintexpr...| a |test| function available analogous
    to the |test{\ifsometest}| construct from the |etoolbox| package;
    but any \emph{expandable} |\ifsometest| can be inserted directly in
    an |\xintexpr|-ession as |\ifsometest10| (or |\ifsometest{1}{0}|),
    for example |if(\ifsometest{1}{0},YES,NO)| (see the |if| operator
    below) works.

    A straight |\ifsometest{YES}{NO}| would do the same more
    efficiently, the point of |\ifsometest10| is to allow arbitrary
    boolean combinations using the (described later) \verb+&+ and
    \verb+|+ logic operators:
    \verb+\ifsometest10 & \ifsomeothertest10 | \ifsomethirdtest10+,
    etc... |YES| or |NO| above stand for material compatible with the
    |\xintexpr| parser syntax.

    See  also \csbxint{ifboolexpr}, in this context.

\item[functions with one mandatory and a second but optional argument]
\noindent\par
  \begin{description}
  \item[round] For example
    |round(-2^9/3^5,12)=|\dtt{\xinttheexpr round(-2^9/3^5,12)\relax.} 
  \item[trunc] For example
    |trunc(-2^9/3^5,12)=|\dtt{\xinttheexpr trunc(-2^9/3^5,12)\relax.} 
  \item[float] For example
    |float(-20^9/3^5,12)=|\dtt{\xinttheexpr float(-20^9/3^5,12)\relax.} 
  \item [sqrt] in \csbxint{expr} and \csbxint{floatexpr}, uses the float evaluation
    with the precision given by the optional second argument.
\begin{everbatim*}
\xinttheexpr sqrt(2,31)\relax\ and \xinttheiiexpr sqrt(num(2e60))\relax
\end{everbatim*}
  \end{description}

  \item[functions with two arguments] 
\noindent\par
  \begin{description}
  \item[quo] first truncates the arguments then computes the Euclidean quotient.
  \item[rem] first truncates the arguments then computes the Euclidean remainder.
  \item[mod] computes the modulo associated to the truncated division, same as
    |/:| infix operator
\begin{everbatim*}
\xinttheexpr mod(11/7,1/13), reduce(((11/7)//(1/13))*1/13+mod(11/7,1/13)),
mod(11/7,1/13)- (11/7)/:(1/13), (11/7)//(1/13)\relax
\end{everbatim*}
  \end{description}

  \item[the if conditional (twofold way)] 
\noindent\par
\ctexttt{if}|(cond,yes,no)|
    checks if |cond| is true or false and takes the corresponding
    branch. Any non zero number or fraction is logical true. The zero
    value is logical false. Both ``branches'' are evaluated (they are
    not really branches but just numbers). See also the |?| operator.

  \item[the ifsgn conditional (threefold way)]
\noindent\par
    \ctexttt{ifsgn}|(cond,<0,=0,>0)| checks the sign of |cond| and
    proceeds correspondingly. All three are evaluated. See also the |??|
    operator.

  \item[functions with an arbitrary number of arguments]
\noindent\par
This argument may well be generated by one or many |a..b| or |a..[d]..b|
constructs, separated by commas.
  \begin{description}
\item[all] inserts a logical |AND| in between arguments and evaluates,
\item[any] inserts a logical |OR| in between all arguments and evaluates,
\item[xor] inserts a logical |XOR| in between all arguments and evaluates,
\item[|`+`|] adds (left ticks mandatory):
\begin{everbatim*}
\xinttheexpr `+`(1,3,19), `+`(1*2,3*4,19*20)\relax
\end{everbatim*}
\item[|`*`|] multiplies (left ticks mandatory):
\begin{everbatim*}
\xinttheexpr `*`(1,3,19), `*`(1^2,3^2,19^2), `*`(1*2,3*4,19*20)\relax
\end{everbatim*}
\item[max] maximum,
\item[min] minimum,
\item[gcd] first truncates to integers then computes the |GCD|, requires \xintgcdname,
\item[lcm] first truncates to integers then computes the |LCM|, requires \xintgcdname,
\item[first] first among comma separated items, |first(list)| is like |[list][:1]|.
\begin{everbatim*}
\xinttheiiexpr first(-7..3), [-7..3][:1]\relax
\end{everbatim*}
\item[last] last among comma separated items, |last(list)| is like |[list][-1:]|.
\begin{everbatim*}
\xinttheiiexpr last(-7..3), [-7..3][-1:]\relax
\end{everbatim*}
\item[reversed] reverses the order
\begin{everbatim*}
\xinttheiiexpr reversed(123..150)\relax
\end{everbatim*}
  \end{description}

\item[functions using dummy variables]
\noindent\par
These constructs are nestable to arbitrary depth if suitably parenthesized.
One should use parentheses appropriately. The \csbxint{expr} parser in normal
operation is not bad at identifying missing or extra opening or closing
parentheses, but when it handles |seq|, |add|, |mul| or similar constructs it
switches to another mode of operation (it starts using delimited macros,
something which is almost non-existent in all its other operations) and
ill-formed expressions are much more likely to let the parser fetch tokens
from beyond the mandatory ending |\relax|. Thus, in case of a missing
parenthesis in such circumstances the error message from \TeX{} might be very
cryptic, even for the seasoned \xintname user.

The usable dummy variables are all lowercase and uppercase Latin letters.
\begin{description}
\item [subs] for variable substitution, useful to get something evaluated only
  once
\begin{everbatim*}
\xinttheexpr subs(subs(seq(x*z,x=1..10),z=y^2),y=10)\relax
\end{everbatim*}
Attention that |xz| generates an error, one must use explicitely |x*z|, else
the parser expects a variable with name |xz|.

The substituted variable may be a comma separated list (this is impossible
with |seq| which will always pick one item after the other from a list).
\begin{everbatim*}
\xinttheexpr subs([x]^2,x=-123,17,32)\relax
\end{everbatim*}


\item[add] addition
\begin{everbatim*}
\xinttheiiexpr add(x^3,x=1..50), add(x(x+1), x=1,3,19)\relax
\end{everbatim*}
See |`+`| for syntax without a dummy variable.

\item[mul] multiplication
\begin{everbatim*}
\xinttheiiexpr mul(x^2, x=1,3,19), mul(2n+1,n=1..10)\relax
\end{everbatim*}
See |`*`| for syntax without a dummy variable.

\item[seq] comma separated values generated according to a formula
\begin{everbatim*}
\xinttheiiexpr seq(x(x+1)(x+2)(x+3),x=1..10), `*`(seq(3x+2,x=1..10))\relax
\end{everbatim*}
\begin{everbatim*}
\xinttheiiexpr seq(seq(i^2+j^2, i=0..j), j=0..10)\relax
\end{everbatim*}

\item[rseq] recursive sequence, |@| for the previous value.
\begin{everbatim*}
\printnumber {\xintthefloatexpr subs(rseq (1; @/2+y/2@, i=1..10),y=1000)\relax }
\end{everbatim*}\newline
  Attention: in the example above |y/2@| is interpreted as
  |y/(2*@)|.\IMPORTANT{} With versions |1.2c| or earlier it would have been
  interpreted as |(y/2)*@|.

In case the initial stretch is a comma separated list, |@| refers at the first
iteration to the whole list. Use parentheses at each iteration to maintain
this ``nuple''.
\begin{everbatim*}
\printnumber{\xintthefloatexpr rseq(1,10^6;
             (sqrt([@][1]*[@][2]),([@][1]+[@][2])/2), i=1..10)\relax }
\end{everbatim*}

\item[rrseq] recursive sequence with multiple initial terms. Say, there are
  |K| of them. Then |@1|, ..., |@4| and then |@@(n)| up to |n=K| refer to the
  last |K| values. Notice the difference with |rseq| for which |@| refers to
  the complete list of all initial terms (if there are more than one).
\begin{everbatim*}
\xinttheiiexpr rrseq(0,1; @1+@2, i=2..30)\relax
\end{everbatim*}
\begin{everbatim*}
\xinttheiiexpr rseq(1; 2@, i=1..10)\relax
\end{everbatim*}
\begin{everbatim*}
\xinttheiiexpr rseq(1; 2@+1, i=1..10)\relax
\end{everbatim*}
\begin{everbatim*}
\xinttheiiexpr rseq(2; @(@+1)/2, i=1..5)\relax
\end{everbatim*}

\begin{everbatim*}
\xinttheiiexpr rrseq(0,1,2,3,4,5; @1+@2+@3+@4+@@(5)+@@(6), i=1..20)\relax
\end{everbatim*}

I implemented an |Rseq| which at all times keeps the memory of \emph{all}
previous items, but decided to drop it as the package was becoming big.

\item[iter] same as |rrseq| but does not print any value until the last |K|.
\begin{everbatim*}
\xinttheiiexpr iter(0,1; @1+@2, i=2..5, 6..10)\relax 
% the iterated over list is allowed to have disjoint defining parts.
\end{everbatim*}
\end{description}

Recursions may be nested, with |@@@(n)| giving access to the values of the
outer recursion\dots and there is even |@@@@(n)| but I never tried it!

With |seq|, |rseq|,
|rrseq|, |iter|, \textbf{but not} with |subs|, |add|, |mul|, one has:
\begin{description}
\item[abort] stop here and now.
\item[omit] omit this value.
\item[break] |break(stuff)| to abort and have |stuff| as last value.
\item[n++] serves to generate a potentially infinite list. The |n++| construct
  in conjunction with an |abort| or |break| is often more efficient, because
  in other cases the list to iterate over is first completely constructed.
\begin{everbatim*}
\xinttheiiexpr iter(1;(@>10^40)?{break(@)}{2@},i=1++)\relax 
\end{everbatim*}
  Note that |n++| can not work in the format |i=10,17,30++|, only |n++|
  nothing before. 
\begin{everbatim*}
First Fibonacci number at least |2^31| and its index
\xinttheiiexpr iter(0,1; (@1>=2^31)?{break(i)}{@2+@1}, i=1++)\relax
\end{everbatim*}
\end{description}

Some additional examples are to be found at the end of this section.
\end{description}

\item The postfix operators \ctexttt{!} and the branching conditionals \ctexttt{?, ??}.
  \begin{description}
  \item[{\color[named]{DarkOrchid}!}] computes the factorial of an integer.

  \item[{\color[named]{DarkOrchid}?}] is used as |(cond)?{yes}{no}|. It
    evaluates the (numerical) condition (any non-zero value counts as
    |true|, zero counts as |false|). It then acts as a macro with two
    mandatory arguments within braces (hence this escapes from the
    parser scope, the braces can not be hidden in a macro), chooses the
    correct branch \emph{without evaluating the wrong one}. Once the
    braces are removed, the parser scans and expands the uncovered
    material so for example
    %
    \leftedline{|\xinttheiexpr (3>2)?{5+6}{7-1}2^3\relax|} 
    %
    is legal and computes
    |5+62^3=|\dtt{\xinttheiexpr(3>2)?{5+(6}{7-(1}2^3)\relax}. Note
    though that it would be better practice to include here the |2^3|
    inside the branches. The contents of the branches may be arbitrary
    as long as once glued to what is next the syntax is respected:
    {|\xintexpr (3>2)?{5+(6}{7-(1}2^3)\relax| also works.} Differs thus
    from the |if| conditional in two ways: the false branch is not at
    all computed, and the number scanner is still active on exit, more
    digits may follow.

  \item[{\color[named]{DarkOrchid}??}] is used as |(cond)??{<0}{=0}{>0}|.
    |cond| is anything, its sign is evaluated and depending on the sign the
    correct branch is un-braced, the two others are swallowed. The un-braced
    branch will then be parsed as usual. Differs from the |ifsgn| conditional
    as the two false branches are not evaluated and furthermore the number
    scanner is still active on exit.
    %
    \leftedline{|\def\x{0.33}\def\y{1/3}|}
    %
    \leftedline{|\xinttheexpr (\x-\y)??{sqrt}{0}{1/}(\y-\x)\relax|%
      \dtt{=\def\x{0.33}\def\y{1/3}%
      \xinttheexpr (\x-\y)??{sqrt}{0}{1/}(\y-\x)\relax }}
    %
  \end{description}

\item \def\MicroFont{\color[named]{DarkOrchid}\ttfamily}The
  |.| as decimal mark; the number scanner treats it as an inherent,
  optional and unique component of a being formed number. One can do
  things such as
  %
  \leftedline{\restoreMicroFont|\xinttheexpr 0.^2+2^.0\relax|}
  %
  which is |0^2+2^0| and produces \dtt{\xinttheexpr 0.^2+2^.0\relax}.

  However a single dot |"."| as in |\xinttheexpr .^2\relax| is now illegal
  input.\MyMarginNote{Changed!}

\item The |e| and |E| for scientific notation. They are parsed
  like the decimal mark is.%  Thus |1e(3+2)| is no legal syntax anymore, one
  % must use |10^(3+2)| in such cases.
\begingroup
\restoreMicroFont |1e3^2| is \dtt{\xinttheexpr 1e3^2\relax}
\endgroup

\item The |"| for hexadecimal numbers: it is treated with highest
  priority, allowed only at locations where the parser expects to start
  forming a numeric operand, once encountered it triggers the
  hexadecimal scanner which looks for successive hexadecimal digits (as
  usual skipping spaces and expanding forward everything) possibly a
  unique optional dot (allowed directly in front) and then an optional
  (possibly empty) fractional part. The dot and fractional part are not
  allowed in {\restoreMicroFont|\xintiiexpr..\relax|}. The |"|
  functionality \fbox{requires package \xintbinhexname} (there is
  no warning, but an ``undefined control sequence'' error will
  naturally results if the package has not been loaded).
\begingroup
  \restoreMicroFont |"A*"A^"A| is \dtt{\xinttheexpr "A*"A^"A\relax}.
\endgroup


\item The power operator |^|, or |**|. It is left associative:
  {\restoreMicroFont|\xinttheiexpr 2^2^3\relax|} evaluates to \xinttheiexpr
    2^2^3\relax, not \xinttheiexpr 2^(2^3)\relax. Note that if the float
    precision is too low, iterated powers within |\xintfloatexpr..\relax| may
    fail: for example with the default setting |(1+1e-8)^(12^16)| will be
    computed with |12^16| approximated from its $16$ most significant digits
    but it has $18$ digits (\dtt{={\xintiiPow{12}{16}}}), hence the result is
    wrong:
  % REVOIR CECI
  \begingroup
  %
  \leftedline{$\np{\xintthefloatexpr (1+1e-8)^(12^16)\relax }$}
  %
  One should code
  %
  \leftedline{\restoreMicroFont|\xintthe\xintfloatexpr (1+1e-8)^\xintiiexpr 12^16\relax
    \relax|}
  %
  to obtain the correct floating point evaluation
  % REVOIR CECI
  % 
  \leftedline{$\np{1.00000001}^{12^{16}}\approx\np{\xintthefloatexpr
      (1+1e-8)^\xintiiexpr 12^16\relax\relax }$}
  %
  \endgroup

\item Multiplication and division \raisebox{-.3\height}{|*|}, |/|. The
  division is left associative, too: 
  %
  \begingroup\restoreMicroFont
  %
  |\xinttheiexpr 100/50/2\relax| evaluates to \xinttheiexpr 100/50/2\relax,
  not \xinttheiexpr 100/(50/2)\relax.
  %
  \endgroup
  Inside \csbxint{iiexpr}, |/| does \emph{rounded} division.

\item Truncated division |//| and modulo |/:| (equivalently |'mod'|, quotes
  mandatory) are at the same level of priority than multiplication and
  division, thus left-associative with them. Apply parentheses for
  disambiguation.
\begin{everbatim*}
\xinttheexpr 100000//13, 100000/:13, 100000 'mod' 13, trunc(100000/13,10),
            trunc(100000/:13/13,10)\relax
\end{everbatim*}

\item The list itemwise operators |*[|, |/[|, |^[|, |**[|, |]*|, |]/|, |]^|,
  |]**| are at the same precedence level as, respectively, |*| and |/| or |^|
  and |**|.

\item Addition and subtraction |+|, |-|. Again, |-| is left
  associative: 
  %
  \begingroup\restoreMicroFont 
  %
  |\xinttheiexpr 100-50-2\relax| evaluates to \xinttheiexpr 100-50-2\relax,
  not \xinttheiexpr 100-(50-2)\relax.
  %
  \endgroup

\item The list itemwise operators |+[|, |-[|, |]+|, |]-|,  are at
  the same precedence level as |+| and |-|, 

\item Comparison operators |<|, |>|, |=| (same as |==|), |<=|, |>=|, |!=| all
  at the same level of precedence, use parentheses for disambiguation.

\item Conjunction (logical and): |&&| or equivalently
  |'and'| (quotes mandatory).

\item Inclusive disjunction (logical or): \verb+||+
  and equivalently |'or'| (quotes mandatory).

\item XOR: |'xor'| with mandatory quotes is at the same level of precedence
  as \verb+||+.

\item The comma:
\restoreMicroFont With |\xinttheexpr 2^3,3^4,5^6\relax| 
one obtains as output \xinttheexpr 2^3,3^4,5^6\relax{}.

\item The parentheses.
\end{itemize}

\subsection{Some further examples with dummy variables}

These examples which were first added to this manual at the time of the |v1.1|
release.

\begin{everbatim*}
Prime numbers are always cool
\xinttheiiexpr seq((seq((subs((x/:m)?{(m*m>x)?{1}{0}}{-1},m=2n+1))
                        ??{break(0)}{omit}{break(1)},n=1++))?{x}{omit},
               x=10001..[2]..10200)\relax
\end{everbatim*}

The syntax in this last example may look a bit involved. First |x/:m| computes
|x modulo m| (this is the modulo with respect to truncated division, which
here for positive arguments is like Euclidean division; in
|\xintexpr...\relax|, |a/:b| is such that |a = b*(a//b)+a/:b|, with |a//b| the
algebraic quotient |a/b| truncated to an integer.). The |(x)?{yes}{no}|
construct checks if |x| (which \emph{must} be within parentheses) is true or
false, i.e. non zero or zero. It then executes either the |yes| or the |no|
branch, the non chosen branch is \emph{not} evaluated. Thus if |m| divides |x|
we are in the second (``false'') branch. This gives a |-1|. This |-1| is the
argument to a |??| branch which is of the type |(y)??{y<0}{y=0}{y>0}|, thus here
the |y<0|, i.e., |break(0)| is chosen. This |0| is thus given to another |?|
which consequently chooses |omit|, hence the number is not kept in the list.
The numbers which survive are the prime numbers.

% A006877 In the `3x+1' problem, these values for the starting value set new
% records for number of steps to reach 1. (Formerly M0748) 14 1, 2, 3, 6, 7,
% 9, 18, 25, 27, 54, 73, 97, 129, 171, 231, 313, 327, 649, 703, 871, 1161,
% 2223, 2463, 2919, 3711, 6171, 10971, 13255, 17647, 23529, 26623, 34239,
% 35655, 52527, 77031, 106239, 142587, 156159, 216367, 230631, 410011, 511935,
% 626331, 837799

\begin{everbatim*}
The first Fibonacci number beyond |2^64| bound is
\xinttheiiexpr subs(iter(0,1;(@1>N)?{break(i)}{@1+@2},i=1++),N=2^64)\relax{}
and the previous number was its index.
\end{everbatim*}

One more recursion:
\begin{everbatim*}
\def\syr #1{\xinttheiiexpr rseq(#1; (@<=1)?{break(i)}{odd(@)?{3@+1}{@//2}},i=0++)\relax}
The 3x+1 problem: \syr{231}\par
\end{everbatim*}

OK, a final one:
\begin{everbatim*}
\def\syrMax #1{\xinttheiiexpr iter(#1,#1;even(i)?
                                       {(@2<=1)?{break(i/2)}{odd(@2)?{3@2+1}{@2//2}}}
                                       {(@1>@2)?{@1}{@2}},i=0++)\relax }
With initial value 1161, the maximal number attained is \syrMax{1161} and that latter
number is the number of steps which was needed to reach 1.\par
\end{everbatim*}

Well, one more:

\begin{everbatim*}
\newcommand\GCD [2]{\xinttheiiexpr rrseq(#1,#2; (@1=0)?{abort}{@2/:@1}, i=1++)\relax }
\GCD {13^10*17^5*29^5}{2^5*3^6*17^2}
\end{everbatim*}

and the ultimate:

\begin{everbatim*}
\newcommand\Factors [1]{\xinttheiiexpr
    subs(seq((i/:3=2)?{omit}{[L][i]},i=1..([L][0])),
    L=rseq(#1;(p^2>[@][1])?{([@][1]>1)?{break(1,[@][1],1)}{abort}}
                          {(([@][1])/:p)?{omit}
    {iter(([@][1])//p; (@/:p)?{break(@,p,e)}{@//p},e=1++)}},p=2++))\relax }
\Factors {41^4*59^2*29^3*13^5*17^8*29^2*59^4*37^6}
\end{everbatim*}

This might look a bit scary, I admit. \xintexprname has minimal tools and
is obstinate about doing everything expandably! We are hampered by absence of a
notion of ``nuple''. The algorithm divides |N| by |2| until no more possible,
then by |3|, then by |4| (which is silly), then by |5|, then by |6| (silly
again), \dots. 

The variable |L=rseq(#1;...)| expands, if one follows the steps, to a comma
separated list starting with the initial (evaluated) |N=#1| and then
pseudo-triplets where the first item is |N| trimmed of small primes, the
second item is the last prime divisor found, and the third item is its
exponent in original |N|.

The algorithm needs to keep handy the last computed quotient by prime powers,
hence all of them, but at the very end it will be cleaner to get rid of them
(this corresponds to the first line in the code above). This is achieved in a
cumbersome inefficient way; indeed each item extraction |[L][i]| is costly: it
is not like accessing an array stored in memory, due to expandability, nothing
can be stored in memory! Nevertheless, this step could be done here in a far
less inefficient manner if there was a variant of |seq| which, in the spirit
of \csbxint{iloopindex}, would know how many steps it had been through so far.
This is a feature to be added to |\xintexpr|! (as well as a |++| construct
allowing a non unit step).

Notice that in |iter(([@][1])//p;| the |@| refers to the previous triplet (or
in the first step to |N|), but the latter |@| showing up in |(@/:p)?| refers
to the previous value computed by |iter|. 

\begin{snugframed}
  Parentheses are essential in |..([y][0])| else the parser will see |..[| and
  end up in ultimate confusion, and also in |([@][1])/:p| else the parser will
  see the itemwise operator |]/| on lists and again be very confused (I could
  implement a |]/:| on lists, but in this situation this would also be very
  confusing to the parser.)
\end{snugframed}

For comparison, here is an \fexpan dable macro expanding to the same result,
but coded directly with the \xintname macros. Here |#1| can not be itself an
expression, naturally. But at least we let |\Factorize| \fexpan d its
argument.
\begin{everbatim}
\makeatletter
\newcommand\Factorize [1]
      {\romannumeral0\expandafter\factorize\expandafter{\romannumeral-`0#1}}%
\newcommand\factorize [1]{\xintiiifOne{#1}{ 1}{\factors@a #1.{#1};}}%
\def\factors@a #1.{\xintiiifOdd{#1}
   {\factors@c 3.#1.}%
   {\expandafter\factors@b \expandafter1\expandafter.\romannumeral0\xinthalf{#1}.}}%
\def\factors@b #1.#2.{\xintiiifOne{#2}
   {\factors@end {2, #1}}%
   {\xintiiifOdd{#2}{\factors@c 3.#2.{2, #1}}%
                     {\expandafter\factors@b \the\numexpr #1+\@ne\expandafter.%
                         \romannumeral0\xinthalf{#2}.}}%
}%
\def\factors@c #1.#2.{%
    \expandafter\factors@d\romannumeral0\xintiidivision {#2}{#1}{#1}{#2}%
}%
\def\factors@d #1#2#3#4{\xintiiifNotZero{#2}
   {\xintiiifGt{#3}{#1}
        {\factors@end {#4, 1}}% ultimate quotient is a prime with power 1
        {\expandafter\factors@c\the\numexpr #3+\tw@.#4.}}%
   {\factors@e 1.#3.#1.}%
}%
\def\factors@e #1.#2.#3.{\xintiiifOne{#3}
   {\factors@end {#2, #1}}%
   {\expandafter\factors@f\romannumeral0\xintiidivision {#3}{#2}{#1}{#2}{#3}}%
}%
\def\factors@f #1#2#3#4#5{\xintiiifNotZero{#2}
   {\expandafter\factors@c\the\numexpr #4+\tw@.#5.{#4, #3}}%
   {\expandafter\factors@e\the\numexpr #3+\@ne.#4.#1.}%
}%
\def\factors@end #1;{\xintlistwithsep{, }{\xintRevWithBraces {#1}}}%
\makeatother
\end{everbatim}

% 18 novembre 2015
% le fichier testfactorize.tex est dans devtests.
% 12400
% 87975
%  comparer aux rsultats du 5 novembre 2014.
% % Rsultat: 30 itrations 
% % 12232 % \factorize par macros
% % 94307 % \factors par xintiiexpr 1.1a
% % 1815443 % l3bigint
% il s'est amlior depuis !
% cependant je ne peux pas tester car \bigint_factor:n plus fonctionnel.
% Pour mmoire timing du fichier complet:
% en novembre 2014
% 12308
% 94591
% 434095
%    macro:->2147483647, 2147483647, 1+++
% 3443269
%    macro:->2147483647, 2147483647, 1+++
% en novembre 2015
% 12441
% 87878
% 210898
%    macro:->2147483647, 2147483647, 1+++
% 2700184
%    macro:->2147483647, 2147483647, 1+++

The macro |\Factorize| puts a little stress on the input save stack in order
not be bothered with previously gathered things. I timed it to be about seven
times faster than |\Factors| in test cases such as
|16246355912554185673266068721806243461403654781833| and others. Among the
various things explaining the speed-up, there is fact that we step by
increments of two, not one, and also that we divide only once, obtaining
quotient and remainder in one go. These two things already make for a speed-up
factor of about four. Thus, our earlier |\Factors| was not completely
inefficient, and was quite easier to come up with than
|\Factorize|.\footnote{2015/11/18 I have not revisited this code for a long
  time, and perhaps I could improve it now with some new techniques.}

If we only considered small integers, we could write pure |\numexpr| methods
which would be very much faster (especially if we had a table of small primes
prepared first) but still ridiculously slow compared to any non expandable
implementation, not to mention use of programming languages directly accessing
the CPU registers\dots

\subsection{The \csbh{xintthecoords} command}
\label{xintthecoords}

It converts a comma separated list into the format for list of coordinates as
expected by the |TikZ| |coordinates| syntax. The code had to work around the
problem that |TikZ| seemingly allows only a maximal number of about one
hundred expansion steps for the list to be entirely produced. Presumably to
catch an infinite loop, but one hundred is ridiculously low a number of
expansion steps for any serious work in \TeX{} for dealing with tokens.

\begin{everbatim*}
{\centering\begin{tikzpicture}[scale=10]\xintDigits:=8;
  \clip (-1.1,-.25) rectangle (.3,.25);
  \draw [blue] (-1.1,0)--(1,0);
  \draw [blue] (0,-1)--(0,+1);
  \draw [red] plot[smooth] coordinates {\xintthecoords
    % converts into (x1, y1) (x2, y2)... format 
    \xintfloatexpr seq((x^2-1,mul(x-t,t=-1+[0..4]/2)),x=-1.2..[0.1]..+1.2) \relax };
\end{tikzpicture}\par }
\end{everbatim*}

% Notice: if x goes no take exactly value 1 or -1, the origin appears slightly
% off the curve, not MY fault!!!

\csbxint{thecoords} should be followed immediately by \csbxint{floatexpr} or
\csbxint{iexpr} or \csbxint{iiexpr}, but not |\xintthefloatexpr|, etc\dots 

Besides, as |TikZ| will not understand the |A/B[N]| format which is used on
output by |\xintexpr|, |\xintexpr| is not really usable with |\xintthecoords|
for a |TikZ| picture, but one may use it on its own, and the reason for the
spaces in and between coordinate pairs is to allow if necessary to print on
the page for examination with about correct line-breaks.

\begin{everbatim*}
\edef\x{\xintthecoords \xintexpr rrseq(1/2,1/3; @1+@2, x=1..20)\relax }
\meaning\x +++
\end{everbatim*}

\subsection{Breaking changes which came with the 1.1 release of
  \xintexprname}
\label{sec:expr11}

Release |1.1| of |2014/10/29| had brought many changes to \xintexprname. The
numerous syntax extensions have now been incorporated to the general
description in previous \autoref{ssec:syntax}. Here we keep only a short list or
breaking changes, for the record.

\begin{itemize}[parsep=0pt, labelwidth=\leftmarginii,
  itemindent=0pt, listparindent=\leftmarginiii, leftmargin=\leftmarginii]
  \item in |\xintiiexpr|, |/| does \emph{rounded} division, rather than as
    in earlier releases the
    Euclidean division (for positive arguments, this is truncated division).
    The new |//| operator does truncated division,
  \item the |:| operator for three-way branching is gone, replaced with |??|,
  \item |1e(3+5)| is now illegal. The number parser identifies |e| and |E|
    in the same way it does for the decimal mark, earlier versions treated
    |e| as |E| rather as postfix operators,
  \item the |add| and |mul| have a new syntax, old syntax is with |`+`| and
    |`*`| (quotes mandatory), |sum| and |prd| are gone,
  \item no more special treatment for encountered brace pairs |{..}| by the
    number scanner, |a/b[N]| notation can be used without use of braces (the
    |N| will end up space-stripped in a |\numexpr|, it is not parsed by the
    |\xintexpr|-ession scanner).
  \item although |&| and \verb+|+ are still available as Boolean operators the
    use of |&&| and \verb+||+ is strongly recommended. The single
    letter operators might be assigned some other meaning in later releases
    (bitwise operations, perhaps). Do not use them.
  \item place holders for |\xintNewExpr|
    could be denoted |#1|, |#2|, ... or also, for special purposes |$1|, |$2|,
    ... Only the first form is now accepted and the special cases previously
    treated via the second form are now managed via a |protect(...)| function.
\end{itemize}

\subsection{\texorpdfstring{\texttt{\protect\string\numexpr}}{\textbackslash
    numexpr} or \texorpdfstring{\texttt{\protect\string\dimexpr}}{\textbackslash
    dimexpr} expressions, count and dimension registers and variables}
\label{ssec:countinexpr}

Count registers, count control sequences, dimen registers, dimen control
sequences (like |\parindent|), skips and skip control sequences, |\numexpr|,
|\dimexpr|, |\glueexpr|, |\fontdimen| can be inserted directly, they will be
unpacked using |\number| which gives the internal value in terms of scaled
points for the dimensional variables: $1$\,|pt|${}=65536$\,|sp| (stretch and
shrink components are thus discarded).

Tacit multiplication is implied, when a number or decimal number prefixes such
a register or control sequence. \LaTeX{} lengths are skip control sequences
and \LaTeX{} counters should be inserted using |\value|.

Release |1.2| of the |\xintexpr| parser also recognizes and prefixes with
|\number| the |\ht|, |\dp|, and |\wd| \TeX{} primitives as well as the
|\fontcharht|, |\fontcharwd|, |\fontchardp| and |\fontcharic| \eTeX{}
primitives.

In the case of numbered registers like |\count255| or |\dimen0| (or |\ht0|),
the resulting digits will be re-parsed, so for example |\count255 0| is like
|100| if |\the\count255| would give |10|. The same happens with inputs such
as |\fontdimen6\font|. And |\numexpr 35+52\relax| will be exactly as if |87|
as been encountered by the parser, thus more digits may follow: |\numexpr
35+52\relax 000| is like |87000|. If a new |\numexpr| follows, it is treated
as what would happen when |\xintexpr| scans a number and finds a non-digit: it
does a tacit multiplication.
\begin{everbatim*}
\xinttheexpr \numexpr 351+877\relax\numexpr 1000-125\relax\relax{} is the same
as \xinttheexpr 1228*875\relax.
\end{everbatim*}

Control sequences however (such as |\parindent|) are picked up as a whole by
|\xintexpr|, and the numbers they define cannot be extended extra digits, a
syntax error is raised if the parser finds digits rather than a legal
operation after such a control sequence.

A token list variable must be prefixed by |\the|, it will not be unpacked
automatically (the parser will actually try |\number|, and thus fail). Do not
use |\the| but only |\number| with a dimen or skip, as the |\xintexpr| parser
doesn't understand |pt| and its presence is a syntax error. To use a dimension
expressed in terms of points or other \TeX{} recognized units, incorporate it in
|\dimexpr...\relax|.

Regarding how dimensional expressions are converted by \TeX{} into scaled points
see also \autoref{sec:Dimensions}.

\subsection{Catcodes and spaces}

Active characters may (and will) break the functioning of \csbxint{expr}.
Inside an expression one may prefix, for example a |:| with |\string|. Or, for
a more radical way, there is \csbxint{exprSafeCatcodes}. This is a
non-expandable step as it changes catcodes.

\subsubsection{\csbh{xintexprSafeCatcodes}}
\label{xintexprSafeCatcodes}
%{\small New with release |1.09a|.\par}

This command sets the catcodes of
the relevant characters to safe values. This is used internally by
\csbxint{NewExpr} (restoring the catcodes on exit), hence \csbxint{NewExpr} does
not have to be protected against active characters.

\subsubsection{\csbh{xintexprRestoreCatcodes}}\label{xintexprRestoreCatcodes}
%{\small New with release |1.09a|.\par}

Restores the catcodes to the earlier state. 

\bigskip

Spaces inside an |\xinttheexpr...\relax| should mostly be
innocuous (except inside macro arguments).

|\xintexpr| and |\xinttheexpr| are for the most part agnostic regarding
catcodes: (unbraced) digits, binary operators, minus and plus signs as
prefixes, dot as decimal mark, parentheses, may be indifferently of catcode
letter or other or subscript or superscript, ..., it doesn't matter.%
%
\footnote{Furthermore, although \csbxint{expr} uses \csa{string}, it is
  (we hope) escape-char agnostic.}

The characters |+|, |-|, |*|, |/|, |^|, |!|, |&|, \verb+|+, |?|, |:|, |<|, |>|,
|=|, |(|, |)|, |"|, |[|, |]|, |;|, the dot and the comma should not be active if
in the expression, as everything is expanded along the way. If one of them is
active, it should be prefixed with |\string|.

The exclamation mark should have its standard catcode, because it is used for
internal purposes with a different one.

% TOO TECHNICAL
%
% The |!| as either logical negation or postfix factorial operator must be a
% standard (\emph{i.e.} catcode $12$) |!|, more precisely a catcode $11$
% exclamation point |!| must be avoided as it is used internally by |\xintexpr|
% for various special purposes.

Digits, slash, square brackets, minus sign, in the output from an |\xinttheexpr|
are all of catcode 12. For |\xintthefloatexpr| the `e' in the output has its standard catcode ``letter''.

A macro with arguments will expand and grab its arguments before the
parser may get a chance to see them, so the situation with catcodes and spaces
is not the same within such macro arguments.

\subsection{Expandability, \csh{xinteval}}

As is the case with all other package macros |\xintexpr| \fexpan ds (in two
steps) to its final (non-printable) result; and |\xinttheexpr| \fexpan ds (in
two steps) to the chain of digits (and possibly minus sign |-|, decimal mark
|.|, fraction slash |/|, scientific |e|, square brackets |[|, |]|) representing
the result.

Starting with |1.09j|, an |\xintexpr..\relax| can be inserted without
|\xintthe| prefix inside an |\edef|, or a |\write|. It expands to a private
more compact representation (five tokens) than |\xinttheexpr| or
|\xintthe\xintexpr|.

The material between |\xintexpr| and |\relax| should contain only expandable
material.

The once expanded |\xintexpr| is |\romannumeral0\xinteval|. And there is
similarly |\xintieval|, |\xintiieval|, and |\xintfloateval|. For the other
cases one can use |\romannumeral-`0| as prefix. For an example of expandable
algorithms making use of chains of |\xinteval|-uations connected via
|\expandafter| see \autoref{ssec:fibonacci}.

An expression can only be legally finished by a |\relax| token, which
will be absorbed.

It is quite possible to nest expressions among themselves; for example, if one
needs inside an |\xintiiexpr...\relax| to do some computations with fractions,
rounding the final result to an integer, on just has to insert
|\xintiexpr...\relax|. The functioning of the infix operators will not be in
the least affected from the fact that the surrounding ``environment'' is the
|\xintiiexpr| one.

\subsection{Memory considerations}

The parser creates an undefined control sequence for each intermediate
computation evaluation: addition, subtraction, etc\dots Thus, a moderately sized
expression might create 10, or 20 such control sequences. On my \TeX{}
installation, the memory available for such things is of circa \np{200000}
multi-letter control words. So this means that a document containing hundreds,
perhaps even thousands of expressions will compile with no problem.

Besides the hash table, also \TeX{} main memory is impacted. Thus, if
\xintexprname is used for computing plots%
%
\footnote{this is not very probable as so far \xintname does not include
  a mathematical library with floating point calculations, but provides
  only the basic operations of algebra.}%
%
, this may cause a problem.

There is a (partial) solution.%
%
\footnote{which convinced me that I could stick with the parser
  implementation despite its potential impact on the hash-table and
  other parts of \TeX{}'s memory.}

A
document can possibly do tens of thousands of evaluations only
if some formulas are being used repeatedly, for example inside loops, with
counters being incremented, or with data being fetched from a file. So it is the
same formula used again and again with varying numbers inside.

With the \csbxint{NewExpr} command, it is possible to convert once and
for all an expression containing parameters into an expandable macro
with parameters. Only this initial definition of this macro actually
activates the \csbxint{expr} parser and will (very moderately) impact
the hash-table: once this unique parsing is done, a macro with
parameters is produced which is built-up recursively from the
\csbxint{Add}, \csbxint{Mul}, etc... macros, exactly as it would be
necessary to do without the facilities of the \xintexprname package.

\subsection{The \csbh{xintNewExpr} command}\label{xintNewExpr}

The command is used as:
%
\leftedline{|\xintNewExpr{\myformula}[n]|\marg{stuff}, where}
\begin{itemize}
\item \meta{stuff} will be inserted inside |\xinttheexpr . . . \relax|,
\item |n| is an integer between zero and nine, inclusive, which is the number
  of parameters of |\myformula|,
\item the placeholders |#1|, |#2|, ..., |#n| are used inside \meta{stuff} in
  their usual r\^ole,%
%
\catcode`# 12
\footnote{if \csa{xintNewExpr} is used inside a macro,
    the |#|'s must be doubled as usual.}
  \footnote{the |#|'s will in pratice have their usual
    catcode, but  category code other |#|'s are accepted too.}
\catcode`# 6
%
\item the |[n]| is \emph{mandatory}, even for |n=0|.%
\footnote{there is some use for \csa{xintNewExpr}|[0]| compared to an
    \csa{edef} as \csa{xintNewExpr} has some built-in catcode protection.}
\item the macro |\myformula| is defined without checking if it already exists,
  \LaTeX{} users might prefer to do first |\newcommand*\myformula {}| to get a
  reasonable error message in case |\myformula| already exists,
\item the definition of |\myformula| made by |\xintNewExpr| is global (i.e. it
  does not obey the scope of environments). The protection against active
  characters is done automatically.
\end{itemize}

It will be a completely expandable macro entirely built-up using |\xintAdd|,
|\xintSub|, |\xintMul|, |\xintDiv|, |\xintPow|, etc\dots as corresponds to the
expression written with the infix operators.
Macros created by |\xintNewExpr| can thus be nested.

\begin{everbatim*}
    \xintNewFloatExpr \FA [2]{(#1+#2)^10}
    \xintNewFloatExpr \FB [2]{sqrt(#1*#2)}
\begin{enumerate}[nosep]
    \item \FA {5}{5}
    \item \FB {30}{10}
    \item \FA {\FB {30}{10}}{\FB {40}{20}}
\end{enumerate}
\end{everbatim*}

\begin{framed}
  The use of \csbxint{NewExpr} circumvents the impact of the |\xintexpr|
  parsers on \TeX's memory: it is useful if one has a formula which has to be
  re-evaluated thousands of times with distinct inputs each with dozens, or
  hundreds of characters.

  A ``formula'' created by |\xintNewExpr| is thus a macro whose parameters are
  given to a possibly very complicated combination of the various macros of
  \xintname and \xintfracname. Consequently, one can not use at all any infix
  notation in the inputs, but only the formats which are recognized by the
  \xintfracname macros.

  This is thus quite different from a macro with parameters which one would
  have defined via a simple |\def| or |\newcommand| as for example:
  %
  \leftedline{|\newcommand\myformula [1]{\xinttheexpr (#1)^3\relax}|}
  %
  Such a macro |\myformula|, if it was used tens of thousands of times with
  various big inputs would end up populating large parts of \TeX's memory. It
  would thus be better for such use cases to go for:
  % 
  \leftedline{|\xintNewExpr\myformula [1]{#1^3\relax}|}
  %
  Here naturally the situation is over-simplified and it would be even simpler
  to go directly for the use of the macro |\xintPow| or |\xintPower|.
\end{framed}

|\xintNewExpr| tries to do as many evaluations as are possible at the time the
macro parameters are still parameters. Let's see a few examples. For this I
will use |\meaning| which reveals the contents of a macro.

\begin{enumerate}
\item in these examples we sometimes use |\printnumber| to avoid for the
  meaning to go into the right margin, but this zaps all spaces originally in
  the output from |\meaning|,
\item the examples use a mysterious |\fixmeaning| macro, which is there to get
  in the display |\romannumeral`^^@| rather than the frankly cabalistic
  |\romannumeral``| which made the admiration of the readers of the
  documentation dated |2015/10/19| (the second |`| stood for an ascii code
  zero token as per |T1| encoded |newtxtt| font). Thus the true meaning is
  ``fixed'' to display something different which is how the macro could be
  defined in a standard |tex| source file (modulo, as one can see in example,
  the use of characters such as |:| as letters in control sequence names).
  Prior to |1.2a|, the meaning would have started with a more mundane
  |\romannumeral-`0|, but I decided at the time of releasing |1.2a| to imitate
  the serious guys and switch for the more hacky yet |\romannumeral`^^@|
  everywhere in the source code (not only in the macros produced by
  \csbxint{NewExpr}), or to be more precise for an equivalent as the caret has
  catcode letter in \xintname's source code, and I had to use another
  character.
\item the meaning reveals the use of some private macros from the \xintname
  bundle, which should not be directly used. If the things look a bit
  complicated, it is because they have to cater for many possibilities.
\item the point of showing the meaning is also to see what has already been
  evaluated in the construction of the macros.
\end{enumerate}

\begin{everbatim*}
\xintNewIIExpr\FA [1]{13*25*78*#1+2826*292}\fixmeaning\FA
\end{everbatim*}
\smallskip

\begin{everbatim*}
\xintNewIExpr\FA [2]{(3/5*9/7*13/11*#1-#2)*3^7}
\printnumber{\fixmeaning\FA}
\end{everbatim*}

\smallskip

\begin{everbatim*}
% an example with optional parameter
\xintNewIExpr\FA [3]{[24] (#1+#2)/(#1-#2)^#3}
\printnumber{\fixmeaning\FA}
\end{everbatim*}

\smallskip

\begin{everbatim*}
\xintNewFloatExpr\FA [2]{[12] 3.1415^3*#1-#2^5}
\printnumber{\fixmeaning\FA}
\end{everbatim*}

\smallskip

\begin{everbatim*}
\xintNewExpr\DET[9]{ #1*#5*#9+#2*#6*#7+#3*#4*#8-#1*#6*#8-#2*#4*#9-#3*#5*#7 }
\printnumber{\fixmeaning\DET}
\end{everbatim*}

\smallskip

\begin{everbatim*}
\xintNewExpr\FA[3]{ #1*#1+#2*#2+#3*#3-(#1*#2+#2*#3+#3*#1) }
\printnumber{\fixmeaning\FA }
\end{everbatim*}


One can even do some quite daring things:
\begin{everbatim*}
\xintNewExpr\FA[5]{[#1..[#2]..#3][#4:#5]}
And this works:
\begin{itemize}[nosep]
\item \FA{1}{3}{90}{20}{30}
\item \FA{1}{3}{90}{-40}{-15}
\item \FA{1.234}{-0.123}{-10}{3}{7}
\end{itemize}
\fdef\test {\FA {0}{10}{100}{3}{6}}\meaning\test +++
\end{everbatim*}

In the last example though, do not hope to use empty |#4| or |#5|: this is
possible in an expression, because the parser identifies |][:| or |:]| and
handles them appropriately. Here the macro |\FA| is built with idea that there
is something non-empty as it found the place holders |#4| and |#5|.


\subsubsection {Conditional operators and \csbh{NewExpr}}

The |?| and |??| conditional operators cannot be parsed by |\xintNewExpr| when
they contain macro parameters |#1|,\dots, |#9| within their scope. However
replacing them with the functions |if| and, respectively |ifsgn|, the parsing
should succeed. And the created macro will \emph{not evaluate the branches to
  be skipped}, thus behaving exactly like |?| and |??| would have in the
|\xintexpr|.

\begin{everbatim*}
\xintNewExpr\Formula [3]{ if((#1>#2) && (#2>#3), sqrt(#1-#2)*sqrt(#2-#3),  #1^2+#3/#2) }%
\printnumber{\fixmeaning\Formula }
\end{everbatim*}

This formula (with its |\xintiiifNotZero|) will gobble the false branch without
evaluating it when used with given arguments.

Remark: the meaning above reveals some of the private macros used by the
package. They are not for direct use.

Another example

\begin{everbatim*}
\xintNewExpr\myformula[3]{ ifsgn(#1,#2/#3,#2-#3,#2*#3) }%
\fixmeaning\myformula
\end{everbatim*}

Again,  this macro gobbles the false branches, as would have the operator |??|
inside an |\xintexpr|-ession.

\subsubsection{External macros and \csbh{NewExpr}; the protect function}
\label{sssec:protect}

For macros within such a created \xintname-formula command, there
are two cases:
\begin{itemize}
\item the macro does not involve the numbered parameters in its arguments: it
  may then be left as is, and will be evaluated once during the construction of
  the formula,
\item it does involve at least one of the macro parameters as argument. Then:
  \begin{snugframed}
    the whole thing (macro + argument) should be |protect|-ed, not in the
    \LaTeX{} sense (!), but in the following way: |protect(\macro {#1})|.\IMPORTANT
  \end{snugframed}
\end{itemize}

Here is a silly example illustrating the general principle: the macros here have
equivalent functional forms which are more convenient; but some of the more
obscure package macros of \xintname dealing with integers do not have functions
pre-defined to be in correspondance with them, use this mechanism could be
applied to them.

\begin{everbatim*}
\xintNewExpr\myformI[2]{protect(\xintRound{#1}{#2}) - protect(\xintTrunc{#1}{#2})}%
\fixmeaning\myformI

\xintNewIIExpr\formula [3]{rem(#1,quo(protect(\the\numexpr #2\relax),#3))}%
\noindent\fixmeaning\formula
\end{everbatim*}

Only macros involving the |#1|, |#2|, etc\dots should be protected in this
way; the |+|, |*|, etc\dots symbols, the functions from the \csbxint{expr}
syntax, none should ever be included in a protected string.


\subsubsection{Limitations of \csbxint{NewExpr}}

All depends on where the macro parameters arise |#1|, |#2|, ... we went to some
effort to allow many things but not everything goes through. |\xintNewExpr|
tries to evaluate completely as many things as possible which do not involve the
macro parameters. A somewhat elaborate scheme allows to handle also
complicated situations with list operations:

\begin{everbatim*}
\xintNewIExpr \FA [3] {[3] `+`([1.5..[3.5+#1]..#2]*#3)}
\begin{itemize}[nosep]
\item \FA {3.5}{50}{100} (cf. \xinttheiexpr [3] 1.5..[7]..50\relax)
\item \FA {-15}{-100}{20} (cf. \xinttheiexpr [3] 1.5..[-11.5]..-100\relax)
\item \FA {0}{20}{1} (cf. \xinttheiexpr [3] 1.5..[3.5]..20\relax)
\end{itemize}
\end{everbatim*}

Some things are definitely expected not to work therein: particularly the
|seq|, |rseq|, |rrseq|, |iter| with |omit|, |abort|,
|break|. Also, but this is quite anecdotical, |first| and |last| should not
work (I did not try; actually I did not try the functions with dummy letters
either, because each time I think about compatibility with \csbxint{NewExpr},
my head starts spinning.)

Also, using sub-|\xintexpr|-essions (including some of the macro parameters)
inside something given to |\xintNewExpr| will probably not work.

Naturally, it is always possible to use, after the macro has been constructed,
|\xinttheexpr...\relax| among the arguments.

\subsection{\csbh{xintiexpr}, \csbh{xinttheiexpr}}
\label{xintiexpr}\label{xinttheiexpr}
% \label{xintnumexpr}\label{xintthenumexpr}

Equivalent\etype{x} to doing |\xintexpr round(...)\relax|. Thus, \emph{only} the
final result is rounded to an integer. Half integers are rounded towards
$+\infty$ for positive numbers and towards $-\infty$ for negative ones. Comma
separated lists of expressions are allowed. 

An optional parameter within brackets is allowed: if strictly positive it
instructs the expression to do its final rounding to the nearest value with
that many digits after the decimal mark.

% Le temps est venu pour leur obsolescence

% Initially baptized |\xintnumexpr|,
% |\xintthenumexpr| but
% I am not too happy about this choice of name; one should keep in mind that
% |\numexpr|'s integer division rounds, whereas in |\xintiexpr|, the |/| is an
% exact fractional operation, and only the final result is rounded to an integer.

% So |\xintnumexpr|, |\xintthenumexpr| are deprecated, and although still provided
% for the time being this might change in the future.

\subsection{\csbh{xintiiexpr}, \csbh{xinttheiiexpr}}
\label{xintiiexpr}\label{xinttheiiexpr}

This variant\etype{x} does not know fractions. It deals almost only with long
integers. Comma separated lists of expressions are allowed.

\begin{framed}
  It maps |/| to the \emph{rounded} quotient. The operator
  |//| is, like in |\xintexpr...\relax|, mapped to \emph{truncated} division.
  The euclidean quotient (which for positive operands is like the truncated
  quotient) was, prior to release |1.1|, associated to |/|. The function
  |quo(a,b)| can still be employed.
\end{framed}

The \csbxint{iiexpr}-essions use the `ii' macros for addition, subtraction,
multiplication, power, square, sums, products, euclidean quotient and
remainder. 

The |round|, |trunc|, |floor|, |ceil| functions are still available, and are
about the only places where fractions can be used, but |/| within, if not
somehow hidden will be executed as integer rounded division. To avoid this one
can wrap the input in \dtt{qfrac}: this means however that none of the normal
expression parsing will be executed on the argument.

To understand the illustrative examples, recall that |round| and |trunc| have
a second (non negative) optional argument. In a normal \csbxint{expr}-essions,
|round| and |trunc| are mapped to \csbxint{Round} and \csbxint{Trunc}, in
\csbxint{iiexpr}-essions, they are mapped to \csbxint{iRound} and
\csbxint{iTrunc}.


\begin{everbatim*}
\xinttheiiexpr 5/3, round(5/3,3), trunc(5/3,3), trunc(\xintDiv {5}{3},3),
trunc(\xintRaw {5/3},3)\relax{} are problematic, but
%
\xinttheiiexpr 5/3,  round(qfrac(5/3),3), trunc(qfrac(5/3),3), floor(qfrac(5/3)),
ceil(qfrac(5/3))\relax{} work!
\end{everbatim*}

On the other hand decimal numbers and scientific numbers can be used directly
as arguments to the |num|, |round|, or any function producing an integer.

\begin{framed}
  Scientific numbers are either rounded (in case of negative exponent) or
  represented with as many zeroes as necessary, thus one does not want to
  insert \dtt{num(1e100000)} for example in an \csa{xintiiexpr}ession !
\end{framed}

%
\begin{everbatim*}
\xinttheiiexpr num(13.4567e3)+num(10000123e-3)\relax % should compute 13456+10000
\end{everbatim*}
%

The |reduce| function is not available and will raise un error. The |frac|
function also. The |sqrt| function is mapped to \csbxint{iiSqrt} which gives
a truncated square root. The |sqrtr| function is mapped to \csbxint{iiSqrtR}
which gives a rounded square root.

One can use the Float macros if one is careful to use |num|, or |round|
etc\dots on their output.

\begin{everbatim*}
\xinttheiiexpr \xintFloatSqrt [20]{2}, \xintFloatSqrt [20]{3}\relax % no operations

\noindent The next example requires the |round|, and one could not put the |+| inside it:

\xinttheiiexpr round(\xintFloatSqrt [20]{2},19)+round(\xintFloatSqrt [20]{3},19)\relax

(the second argument of |round| and |trunc| tells how many digits from after the 
decimal mark one should keep.)
\end{everbatim*}

The whole point of \csbxint{iiexpr} is to gain some speed in
\emph{integer-only} algorithms, and the above explanations related to how to
nevertheless use fractions therein are a bit peripheral. We observed
(2013/12/18) of the order of $30$\% speed gain when dealing with numbers with
circa one hundred digits (v1.2: this info may be obsolete).

%  but this gain decreases the longer the manipulated
% numbers become and becomes negligible for numbers with thousand digits: the
% overhead from parsing fraction format is little compared to other expensive
% aspects of the expandable shuffling of tokens


\subsection{\csbh{xintboolexpr},
  \csbh{xinttheboolexpr}}\label{xintboolexpr}\label{xinttheboolexpr}
%{\small New in |1.09c|.\par}

Equivalent\etype{x} to doing |\xintexpr ...\relax| and returning $1$ if the
result does not vanish, and $0$ is the result is zero. As |\xintexpr|, this
can be used on comma separated lists of expressions, and will return a
comma separated list of $0$'s and $1$'s.

\subsection{\csbh{xintfloatexpr},
  \csbh{xintthefloatexpr}}\label{xintfloatexpr}\label{xintthefloatexpr}

\csbxint{floatexpr}|...\relax|\etype{x} is exactly like |\xintexpr...\relax|
but with the four binary operations and the power function mapped to
\csa{xintFloatAdd}, \csa{xintFloatSub}, \csa{xintFloatMul}, \csa{xintFloatDiv}
and \csa{xintFloatPower}. The precision for the computation is from the
current setting of |\xintDigits|. Comma separated lists of expressions are
allowed. 

An optional parameter within brackets is allowed: the final float will have
that many digits of precision. This is provided to get rid of non-relevant
last digits.

\xintDigits:= 9;

Note that |1.000000001| and |(1+1e-9)| will not be equivalent for
|D=\xinttheDigits| set to nine or less. Indeed the addition implicit in |1+1e-9|
(and executed when the closing parenthesis is found) will provoke the rounding
to |1|. Whereas |1.000000001|, when found as operand of one of the four
elementary operations is kept with |D+2| digits, and even more for the power
function.
% REVOIR ceci
%
\leftedline{|\xintDigits:= 9; \xintthefloatexpr
  (1+1e-9)-1\relax|\dtt{=\xintthefloatexpr (1+1e-9)-1\relax}}
%
\leftedline{|\xintDigits:= 9; \xintthefloatexpr
  1.000000001-1\relax|\dtt{=\xintthefloatexpr 1.000000001-1\relax}}

For the fun of it:\xintDigits:=20; |\xintDigits:=20;|%
%
\leftedline{|\xintthefloatexpr (1+1e-7)^1e7\relax|%
       \dtt{=\xintthefloatexpr (1+1e-7)^1e7\relax}}

|\xintDigits:=36;|\xintDigits:=36;
%
\leftedline{|\xintthefloatexpr
  ((1/13+1/121)*(1/179-1/173))/(1/19-1/18)\relax|}
%
\leftedline{\dtt{\xintthefloatexpr
  ((1/13+1/121)*(1/179-1/173))/(1/19-1/18)\relax}}
%
\leftedline{|\xintFloat{\xinttheexpr
  ((1/13+1/121)*(1/179-1/173))/(1/19-1/18)\relax}|}
%
\leftedline{\dtt{\xintFloat
  {\xinttheexpr((1/13+1/121)*(1/179-1/173))/(1/19-1/18)\relax}}}

\xintDigits := 16;

The latter result is the rounding of the exact result. The previous one has
rounding errors coming from the various roundings done for each
sub-expression. It was a bit funny  to discover that |maple|, configured with
|Digits:=36;| and with decimal dots everywhere to let it input the numbers as
floats, gives exactly the same result with the same rounding errors
as does |\xintthefloatexpr|!

Using |\xintthefloatexpr| only pays off compared to using |\xinttheexpr|
followed with |\xintFloat| if the computations turn out to involve hundreds of
digits. For elementary calculations with hand written numbers (not using the
scientific notation with exponents differing greatly) it will generally be more
efficient to use |\xinttheexpr|. The situation is quickly otherwise if one
starts using the Power function. Then, |\xintthefloat| is often useful; and
sometimes indispensable to achieve the (approximate) computation in reasonable
time.

We can try some crazy things:
%
\leftedline{|\xintDigits:=12;\xintthefloatexpr 1.000000000000001^1e15\relax|}
%
\leftedline{\xintDigits:=12;%
  \dtt{\xintthefloatexpr 1.000000000000001^1e15\relax}}
%
Contrarily to some professional computing sofware which are our concurrents on
this market, the \dtt{1.000000000000001} wasn't rounded to |1| despite the
setting of \csa{xintDigits}; it would have been if we had input it as
|(1+1e-15)|.

% \xintDigits:=12;
% \pdfresettimer
% \edef\z{\xintthefloatexpr 1.000000000000001^1e15\relax}%
% \edef\temps{\the\pdfelapsedtime}%
% \xintRound {5}{\temps/65536}s\endgraf

\xintDigits := 16; % mais en fait \centeredline cre un groupe.

\subsection{\csbh{xintifboolexpr}}\label{xintifboolexpr}
%{\small New in |1.09c|.\par}

\csh{xintifboolexpr}|{<expr>}{YES}{NO}|\etype{xnn} does |\xinttheexpr
<expr>\relax| and then executes the |YES| or the |NO| branch depending on
whether the outcome was non-zero or zero. |<expr>| can involve various |&| and
\verb+|+, parentheses, |all|, |any|, |xor|, the |bool| or |togl| operators, but
is not limited to them: the most general computation can be done, the test is on
whether the outcome of the computation vanishes or not.

Will not work on an expression composed of comma separated sub-expressions.

\subsection{\csbh{xintifboolfloatexpr}}\label{xintifboolfloatexpr}
%{\small New in |1.09c|.\par}

\csh{xintifboolfloatexpr}|{<expr>}{YES}{NO}|\etype{xnn} does |\xintthefloatexpr
<expr>\relax| and then executes the |YES| or the |NO| branch depending on
whether the outcome was non zero or zero.

\subsection{\csbh{xintifbooliiexpr}}\label{xintifbooliiexpr}
%{\small New in |1.09i|.\par}

\csh{xintifbooliiexpr}|{<expr>}{YES}{NO}|\etype{xnn} does |\xinttheiiexpr
<expr>\relax| and then executes the |YES| or the |NO| branch depending on
whether the outcome was non zero or zero.

\subsection{\csbh{xintNewFloatExpr}}\label{xintNewFloatExpr}

This is exactly like \csbxint{NewExpr} except that the created formulas are
set-up to use |\xintthefloatexpr|. The precision used for the computation will
be the one given by |\xintDigits| at the time of use of the created formulas.
However, the numbers hard-wired in the original expression will have been
evaluated with the then current setting for |\xintDigits|.

\begin{everbatim*}
\xintNewFloatExpr \f [1] {sqrt(#1)}
\f {2} (with \xinttheDigits{} of precision).

{\xintDigits := 32;\f {2} (with \xinttheDigits{} of precision).}

\xintNewFloatExpr \f [1] {sqrt(#1)*sqrt(2)}
\f {2} (with \xinttheDigits {} of precision).

{\xintDigits := 32;\f {2} (?? we thought we had a higher precision. Explanation next)}

The sqrt(2) in the second formula was computed with only \xinttheDigits{} of
precision. Setting |\xintDigits| to a higher value at the time of definition will
confirm that the result above is from a mismatch of the precision for |sqrt(2)| at
the time of its evaluation and the precision for the new |sqrt(2)| with |#1=2| at
the time of use.

{\xintDigits := 32;\xintNewFloatExpr \f [1] {sqrt(#1)*sqrt(2)}
\f {2} (with \xinttheDigits {} of precision)}
\end{everbatim*}

\subsection{\csbh{xintNewIExpr}}\label{xintNewIExpr}
%{\small New in |1.09c|.\par }

Like \csbxint{NewExpr} but using |\xinttheiexpr|. 

%Former denomination was
%|\xintNewNumExpr| which is deprecated and should not be used.

\subsection{\csbh{xintNewIIExpr}}\label{xintNewIIExpr}
%{\small New in |1.09i|.\par }

Like \csbxint{NewExpr} but using |\xinttheiiexpr|.

\subsection{\csbh{xintNewBoolExpr}}\label{xintNewBoolExpr}
%{\small New in |1.09c|.\par }

Like \csbxint{NewExpr} but using |\xinttheboolexpr|.

\xintDigits:= 16;

\subsection{Technicalities}

As already mentioned \csa{xintNewExpr}|\myformula[n]| does not check the prior
existence of a macro |\myformula|. And the number of parameters |n| given as
mandatory argument within square brackets should be (at least) equal
to the number of parameters in the expression.

Obviously I should mention that \csa{xintNewExpr} itself can not be used in an
expansion-only context, as it creates a macro.

The |\escapechar| setting may be arbitrary when using |\xintexpr|.

The format of the output  of
|\xintexpr|\meta{stuff}|\relax| is a |!| (with catcode 11) followed by various things:
\begin{everbatim*}
\fdef\f {\xintexpr 1.23^10\relax }\meaning\f
\end{everbatim*}

\begin{framed}
  Note that |\xintexpr| is thus compatible with complete expansion, contrarily
  to |\numexpr| which is non-expandable, if not prefixed by |\the| or |\number|,
  and away from contexts where \TeX{} is building a number. See
  \autoref{ssec:fibonacci} for some illustration.
%  pour mmoire:
%  \MyMarginNote[\kern\dimexpr\FrameSep+\FrameRule\relax]{New with 1.09j!}
\end{framed}

I decided to put all intermediate results (from each evaluation of an infix
operators, or of a parenthesized subpart of the expression, or from application
of the minus as prefix, or of the exclamation sign as postfix, or any
encountered braced material) inside |\csname...\endcsname|, as this can be done
expandably and encapsulates an arbitrarily long fraction in a single token (left
with undefined meaning), thus providing tremendous relief to the programmer in
his/her expansion control.

\begin{framed}
  As the |\xintexpr| computations corresponding to functions and infix
  or postfix operators are done inside |\csname...\endcsname|, the
  \fexpan dability could possibly be dropped and one could imagine
  implementing the basic operations with expandable but not \fexpan
  dable macros (as \csbxint{XTrunc}.) I have not investigated that
  possibility.
\end{framed}

Syntax errors in the input such as using a one-argument function with two
arguments will generate low-level \TeX{} processing unrecoverable errors, with
cryptic accompanying message. 

Some other problems will give rise to `error messages' macros giving some
indication on the location and nature of the problem. Mainly, an attempt has
been made to handle gracefully missing or extraneous parentheses.

However, this mechanism is completely inoperant for parentheses involved in
the syntax of the |seq|, |add|, |mul|, |subs|, |rseq| and |rrseq| functions.

% When the scanner is looking for a number and finds something else not otherwise
% treated, it assumes it is the start of the function name and will expand forward
% in the hope of hitting an opening parenthesis; if none is found at least it
% should stop when encountering the |\relax| marking the end of the expressions.

Note that |\relax| is \emph{mandatory} (contrarily to a |\numexpr|).

\subsection{Acknowledgements (2013/05/25)}

I was greatly helped in my preparatory thinking, prior to producing such an
expandable parser, by the commented source of the
\href{http://www.ctan.org/pkg/l3kernel}{l3fp} package, specifically the
|l3fp-parse.dtx| file (in the version of April-May 2013). Also the source of the
|calc| package was instructive, despite the fact that here for |\xintexpr| the
principles are necessarily different due to the aim of achieving expandability.

%\etocdepthtag.toc {commandsB}

\section{Commands of the \xintbinhexname package}
\label{sec:binhex}

\localtableofcontents

This package was first included in the |1.08| (|2013/06/07|) release of
\xintname. It provides expandable conversions of arbitrarily big integers to and
from binary and hexadecimal.

The argument is first \fexpan ded. It then may start with an optional minus
sign (unique, of category code other), followed with optional leading zeroes
(arbitrarily many, category code other) and then ``digits'' (hexadecimal
letters may be of category code letter or other, and must be
uppercased). The optional (unique) minus sign (plus sign is not allowed) is
kept in the output. Leading zeroes are allowed, and stripped. The
hexadecimal letters on output are of category code letter, and
uppercased.

% \clearpage

\subsection{\csbh{xintDecToHex}}\label{xintDecToHex}

Converts from decimal to hexadecimal.\etype{f}

\texttt{\string\xintDecToHex \string{\printnumber{2718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003}\string}}\endgraf\noindent\dtt{->\printnumber{\xintDecToHex{2718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003}}}

\subsection{\csbh{xintDecToBin}}\label{xintDecToBin}

Converts from decimal to binary.\etype{f}

\texttt{\string\xintDecToBin \string{\printnumber{2718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003}\string}}\endgraf\noindent\dtt{->\printnumber{\xintDecToBin{2718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427427466391932003}}}

\subsection{\csbh{xintHexToDec}}\label{xintHexToDec}

Converts from hexadecimal to decimal.\etype{f}

\texttt{\string\xintHexToDec
  \string{\printnumber{11A9397C66949A97051F7D0A817914E3E0B17C41B11C48BAEF2B5760BB38D272F46DCE46C6032936BF37DAC918814C63}\string}}\endgraf\noindent
\dtt{->\printnumber{\xintHexToDec{11A9397C66949A97051F7D0A817914E3E0B17C41B11C48BAEF2B5760BB38D272F46DCE46C6032936BF37DAC918814C63}}}

\subsection{\csbh{xintBinToDec}}\label{xintBinToDec}

Converts from binary to decimal.\etype{f}

\texttt{\string\xintBinToDec
  \string{\printnumber{100011010100100111001011111000110011010010100100110101001011100000101000111110111110100001010100000010111100100010100111000111110000010110001011111000100000110110001000111000100100010111010111011110010101101010111011000001011101100111000110100100111001011110100011011011100111001000110110001100000001100101001001101101011111100110111110110101100100100011000100000010100110001100011}\string}}\endgraf\noindent
\dtt{->\printnumber{\xintBinToDec{100011010100100111001011111000110011010010100100110101001011100000101000111110111110100001010100000010111100100010100111000111110000010110001011111000100000110110001000111000100100010111010111011110010101101010111011000001011101100111000110100100111001011110100011011011100111001000110110001100000001100101001001101101011111100110111110110101100100100011000100000010100110001100011}}}

\subsection{\csbh{xintBinToHex}}\label{xintBinToHex}

Converts from binary to hexadecimal.\etype{f}

\texttt{\string\xintBinToHex
  \string{\printnumber{100011010100100111001011111000110011010010100100110101001011100000101000111110111110100001010100000010111100100010100111000111110000010110001011111000100000110110001000111000100100010111010111011110010101101010111011000001011101100111000110100100111001011110100011011011100111001000110110001100000001100101001001101101011111100110111110110101100100100011000100000010100110001100011}\string}}\endgraf\noindent
\dtt{->\printnumber{\xintBinToHex{100011010100100111001011111000110011010010100100110101001011100000101000111110111110100001010100000010111100100010100111000111110000010110001011111000100000110110001000111000100100010111010111011110010101101010111011000001011101100111000110100100111001011110100011011011100111001000110110001100000001100101001001101101011111100110111110110101100100100011000100000010100110001100011}}}

\subsection{\csbh{xintHexToBin}}\label{xintHexToBin}

Converts from hexadecimal to binary.\etype{f}

\texttt{\string\xintHexToBin
  \string{\printnumber{11A9397C66949A97051F7D0A817914E3E0B17C41B11C48BAEF2B5760BB38D272F46DCE46C6032936BF37DAC918814C63}\string}}\endgraf\noindent
\dtt{->\printnumber{\xintHexToBin{11A9397C66949A97051F7D0A817914E3E0B17C41B11C48BAEF2B5760BB38D272F46DCE46C6032936BF37DAC918814C63}}}

\subsection{\csbh{xintCHexToBin}}\label{xintCHexToBin}

Also converts from hexadecimal to binary.\etype{f} Faster on inputs with at
least one hundred hexadecimal digits.

\texttt{\string\xintCHexToBin
  \string{\printnumber{11A9397C66949A97051F7D0A817914E3E0B17C41B11C48BAEF2B5760BB38D272F46DCE46C6032936BF37DAC918814C63}\string}}\endgraf\noindent
\dtt{->\printnumber{\xintCHexToBin{11A9397C66949A97051F7D0A817914E3E0B17C41B11C48BAEF2B5760BB38D272F46DCE46C6032936BF37DAC918814C63}}}

\section{Commands of the \xintgcdname package}
\label{sec:gcd}

\localtableofcontents

This package was included in the original release |1.0| (|2013/03/28|) of the
\xintname bundle.

Since release |1.09a| the macros filter their inputs through the \csbxint{Num}
macro, so one can use count registers, or fractions as long as they reduce to
integers.

Since release |1.1|, the two ``|typeset|'' macros require the explicit
loading by the user of package \xinttoolsname.


%% \clearpage

\subsection{\csbh{xintGCD}, \csbh{xintiiGCD}}\label{xintGCD}\label{xintiiGCD}

|\xintGCD|\n\m\etype{\Numf\Numf} computes the greatest common divisor. It is
positive, except when both |N| and |M| vanish, in which case the macro returns
zero.
%
\leftedline{\csa{xintGCD}|{10000}{1113}|\dtt{=\xintGCD{10000}{1113}}}
%
\leftedline{|\xintiiGCD{123456789012345}{9876543210321}=|\dtt
  {\xintiiGCD{123456789012345}{9876543210321}}}

\csa{xintiiGCD} skips the \csbxint{Num} overhead.\etype{ff}

\subsection{\csbh{xintGCDof}}\label{xintGCDof}
%{\small New with release |1.09a|.\par}

\csa{xintGCDof}|{{a}{b}{c}...}|\etype{f{$\to$}{\lowast\Numf}} computes the greatest common divisor of all
integers |a|, |b|, \dots{}  The list argument
may be a macro, it is \fexpan ded first and must contain at least one item.

\subsection{\csbh{xintLCM}, \csbh{xintiiLCM}}\label{xintLCM}\label{xintiiLCM}
%{\small New with release |1.09a|.\par}

|\xintGCD|\n\m\etype{\Numf\Numf} computes the least common multiple. It is
|0| if one of the two integers vanishes.

\csa{xintiiLCM} skips the \csbxint{Num} overhead.\etype{ff}

\subsection{\csbh{xintLCMof}}\label{xintLCMof}
%{\small New with release |1.09a|.\par}

\csa{xintLCMof}|{{a}{b}{c}...}|\etype{f{$\to$}{\lowast\Numf}} computes the least
common multiple of all integers |a|, |b|, \dots{} The list argument may be a
macro, it is \fexpan ded first and must contain at least one item.

\subsection{\csbh{xintBezout}}\label{xintBezout}

\xintAssign{{\xintBezout {10000}{1113}}}\to\X
\xintAssign {\xintBezout {10000}{1113}}\to\A\B\U\V\D

|\xintBezout|\n\m\etype{\Numf\Numf} returns five numbers |A|, |B|, |U|, |V|,
|D| within braces. |A| is the first (expanded, as usual) input number, |B| the
second, |D| is the GCD, and \dtt{UA - VB = D}. %
%
\leftedline{|\xintAssign
 {{\xintBezout {10000}{1113}}}\to\X|} %
%
\leftedline{|\meaning\X:
 |\dtt{\meaning\X }.}
\noindent{|\xintAssign {\xintBezout {10000}{1113}}\to\A\B\U\V\D|}\\
|\A: |\dtt{\A },
|\B: |\dtt{\B },
|\U: |\dtt{\U },
|\V: |\dtt{\V },
|\D: |\dtt{\D }.\\
\xintAssign {\xintBezout {123456789012345}{9876543210321}}\to\A\B\U\V\D
\noindent{|\xintAssign {\xintBezout {123456789012345}{9876543210321}}\to\A\B\U\V\D
|}\\
|\A: |\dtt{\A },
|\B: |\dtt{\B },
|\U: |\dtt{\U },
|\V: |\dtt{\V },
|\D: |\dtt{\D }.

\subsection{\csbh{xintEuclideAlgorithm}}\label{xintEuclideAlgorithm}

\xintAssign {{\xintEuclideAlgorithm {10000}{1113}}}\to\X

\def\restorebracecatcodes
   {\catcode`\{=1 \catcode`\}=2 }

\def\allowlistsplit
   {\catcode`\{=12 \catcode`\}=12 \allowlistsplita }

\def\allowlistsplitx {\futurelet\listnext\allowlistsplitxx }

\def\allowlistsplitxx {\ifx\listnext\relax \restorebracecatcodes
                        \else \expandafter\allowlistsplitxxx \fi }
\begingroup
\catcode`\[=1
\catcode`\]=2
\catcode`\{=12
\catcode`\}=12
\gdef\allowlistsplita #1{[#1\allowlistsplitx {]
\gdef\allowlistsplitxxx {#1}%
     [{#1}\hskip 0pt plus 1pt \allowlistsplitx ]
\endgroup

|\xintEuclideAlgorithm|\n\m\etype{\Numf\Numf} applies the Euclide algorithm
and keeps a copy of all quotients and remainders. %
%
\leftedline{|\xintAssign {{\xintEuclideAlgorithm {10000}{1113}}}\to\X|}

|\meaning\X: |\dtt{\expandafter\allowlistsplit\meaning\X\relax .}

The first token is the number of steps, the second is |N|, the
third is the GCD, the fourth is |M| then the first quotient and
remainder, the second quotient and remainder, \dots until the
final quotient and last (zero) remainder.

\subsection{\csbh{xintBezoutAlgorithm}}\label{xintBezoutAlgorithm}

\xintAssign {{\xintBezoutAlgorithm {10000}{1113}}}\to\X

|\xintBezoutAlgorithm|\n\m\etype{\Numf\Numf} applies the Euclide algorithm
and keeps a copy of all quotients and remainders. Furthermore it computes the
entries of the successive products of the 2 by 2 matrices
$\left(\vcenter{\halign {\,#&\,#\cr q & 1 \cr 1 & 0 \cr}}\right)$ formed from
the quotients arising in the algorithm. %
%
\leftedline{|\xintAssign {{\xintBezoutAlgorithm {10000}{1113}}}\to\X|}

|\meaning\X: |\dtt{\expandafter\allowlistsplit\meaning\X \relax .}

The first token is the number of steps, the second is |N|, then
|0|, |1|, the GCD, |M|, |1|, |0|, the first quotient, the first
remainder, the top left entry of the first matrix, the bottom left
entry, and then these four things at each step until the end.

\subsection{\csbh{xintTypesetEuclideAlgorithm}}\label{xintTypesetEuclideAlgorithm}

Requires explicit loading by the user of package \xinttoolsname.

This macro is just an example of how to organize the data returned by
\csa{xintEuclideAlgorithm}.\ntype{\Numf\Numf} Copy the source code to a new
macro and modify it to what is needed.
%
\leftedline{|\xintTypesetEuclideAlgorithm {123456789012345}{9876543210321}|}
\xintTypesetEuclideAlgorithm {123456789012345}{9876543210321}

\subsection{\csbh{xintTypesetBezoutAlgorithm}}%
\label{xintTypesetBezoutAlgorithm}

Requires explicit loading by the user of package \xinttoolsname.

This macro is just an example of how to organize the data returned by
\csa{xintBezoutAlgorithm}.\ntype{\Numf\Numf} Copy the source code to a new
macro and modify it to what is needed.
%
\leftedline{|\xintTypesetBezoutAlgorithm {10000}{1113}|}
\xintTypesetBezoutAlgorithm {10000}{1113}

\section{Commands of the \xintseriesname package}
\label{sec:series}

\localtableofcontents

This package was first released with version |1.03| (|2013/04/14|) of the
\xintname bundle.

The \Ff{} expansion type of various macro arguments is only a \Numf{} if only
\xintname but not \xintfracname is loaded. The macro \csbxint{iSeries} is
special and expects summing big integers obeying the strict format, even if
\xintfracname is loaded.

The arguments serving as indices are of the \numx{} expansion type.

In some cases one or two of the macro arguments are only expanded at a later
stage not immediately.

%% \clearpage

\subsection{\csbh{xintSeries}}\label{xintSeries}

\csa{xintSeries}|{A}{B}{\coeff}|\etype{\numx\numx\Ff} computes
$\sum_{\text{|n=A|}}^{\text{|n=B|}}|\coeff{n}|$. The initial and final indices
must obey the |\numexpr| constraint of expanding to numbers at most |2^31-1|.
The |\coeff| macro must be a one-parameter \fexpan dable command, taking on
input an explicit number |n| and producing some number or fraction |\coeff{n}|;
it is expanded at the time it is
needed.%
%
\footnote{\label{fn:xintiiMON}\csbxint{iiMON} is like \csbxint{MON} but
  does not parse its argument through \csbxint{Num}, for efficiency;
  other macros of this type are \csbxint{iiAdd}, \csbxint{iiMul},
  \csbxint{iiSum}, \csbxint{iiPrd}, \csbxint{iiMMON}, \csbxint{iiLDg},
  \csbxint{iiFDg}, \csbxint{iiOdd}, \dots}

\begin{everbatim*}
\def\coeff #1{\xintiiMON{#1}/#1.5} % (-1)^n/(n+1/2)
\fdef\w {\xintSeries {0}{50}{\coeff}} % we want to re-use it
\fdef\z {\xintJrr {\w}[0]} % the [0] for a microsecond gain.
% \xintJrr preferred to \xintIrr: a big common factor is suspected.
% But numbers much bigger would be needed to show the greater efficiency.
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} = \xintFrac\z \]
\end{everbatim*}

The definition of |\coeff| as |\xintiiMON{#1}/#1.5| is quite suboptimal. It
allows |#1| to be a big integer, but anyhow only small integers are accepted
as initial and final indices (they are of the \numx{} type). Second, when the
\xintfracname parser sees the |#1.5| it will remove the dot hence create a
denominator with one digit more. For example |1/3.5| turns internally into
|10/35| whereas it would be more efficient to have |2/7|. For info here is the
non-reduced |\w|:
\[\xintFrac\w\]
It would have been bigger still in releases earlier than |1.1|: now, the
\xintfracname \csbxint{Add} routine does not multiply blindly denominators
anymore, it checks if one is a multiple of the other. However it does not
practice systematic reduction to lowest terms.

A more efficient way to code |\coeff| is illustrated next.
\begin{everbatim*}
\def\coeff #1{\the\numexpr\ifodd #1 -2\else2\fi\relax/\the\numexpr 2*#1+1\relax [0]}%
% The [0] in \coeff is a tiny optimization: in its presence the \xintfracname parser 
% sees something which is already in internal format.
\fdef\w {\xintSeries {0}{50}{\coeff}}
\[\sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12}=\xintFrac\w\]
\end{everbatim*}
The reduced form |\z| as displayed above only differs from this one by a
factor of \dtt{\xintNum {\xintDenominator\w/\xintDenominator\z}}.

\setlength{\columnsep}{0pt}
\everb|@
\def\coeffleibnitz #1{\the\numexpr\ifodd #1 1\else-1\fi\relax/#1[0]}
\cnta 1
\loop  % in this loop we recompute from scratch each partial sum!
% we can afford that, as \xintSeries is fast enough.
\noindent\hbox to 2em{\hfil\texttt{\the\cnta.} }%
         \xintTrunc {12}{\xintSeries {1}{\cnta}{\coeffleibnitz}}\dots
\endgraf
\ifnum\cnta < 30 \advance\cnta 1 \repeat
|

\begin{multicols}{3}
  \def\coeffleibnitz #1{\the\numexpr\ifodd #1 1\else-1\fi\relax/#1[0]} \cnta 1
  \loop
  \noindent\hbox to 2em{\hfil\dtt{\the\cnta.} }%
  \xintTrunc {12}{\xintSeries {1}{\cnta}{\coeffleibnitz}}\dots
    \endgraf
    \ifnum\cnta < 30 \advance\cnta 1 \repeat
\end{multicols}

\subsection{\csbh{xintiSeries}}\label{xintiSeries}

\def\coeff #1{\xintiTrunc {40}
   {\the\numexpr\ifodd #1 -2\else2\fi\relax/\the\numexpr 2*#1+1\relax [0]}}%

 \csa{xintiSeries}|{A}{B}{\coeff}|\etype{\numx\numx f} computes
 $\sum_{\text{|n=A|}}^{\text{|n=B|}}|\coeff{n}|$ where |\coeff{n}|
 must \fexpan d to a (possibly long) integer in the strict format.
\everb|@
\def\coeff #1{\xintiTrunc {40}{\xintMON{#1}/#1.5}}%
% better:
\def\coeff #1{\xintiTrunc {40}
   {\the\numexpr 2*\xintiiMON{#1}\relax/\the\numexpr 2*#1+1\relax [0]}}%
% better still:
\def\coeff #1{\xintiTrunc {40}
 {\the\numexpr\ifodd #1 -2\else2\fi\relax/\the\numexpr 2*#1+1\relax [0]}}%
% (-1)^n/(n+1/2) times 10^40, truncated to an integer.
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} \approx
        \xintTrunc {40}{\xintiSeries {0}{50}{\coeff}[-40]}\dots\]
|

\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} \approx \xintTrunc
{40}{\xintiSeries {0}{50}{\coeff}[-40]}\] 

We should have cut out at
least the last two digits: truncating errors originating with the first
coefficients of the sum will never go away, and each truncation
introduces an uncertainty in the last digit, so as we have 40 terms, we
should trash the last two digits, or at least round at 38 digits. It is
interesting to compare with the computation where rounding rather than
truncation is used, and with the decimal
expansion of the exactly computed partial sum of the series:
\everb|@
\def\coeff #1{\xintiRound {40} % rounding at 40
  {\the\numexpr\ifodd #1 -2\else2\fi\relax/\the\numexpr 2*#1+1\relax [0]}}%
% (-1)^n/(n+1/2) times 10^40, rounded to an integer.
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} \approx
        \xintTrunc {40}{\xintiSeries {0}{50}{\coeff}[-40]}\]
\def\exactcoeff #1%
  {\the\numexpr\ifodd #1 -2\else2\fi\relax/\the\numexpr 2*#1+1\relax [0]}%
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12}
   = \xintTrunc {50}{\xintSeries {0}{50}{\exactcoeff}}\dots\]
|

\def\coeff #1{\xintiRound {40}
   {\the\numexpr\ifodd #1 -2\else2\fi\relax/\the\numexpr 2*#1+1\relax [0]}}%
% (-1)^n/(n+1/2) times 10^40, rounded to an integer.
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} \approx
        \xintTrunc {40}{\xintiSeries {0}{50}{\coeff}[-40]}\]
\def\exactcoeff #1%
  {\the\numexpr\ifodd #1 -2\else2\fi\relax/\the\numexpr 2*#1+1\relax [0]}%
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12}
   = \xintTrunc {50}{\xintSeries {0}{50}{\exactcoeff}}\dots\]
This shows indeed that our sum of truncated terms
estimated wrongly the 39th and 40th digits of the exact result%
%
\footnote{as the series is alternating, we can roughly expect an error
  of $\sqrt{40}$ and the last two digits are off by 4 units, which is
  not contradictory to our expectations.}
%
and that the sum of rounded terms fared a bit better.

\subsection{\csbh{xintRationalSeries}}\label{xintRationalSeries}

%{\small \hspace*{\parindent}New with release |1.04|.\par}

\noindent \csa{xintRationalSeries}|{A}{B}{f}{\ratio}|\etype{\numx\numx\Ff\Ff}
evaluates $\sum_{\text{|n=A|}}^{\text{|n=B|}}|F(n)|$, where |F(n)| is specified
indirectly via the data of |f=F(A)| and the one-parameter macro |\ratio| which
must be such that |\macro{n}| expands to |F(n)/F(n-1)|. The name indicates that
\csa{xintRationalSeries} was designed to be useful in the cases where
|F(n)/F(n-1)| is a rational function of |n| but it may be anything expanding to
a fraction. The macro |\ratio| must be an expandable-only compatible command and
expand to its value after iterated full expansion of its first token. |A| and
|B| are fed to a |\numexpr| hence may be count registers or arithmetic
expressions built with such; they must obey the \TeX{}bound. The initial term
|f| may be a macro |\f|, it will be expanded to its value representing |F(A)|.

\begin{everbatim*}
\def\ratio #1{2/#1[0]}% 2/n, to compute exp(2)
\cnta 0 % previously declared count
\begin{quote}
\loop \fdef\z {\xintRationalSeries {0}{\cnta}{1}{\ratio }}%
\noindent$\sum_{n=0}^{\the\cnta} \frac{2^n}{n!}=
           \xintTrunc{12}\z\dots=
           \xintFrac\z=\xintFrac{\xintIrr\z}$\vtop to 5pt{}\par
\ifnum\cnta<20 \advance\cnta 1 \repeat 
\end{quote}
\end{everbatim*}

\begin{everbatim*}
\def\ratio #1{-1/#1[0]}% -1/n, comes from the series of exp(-1)
\cnta 0 % previously declared count
\begin{quote}
\loop
\fdef\z {\xintRationalSeries {0}{\cnta}{1}{\ratio }}%
\noindent$\sum_{n=0}^{\the\cnta} \frac{(-1)^n}{n!}=
  \xintTrunc{20}\z\dots=\xintFrac{\z}=\xintFrac{\xintIrr\z}$%
         \vtop to 5pt{}\par
\ifnum\cnta<20 \advance\cnta 1 \repeat
\end{quote}
\end{everbatim*}


 \def\ratioexp #1#2{\xintDiv{#1}{#2}}% #1/#2

\medskip We can incorporate an indeterminate if we define |\ratio| to be
a macro with two parameters: |\def\ratioexp
  #1#2{\xintDiv{#1}{#2}}|\texttt{\%}| x/n: x=#1, n=#2|.
Then, if |\x| expands to some fraction |x|, the
command %
%
\leftedline{|\xintRationalSeries {0}{b}{1}{\ratioexp{\x}}|}
will compute $\sum_{n=0}^{n=b} x^n/n!$:\par
\begin{everbatim*}
\cnta 0
\def\ratioexp #1#2{\xintDiv{#1}{#2}}% #1/#2
\loop
\noindent
$\sum_{n=0}^{\the\cnta} (.57)^n/n! = \xintTrunc {50}
     {\xintRationalSeries {0}{\cnta}{1}{\ratioexp{.57}}}\dots$
     \vtop to 5pt {}\endgraf
\ifnum\cnta<50 \advance\cnta 10 \repeat
\end{everbatim*}

Observe that in this last example the |x| was directly inserted; if it
had been a more complicated explicit fraction it would have been
worthwile to use |\ratioexp\x| with |\x| defined to expand to its value.
In the further situation where this fraction |x| is not explicit but
itself defined via a complicated, and time-costly, formula, it should be
noted that \csa{xintRationalSeries} will do again the evaluation of |\x|
for each term of the partial sum. The easiest is thus when |x| can be
defined as an |\edef|. If however, you are in an expandable-only context
and cannot store in a macro like |\x| the value to be used, a variant of
\csa{xintRationalSeries} is needed which will first evaluate this |\x| and then
use this result without recomputing it. This is \csbxint{RationalSeriesX},
documented next.

Here is a slightly more complicated evaluation:
\begin{everbatim*}
\cnta 1
\begin{multicols}{2}
\loop \fdef\z {\xintRationalSeries
                   {\cnta}
                   {2*\cnta-1}
                   {\xintiPow {\the\cnta}{\cnta}/\xintFac{\cnta}}
                   {\ratioexp{\the\cnta}}}%
\fdef\w {\xintRationalSeries {0}{2*\cnta-1}{1}{\ratioexp{\the\cnta}}}%
\noindent
$\sum_{n=\the\cnta}^{\the\numexpr 2*\cnta-1\relax} \frac{\the\cnta^n}{n!}/%
          \sum_{n=0}^{\the\numexpr 2*\cnta-1\relax} \frac{\the\cnta^n}{n!} =
          \xintTrunc{8}{\xintDiv\z\w}\dots$ \vtop to 5pt{}\endgraf
\ifnum\cnta<20 \advance\cnta 1 \repeat
\end{multicols}
\end{everbatim*}


\subsection{\csbh{xintRationalSeriesX}}\label{xintRationalSeriesX}

%{\small \hspace*{\parindent}New with release |1.04|.\par}

\noindent\csa{xintRationalSeriesX}|{A}{B}{\first}{\ratio}{\g}|%
\etype{\numx\numx\Ff\Ff f} is a parametrized version of \csa{xintRationalSeries}
where |\first| is now a one-parameter macro such that |\first{\g}| gives the
initial term and |\ratio| is a two-parameter macro such that |\ratio{n}{\g}|
represents the ratio of one term to the previous one. The parameter |\g| is
evaluated only once at the beginning of the computation, and can thus itself be
the yet unevaluated result of a previous computation.

Let |\ratio| be such a two-parameter macro; note the subtle differences
between%
%
\leftedline{|\xintRationalSeries {A}{B}{\first}{\ratio{\g}}|}
%
\leftedline{and |\xintRationalSeriesX {A}{B}{\first}{\ratio}{\g}|.} First the
location of braces differ... then, in the former case |\first| is a
\emph{no-parameter} macro expanding to a fractional number, and in the latter,
it is a
\emph{one-parameter} macro which will use |\g|. Furthermore the |X| variant
will expand |\g| at the very beginning whereas the former non-|X| former variant
will evaluate it each time it needs it (which is bad if this
evaluation is time-costly, but good if |\g| is a big explicit fraction
encapsulated in a macro).

The example will use the macro \csbxint{PowerSeries} which computes
efficiently exact partial sums of power series, and is discussed in the
next section.
\begin{everbatim*}
\def\firstterm #1{1[0]}% first term of the exponential series
% although it is the constant 1, here it must be defined as a
% one-parameter macro. Next comes the ratio function for exp:
\def\ratioexp  #1#2{\xintDiv {#1}{#2}}% x/n
% These are the (-1)^{n-1}/n of the log(1+h) series:
\def\coefflog #1{\the\numexpr\ifodd #1 1\else-1\fi\relax/#1[0]}%
% Let L(h) be the first 10 terms of the log(1+h) series and
% let E(t) be the first 10 terms of the exp(t) series.
% The following computes E(L(a/10)) for a=1,...,12.
\begin{multicols}{3}\raggedcolumns
\cnta 0
\loop
\noindent\xintTrunc {18}{%
     \xintRationalSeriesX {0}{9}{\firstterm}{\ratioexp}
         {\xintPowerSeries{1}{10}{\coefflog}{\the\cnta[-1]}}}\dots
\endgraf
\ifnum\cnta < 12 \advance \cnta 1 \repeat
\end{multicols}
\end{everbatim*}


These completely exact operations rapidly create numbers with many digits. Let
us print in full the raw fractions created by the operation illustrated above:

\fdef\z{\xintRationalSeriesX {0}{9}{\firstterm}
{\ratioexp}{\xintPowerSeries{1}{10}{\coefflog}{1[-1]}}}

|E(L(1[-1]))=|\dtt{\printnumber{\z}} (length of numerator:
\xintLen {\xintNumerator \z})

\fdef\z{\xintRationalSeriesX {0}{9}{\firstterm}
{\ratioexp}{\xintPowerSeries{1}{10}{\coefflog}{12[-2]}}}

|E(L(12[-2]))=|\dtt{\printnumber{\z}} (length of numerator:
\xintLen {\xintNumerator \z})

\fdef\z{\xintRationalSeriesX {0}{9}{\firstterm}
{\ratioexp}{\xintPowerSeries{1}{10}{\coefflog}{123[-3]}}}

|E(L(123[-3]))=|\dtt{\printnumber{\z}} (length of numerator:
\xintLen {\xintNumerator \z})

We see that the denominators here remain the same, as our input only had various
powers of ten as denominators, and \xintfracname efficiently assemble (some
only, as we can see) powers of ten. Notice that 1 more digit in an input
denominator seems to mean 90 more in the raw output. We can check that with some
other test cases:

\fdef\z{\xintRationalSeriesX {0}{9}{\firstterm}
{\ratioexp}{\xintPowerSeries{1}{10}{\coefflog}{1/7}}}

|E(L(1/7))=|\dtt{\printnumber{\z}} (length of numerator:
\xintLen {\xintNumerator \z}; length of denominator:
\xintLen {\xintDenominator \z})

\fdef\z{\xintRationalSeriesX {0}{9}{\firstterm}
{\ratioexp}{\xintPowerSeries{1}{10}{\coefflog}{1/71}}}

|E(L(1/71))=|\dtt{\printnumber{\z}} (length of numerator:
\xintLen {\xintNumerator \z}; length of denominator:
\xintLen {\xintDenominator \z})

\fdef\z{\xintRationalSeriesX {0}{9}{\firstterm}
{\ratioexp}{\xintPowerSeries{1}{10}{\coefflog}{1/712}}}

|E(L(1/712))=|\dtt{\printnumber{\z}} (length of numerator:
\xintLen {\xintNumerator \z}; length of denominator:
\xintLen {\xintDenominator \z})

% \pdfresettimer
% \edef\w{\xintDenominator{\xintIrr{\z}}}
% \the\pdfelapsedtime

Thus
decimal numbers such as |0.123| (equivalently
|123[-3]|) give less computing intensive tasks than fractions such as |1/712|:
in the case of decimal numbers the (raw) denominators originate in the
coefficients of the series themselves, powers of ten of the input within
brackets being treated separately. And even then the
numerators will grow with the size of the input in a sort of linear way, the
coefficient being given by the order of series: here 10 from the log and 9 from
the exp, so 90. One more digit in the input means 90 more digits in the
numerator of the output: obviously we can not go on composing such partial sums
of series and hope that \xintname will joyfully do all at the speed of light!

Hence, truncating the output (or better, rounding) is the only way to go if one
needs a general calculus of special functions. This is why the package
\xintseriesname provides, besides \csbxint{Series}, \csbxint{RationalSeries}, or
\csbxint{PowerSeries} which compute \emph{exact} sums, 
\csbxint{FxPtPowerSeries} for fixed-point computations and a (tentative naive)
\csbxint{FloatPowerSeries}.

\subsection{\csbh{xintPowerSeries}}\label{xintPowerSeries}

\csa{xintPowerSeries}|{A}{B}{\coeff}{f}|\etype{\numx\numx\Ff\Ff}
evaluates the sum
$\sum_{\text{|n=A|}}^{\text{|n=B|}}|\coeff{n}|\cdot |f|^{\text{|n|}}$. The
initial and final indices are given to a |\numexpr| expression. The |\coeff|
macro (which, as argument to \csa{xintPowerSeries} is expanded only at the time
|\coeff{n}| is needed) should be defined as a one-parameter expandable command,
its input will be an explicit number.

The |f| can be either a fraction directly input or a macro |\f| expanding to
such a fraction. It is actually more efficient to encapsulate an explicit
fraction |f| in such a macro, if it has big numerators and denominators (`big'
means hundreds of digits) as it will then take less space in the processing
until being (repeatedly) used.

This macro computes the \emph{exact} result (one can use it also for
polynomial evaluation), using a Horner scheme which helps avoiding a
denominator build-up (this problem however,  even if using a naive additive
approach, is much less acute since release |1.1| and its new policy regarding
\csbxint{Add}).

\begin{everbatim*}
\def\geom #1{1[0]} % the geometric series
\def\f {5/17[0]}
\[ \sum_{n=0}^{n=20} \Bigl(\frac 5{17}\Bigr)^n
 =\xintFrac{\xintIrr{\xintPowerSeries {0}{20}{\geom}{\f}}}
 =\xintFrac{\xinttheexpr (17^21-5^21)/12/17^20\relax}\]
\end{everbatim*}

\begin{everbatim*}
\def\coefflog #1{1/#1[0]}% 1/n
\def\f {1/2[0]}%
\[ \log 2 \approx \sum_{n=1}^{20} \frac1{n\cdot 2^n}
    = \xintFrac {\xintIrr {\xintPowerSeries {1}{20}{\coefflog}{\f}}}\]
\[ \log 2 \approx \sum_{n=1}^{50} \frac1{n\cdot 2^n}
    = \xintFrac {\xintIrr {\xintPowerSeries {1}{50}{\coefflog}{\f}}}\]
\end{everbatim*}


\begin{everbatim*}
\setlength{\columnsep}{0pt}
\begin{multicols}{3}
\cnta 1 % previously declared count
\loop   % in this loop we recompute from scratch each partial sum!
% we can afford that, as \xintPowerSeries is fast enough.
\noindent\hbox to 2em{\hfil\texttt{\the\cnta.} }%
         \xintTrunc {12}
             {\xintPowerSeries {1}{\cnta}{\coefflog}{\f}}\dots
\endgraf
\ifnum \cnta < 30 \advance\cnta 1 \repeat
\end{multicols}
\end{everbatim*}


\begin{everbatim*}
\def\coeffarctg  #1{1/\the\numexpr\ifodd #1 -2*#1-1\else2*#1+1\fi\relax }%
% the above gives (-1)^n/(2n+1). The sign being in the denominator,
%             **** no [0] should be added ****,
% else nothing is guaranteed to work (even if it could by sheer luck)
% Notice in passing this aspect of \numexpr:
%         ****  \numexpr -(1)\relax is ilegal !!! ****
\def\f {1/25[0]}% 1/5^2
\[\mathrm{Arctg}(\frac15)\approx \frac15\sum_{n=0}^{15} \frac{(-1)^n}{(2n+1)25^n}
= \xintFrac{\xintIrr {\xintDiv {\xintPowerSeries {0}{15}{\coeffarctg}{\f}}{5}}}\]
\end{everbatim*}


\subsection{\csbh{xintPowerSeriesX}}\label{xintPowerSeriesX}

%{\small\hspace*{\parindent}New with release |1.04|.\par}

\noindent This is the same as \csbxint{PowerSeries}\ntype{\numx\numx\Ff\Ff}
apart
from the fact that the last parameter |f| is expanded once and for all before
being then used repeatedly. If the |f| parameter is to be an explicit big
fraction with many (dozens) digits, rather than using it directly it is slightly
better to have some macro |\g| defined to expand to the explicit fraction and
then use \csbxint{PowerSeries} with |\g|; but if |f| has not yet been evaluated
and will be the output of a complicated expansion of some |\f|, and if, due to
an expanding only context, doing |\edef\g{\f}| is no option, then
\csa{xintPowerSeriesX} should be used with |\f| as last parameter.
%
\begin{everbatim*}
\def\ratioexp #1#2{\xintDiv {#1}{#2}}% x/n
% These are the (-1)^{n-1}/n of the log(1+h) series:
\def\coefflog #1{\the\numexpr\ifodd #1 1\else-1\fi\relax/#1[0]}%
% Let L(h) be the first 10 terms of the log(1+h) series and
% let E(t) be the first 10 terms of the exp(t) series.
% The following computes L(E(a/10)-1) for a=1,..., 12.
\begin{multicols}{3}\raggedcolumns
\cnta 1
\loop
\noindent\xintTrunc {18}{%
   \xintPowerSeriesX {1}{10}{\coefflog}
  {\xintSub
      {\xintRationalSeries {0}{9}{1[0]}{\ratioexp{\the\cnta[-1]}}}
      {1}}}\dots
\endgraf
\ifnum\cnta < 12 \advance \cnta 1 \repeat
\end{multicols}
\end{everbatim*}


\subsection{\csbh{xintFxPtPowerSeries}}\label{xintFxPtPowerSeries}

\csa{xintFxPtPowerSeries}|{A}{B}{\coeff}{f}{D}|\etype{\numx\numx}
computes
$\sum_{\text{|n=A|}}^{\text{|n=B|}}|\coeff{n}|\cdot |f|^{\,\text{|n|}}$ with each
    term of the series truncated to |D| digits\etype{\Ff\Ff\numx}
 after the decimal point. As
    usual, |A| and |B| are completely expanded through their inclusion in a
    |\numexpr| expression. Regarding |D| it will be similarly be expanded each
    time it is used inside an \csa{xintTrunc}. The one-parameter macro |\coeff|
    is similarly  expanded at the time it is used inside the
    computations. Idem for |f|. If |f| itself is some complicated macro it is
    thus better to use the variant \csbxint{FxPtPowerSeriesX} which expands it
    first and then uses the result of that expansion.

The current (|1.04|) implementation is: the first power |f^A| is
computed exactly, then \emph{truncated}. Then each successive power is
obtained from the previous one by multiplication by the exact value of
|f|, and truncated. And |\coeff{n}|\raisebox{.5ex}{|.|}|f^n| is obtained
from that by multiplying by |\coeff{n}| (untruncated) and then
truncating. Finally the sum is computed exactly. Apart from that
\csa{xintFxPtPowerSeries} (where |FxPt| means `fixed-point') is like
\csa{xintPowerSeries}.

There should be a variant for things of the type $\sum c_n \frac {f^n}{n!}$ to
avoid having to compute the factorial from scratch at each coefficient, the same
way \csa{xintFxPtPowerSeries} does not compute |f^n| from scratch at each |n|.
Perhaps in the next package release.

\def\coeffexp #1{1/\xintFac {#1}[0]}% [0] for faster parsing
\def\f {-1/2[0]}%
\newcount\cnta

\setlength{\multicolsep}{0pt}

\begin{multicols}{3}[%
\centeredline{$e^{-\frac12}\approx{}$}]%
\cnta 0
\noindent\loop
$\xintFxPtPowerSeries {0}{\cnta}{\coeffexp}{\f}{20}$\\
\ifnum\cnta<19
\advance\cnta 1
\repeat\par
\end{multicols}
\everb|@
\def\coeffexp #1{1/\xintFac {#1}[0]}% 1/n!
\def\f {-1/2[0]}% [0] for faster input parsing
\cnta 0 % previously declared \count register
\noindent\loop
$\xintFxPtPowerSeries {0}{\cnta}{\coeffexp}{\f}{20}$\\
\ifnum\cnta<19 \advance\cnta 1 \repeat\par
% One should **not** trust the final digits, as the potential truncation
% errors of up to 10^{-20} per term accumulate and never disappear! (the
% effect is attenuated by the alternating signs in the series). We  can
% confirm that the last two digits (of our evaluation of the nineteenth
% partial sum) are wrong via the evaluation with more digits:   
|

%
\leftedline{|\xintFxPtPowerSeries {0}{19}{\coeffexp}{\f}{25}=|
\dtt{\xintFxPtPowerSeries {0}{19}{\coeffexp}{\f}{25}}}
\fdef\z{\xintIrr {\xintPowerSeries {0}{19}{\coeffexp}{\f}}}
%

\texttt{\hyphenchar\font45 }%
It is no difficulty for \xintfracname to compute exactly, with the help
of \csa{xintPowerSeries}, the nineteenth partial sum, and to then give
(the start of) its exact decimal expansion:
%
\leftedline{|\xintPowerSeries {0}{19}{\coeffexp}{\f}| ${}=
  \displaystyle\xintFrac{\z}$%
  \vphantom{\vrule height 20pt depth 12pt}}%
%
\leftedline{${}=\xintTrunc {30}{\z}\dots$} Thus, one should always
estimate a priori how many ending digits are not reliable: if there are
|N| terms and |N| has |k| digits, then digits up to but excluding the
last |k| may usually be trusted. If we are optimistic and the series is
alternating we may even replace |N| with $\sqrt{|N|}$ to get the number |k|
of digits possibly of dubious significance.

\subsection{\csbh{xintFxPtPowerSeriesX}}\label{xintFxPtPowerSeriesX}

%{\small\hspace*{\parindent}New with release |1.04|.\par}

\noindent\csa{xintFxPtPowerSeriesX}|{A}{B}{\coeff}{\f}{D}|%
\ntype{\numx\numx}
computes, exactly as
\csa{xintFxPtPowerSeries}, the sum of
|\coeff{n}|\raisebox{.5ex}{|.|}|\f^n|\etype{\Ff\Ff\numx} from |n=A| to |n=B| with each term
of the series being \emph{truncated} to |D| digits after the decimal
point. The sole difference is that |\f| is first expanded and it
is the result of this which is used in the computations.

% Let us illustrate this on the computation of |(1+y)^{5/3}| where
% |1+y=(1+x)^{3/5}| and each of the two binomial series is evaluated with ten
% terms, the results being computed with |8| digits after the decimal point, and
% $|f|<1/10$.

Let us illustrate this on the numerical exploration of the identity
%
\leftedline{|log(1+x) = -log(1/(1+x))|}
%
Let |L(h)=log(1+h)|, and |D(h)=L(h)+L(-h/(1+h))|. Theoretically thus,
|D(h)=0| but we shall evaluate |L(h)| and |-h/(1+h)| keeping only 10
terms of their respective series. We will assume $|h|<0.5$. With only
ten terms kept in the power series we do not have quite 3 digits
precision as $2^{10}=1024$. So it wouldn't make sense to evaluate things
more precisely than, say circa 5 digits after the decimal points.
\begin{everbatim*}
\cnta 0
\def\coefflog #1{\the\numexpr\ifodd#1 1\else-1\fi\relax/#1[0]}% (-1)^{n-1}/n
\def\coeffalt #1{\the\numexpr\ifodd#1 -1\else1\fi\relax [0]}%   (-1)^n
\begin{multicols}2
\loop
\noindent \hbox to 2.5cm {\hss\texttt{D(\the\cnta/100): }}%
\xintAdd {\xintFxPtPowerSeriesX {1}{10}{\coefflog}{\the\cnta [-2]}{5}}
         {\xintFxPtPowerSeriesX {1}{10}{\coefflog}
             {\xintFxPtPowerSeriesX {1}{10}{\coeffalt}{\the\cnta [-2]}{5}}
          {5}}\endgraf
\ifnum\cnta < 49 \advance\cnta 7 \repeat
\end{multicols}
\end{everbatim*}


Let's say we evaluate functions on |[-1/2,+1/2]| with values more or less also
in |[-1/2,+1/2]| and we want to keep 4 digits of precision. So, roughly we need
at least 14 terms in series like the geometric or log series. Let's make this
15. Then it doesn't make sense to compute intermediate summands with more than 6
digits precision. So we compute with 6 digits
precision but return only 4 digits (rounded) after the decimal point.
This result with 4 post-decimal points precision is then used as input
to the next evaluation.
\begin{everbatim*}
\begin{multicols}2
\loop
\noindent \hbox to 2.5cm {\hss\texttt{D(\the\cnta/100): }}%
\dtt{\xintRound{4}
 {\xintAdd {\xintFxPtPowerSeriesX {1}{15}{\coefflog}{\the\cnta [-2]}{6}}
           {\xintFxPtPowerSeriesX {1}{15}{\coefflog}
                  {\xintRound {4}{\xintFxPtPowerSeriesX {1}{15}{\coeffalt}
                                 {\the\cnta [-2]}{6}}}
            {6}}%
 }}\endgraf
\ifnum\cnta < 49 \advance\cnta 7 \repeat
\end{multicols}
\end{everbatim*}

Not bad... I have cheated a bit: the `four-digits precise' numeric
evaluations were left unrounded in the final addition. However the inner
rounding to four digits worked fine and made the next step faster than
it would have been with longer inputs. The morale is that one should not
use the raw results of \csa{xintFxPtPowerSeriesX} with the |D| digits
with which it was computed, as the last are to be considered garbage.
Rather, one should keep from the output only some smaller number of
digits. This will make further computations faster and not less precise.
I guess there should be some command to do this final truncating, or
better, rounding, at a given number |D'<D| of digits. Maybe for the next
release.

\subsection{\csbh{xintFloatPowerSeries}}\label{xintFloatPowerSeries}

%{\small\hspace*{\parindent}New with |1.08a|.\par}

\noindent\csa{xintFloatPowerSeries}|[P]{A}{B}{\coeff}{f}|%
\ntype{{\upshape[\numx]}\numx\numx}
 computes
$\sum_{\text{|n=A|}}^{\text{|n=B|}}|\coeff{n}|\cdot |f|^{\,\text{|n|}}$
with a floating point
precision given by the optional parameter |P| or by the current setting of
|\xintDigits|.\etype{\Ff\Ff}

In the current, preliminary, version, no attempt has been made to try to
guarantee to the final result the precision |P|. Rather, |P| is used for all
intermediate floating point evaluations. So
rounding errors will make some of the last printed digits invalid. The
operations done are first the evaluation of |f^A| using \csa{xintFloatPow}, then
each successive power is obtained from this first one by multiplication by |f|
using \csa{xintFloatMul}, then again with \csa{xintFloatMul} this is multiplied
with |\coeff{n}|, and the sum is done adding one term at a time with
\csa{xintFloatAdd}. To sum up, this is just the naive transformation of
\csa{xintFxPtPowerSeries} from fixed point to floating point.

\def\coefflog #1{\the\numexpr\ifodd#1 1\else-1\fi\relax/#1[0]}%

\everb+@
\def\coefflog #1{\the\numexpr\ifodd#1 1\else-1\fi\relax/#1[0]}%
\xintFloatPowerSeries [8]{1}{30}{\coefflog}{-1/2[0]}
+

%
\leftedline{\dtt{\xintFloatPowerSeries [8]{1}{30}{\coefflog}{-1/2[0]}}}

\subsection{\csbh{xintFloatPowerSeriesX}}\label{xintFloatPowerSeriesX}

%{\small\hspace*{\parindent}New with |1.08a|.\par}

\noindent\csa{xintFloatPowerSeriesX}|[P]{A}{B}{\coeff}{f}|%
\ntype{{\upshape[\numx]}\numx\numx}
is like
\csa{xintFloatPowerSeries} with the difference that |f| is
expanded once\etype{\Ff\Ff}
and for all at the start of the computation, thus allowing
efficient chaining of such series evaluations.
\def\coefflog #1{\the\numexpr\ifodd#1 1\else-1\fi\relax/#1[0]}%

\everb+@
\def\coeffexp #1{1/\xintFac {#1}[0]}% 1/n! (exact, not float)
\def\coefflog #1{\the\numexpr\ifodd#1 1\else-1\fi\relax/#1[0]}%
\xintFloatPowerSeriesX [8]{0}{30}{\coeffexp}
    {\xintFloatPowerSeries [8]{1}{30}{\coefflog}{-1/2[0]}}
+

%
\leftedline{\dtt{\xintFloatPowerSeriesX [8]{0}{30}{\coeffexp}
    {\xintFloatPowerSeries [8]{1}{30}{\coefflog}{-1/2[0]}}}}

\subsection{Computing \texorpdfstring{$\log 2$}{log(2)} and \texorpdfstring{$\pi$}{pi}}\label{ssec:Machin}

In this final section, the use of \csbxint{FxPtPowerSeries} (and
\csbxint{PowerSeries}) will be
illustrated on the (expandable... why make things simple when it is so easy to
make them difficult!) computations of the first digits of the decimal expansion
of the familiar constants $\log 2$ and $\pi$.

Let us start with $\log 2$. We will get it from this formula (which is
left as an exercise): %
%
\leftedline{\dtt{log(2)=-2\,log(1-13/256)-%
 5\,log(1-1/9)}}
%
The number of terms to be kept in the log series, for a desired
precision of |10^{-D}| was roughly estimated without much theoretical
analysis. Computing exactly the partial sums with \csa{xintPowerSeries}
and then printing the truncated values, from |D=0| up to |D=100| showed
that it worked in terms of quality of the approximation. Because of
possible strings of zeroes or nines in the exact decimal expansion (in
the present case of $\log 2$, strings of zeroes around the fourtieth and
the sixtieth decimals), this
does not mean though that all digits printed were always exact. In
the end one always end up having to compute at some higher level of
desired precision to validate the earlier result.

Then we tried with \csa{xintFxPtPowerSeries}: this is worthwile only for
|D|'s at least 50, as the exact evaluations are faster (with these
short-length |f|'s) for a lower
number of digits. And as expected the degradation in the quality of
approximation was in this range of the order of two or three digits.
This meant roughly that the 3+1=4 ending digits were wrong. Again, we ended
up having to compute with five more digits and compare with the earlier
value to validate it. We use truncation rather than rounding because our
goal is not to obtain the correct rounded decimal expansion but the
correct exact truncated one.

% 693147180559945309417232121458176568075500134360255254120680009493

\begin{everbatim*}
\def\coefflog #1{1/#1[0]}% 1/n
\def\xa {13/256[0]}%  we will compute log(1-13/256)
\def\xb {1/9[0]}%     we will compute log(1-1/9)
\def\LogTwo #1%
%  get log(2)=-2log(1-13/256)- 5log(1-1/9)
{% we want to use \printnumber, hence need something expanding in two steps
 % only, so we use here the \romannumeral0 method
  \romannumeral0\expandafter\LogTwoDoIt \expandafter
    % Nb Terms for 1/9:
  {\the\numexpr #1*150/143\expandafter}\expandafter
    % Nb Terms for 13/256:
  {\the\numexpr #1*100/129\expandafter}\expandafter
    % We print #1 digits, but we know the ending ones are garbage
  {\the\numexpr #1\relax}% allows #1 to be a count register
}%
\def\LogTwoDoIt #1#2#3%
%  #1=nb of terms for 1/9, #2=nb of terms for 13/256,
{% #3=nb of digits for computations, also used for printing
 \xinttrunc {#3} % lowercase form to stop the \romannumeral0 expansion!
 {\xintAdd
  {\xintMul {2}{\xintFxPtPowerSeries {1}{#2}{\coefflog}{\xa}{#3}}}
  {\xintMul {5}{\xintFxPtPowerSeries {1}{#1}{\coefflog}{\xb}{#3}}}%
 }%
}%
\noindent $\log 2 \approx \LogTwo {60}\dots$\endgraf
\noindent\phantom{$\log 2$}${}\approx{}$\printnumber{\LogTwo {65}}\dots\endgraf
\noindent\phantom{$\log 2$}${}\approx{}$\printnumber{\LogTwo {70}}\dots\endgraf
\end{everbatim*}

Here is the code doing an exact evaluation of the partial sums. We have
added a |+1| to the number of digits for estimating the number of terms
to keep from the log series: we experimented that this gets exactly the
first |D| digits, for all values from |D=0| to |D=100|, except in one
case (|D=40|) where the last digit is wrong. For values of |D|
higher than |100| it is more efficient to use the code using
\csa{xintFxPtPowerSeries}.
\everb|@
\def\LogTwo #1% get log(2)=-2log(1-13/256)- 5log(1-1/9)
{%
    \romannumeral0\expandafter\LogTwoDoIt \expandafter
    {\the\numexpr (#1+1)*150/143\expandafter}\expandafter
    {\the\numexpr (#1+1)*100/129\expandafter}\expandafter
    {\the\numexpr #1\relax}%
}%
\def\LogTwoDoIt #1#2#3%
{%   #3=nb of digits for truncating an EXACT partial sum
  \xinttrunc {#3}
    {\xintAdd
      {\xintMul {2}{\xintPowerSeries {1}{#2}{\coefflog}{\xa}}}
      {\xintMul {5}{\xintPowerSeries {1}{#1}{\coefflog}{\xb}}}%
    }%
}%
|

Let us turn now to Pi, computed with the Machin formula. Again the numbers of
terms to keep in the two |arctg| series were roughly estimated, and some
experimentations showed that removing the last three digits was enough (at least
for |D=0-100| range). And the algorithm does print the correct digits when used
with |D=1000| (to be convinced of that one needs to run it for |D=1000| and
again, say for |D=1010|.) A theoretical analysis could help confirm that this
algorithm always gets better than |10^{-D}| precision, but again, strings of
zeroes or nines encountered in the decimal expansion may falsify the ending
digits, nines may be zeroes (and the last non-nine one should be increased) and
zeroes may be nine (and the last non-zero one should be decreased).

\hypertarget{MachinCode}{}
\begin{everbatim*}
\def\coeffarctg #1{\the\numexpr\ifodd#1 -1\else1\fi\relax/%
                                       \the\numexpr 2*#1+1\relax [0]}%
%\def\coeffarctg #1{\romannumeral0\xintmon{#1}/\the\numexpr 2*#1+1\relax }%
\def\xa {1/25[0]}%      1/5^2, the [0] for faster parsing
\def\xb {1/57121[0]}% 1/239^2, the [0] for faster parsing
\def\Machin #1{% #1 may be a count register, \Machin {\mycount} is allowed
    \romannumeral0\expandafter\MachinA \expandafter
     % number of terms for arctg(1/5):
    {\the\numexpr (#1+3)*5/7\expandafter}\expandafter
     % number of terms for arctg(1/239):
    {\the\numexpr (#1+3)*10/45\expandafter}\expandafter
     % do the computations with 3 additional digits:
    {\the\numexpr #1+3\expandafter}\expandafter
     % allow #1 to be a count register:
    {\the\numexpr #1\relax }}%
\def\MachinA #1#2#3#4%
{\xinttrunc {#4}
 {\xintSub
  {\xintMul {16/5}{\xintFxPtPowerSeries {0}{#1}{\coeffarctg}{\xa}{#3}}}
  {\xintMul{4/239}{\xintFxPtPowerSeries {0}{#2}{\coeffarctg}{\xb}{#3}}}%
 }}%
\begin{framed}
  \[ \pi = \Machin {60}\dots \]
\end{framed}
\end{everbatim*}

Here is a variant|\MachinBis|,
which evaluates the partial sums \emph{exactly} using
\csa{xintPowerSeries}, before their final truncation. No need for a
``|+3|'' then.
\begin{everbatim*}
\def\MachinBis #1{% #1 may be a count register,
% the final result will be truncated to #1 digits post decimal point
    \romannumeral0\expandafter\MachinBisA \expandafter
     % number of terms for arctg(1/5):
    {\the\numexpr #1*5/7\expandafter}\expandafter
     % number of terms for arctg(1/239):
    {\the\numexpr #1*10/45\expandafter}\expandafter
      % allow #1 to be a count register:
    {\the\numexpr #1\relax }}%
\def\MachinBisA #1#2#3%
{\xinttrunc {#3} %
 {\xintSub
   {\xintMul {16/5}{\xintPowerSeries {0}{#1}{\coeffarctg}{\xa}}}
   {\xintMul{4/239}{\xintPowerSeries {0}{#2}{\coeffarctg}{\xb}}}%
}}%
\end{everbatim*}

Let us use this variant for a loop showing the build-up of digits:
\begin{everbatim*}
\begin{multicols}{2}
  \cnta 0 % previously declared \count register
  \loop \noindent
        \centeredline{\dtt{\MachinBis{\cnta}}}%
  \ifnum\cnta < 30
  \advance\cnta 1 \repeat
\end{multicols}
\end{everbatim*}

\hypertarget{Machin1000}{}
%
You want more digits and have some time? compile this copy of the
\hyperlink{MachinCode}{|\Machin|} with |etex| (or |pdftex|):
%
\everb|@
% Compile with e-TeX extensions enabled (etex, pdftex, ...)
\input xintfrac.sty
\input xintseries.sty
% pi = 16 Arctg(1/5) - 4 Arctg(1/239) (John Machin's formula)
\def\coeffarctg #1{\the\numexpr\ifodd#1 -1\else1\fi\relax/%
                                       \the\numexpr 2*#1+1\relax [0]}%
\def\xa {1/25[0]}%
\def\xb {1/57121[0]}%
\def\Machin #1{%
    \romannumeral0\expandafter\MachinA \expandafter
    {\the\numexpr (#1+3)*5/7\expandafter}\expandafter
    {\the\numexpr (#1+3)*10/45\expandafter}\expandafter
    {\the\numexpr #1+3\expandafter}\expandafter
    {\the\numexpr #1\relax }}%
\def\MachinA #1#2#3#4%
{\xinttrunc {#4}
 {\xintSub
  {\xintMul {16/5}{\xintFxPtPowerSeries {0}{#1}{\coeffarctg}{\xa}{#3}}}
  {\xintMul {4/239}{\xintFxPtPowerSeries {0}{#2}{\coeffarctg}{\xb}{#3}}}%
}}%
\pdfresettimer
\fdef\Z {\Machin {1000}}
\odef\W {\the\pdfelapsedtime}
\message{\Z}
\message{computed in \xintRound {2}{\W/65536} seconds.}
\bye 
|

This will log the first 1000 digits of $\pi$ after the decimal point. On my
laptop (a 2012 model) this took about $5.6$ seconds last time I tried.%
%
\footnote{With \texttt{v1.09i} and earlier \xintname, this used to be \dtt{42}
  seconds; starting with \texttt{v1.09j}, and prior to \texttt{v1.2}, it was
  \dtt{16} seconds (this was probably due to a more efficient division with
  denominators at most $9999$). The |v1.2| \xintcorename achieves a further
  gain.}
%
As mentioned in the
introduction, the file \href{http://www.ctan.org/pkg/pi}{pi.tex} by \textsc{D.
  Roegel} shows that orders of magnitude faster computations are possible within
\TeX{}, but recall our constraints of complete expandability and be merciful,
please.

\textbf{Why truncating rather than rounding?} One of our main competitors
on the market of scientific computing, a canadian product (not
encumbered with expandability constraints, and having barely ever heard
of \TeX{} ;-), prints numbers rounded in the last digit. Why didn't we
follow suit in the macros \csa{xintFxPtPowerSeries} and
\csa{xintFxPtPowerSeriesX}? To round at |D| digits, and excluding a
rewrite or cloning of the division algorithm which anyhow would add to
it some overhead in its final steps, \xintfracname needs to truncate at
|D+1|, then round. And rounding loses information! So, with more time
spent, we obtain a worst result than the one truncated at |D+1| (one
could imagine that additions and so on, done with only |D| digits, cost
less; true, but this is a negligeable effect per summand compared to the
additional cost for this term of having been truncated at |D+1| then
rounded). Rounding is the way to go when setting up algorithms to
evaluate functions destined to be composed one after the other: exact
algebraic operations with many summands and an |f| variable which is a
fraction are costly and create an even bigger fraction; replacing |f|
with a reasonable rounding, and rounding the result, is necessary to
allow arbitrary chaining.

But, for the
computation of a single constant, we are really interested in the exact
decimal expansion, so we truncate and compute more terms until the
earlier result gets validated. Finally if we do want the rounding we can
always do it on a value computed with |D+1| truncation.

%  \clearpage

\section{Commands of the \xintcfracname package}
\label{sec:cfrac}

\localtableofcontents

This package was first included in release |1.04| (|2013/04/25|) of the
\xintname bundle. It was kept almost unchanged until |1.09m| of |2014/02/26|
which brings some new macros: \csbxint{FtoC}, \csbxint{CtoF}, \csbxint{CtoCv},
dealing with sequences of braced partial quotients rather than comma separated
ones, \csbxint{FGtoC} which is to produce ``guaranteed'' coefficients of some
real number known approximately, and \csbxint{GGCFrac} for displaying arbitrary
material as a continued fraction; also, some changes to existing macros:
\csbxint{FtoCs} and \csbxint{CntoCs} insert spaces after the commas,
\csbxint{CstoF} and \csbxint{CstoCv} authorize spaces in the input also before
the commas.

This section contains:
\begin{enumerate}
\item an \hyperref[ssec:cfracoverview]{overview} of the package functionalities,
\item a description of each one of the package macros,
\item further illustration of their use via the study of the
  \hyperref[ssec:e-convergents]{convergents of $e$}.
\end{enumerate}

\subsection{Package overview}\label{ssec:cfracoverview}

The package computes partial quotients and convergents of a fraction, or
conversely start from coefficients and obtain the corresponding fraction; three
macros \csbxint {CFrac}, \csbxint {GCFrac} and \csbxint {GGCFrac} are
for typesetting (the first two assume that the coefficients are numeric
quantities acceptable by the \xintfracname \csbxint{Frac} macro, the
last one will display arbitrary material), the others
can be nested (if applicable) or see their outputs further processed by other
macros from the \xintname bundle, particularly the macros of \xinttoolsname
dealing with sequences of braced items or comma separated lists.

A \emph{simple} continued fraction has coefficients
|[c0,c1,...,cN]| (usually called partial quotients, but I
dislike this entrenched terminology), where |c0| is a positive or
negative integer and the others are positive integers.

Typesetting is usually done via the |amsmath| macro |\cfrac|:
\begin{everbatim*}
\[ c_0 + \cfrac{1}{c_1+\cfrac1{c_2+\cfrac1{c_3+\cfrac1{\ddots}}}}\]
\end{everbatim*}

Here is a concrete example:
\begin{everbatim*}
\[ \xintFrac {208341/66317}=\xintCFrac {208341/66317}\]%
\end{everbatim*}
But it is the command \csbxint{CFrac} which did all the work of \emph{computing}
the continued fraction \emph{and} using |\cfrac| from |amsmath| to typeset
it.

A \emph{generalized} continued fraction has the same structure but the
numerators are not restricted to be $1$, and numbers used in the continued
fraction may be arbitrary, also fractions, irrationals, complex,
indeterminates.%
%
\footnote{\xintcfracname may be used with indeterminates,
  for basic conversions from one inline format to another, but not for
  actual computations. See \csbxint{GGCFrac}.}
%
The \emph{centered} continued fraction is an
example:
\begin{everbatim*}
\[ \xintFrac {915286/188421}=\xintGCFrac {5+-1/7+1/39+-1/53+-1/13}
  =\xintCFrac {915286/188421}\]
\end{everbatim*}

The command \csbxint{GCFrac}, contrarily to
\csbxint{CFrac}, does not compute anything, it just typesets starting from a
generalized continued fraction in inline format, which in this example
was input literally.  We also used \csa{xintCFrac}
for comparison of the two types of continued fractions.

To let \TeX{} compute the centered continued fraction of |f| there is
\csbxint{FtoCC}:
\begin{everbatim*}
\[\xintFrac {915286/188421}\to\xintFtoCC {915286/188421}\]
\end{everbatim*}
The package macros are expandable and may be nested (naturally \csa{xintCFrac}
and \csa{xintGCFrac} must be at the top level, as they deal with typesetting).
\begin{everbatim*}
\[\xintGCFrac {\xintFtoCC{915286/188421}}\]
\end{everbatim*}

The `inline' format expected on input by \csbxint{GCFrac} is
%
\leftedline{$a_0+b_0/a_1+b_1/a_2+b_2/a_3+\cdots+b_{n-2}/a_{n-1}+b_{n-1}/a_n$}
%
Fractions among the coefficients are allowed but they must be enclosed
within braces. Signed integers may be left without braces (but the |+|
signs are mandatory). No spaces are allowed around the plus and fraction
symbols. The coefficients may themselves be macros, as long as these
macros are \fexpan dable.
\begin{everbatim*}
\[ \xintFrac{\xintGCtoF {1+-1/57+\xintPow {-3}{7}/\xintiQuo {132}{25}}}
    = \xintGCFrac {1+-1/57+\xintPow {-3}{7}/\xintiQuo {132}{25}}\]
\end{everbatim*}
To compute the actual fraction one has \csbxint{GCtoF}:
\begin{everbatim*}
\[\xintFrac{\xintGCtoF {1+-1/57+\xintPow {-3}{7}/\xintiQuo {132}{25}}}\]
\end{everbatim*}
For non-numeric input  there is \csbxint{GGCFrac}.
\begin{everbatim*}
\[\xintGGCFrac {a_0+b_0/a_1+b_1/a_2+b_2/\ddots+\ddots/a_{n-1}+b_{n-1}/a_n}\]
\end{everbatim*}
For regular continued fractions, there is a simpler comma separated format:
\begin{everbatim*}
\[-7,6,19,1,33\to\xintFrac{\xintCstoF{-7,6,19,1,33}}=\xintCFrac{\xintCstoF{-7,6,19,1,33}}\]
\end{everbatim*}
The command \csbxint{FtoCs} produces from a fraction |f| the comma separated
list of its coefficients.
\begin{everbatim*}
\[\xintFrac{1084483/398959}=[\xintFtoCs{1084483/398959}]\]
\end{everbatim*}
If one prefers other separators, one can use the two arguments macros
\csbxint{FtoCx} whose first argument is the separator (which may consist of more
than one token) which is to be used.
\begin{everbatim*}
\[\xintFrac{2721/1001}=\xintFtoCx {+1/(}{2721/1001})\cdots)\]
\end{everbatim*}
This allows under Plain  \TeX{} with |amstex| to obtain the same effect
as with \LaTeX{}+|\amsmath|+\csbxint{CFrac}:
%
\leftedline{|$$\xintFwOver{2721/1001}=\xintFtoCx {+\cfrac1\\ }{2721/1001}\endcfrac$$|}

As a shortcut to \csa{xintFtoCx} with separator |1+/|, there is
\csbxint{FtoGC}:
\begin{everbatim*}
2721/1001=\xintFtoGC {2721/1001}
\end{everbatim*}
Let us compare in that case with the output of \csbxint{FtoCC}:
\begin{everbatim*}
2721/1001=\xintFtoCC {2721/1001}
\end{everbatim*}
To obtain the coefficients as a sequence of braced numbers, there is
\csbxint{FtoC} (this is a shortcut for |\xintFtoCx {}|). This list
(sequence) may then be manipulated using the various macros of \xinttoolsname
such as the non-expandable macro \csbxint{AssignArray} or the expandable
\csbxint{Apply} and \csbxint{ListWithSep}.

Conversely to go from such a sequence of braced coefficients to the
corresponding fraction there is \csbxint{CtoF}.

The `|\printnumber|' (\autoref{ssec:printnumber}) macro which we use in this
document to print long numbers can also be useful on long continued fractions.
%
\begin{everbatim*}
\printnumber{\xintFtoCC {35037018906350720204351049/244241737886197404558180}}
\end{everbatim*}
%
If we apply \csbxint{GCtoF} to this generalized continued fraction, we
discover that the original fraction was reducible:
%
\leftedline{|\xintGCtoF
  {143+1/2+...+-1/9}|\dtt{=\xintGCtoF{143+1/2+1/5+-1/4+-1/4+-1/4+-1/3+1/2+1/2+1/6+-1/22+1/2+1/10+-1/5+-1/11+-1/3+1/4+-1/2+1/2+1/4+-1/2+1/23+1/3+1/8+-1/6+-1/9}}}

\def\mymacro #1{$\xintFrac{#1}=[\xintFtoCs{#1}]$\vtop to 6pt{}}

\begingroup
\catcode`^\active
\def^#1^{\hbox{#1}}%

When a generalized continued fraction is built with integers, and
numerators are only |1|'s or |-1|'s, the produced fraction is
irreducible. And if we compute it again with the last sub-fraction
omitted we get another irreducible fraction related to the bigger one by
a Bezout identity. Doing this here we get:
%
\leftedline{|\xintGCtoF {143+1/2+...+-1/6}|\dtt{=\xintGCtoF{143+1/2+1/5+-1/4+-1/4+-1/4+-1/3+1/2+1/2+1/6+-1/22+1/2+1/10+-1/5+-1/11+-1/3+1/4+-1/2+1/2+1/4+-1/2+1/23+1/3+1/8+-1/6}}}
and indeed:
\[\begin{vmatrix}
    ^2897319801297630107^ & ^328124887710626729^\\
      ^20197107104701740^ & ^2287346221788023^
   \end{vmatrix} = \mbox{\dtt{\xintiSub {\xintiMul {2897319801297630107}{2287346221788023}}{\xintiMul{20197107104701740}{328124887710626729}}}}\]

\endgroup

The various fractions obtained from the truncation of a continued fraction to
its initial terms are called the convergents. The commands of \xintcfracname
such as \csbxint{FtoCv}, \csbxint{FtoCCv}, and others which compute such
convergents, return them as a list of braced items, with no separator (as does
\csbxint {FtoC} for the partial quotients). Here is an example:

\begin{everbatim*}
\[\xintFrac{915286/188421}\to 
  \xintListWithSep{,}{\xintApply\xintFrac{\xintFtoCv{915286/188421}}}\]
\end{everbatim*}
\begin{everbatim*}
\[\xintFrac{915286/188421}\to 
  \xintListWithSep{,}{\xintApply\xintFrac{\xintFtoCCv{915286/188421}}}\]
\end{everbatim*}
%
We thus see that the `centered convergents' obtained with \csbxint{FtoCCv} are
among the fuller list of convergents as returned by \csbxint{FtoCv}.

Here is a more complicated use of \csa{xintApply}
and \csa{xintListWithSep}. We first define a macro which will be applied to each
convergent:%
%
\leftedline{|\newcommand{\mymacro}[1]{$\xintFrac{#1}=[\xintFtoCs{#1}]$\vtop to 6pt{}}|}
%
Next, we use the following code:
%
\leftedline{|$\xintFrac{49171/18089}\to{}$|}
%
\leftedline{|\xintListWithSep {,
  }{\xintApply{\mymacro}{\xintFtoCv{49171/18089}}}|}
It produces:\par
\noindent$ \xintFrac{49171/18089}\to {}$\xintListWithSep {,
  }{\xintApply{\mymacro}{\xintFtoCv{49171/18089}}}.

The macro \csbxint{CntoF} allows to specify the coefficients as a function given
by a one-parameter macro. The produced values do not have to be integers.
\begin{everbatim*}
\def\cn #1{\xintiiPow {2}{#1}}% 2^n
  \[\xintFrac{\xintCntoF {6}{\cn}}=\xintCFrac [l]{\xintCntoF {6}{\cn}}\]
\end{everbatim*}

Notice  the use of the optional argument |[l]| to \csa{xintCFrac}. Other
possibilities are |[r]| and (default) |[c]|.
\begin{everbatim*}
\def\cn #1{\xintPow {2}{-#1}}%
  \[\xintFrac{\xintCntoF {6}{\cn}}=\xintGCFrac [r]{\xintCntoGC {6}{\cn}}=
      [\xintFtoCs {\xintCntoF {6}{\cn}}]\]
\end{everbatim*}
We used \csbxint{CntoGC} as we wanted to display also the continued fraction and
not only the fraction returned by \csa{xintCntoF}.

There are also \csbxint{GCntoF} and \csbxint{GCntoGC} which allow the same for
generalized fractions. An initial portion of a generalized continued
fraction for $\pi$ is obtained like this
\begin{everbatim*}
\def\an #1{\the\numexpr 2*#1+1\relax }%
\def\bn #1{\the\numexpr (#1+1)*(#1+1)\relax }%
\[\xintFrac{\xintDiv {4}{\xintGCntoF {5}{\an}{\bn}}} =
        \cfrac{4}{\xintGCFrac{\xintGCntoGC {5}{\an}{\bn}}} =
                  \xintTrunc {10}{\xintDiv {4}{\xintGCntoF {5}{\an}{\bn}}}\dots\]
\end{everbatim*}

We see that the quality of approximation is not fantastic compared to the simple
continued fraction of $\pi$ with about as many terms:
\begin{everbatim*}
\[\xintFrac{\xintCstoF{3,7,15,1,292,1,1}}=
             \xintGCFrac{3+1/7+1/15+1/1+1/292+1/1+1/1}=
                       \xintTrunc{10}{\xintCstoF{3,7,15,1,292,1,1}}\dots\]
\end{everbatim*}

When studying the continued fraction of some real number, there is always
some doubt about how many terms are valid, when computed starting from some
approximation. If $f\leqslant x\leqslant g$ and $f, g$ both have the
same first $K$ partial quotients, then $x$ also has the same first $K$ quotients
and convergents. The macro \csbxint{FGtoC} outputs as a sequence of braced items
the common partial quotients of its two arguments. We can thus use it to produce
a sure list of valid convergents of $\pi$ for example, starting from some proven
lower and upper bound:
\begin{everbatim*}
$$\pi\to [\xintListWithSep{,}
         {\xintFGtoC {3.14159265358979323}{3.14159265358979324}}, \dots]$$
\noindent$\pi\to\xintListWithSep{,\allowbreak\;}
   {\xintApply{\xintFrac}
   {\xintCtoCv{\xintFGtoC {3.14159265358979323}{3.14159265358979324}}}}, \dots$
\end{everbatim*}


\subsection{\csbh{xintCFrac}}\label{xintCFrac}

\csa{xintCFrac}|{f}|\ntype{\Ff} is a math-mode only, \LaTeX{} with |amsmath|
only, macro which first computes then displays with the help of |\cfrac| the
simple continued fraction corresponding to the given fraction. It admits an
optional argument which may be |[l]|, |[r]| or (the default) |[c]| to specify
the location of the one's in the numerators of the sub-fractions. Each
coefficient is typeset using the \csbxint{Frac} macro from the \xintfracname
package. This macro is \fexpan dable in the sense that it prepares expandably
the whole expression with the multiple |\cfrac|'s, but it is not completely
expandable naturally as |\cfrac| isn't.

\subsection{\csbh{xintGCFrac}}\label{xintGCFrac}

\csa{xintGCFrac}|{a+b/c+d/e+f/g+h/...+x/y}|\ntype{f} uses similarly |\cfrac|
to prepare the typesetting with the |amsmath| |\cfrac| (\LaTeX{}) of a
generalized continued fraction given in inline format (or as macro which
will \fexpan d to it). It admits the
same optional argument as \csa{xintCFrac}. Plain \TeX{} with |amstex|
users, see \csbxint{GCtoGCx}.
\begin{everbatim*}
\[\xintGCFrac {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}}\]
\end{everbatim*}
This is mostly a typesetting macro, although it does provoke the
expansion of the coefficients. See \csbxint{GCtoF} if you are impatient
to see this specific fraction computed.

It admits an optional argument within square brackets which may be
either |[l]|, |[c]| or |[r]|. Default is |[c]| (numerators are centered).

Numerators and denominators are made arguments to the \csbxint{Frac}
macro. This allows them to be themselves fractions or anything \fexpan
dable giving numbers or fractions, but also means however that they can
not be arbitrary material, they can not contain color changing commands
for example. One of the reasons is that \csa{xintGCFrac} tries to
determine the signs of the numerators and chooses accordingly to use
$+$ or $-$.

\subsection{\csbh{xintGGCFrac}}\label{xintGGCFrac}

\csa{xintGGCFrac}|{a+b/c+d/e+f/g+h/...+x/y}|\ntype{f} is a clone of
\csbxint{GCFrac}, hence again \LaTeX{} specific with package
|amsmath|.
It does not assume the coefficients to be numbers as understood by
\xintfracname. The macro can be used for displaying arbitrary content as
a continued fraction with |\cfrac|, using only plus signs though. Note
though that it will first \fexpan d its argument, which may be thus be
one of the \xintcfracname macros producing a (general) continued
fraction in inline format, see \csbxint{FtoCx} for an example. If this
expansion is not wished, it is enough to start the argument with a
space.
\begin{everbatim*}
\[\xintGGCFrac {1+q/1+q^2/1+q^3/1+q^4/1+q^5/\ddots}\]
\end{everbatim*}

\subsection{\csbh{xintGCtoGCx}}\label{xintGCtoGCx}
%{\small New with release |1.05|.\par}

\csa{xintGCtoGCx}|{sepa}{sepb}{a+b/c+d/e+f/...+x/y}|\etype{nnf} returns the list
of the coefficients of the generalized continued fraction of |f|, each one
within a pair of braces, and separated with the help of |sepa| and |sepb|. Thus
%
\leftedline{|\xintGCtoGCx :;{1+2/3+4/5+6/7}| gives \xintGCtoGCx
  :;{1+2/3+4/5+6/7}}
%
The following can be used byt Plain \TeX{}+|amstex| users to obtain an
output similar as the ones produced by \csbxint{GCFrac} and
\csbxint{GGCFrac}:\par
\everb|@
$$\xintGCtoGCx {+\cfrac}{\\}{a+b/...}\endcfrac$$
$$\xintGCtoGCx {+\cfrac\xintFwOver}{\\\xintFwOver}{a+b/...}\endcfrac$$
|

\subsection{\csbh{xintFtoC}}\label{xintFtoC}

\csa{xintFtoC}|{f}|\etype{\Ff} computes the
coefficients of the simple continued fraction of |f| and returns them as a list
(sequence) of braced items.

\begin{everbatim*}
\fdef\test{\xintFtoC{-5262046/89233}}\texttt{\meaning\test}
\end{everbatim*}

\subsection{\csbh{xintFtoCs}}\label{xintFtoCs}

\csa{xintFtoCs}|{f}|\etype{\Ff} returns the comma separated list of the
coefficients of the simple continued fraction of |f|. Notice that starting with
|1.09m| a space follows each comma (mainly for usage in text mode, as in math
mode spaces are produced in the typeset output by \TeX{} itself).
\begin{everbatim*}
\[ \xintSignedFrac{-5262046/89233} \to [\xintFtoCs{-5262046/89233}]\]
\end{everbatim*}

\subsection{\csbh{xintFtoCx}}\label{xintFtoCx}

\csa{xintFtoCx}|{sep}{f}|\etype{n\Ff} returns the list of the
coefficients of the simple continued fraction of |f| separated with the
help of |sep|, which may be anything (and is kept unexpanded). For
example, with Plain \TeX{} and |amstex|,
%
\leftedline{|$$\xintFtoCx {+\cfrac1\\ }{-5262046/89233}\endcfrac$$|}
%
will display the continued fraction using
|\cfrac|. Each coefficient is inside a brace pair \hbox{|{ }|}, allowing
a macro to end the separator and fetch it as argument,
for example, again with Plain \TeX{} and |amstex|:
\everb|@
  \def\highlight #1{\ifnum #1>200 \textcolor{red}{#1}\else #1\fi}
  $$\xintFtoCx {+\cfrac1\\ \highlight}{104348/33215}\endcfrac$$
|

Due to the different and extremely cumbersome syntax of |\cfrac| under
\LaTeX{} it proves a bit tortuous to obtain there the same effect.
Actually, it is partly for this purpose that |1.09m| added \csbxint
{GGCFrac}. We thus use \csa{xintFtoCx} with a suitable separator, and\;
then the whole thing as argument to \csbxint{GGCFrac}:
\begin{everbatim*}
\def\highlight #1{\ifnum #1>200 \fcolorbox{blue}{white}{\boldmath\color{red}$#1$}%
    \else #1\fi}
\[\xintGGCFrac {\xintFtoCx {+1/\highlight}{208341/66317}}\]
\end{everbatim*}

\subsection{\csbh{xintFtoGC}}\label{xintFtoGC}

\csa{xintFtoGC}|{f}|\etype{\Ff} does the same as \csa{xintFtoCx}|{+1/}{f}|. Its
output may thus be used in the package macros expecting such an `inline
format'.
% This continued fraction is a \emph{simple} one, not a
% \emph{generalized} one, but as it is produced in the format used for
% user input of generalized continued fractions, the macro was called
% \csa{xintFtoGC} rather than \csa{xintFtoC} for example.
%
\begin{everbatim*}
566827/208524=\xintFtoGC {566827/208524}
\end{everbatim*}

\subsection{\csbh{xintFGtoC}}\label{xintFGtoC}

\csa{xintFGtoC}|{f}{g}|\etype{\Ff\Ff} computes the common initial coefficients
to
two given fractions |f| and |g|. Notice that any real number |f<x<g| or |f>x>g|
will then necessarily share with |f| and |g| these common initial coefficients
for its regular continued fraction. The coefficients are output as a sequence of
braced numbers. This list can then be manipulated via macros from
\xinttoolsname, or other macros of \xintcfracname.

\begin{everbatim*}
\fdef\test{\xintFGtoC{-5262046/89233}{-5314647/90125}}\texttt{\meaning\test}
\end{everbatim*}
\begin{everbatim*}
\fdef\test{\xintFGtoC{3.141592653}{3.141592654}}\texttt{\meaning\test}
\end{everbatim*}
\begin{everbatim*}
\fdef\test{\xintFGtoC{3.1415926535897932384}{3.1415926535897932385}}\meaning\test
\end{everbatim*}
\begin{everbatim*}
\xintRound {30}{\xintCstoF{\xintListWithSep{,}{\test}}}
\end{everbatim*}
\begin{everbatim*}
\xintRound {30}{\xintCtoF{\test}}
\end{everbatim*}
\begin{everbatim*}
\fdef\test{\xintFGtoC{1.41421356237309}{1.4142135623731}}\meaning\test
\end{everbatim*}

\subsection{\csbh{xintFtoCC}}\label{xintFtoCC}

\csa{xintFtoCC}|{f}|\etype{\Ff} returns the `centered' continued fraction of
|f|, in `inline format'. %
\begin{everbatim*}
566827/208524=\xintFtoCC {566827/208524}
\end{everbatim*}
\begin{everbatim*}
\[\xintFrac{566827/208524} = \xintGCFrac{\xintFtoCC{566827/208524}}\]
\end{everbatim*}

\subsection{\csbh{xintCstoF}}\label{xintCstoF}

\csa{xintCstoF}|{a,b,c,d,...,z}|\etype{f} computes the fraction corresponding to
the coefficients, which may be fractions or even macros expanding to such
fractions. The final fraction may then be highly reducible. Starting with
release |1.09m| spaces before commas are allowed and trimmed automatically
(spaces after commas were already silently handled in earlier releases).
\begin{everbatim*}
\[\xintGCFrac {-1+1/3+1/-5+1/7+1/-9+1/11+1/-13}=
  \xintSignedFrac{\xintCstoF {-1,3,-5,7,-9,11,-13}}=\xintSignedFrac{\xintGCtoF
    {-1+1/3+1/-5+1/7+1/-9+1/11+1/-13}}\]
\end{everbatim*}
\begin{everbatim*}
\[\xintGCFrac{{1/2}+1/{1/3}+1/{1/4}+1/{1/5}}=\xintFrac{\xintCstoF {1/2,1/3,1/4,1/5}}\]
\end{everbatim*}
%
A generalized continued fraction may produce a reducible fraction
(\csa{xintCstoF} tries its best not to accumulate in a silly way superfluous
factors but will not do simplifications which would be obvious to a human, like
simplification by 3 in the result above).

\subsection{\csbh{xintCtoF}}\label{xintCtoF}

\csa{xintCtoF}|{{a}{b}{c}...{z}}|\etype{f} computes the fraction corresponding
to the coefficients, which may be fractions or even macros.
\begin{everbatim*}
\xintCtoF {\xintApply {\xintiiPow 3}{\xintSeq {1}{5}}}
\end{everbatim*}
\begin{everbatim*}
\[ \xintFrac{14946960/4805083}=\xintCFrac {14946960/4805083}\]
\end{everbatim*}
In the example above the power of $3$ was already pre-computed via the expansion
done by |\xintApply|, but if we try with |\xintApply { \xintiiPow 3}| where the
space will stop this expansion, we can check that |\xintCtoF| will itself
provoke the needed coefficient expansion.% ok

\subsection{\csbh{xintGCtoF}}\label{xintGCtoF}

\csa{xintGCtoF}|{a+b/c+d/e+f/g+......+v/w+x/y}|\etype{f} computes the fraction
defined by the inline generalized continued fraction. Coefficients may be
fractions but must then be put within braces. They can be macros. The plus signs
are mandatory. 
\begin{everbatim*}
\[\xintGCFrac {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}} =
\xintFrac{\xintGCtoF {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}}} =
\xintFrac{\xintIrr{\xintGCtoF
                  {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/\xintFac {6}}}}\]
\end{everbatim*}

\begin{everbatim*}
\[ \xintGCFrac{{1/2}+{2/3}/{4/5}+{1/2}/{1/5}+{3/2}/{5/3}} =
   \xintFrac{\xintGCtoF {{1/2}+{2/3}/{4/5}+{1/2}/{1/5}+{3/2}/{5/3}}} \]
\end{everbatim*}

The macro tries its best not to accumulate superfluous factor in the
denominators, but doesn't reduce the fraction to irreducible form before
returning it and does not do simplifications which would be obvious to a human.

\subsection{\csbh{xintCstoCv}}\label{xintCstoCv}

\csa{xintCstoCv}|{a,b,c,d,...,z}|\etype{f} returns the sequence of the
corresponding convergents, each one within braces.

It is allowed to use fractions as coefficients (the computed
convergents have then no reason to be the real convergents of the final
fraction). When the coefficients are integers, the convergents are irreducible
fractions, but otherwise it is not necessarily the case.
\begin{everbatim*}
\xintListWithSep:{\xintCstoCv{1,2,3,4,5,6}}
\end{everbatim*}
\begin{everbatim*}
\xintListWithSep:{\xintCstoCv{1,1/2,1/3,1/4,1/5,1/6}}
\end{everbatim*}
\begin{everbatim*}
\[\xintListWithSep{\to}{\xintApply\xintFrac{\xintCstoCv {\xintPow
        {-.3}{-5},7.3/4.57,\xintCstoF{3/4,9,-1/3}}}}\]
\end{everbatim*}

\subsection{\csbh{xintCtoCv}}\label{xintCtoCv}

\csa{xintCtoCv}|{{a}{b}{c}...{z}}|\etype{f} returns the sequence of the
corresponding convergents, each one within braces.
\begin{everbatim*}
\fdef\test{\xintCtoCv {11111111111}}\texttt{\meaning\test}
\end{everbatim*}

\subsection{\csbh{xintGCtoCv}}\label{xintGCtoCv}

\csa{xintGCtoCv}|{a+b/c+d/e+f/g+......+v/w+x/y}|\etype{f} returns the list of
the corresponding convergents. The coefficients may be fractions, but must then
be inside braces. Or they may be macros, too.

The convergents will in the general case be reducible. To put them into
irreducible form, one needs one more step, for example it can be done
with |\xintApply\xintIrr|.
\begin{everbatim*}
\[\xintListWithSep{,}{\xintApply\xintFrac
                {\xintGCtoCv{3+{-2}/{7/2}+{3/4}/12+{-56}/3}}}\]
\[\xintListWithSep{,}{\xintApply\xintFrac{\xintApply\xintIrr
                {\xintGCtoCv{3+{-2}/{7/2}+{3/4}/12+{-56}/3}}}}\]
\end{everbatim*}


\subsection{\csbh{xintFtoCv}}\label{xintFtoCv}

\csa{xintFtoCv}|{f}|\etype{\Ff} returns the list of the (braced) convergents of
|f|, with no separator. To be treated with \csbxint{AssignArray} or
\csbxint{ListWithSep}.
\begin{everbatim*}
\[\xintListWithSep{\to}{\xintApply\xintFrac{\xintFtoCv{5211/3748}}}\]
\end{everbatim*}

\subsection{\csbh{xintFtoCCv}}\label{xintFtoCCv}

\csa{xintFtoCCv}|{f}|\etype{\Ff} returns the list of the (braced) centered
convergents of |f|, with no separator. To be treated with \csbxint{AssignArray}
or \csbxint{ListWithSep}.
\begin{everbatim*}
\[\xintListWithSep{\to}{\xintApply\xintFrac{\xintFtoCCv{5211/3748}}}\]
\end{everbatim*}

\subsection{\csbh{xintCntoF}}\label{xintCntoF}


\csa{xintCntoF}|{N}{\macro}|\etype{\numx f} computes the fraction |f| having
coefficients |c(j)=\macro{j}| for |j=0,1,...,N|. The |N| parameter is given to a
|\numexpr|. The values of the coefficients, as returned by |\macro| do not have
to be positive, nor integers, and it is thus not necessarily the case that the
original |c(j)| are the true coefficients of the final |f|.
\begin{everbatim*}
\def\macro #1{\the\numexpr 1+#1*#1\relax} \xintCntoF {5}{\macro}
\end{everbatim*}

This example shows that the fraction is output with a trailing number in square
brackets (representing a power of ten), this is for consistency with what do
most macros of \xintfracname, and does not have to be always this annoying |[0]|
as the coefficients may for example be numbers in scientific notation. To avoid
these trailing square brackets, for example if the coefficients are known to be integers, there is always the possibility to filter the output via
\csbxint{PRaw}, or \csbxint{Irr} (the latter is overkill in the case of integer
coefficients, as the fraction is guaranteed to be irreducible then).

\subsection{\csbh{xintGCntoF}}\label{xintGCntoF}

\csa{xintGCntoF}|{N}{\macroA}{\macroB}|\etype{\numx ff} returns the fraction |f|
corresponding to the inline generalized continued fraction
|a0+b0/a1+b1/a2+....+b(N-1)/aN|, with |a(j)=\macroA{j}| and |b(j)=\macroB{j}|.
The |N| parameter is given to a |\numexpr|.
\begin{everbatim*}
\def\coeffA #1{\the\numexpr #1+4-3*((#1+2)/3)\relax }%
\def\coeffB #1{\the\numexpr \ifodd #1 -\fi 1\relax }% (-1)^n
\[\xintGCFrac{\xintGCntoGC {6}{\coeffA}{\coeffB}} = 
                                \xintFrac{\xintGCntoF {6}{\coeffA}{\coeffB}}\]
\end{everbatim*}
There is also \csbxint{GCntoGC} to get the `inline format' continued
fraction.

\subsection{\csbh{xintCntoCs}}\label{xintCntoCs}

\csa{xintCntoCs}|{N}{\macro}|\etype{\numx f} produces the comma separated list
of the corresponding coefficients, from |n=0| to |n=N|. The |N| is given to a
|\numexpr|. %
\begin{everbatim*}
\xintCntoCs {5}{\macro}
\end{everbatim*}
\begin{everbatim*}
\[ \xintFrac{\xintCntoF{5}{\macro}}=\xintCFrac{\xintCntoF {5}{\macro}}\]
\end{everbatim*}

\subsection{\csbh{xintCntoGC}}\label{xintCntoGC}

%
\csa{xintCntoGC}|{N}{\macro}|\etype{\numx f} evaluates the |c(j)=\macro{j}| from
|j=0| to |j=N| and returns a continued fraction written in inline format:
|{c(0)}+1/{c(1)}+1/...+1/{c(N)}|. The parameter |N| is given to a |\numexpr|.
The coefficients, after expansion, are, as shown, being enclosed in an added
pair of braces, they may thus be fractions.
\begin{everbatim*}
\def\macro #1{\the\numexpr\ifodd#1 -1-#1\else1+#1\fi\relax/\the\numexpr 1+#1*#1\relax} 
\fdef\x{\xintCntoGC {5}{\macro}}\meaning\x
\[\xintGCFrac{\xintCntoGC {5}{\macro}}\]
\end{everbatim*}

\subsection{\csbh{xintGCntoGC}}\label{xintGCntoGC}

\csa{xintGCntoGC}|{N}{\macroA}{\macroB}|\etype{\numx ff} evaluates the
coefficients and then returns the corresponding
|{a0}+{b0}/{a1}+{b1}/{a2}+...+{b(N-1)}/{aN}| inline generalized fraction. |N| is
givent to a |\numexpr|. The coefficients are enclosed into pairs
of braces, and may thus be fractions, the fraction slash will not be
confused in further processing by the continued fraction slashes.
%
\begin{everbatim*}
\def\an #1{\the\numexpr  #1*#1*#1+1\relax}%
\def\bn #1{\the\numexpr \ifodd#1 -\fi 1*(#1+1)\relax}%
$\xintGCntoGC {5}{\an}{\bn}=\xintGCFrac {\xintGCntoGC {5}{\an}{\bn}} =
\displaystyle\xintFrac {\xintGCntoF {5}{\an}{\bn}}$\par
\end{everbatim*}

\subsection{\csbh{xintCstoGC}}\label{xintCstoGC}

\csa{xintCstoGC}|{a,b,..,z}|\etype{f} transforms a comma separated list (or
something expanding to such a list) into an `inline format' continued fraction
|{a}+1/{b}+1/...+1/{z}|. The coefficients are just copied and put within braces,
without expansion. The output can then be used in \csbxint{GCFrac} for example.
\begin{everbatim*}
\[\xintGCFrac {\xintCstoGC {-1,1/2,-1/3,1/4,-1/5}}=\xintSignedFrac{\xintCstoF {-1,1/2,-1/3,1/4,-1/5}}\]
\end{everbatim*}
\subsection{\csbh{xintiCstoF}, \csbh{xintiGCtoF}, \csbh{xintiCstoCv}, \csbh{xintiGCtoCv}}\label{xintiCstoF}
\label{xintiGCtoF}
\label{xintiCstoCv}
\label{xintiGCtoCv}

Essentially\etype{f} the same as the corresponding macros without the
`i', but for integer-only input. Infinitesimally faster, mainly for
internal use by the package.

\subsection{\csbh{xintGCtoGC}}\label{xintGCtoGC}

\csa{xintGCtoGC}|{a+b/c+d/e+f/g+......+v/w+x/y}|\etype{f} expands (with the
usual meaning) each one of the coefficients and returns an inline continued
fraction of the same type, each expanded coefficient being enclosed within
braces.
%
\begin{everbatim*}
\fdef\x {\xintGCtoGC {1+\xintPow{1.5}{3}/{1/7}+{-3/5}/%
                        \xintFac {6}+\xintCstoF {2,-7,-5}/16}} \meaning\x
\end{everbatim*}

To be honest I have forgotten for which purpose I wrote this macro in the first
place.

\subsection{Euler's number \texorpdfstring{$e$}{e}}\label{ssec:e-convergents}

Let us explore
the convergents of Euler's number $e$.
\smallskip The volume of computation is kept minimal by the following steps:
\begin{itemize}
\item a comma separated list of the first 36 coefficients is produced by
  \csbxint{CntoCs},
\item this is then given to \csbxint{iCstoCv} which produces the list of the
  convergents (there is also \csbxint{CstoCv}, but our
  coefficients being integers we used the infinitesimally
  faster \csbxint{iCstoCv}),
\item then the whole list was converted into a sequence of one-line paragraphs,
  each convergent becomes the argument to a  macro printing it
  together with its decimal expansion with 30 digits after the decimal point.
\item A count register |\cnta| was used to give a line count serving as a visual
  aid: we could also have done that in an expandable way, but well, let's relax
  from time to time\dots
\end{itemize}

\begin{everbatim*}
\def\cn #1{\the\numexpr\ifcase \numexpr #1+3-3*((#1+2)/3)\relax
                           1\or1\or2*(#1/3)\fi\relax }
% produces the pattern 1,1,2,1,1,4,1,1,6,1,1,8,... which are the
% coefficients of the simple continued fraction of e-1.
\cnta 0
\def\mymacro #1{\advance\cnta by 1
                \noindent
                \hbox to 3em {\hfil\small\dtt{\the\cnta.} }%
                $\xintTrunc {30}{\xintAdd {1[0]}{#1}}\dots=
                 \xintFrac{\xintAdd {1[0]}{#1}}$}%
\xintListWithSep{\vtop to 6pt{}\vbox to 12pt{}\par}
    {\xintApply\mymacro{\xintiCstoCv{\xintCntoCs {35}{\cn}}}}
\end{everbatim*}

% \def\testmacro #1{\xintTrunc {30}{\xintAdd {1[0]}{#1}}\xintAdd {1[0]}{#1}}
% \pdfresettimer
% \oodef\z{\xintApply\testmacro{\xintiCstoCv{\xintCntoCs {35}{\cn}}}}
% (\the\pdfelapsedtime)

\smallskip

% The actual computation of the list of all 36 convergents accounts for
% only 8\% of the total time (total time equal to about 5 hundredths of a second
% in my testing, on my laptop): another 80\% is occupied with the computation of
% the truncated decimal expansions (and the addition of 1 to everything as the
% formula gives the continued fraction of $e-1$).

One can with no problem compute
much bigger convergents. Let's get the 200th convergent. It turns out to
have the same first 268 digits after the decimal point as $e-1$. Higher
convergents get more and more digits in proportion to their index: the 500th
convergent already gets 799 digits correct! To allow speedy compilation of the
source of this document when the need arises, I limit here to the 200th
convergent.
%  (getting the 500th took about 1.2s on my laptop last time I tried,
% and the 200th convergent is obtained ten times faster).
\begin{everbatim*}
\fdef\z {\xintCntoF {199}{\cn}}%
\begingroup\parindent 0pt \leftskip 2.5cm
\indent\llap {Numerator = }\printnumber{\xintNumerator\z}\par
\indent\llap {Denominator = }\printnumber{\xintDenominator\z}\par
\indent\llap {Expansion = }\printnumber{\xintTrunc{268}\z}\dots\par\endgroup
\end{everbatim*}


One can also use a centered continued fraction: we get more digits but there are
also more computations as the numerators may be either
$1$ or $-1$.

\ifnum\NoSourceCode=1
\bigskip
\begin{framed}
  \small This documentation has been compiled without the source code,
  which is available in the separate file:
  %
  \centeredline{|sourcexint.pdf|,}
  %
  which should be among the candidates proposed by |texdoc --list xint|. To
  produce a single file including both the user documentation and the 
  source code, run |tex xint.dtx| to generate |xint.tex| (if not already
  available), then edit |xint.tex| to set the |\NoSourceCode| toggle to |0|,
  then run thrice |latex| on |xint.tex| and finally |dvipdfmx| on |xint.dvi|.
  Alternatively, run |pdflatex| either directly on |xint.dtx|, or on
  |xint.tex| with |\NoSourceCode| set to |0|.
\end{framed}
\fi

% Mercredi 08 octobre 2014  22:09:54
\ifnum\dosourcexint=1
+fi
+catcode`\ 0
\catcode0 15 % retour  la normale, peu importe
\catcode`\+ 12
\etocignoredepthtags
\etocsetnexttocdepth{section}
\tableofcontents
\makeatletter
\@gobble\fi

\StopEventually{\end{document}\endinput}

\ifnum\dosourcexint=1
\renewcommand{\etocaftertochook}{\addvspace{\bigskipamount}}
\etocsettocstyle {}{}
\else
\clearpage
% \newgeometry{%hmarginratio=4:3,
%              hscale=0.75,vscale=0.75}% ATTENTION \newgeometry fait
%                                 % un reset de vscale si on ne le
%                                 % prcise pas ici !!!
\fi

\def\MARGEPAGENO{1.25em}
\etocsettocdepth{subsubsection}% 2015/09/15

\etocdepthtag.toc {implementation}
\addtocontents{toc}{\gdef\string\sectioncouleur{[named]{RoyalPurple}}}

\makeatletter
\def\storedlinecounts {}
\def\StoreCodelineNo #1{\edef\storedlinecounts{%
                        \unexpanded\expandafter{\storedlinecounts}%
                        {{#1}{\the\c@CodelineNo}}}\c@CodelineNo\z@ }

% Pour le code des macros 
% On va redfinir \macro@font 
% Pas de couleur, et 0 slashed 

\def\macro@font {\ttbfamily }

% Pour \lverb

\def\MicroFont {\ttzfamily\color[named]{Purple}\makestarlowast }

\makeatother

\MakePercentIgnore
%
% \catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
% \let</dtx>\relax
% \def<*xintkernel>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</dtx>
%<*xintkernel>
%
% \bigskip
% This is \expandafter|\xintbndlversion| of \expandafter|\xintbndldate|.
%
% \begin{itemize}
% \item |1.2d| of |2015/11/18| fixes a bug introduced two days ago by |1.2c|:
% it broke \csa{xintiiDivRound}. Also it makes the definitions via
% \csa{xintdeffunc} and \csa{xintNewExpr} local, and it extends the cases of
% tacit multiplication. Also, tacit multiplication always ties more than
% normal division or multiplication (but naturally less than power or
% factorial). Source code comments have been extended and improved.
%
% \item |1.2c| of |2015/11/16| fixes another bad bug from |1.2|, this time in
%   the subtraction of |xintcore.sty| (it showed in certain cases with a
%   |00000001| string.) New macros \csa{xintdeffunc}, \csa{xintdefiifunc},
%   \csa{xintdeffloatfunc} and boolean \csa{ifxintverbose}. Some on-going code
%   improvements and documentation enhancements, stopped in order to issue
%   this bugfix release.
%
% \item |1.2b| of |2015/10/29| corrects a bug introduced in recent release
%   |1.2| in the division macro of |xintcore.sty| (a sub-routine expecting
%   only eight digit numbers was called with |1+99999999|; happened with
%   divisors |99999999xyz...|).
%
% \item Release |1.2a| of |2015/10/19| fixes a bad bug of |1.2| in
%   |xintexpr.sty|, the parsers mistook decimals |0.0x...| for zero ! Also I
%   took this opportunity to replace about 350 uses of |\romannumeral-`0|
%   throughout the code by a hacky |\romannumeral`&&@| (as |^| is used as
%   letter in constant names, I preferred |&| which is only to be found in a
%   few places, all inside |xintexpr.sty|).
%
% \item Release |1.2| of |2015/10/10| has entirely rewritten the core
%   arithmetic routines in \xintcorenameimp. Many macros benefit indirectly
%   from the faster core routines. The new model is yet to be extended to
%   other portions of the code: for example the routines of \xintbinhexnameimp
%   could be made faster for very big inputs if they adopted some of the style
%   used now for the basic arithmetic routines.
%
%   The parser of \xintexprnameimp is also faster at gathering digits and does
%   not have a limit at |5000| digits per number anymore.
%
% \item Extensive changes in release |1.1| of |2014/10/28| were located in
%   \xintexprnameimp. Also with that release, packages \xintkernelnameimp and
%   \xintcorenameimp were extracted from \xinttoolsnameimp and \xintnameimp,
%   and |\xintAdd| was modified to not multiply denominators blindly.
%
%   \xinttoolsnameimp is not loaded anymore by \xintnameimp, nor by
%   \xintfracnameimp. It is loaded by \xintexprnameimp.
% \end{itemize}
%
% Large portions of the code date back to the initial release, and at that
% time I was learning my trade in expandable TeX macro programming. At some
% point in the future, I will have to re-examine the older parts of the code.
%
% \section {Package \xintkernelnameimp implementation}
% \label{sec:kernelimp}
%
% \localtableofcontents
%
% This package provides the common minimal code base for loading management
% and catcode control and also a few programming utilities. With |1.2| a few
% more helper macros and all |\chardef|'s have been moved here. The package is
% loaded by both |xintcore.sty| and |xinttools.sty| hence by all other
% packages.
% 
% First appeared as a separate package with release |1.1|.
%
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
%
% The code for reload detection was initially copied from \textsc{Heiko
% Oberdiek}'s packages, then modified.
%
% The method for catcodes was also initially directly inspired by these
% packages.
%
% Starting with version |1.06| of the package, also |`| must be
% catcode-protected, because we replace everywhere in the code the
% twice-expansion done with |\expandafter| by the systematic use of
% |\romannumeral-`0|.
%
% Starting with version |1.06b| I decide that I suffer from an indigestion of @
% signs, so I replace them all with underscores |_|, \`a la \LaTeX 3.
%
% Release |1.09b| is more economical: some macros are defined already in
% |xint.sty| (now in |xintkernel.sty|) and re-used in other modules. All catcode
% changes have been unified and \csa{XINT_storecatcodes} will be used by each
% module to redefine |\XINT_restorecatcodes_endinput| in case catcodes have
% changed in-between the loading of |xint.sty| (now |xintkernel.sty|) and the
% module (not very probable but...).
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \catcode95=11   % _
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \let\z\relax
  \expandafter
    \ifx\csname numexpr\endcsname\relax
     \y{xintkernel}{\numexpr not available, aborting input}%
     \def\z{\endgroup\endinput}%
    \else
    \expandafter
     \ifx\csname XINTsetupcatcodes\endcsname\relax
      \else
       \y{xintkernel}{I was already loaded, aborting input}%
       \def\z{\endgroup\endinput}%
      \fi
    \fi
  \ifx\z\relax\else\expandafter\z\fi%
%    \end{macrocode}
% |1.2| corrects a long-standing somewhat subtle bug, of which the author
% became aware only on |15/09/13|: earlier releases had |\aftergroup\endinput|
% above, rather than |\def\z{\endgroup\endinput}| and the |\ifx| test. The
% |\endinput| token was indeed inserted after the |\endgroup| from
% |\PrepareCatcodes|, but all material and in particular |\XINT_setupcatcodes|
% from the macro now called |\PrepareCatcodes| was expanded before the
% |\endinput| had come into effect ! as a result the catcodes would be
% modified in unwanted ways, in Plain \TeX, if the source had for example
% |\input xint.sty| followed by |\input xintkernel.sty|: the catcode changes
% would be done before the second input of |xintkernel.sty| had been aborted.
% One didn't see the situation under \LaTeX{} (in normal circumstances),
% because a second |\usepackage{xintkernel}| would not do any input of
% |xintkernel.sty| to start with.
%    \begin{macrocode}
  \def\PrepareCatcodes
  {%
      \endgroup
      \def\XINT_restorecatcodes
      {% takes care of all, to allow more economical code in modules
           \catcode0=\the\catcode0 %
           \catcode59=\the\catcode59   % ; xintexpr
           \catcode126=\the\catcode126 % ~ xintexpr
           \catcode39=\the\catcode39   % ' xintexpr
           \catcode34=\the\catcode34   % " xintbinhex, and xintexpr
           \catcode63=\the\catcode63   % ? xintexpr
           \catcode124=\the\catcode124 % | xintexpr
           \catcode38=\the\catcode38   % & xintexpr
           \catcode64=\the\catcode64   % @ xintexpr
           \catcode33=\the\catcode33   % ! xintexpr
           \catcode93=\the\catcode93   % ] -, xintfrac, xintseries, xintcfrac
           \catcode91=\the\catcode91   % [ -, xintfrac, xintseries, xintcfrac
           \catcode36=\the\catcode36   % $ xintgcd only
           \catcode94=\the\catcode94   % ^
           \catcode96=\the\catcode96   % `
           \catcode47=\the\catcode47   % /
           \catcode41=\the\catcode41   % )
           \catcode40=\the\catcode40   % (
           \catcode42=\the\catcode42   % *
           \catcode43=\the\catcode43   % +
           \catcode62=\the\catcode62   % >
           \catcode60=\the\catcode60   % <
           \catcode58=\the\catcode58   % :
           \catcode46=\the\catcode46   % .
           \catcode45=\the\catcode45   % -
           \catcode44=\the\catcode44   % ,
           \catcode35=\the\catcode35   % #
           \catcode95=\the\catcode95   % _
           \catcode125=\the\catcode125 % }
           \catcode123=\the\catcode123 % {
           \endlinechar=\the\endlinechar
           \catcode13=\the\catcode13   % ^^M
           \catcode32=\the\catcode32   %
           \catcode61=\the\catcode61\relax   % =
      }%
      \edef\XINT_restorecatcodes_endinput
      {%
           \XINT_restorecatcodes\noexpand\endinput %
      }%
      \def\XINT_setcatcodes
      {%
        \catcode61=12   % =
        \catcode32=10   % space
        \catcode13=5    % ^^M
        \endlinechar=13 %
        \catcode123=1   % {
        \catcode125=2   % }
        \catcode95=11   % _ LETTER
        \catcode35=6    % #
        \catcode44=12   % ,
        \catcode45=12   % -
        \catcode46=12   % .
        \catcode58=11   % : LETTER
        \catcode60=12   % <
        \catcode62=12   % >
        \catcode43=12   % +
        \catcode42=12   % *
        \catcode40=12   % (
        \catcode41=12   % )
        \catcode47=12   % /
        \catcode96=12   % `
        \catcode94=11   % ^ LETTER
        \catcode36=3    % $
        \catcode91=12   % [
        \catcode93=12   % ]
        \catcode33=12   % !
        \catcode64=11   % @ LETTER
        \catcode38=7    % & for \romannumeral`&&@ trick.
        \catcode124=12  % |
        \catcode63=11   % ? LETTER
        \catcode34=12   % "
        \catcode39=12   % '
        \catcode126=3   % ~ MATH
        \catcode59=12   % ;
        \catcode0=12    % for \romannumeral`&&@ trick
      }%
      \XINT_setcatcodes
  }%
\PrepareCatcodes
%    \end{macrocode}
% Other modules could possibly be loaded under a different catcode regime.
%    \begin{macrocode}
\def\XINTsetupcatcodes {% for use by other modules
      \edef\XINT_restorecatcodes_endinput
      {%
           \XINT_restorecatcodes\noexpand\endinput %
      }%
      \XINT_setcatcodes
}%
%    \end{macrocode}
% \subsection{Package identification}
%
% Inspired from \textsc{Heiko Oberdiek}'s packages. Modified in |1.09b| to allow
% re-use in the other modules. Also I assume now that if |\ProvidesPackage|
% exists it then does define |\ver@<pkgname>.sty|, code of |HO| for some reason
% escaping me  (compatibility with LaTeX 2.09 or other things ??) seems to set
% extra precautions.
%
% |1.09c| uses e-\TeX{} |\ifdefined|.
%    \begin{macrocode}
\ifdefined\ProvidesPackage
  \let\XINT_providespackage\relax
\else
  \def\XINT_providespackage #1#2[#3]%
              {\immediate\write-1{Package: #2 #3}%
               \expandafter\xdef\csname ver@#2.sty\endcsname{#3}}%
\fi
\XINT_providespackage
\ProvidesPackage {xintkernel}%
  [2015/11/18 v1.2d Paraphernalia for the xint packages (jfB)]%
%    \end{macrocode}
% \subsection{Constants}
% |v1.2| decides to move them to \xintkernelnameimp from \xintcorenameimp and
% \xintnameimp. The |\count|'s are left in their respective packages.
%    \begin{macrocode}
\chardef\xint_c_     0
\chardef\xint_c_i    1
\chardef\xint_c_ii   2
\chardef\xint_c_iii  3
\chardef\xint_c_iv   4
\chardef\xint_c_v    5
\chardef\xint_c_vi   6
\chardef\xint_c_vii  7
\chardef\xint_c_viii 8
\chardef\xint_c_ix     9
\chardef\xint_c_x     10
\chardef\xint_c_xiv   14
\chardef\xint_c_xvi   16
\chardef\xint_c_xviii 18
\chardef\xint_c_xxii  22
\chardef\xint_c_ii^v  32
\chardef\xint_c_ii^vi 64
\chardef\xint_c_ii^vii       128
\mathchardef\xint_c_ii^viii  256
\mathchardef\xint_c_ii^xii  4096
\mathchardef\xint_c_x^iv   10000
%    \end{macrocode}
% \subsection{Token management utilities}
%    \begin{macrocode}
\def\XINT_tmpa { }%
\ifx\XINT_tmpa\space\else 
   \immediate\write-1{Package xintkernel Warning: ATTENTION!}%
   \immediate\write-1{\string\space\XINT_tmpa macro does not have its normal
     meaning.}%
   \immediate\write-1{\XINT_tmpa\XINT_tmpa\XINT_tmpa\XINT_tmpa
                      All kinds of catastrophes will ensue!!!!}%
\fi
\def\XINT_tmpb {}%
\ifx\XINT_tmpb\empty\else
    \immediate\write-1{Package xintkernel Warning: ATTENTION!}%
    \immediate\write-1{\string\empty\XINT_tmpa macro does not have its normal
      meaning.}%
    \immediate\write-1{\XINT_tmpa\XINT_tmpa\XINT_tmpa\XINT_tmpa
                        All kinds of catastrophes will ensue!!!!}%
\fi
\let\XINT_tmpa\relax \let\XINT_tmpb\relax
\ifdefined\space\else\def\space { }\fi
\ifdefined\empty\else\def\empty {}\fi
\long\def\xint_gobble_     {}%
\long\def\xint_gobble_i    #1{}%
\long\def\xint_gobble_ii   #1#2{}%
\long\def\xint_gobble_iii  #1#2#3{}%
\long\def\xint_gobble_iv   #1#2#3#4{}%
\long\def\xint_gobble_v    #1#2#3#4#5{}%
\long\def\xint_gobble_vi   #1#2#3#4#5#6{}%
\long\def\xint_gobble_vii  #1#2#3#4#5#6#7{}%
\long\def\xint_gobble_viii #1#2#3#4#5#6#7#8{}%
\long\def\xint_firstofone  #1{#1}%
\long\def\xint_firstoftwo  #1#2{#1}%
\long\def\xint_secondoftwo #1#2{#2}%
\long\def\xint_firstofone_thenstop  #1{ #1}%
\long\def\xint_firstoftwo_thenstop  #1#2{ #1}%
\long\def\xint_secondoftwo_thenstop #1#2{ #2}%
\def\xint_minus_thenstop { -}%
\def\xint_exchangetwo_keepbraces    #1#2{{#2}{#1}}%
%    \end{macrocode}
% \subsection{``gob til'' macros and UD style fork}
% Some moved here from \xintcorenameimp by release |1.2|.
%    \begin{macrocode}
\long\def\xint_gob_til_R #1\R {}%
\long\def\xint_gob_til_W #1\W {}%
\long\def\xint_gob_til_Z #1\Z {}%
\def\xint_gob_til_zero #10{}%
\def\xint_gob_til_one  #11{}%
\def\xint_gob_til_zeros_iii   #1000{}%
\def\xint_gob_til_zeros_iv    #10000{}%
\def\xint_gob_til_eightzeroes #100000000{}%
\def\xint_gob_til_exclam #1!{}% catcode 12 exclam
\def\xint_gob_til_dot    #1.{}%
\def\xint_gob_til_G     #1G{}%
\def\xint_gob_til_minus #1-{}%
\def\xint_gob_til_relax #1\relax {}%
\def\xint_UDzerominusfork #10-#2#3\krof {#2}%
\def\xint_UDzerofork       #10#2#3\krof {#2}%
\def\xint_UDsignfork       #1-#2#3\krof {#2}%
\def\xint_UDwfork         #1\W#2#3\krof {#2}%
\def\xint_UDXINTWfork     #1\XINT_W#2#3\krof {#2}%
\def\xint_UDzerosfork     #100#2#3\krof {#2}%
\def\xint_UDonezerofork   #110#2#3\krof {#2}%
\def\xint_UDsignsfork     #1--#2#3\krof {#2}%
\let\xint_relax\relax
\def\xint_brelax {\xint_relax }%
\long\def\xint_gob_til_xint_relax #1\xint_relax {}%
%    \end{macrocode}
% \subsection{\csh{xint_afterfi}}
%    \begin{macrocode}
\long\def\xint_afterfi #1#2\fi {\fi #1}%
%    \end{macrocode}
% \subsection{\csh{xint_bye}}
%    \begin{macrocode}
\long\def\xint_bye #1\xint_bye {}%
%    \end{macrocode}
% \subsection{\csh{xintdothis}, \csh{xintorthat}}
% \lverb|New with 1.1. Public names without underscores with 1.2. Used as
% \if..\xint_dothis{..}\fi <multiple times> followed by \xint_orthat{...}. To
% be used with less probable things first.|
%    \begin{macrocode}
\long\def\xint_dothis #1#2\xint_orthat #3{\fi #1}% v1.1
\let\xint_orthat \xint_firstofone
\long\def\xintdothis #1#2\xintorthat #3{\fi #1}%
\let\xintorthat \xint_firstofone
%    \end{macrocode}
% \subsection{\csh{xint_zapspaces}}
% \lverb|1.1. This little utility zaps leading, intermediate, trailing,
% spaces in completely expanding context (\edef, \csname . . . \endcsname).
% $centeredline$bgroup\xint_zapspaces foo<space>\xint_gobble_i$egroup
%
% Will remove some brace pairs (but not spaces inside them). By the way the
% \zap@spaces of LaTeX2e handles unexpectedly things such as \zap@spaces 1
% {22} 3 4 \@empty (spaces are not all removed). This does not happen with
% \xint_zapspaces.
%
% Explanation: if there are leading spaces, then the first #1 will be empty,
% and the first #2 being undelimited will be stripped from all the remaining
% leading spaces, if there was more than one to start with. Of course
% brace-stripping may occur. And this iterates: each time a #2 is removed,
% either we then have spaces and next #1 will be empty, or we have no spaces
% and #1 will end at the first space. Ultimately #2 will be \xint_gobble_i.
%
% This is not really robust as it may switch the expansion order of macros,
% and the \xint_zapspaces token might end up being fetched up by a macro. But
% it is enough for our purposes, for example:
% $centeredline
% $bgroup\the\numexpr \xint_zapspaces 1 2 \xint_gobble_i\relax$egroup
% expands to 12, and not 12\relax. Imagine also:
% $centeredline
% $bgroup\the\numexpr 1 2\expandafter.\the\numexpr ...$egroup
%
% The space will delay the \expandafter. Thus we have to get rid of spaces in
% contexts where arguments are fetched by delimited macros and fed to
% \numexpr (or for any reason can contain spaces). I apply this corrective
% treatment so far only in $xintexprnameimp but perhaps I should in
% $xintfracnameimp too. As said above, perhaps the zapspaces should force
% expansion too, but I leave it standing.|
%    \begin{macrocode}
\def\xint_zapspaces #1 #2{#1#2\xint_zapspaces }% v1.1
%    \end{macrocode}
% \subsection{\csh{odef}, \csh{oodef}, \csh{fdef}}
% \lverb|May be prefixed with \global. No parameter text.|
%    \begin{macrocode}
\def\xintodef #1{\expandafter\def\expandafter#1\expandafter }%
\def\xintoodef #1{\expandafter\expandafter\expandafter\def
                  \expandafter\expandafter\expandafter#1%
                  \expandafter\expandafter\expandafter }%
\def\xintfdef #1#2{\expandafter\def\expandafter#1\expandafter
                           {\romannumeral`&&@#2}}%
\ifdefined\odef\else\let\odef\xintodef\fi
\ifdefined\oodef\else\let\oodef\xintoodef\fi
\ifdefined\fdef\else\let\fdef\xintfdef\fi
%    \end{macrocode}
% \subsection{\csh{xintReverseOrder}}
% \lverb|\xintReverseOrder: does NOT expand its argument. Thus one must use
% some \expandafter if argument is a macro. A faster reverse, but only
% applicable to (many) digit tokens has been provided with
% \csh{xintReverseDigits} from 1.2 xintcore.|
%    \begin{macrocode}
\def\xintReverseOrder {\romannumeral0\xintreverseorder }%
\long\def\xintreverseorder #1%
{%
    \XINT_rord_main {}#1%
      \xint_relax
        \xint_bye\xint_bye\xint_bye\xint_bye
        \xint_bye\xint_bye\xint_bye\xint_bye
      \xint_relax
}%
\long\def\XINT_rord_main #1#2#3#4#5#6#7#8#9%
{%
    \xint_bye #9\XINT_rord_cleanup\xint_bye
    \XINT_rord_main {#9#8#7#6#5#4#3#2#1}%
}%
\long\edef\XINT_rord_cleanup\xint_bye\XINT_rord_main #1#2\xint_relax
{%
    \noexpand\expandafter\space\noexpand\xint_gob_til_xint_relax #1%
}%
%    \end{macrocode}
% \subsection{\csh{xintLength}}
% \lverb|\xintLength does NOT expand its argument.|
%    \begin{macrocode}
\def\xintLength {\romannumeral0\xintlength }%
\long\def\xintlength #1%
{%
    \XINT_length_loop
    0.#1\xint_relax\xint_relax\xint_relax\xint_relax
         \xint_relax\xint_relax\xint_relax\xint_relax\xint_bye
}%
\long\def\XINT_length_loop #1.#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_xint_relax #9\XINT_length_finish_a\xint_relax
    \expandafter\XINT_length_loop\the\numexpr #1+\xint_c_viii.%
}%
\def\XINT_length_finish_a\xint_relax\expandafter\XINT_length_loop
    \the\numexpr #1+\xint_c_viii.#2\xint_bye
{%
    \XINT_length_finish_b #2\W\W\W\W\W\W\W\Z {#1}%
}%
\def\XINT_length_finish_b #1#2#3#4#5#6#7#8\Z
{%
    \xint_gob_til_W
            #1\XINT_length_finish_c \xint_c_
            #2\XINT_length_finish_c \xint_c_i
            #3\XINT_length_finish_c \xint_c_ii
            #4\XINT_length_finish_c \xint_c_iii
            #5\XINT_length_finish_c \xint_c_iv
            #6\XINT_length_finish_c \xint_c_v
            #7\XINT_length_finish_c \xint_c_vi
            \W\XINT_length_finish_c \xint_c_vii\Z
}%
\edef\XINT_length_finish_c #1#2\Z #3%
   {\noexpand\expandafter\space\noexpand\the\numexpr #3+#1\relax}%
%    \end{macrocode}
% \subsection{\csh{xintMessage}, \csh{ifxintverbose}}
% \lverb|1.2c added for use by \xintdefvar and \xintdeffunct of xintexpr.|
%    \begin{macrocode}
\def\xintMessage #1#2#3{%
       \immediate\write16{Package #1 (#2) on line \the\inputlineno :}%
       \immediate\write16{\space\space\space\space#3}%
}%
\newif\ifxintverbose
\XINT_restorecatcodes_endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xintkernel>\relax
%\def<*xinttools>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xintkernel>
%<*xinttools>
%
% \StoreCodelineNo {xintkernel}
%
% \section{Package \xinttoolsnameimp implementation}
% \label{sec:toolsimp}
%
% \localtableofcontents
%
% Release |1.09g| of |2013/11/22| splits off |xinttools.sty| from |xint.sty|.
% Starting with |1.1|, \xinttoolsnameimp ceases being loaded automatically by
% \xintnameimp.
%
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
%
% The code for reload detection was initially copied from \textsc{Heiko
% Oberdiek}'s packages, then modified.
%
% The method for catcodes was also initially directly inspired by these
% packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xinttools.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xintkernel.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xinttools}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xinttools.sty
      \ifx\w\relax % but xintkernel.sty not yet loaded.
         \def\z{\endgroup\input xintkernel.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xintkernel.sty not yet loaded.
            \def\z{\endgroup\RequirePackage{xintkernel}}%
          \fi
      \else
        \aftergroup\endinput % xinttools already loaded.
      \fi
    \fi
  \fi
\z%
\XINTsetupcatcodes% defined in xintkernel.sty
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\XINT_providespackage
\ProvidesPackage{xinttools}%
  [2015/11/18 v1.2d Expandable and non-expandable utilities (jfB)]%
%    \end{macrocode}
% \lverb|\XINT_toks is used in macros such as \xintFor. It is not used
% elsewhere in the xint bundle.|
%    \begin{macrocode}
\newtoks\XINT_toks
\xint_firstofone{\let\XINT_sptoken= } %<- space here!
%    \end{macrocode}
% \subsection{\csh{xintgodef}, \csh{xintgoodef}, \csh{xintgfdef}}
% \lverb|1.09i. For use in \xintAssign.|
%    \begin{macrocode}
\def\xintgodef  {\global\xintodef }%
\def\xintgoodef {\global\xintoodef }%
\def\xintgfdef  {\global\xintfdef }%
%    \end{macrocode}
% \subsection{\csh{xintRevWithBraces}}
% \lverb|New with 1.06. Makes the expansion of its argument and then reverses
% the resulting tokens or braced tokens, adding a pair of braces to each (thus,
% maintaining it when it was already there.) The reason for
% \xint_relax, here and in other locations, is in case #1 expands to nothing,
% the \romannumeral-`0 must be stopped|
%    \begin{macrocode}
\def\xintRevWithBraces         {\romannumeral0\xintrevwithbraces }%
\def\xintRevWithBracesNoExpand {\romannumeral0\xintrevwithbracesnoexpand }%
\long\def\xintrevwithbraces #1%
{%
    \expandafter\XINT_revwbr_loop\expandafter{\expandafter}%
    \romannumeral`&&@#1\xint_relax\xint_relax\xint_relax\xint_relax
                      \xint_relax\xint_relax\xint_relax\xint_relax\xint_bye
}%
\long\def\xintrevwithbracesnoexpand #1%
{%
    \XINT_revwbr_loop {}%
    #1\xint_relax\xint_relax\xint_relax\xint_relax
      \xint_relax\xint_relax\xint_relax\xint_relax\xint_bye
}%
\long\def\XINT_revwbr_loop #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_xint_relax #9\XINT_revwbr_finish_a\xint_relax
    \XINT_revwbr_loop {{#9}{#8}{#7}{#6}{#5}{#4}{#3}{#2}#1}%
}%
\long\def\XINT_revwbr_finish_a\xint_relax\XINT_revwbr_loop #1#2\xint_bye
{%
    \XINT_revwbr_finish_b #2\R\R\R\R\R\R\R\Z #1%
}%
\def\XINT_revwbr_finish_b #1#2#3#4#5#6#7#8\Z
{%
    \xint_gob_til_R
            #1\XINT_revwbr_finish_c \xint_gobble_viii
            #2\XINT_revwbr_finish_c \xint_gobble_vii
            #3\XINT_revwbr_finish_c \xint_gobble_vi
            #4\XINT_revwbr_finish_c \xint_gobble_v
            #5\XINT_revwbr_finish_c \xint_gobble_iv
            #6\XINT_revwbr_finish_c \xint_gobble_iii
            #7\XINT_revwbr_finish_c \xint_gobble_ii
            \R\XINT_revwbr_finish_c \xint_gobble_i\Z
}%
%    \end{macrocode}
% \lverb|1.1c revisited this old code and improved upon the earlier endings.|
%    \begin{macrocode}
\edef\XINT_revwbr_finish_c #1#2\Z {\noexpand\expandafter\space #1}%
%    \end{macrocode}
% \subsection{\csh{xintZapFirstSpaces}}
% \lverb|1.09f, written [2013/11/01]. Modified (2014/10/21) for release 1.1 to
% correct the bug in case of an empty argument, or argument containing only
% spaces, which had been forgotten in first version. New version is simpler than
% the initial one. This macro does NOT expand its argument.|
%    \begin{macrocode}
\def\xintZapFirstSpaces {\romannumeral0\xintzapfirstspaces }%
%    \end{macrocode}
% \lverb|defined via an \edef in order to inject space tokens inside.|
%    \begin{macrocode}
\long\edef\xintzapfirstspaces #1%
  {\noexpand\XINT_zapbsp_a \space #1\xint_relax \space\space\xint_relax }%            
\xint_firstofone {\long\edef\XINT_zapbsp_a #1 } %<- space token here
{%
%    \end{macrocode}
% \lverb|If the original #1 started with a space, the grabbed #1 is empty. Thus
% _again? will see #1=\xint_bye, and hand over control to _again which will loop
% back into \XINT_zapbsp_a, with one initial space less. If the original #1 did
% not start with a space, or was empty, then the #1 below will be a <sptoken>,
% then an extract of the original #1, not empty and not starting with a space,
% which contains what was up to the first <sp><sp> present in original #1, or,
% if none preexisted, <sptoken> and all of #1 (possibly empty) plus an ending
% \xint_relax. The added initial space will stop later the \romannumeral0. No
% brace stripping is possible. Control is handed over to \XINT_zapbsp_b which
% strips out the ending \xint_relax<sp><sp>\xint_relax|
%    \begin{macrocode}
  \noexpand\XINT_zapbsp_again? #1\noexpand\xint_bye\noexpand\XINT_zapbsp_b #1\space\space
}%
\long\def\XINT_zapbsp_again? #1{\xint_bye #1\XINT_zapbsp_again }%
\xint_firstofone{\def\XINT_zapbsp_again\XINT_zapbsp_b} {\XINT_zapbsp_a }%
\long\def\XINT_zapbsp_b #1\xint_relax #2\xint_relax {#1}%
%    \end{macrocode}
% \subsection{\csh{xintZapLastSpaces}}
% \lverb+1.09f, written [2013/11/01]. +
%    \begin{macrocode}
\def\xintZapLastSpaces {\romannumeral0\xintzaplastspaces }%
%    \end{macrocode}
% \lverb|Next macro is defined via an \edef for the space tokens.|
%    \begin{macrocode}
\long\edef\xintzaplastspaces #1{\noexpand\XINT_zapesp_a {}\noexpand\empty#1%
                                \space\space\noexpand\xint_bye\xint_relax}%
%    \end{macrocode}
% \lverb|The \empty from \xintzaplastspaces is to prevent brace removal in the
% #2 below. The \expandafter chain removes it.|
%    \begin{macrocode}
\xint_firstofone {\long\def\XINT_zapesp_a #1#2 } %<- second space here
    {\expandafter\XINT_zapesp_b\expandafter{#2}{#1}}%
%    \end{macrocode}
% \lverb|Notice again an \empty added here. This is in preparation for possibly looping
% back to \XINT_zapesp_a. If the initial #1 had no <sp><sp>, the stuff however
% will not loop, because #3 will already be <some spaces>\xint_bye. Notice
% that this macro fetches all way to the ending \xint_relax. This looks not
% very efficient, but how often do we have to strip ending spaces from
% something which also has inner stretches of _multiple_ space tokens ?;-). |
%    \begin{macrocode}
\long\def\XINT_zapesp_b #1#2#3\xint_relax
    {\XINT_zapesp_end? #3\XINT_zapesp_e {#2#1}\empty #3\xint_relax }%
%    \end{macrocode}
% \lverb|When we have been over all possible <sp><sp> things, we reach the
% ending space tokens, and #3 will be a bunch of spaces (possibly none)
% followed by \xint_bye. So the #1 in _end? will be \xint_bye. In all other cases
% #1 can not be \xint_bye (assuming naturally this token does nor arise in
% original input), hence control falls back to \XINT_zapesp_e which will loop back
% to \XINT_zapesp_a.|
%    \begin{macrocode}
\long\def\XINT_zapesp_end? #1{\xint_bye #1\XINT_zapesp_end }%
%    \end{macrocode}
% \lverb|We are done. The #1 here has accumulated all the previous material,
% and is stripped of its ending spaces, if any.|
%    \begin{macrocode}
\long\def\XINT_zapesp_end\XINT_zapesp_e #1#2\xint_relax { #1}%
%    \end{macrocode}
% \lverb|We haven't yet reached the end, so we need to re-inject two space
% tokens after what we have gotten so far. Then we loop.|
%    \begin{macrocode}
\long\edef\XINT_zapesp_e #1{\noexpand \XINT_zapesp_a {#1\space\space}}%
%    \end{macrocode}
% \subsection{\csh{xintZapSpaces}}
% \lverb+1.09f, written [2013/11/01]. Modified for 1.1, 2014/10/21 as it has the
% same bug as \xintZapFirstSpaces. We in effect do first \xintZapFirstSpaces,
% then \xintZapLastSpaces.+
%    \begin{macrocode}
\def\xintZapSpaces {\romannumeral0\xintzapspaces }%
\long\edef\xintzapspaces #1% like \xintZapFirstSpaces.
                   {\noexpand\XINT_zapsp_a \space #1\xint_relax \space\space\xint_relax }%
\xint_firstofone {\long\edef\XINT_zapsp_a #1 } %
  {\noexpand\XINT_zapsp_again? #1\noexpand\xint_bye\noexpand\XINT_zapsp_b #1\space\space}%
\long\def\XINT_zapsp_again? #1{\xint_bye #1\XINT_zapsp_again }%
\xint_firstofone{\def\XINT_zapsp_again\XINT_zapsp_b} {\XINT_zapsp_a }%
\xint_firstofone{\def\XINT_zapsp_b} {\XINT_zapsp_c }%
\long\edef\XINT_zapsp_c #1\xint_relax #2\xint_relax {\noexpand\XINT_zapesp_a
    {}\noexpand \empty #1\space\space\noexpand\xint_bye\xint_relax }%
%    \end{macrocode}
% \subsection{\csh{xintZapSpacesB}}
% \lverb+1.09f, written [2013/11/01]. Strips up to one pair of braces (but then
% does not strip spaces inside).+
%    \begin{macrocode}
\def\xintZapSpacesB {\romannumeral0\xintzapspacesb }%
\long\def\xintzapspacesb #1{\XINT_zapspb_one? #1\xint_relax\xint_relax
                         \xint_bye\xintzapspaces {#1}}%
\long\def\XINT_zapspb_one? #1#2%
   {\xint_gob_til_xint_relax #1\XINT_zapspb_onlyspaces\xint_relax
    \xint_gob_til_xint_relax #2\XINT_zapspb_bracedorone\xint_relax
    \xint_bye {#1}}%
\def\XINT_zapspb_onlyspaces\xint_relax
    \xint_gob_til_xint_relax\xint_relax\XINT_zapspb_bracedorone\xint_relax
    \xint_bye #1\xint_bye\xintzapspaces #2{ }%
\long\def\XINT_zapspb_bracedorone\xint_relax
    \xint_bye #1\xint_relax\xint_bye\xintzapspaces #2{ #1}%
%    \end{macrocode}
% \subsection{\csh{xintCSVtoList}, \csh{xintCSVtoListNonStripped}}
% \lverb|\xintCSVtoList transforms a,b,..,z into {a}{b}...{z}. The comma
% separated list may be a macro which is first f-expanded. First included in
% release 1.06. Here, use of \Z (and \R) perfectly safe.
%
% [2013/11/02]: Starting with 1.09f, automatically filters items with
% \xintZapSpacesB to strip away all spaces around commas, and spaces at the start
% and end of the list. The original is kept as \xintCSVtoListNonStripped, and is
% faster. But ... it doesn't strip spaces.|
%    \begin{macrocode}
\def\xintCSVtoList {\romannumeral0\xintcsvtolist }%
\long\def\xintcsvtolist #1{\expandafter\xintApply
           \expandafter\xintzapspacesb
           \expandafter{\romannumeral0\xintcsvtolistnonstripped{#1}}}%
\def\xintCSVtoListNoExpand {\romannumeral0\xintcsvtolistnoexpand }%
\long\def\xintcsvtolistnoexpand #1{\expandafter\xintApply
           \expandafter\xintzapspacesb
           \expandafter{\romannumeral0\xintcsvtolistnonstrippednoexpand{#1}}}%
\def\xintCSVtoListNonStripped {\romannumeral0\xintcsvtolistnonstripped }%
\def\xintCSVtoListNonStrippedNoExpand
         {\romannumeral0\xintcsvtolistnonstrippednoexpand }%
\long\def\xintcsvtolistnonstripped #1%
{%
    \expandafter\XINT_csvtol_loop_a\expandafter
    {\expandafter}\romannumeral`&&@#1%
        ,\xint_bye,\xint_bye,\xint_bye,\xint_bye
        ,\xint_bye,\xint_bye,\xint_bye,\xint_bye,\Z
}%
\long\def\xintcsvtolistnonstrippednoexpand #1%
{%
    \XINT_csvtol_loop_a
    {}#1,\xint_bye,\xint_bye,\xint_bye,\xint_bye
        ,\xint_bye,\xint_bye,\xint_bye,\xint_bye,\Z
}%
\long\def\XINT_csvtol_loop_a #1#2,#3,#4,#5,#6,#7,#8,#9,%
{%
    \xint_bye #9\XINT_csvtol_finish_a\xint_bye
    \XINT_csvtol_loop_b {#1}{{#2}{#3}{#4}{#5}{#6}{#7}{#8}{#9}}%
}%
\long\def\XINT_csvtol_loop_b #1#2{\XINT_csvtol_loop_a {#1#2}}%
\long\def\XINT_csvtol_finish_a\xint_bye\XINT_csvtol_loop_b #1#2#3\Z
{%
    \XINT_csvtol_finish_b #3\R,\R,\R,\R,\R,\R,\R,\Z #2{#1}%
}%
%    \end{macrocode}
% \lverb|1.1c revisits this old code and improves upon the earlier endings.
% But as the _d.. macros have already nine parameters, I needed the
% \expandafter and \xint_gob_til_Z in finish_b (compare \XINT_keep_endb, or
% also \XINT_RQ_end_b).|
%    \begin{macrocode}
\def\XINT_csvtol_finish_b #1,#2,#3,#4,#5,#6,#7,#8\Z
{%
    \xint_gob_til_R
            #1\expandafter\XINT_csvtol_finish_dviii\xint_gob_til_Z
            #2\expandafter\XINT_csvtol_finish_dvii \xint_gob_til_Z
            #3\expandafter\XINT_csvtol_finish_dvi  \xint_gob_til_Z
            #4\expandafter\XINT_csvtol_finish_dv   \xint_gob_til_Z
            #5\expandafter\XINT_csvtol_finish_div  \xint_gob_til_Z
            #6\expandafter\XINT_csvtol_finish_diii \xint_gob_til_Z
            #7\expandafter\XINT_csvtol_finish_dii  \xint_gob_til_Z
            \R\XINT_csvtol_finish_di \Z
}%
\long\def\XINT_csvtol_finish_dviii #1#2#3#4#5#6#7#8#9{ #9}%
\long\def\XINT_csvtol_finish_dvii  #1#2#3#4#5#6#7#8#9{ #9{#1}}%
\long\def\XINT_csvtol_finish_dvi   #1#2#3#4#5#6#7#8#9{ #9{#1}{#2}}%
\long\def\XINT_csvtol_finish_dv    #1#2#3#4#5#6#7#8#9{ #9{#1}{#2}{#3}}%
\long\def\XINT_csvtol_finish_div   #1#2#3#4#5#6#7#8#9{ #9{#1}{#2}{#3}{#4}}%
\long\def\XINT_csvtol_finish_diii  #1#2#3#4#5#6#7#8#9{ #9{#1}{#2}{#3}{#4}{#5}}%
\long\def\XINT_csvtol_finish_dii   #1#2#3#4#5#6#7#8#9%
                                            { #9{#1}{#2}{#3}{#4}{#5}{#6}}%
\long\def\XINT_csvtol_finish_di\Z  #1#2#3#4#5#6#7#8#9%
                                            { #9{#1}{#2}{#3}{#4}{#5}{#6}{#7}}%
%    \end{macrocode}
% \subsection{\csh{xintListWithSep}}
% \lverb|1.04.
% \xintListWithSep {\sep}{{a}{b}...{z}} returns a \sep b \sep ....\sep z. It
% f-expands its second argument. The 'sep' may be \par's: the macro
% \xintlistwithsep etc... are all declared long. 'sep' does not have to be a
% single token. It is not expanded.|
%    \begin{macrocode}
\def\xintListWithSep {\romannumeral0\xintlistwithsep }%
\def\xintListWithSepNoExpand {\romannumeral0\xintlistwithsepnoexpand }%
\long\def\xintlistwithsep #1#2%
    {\expandafter\XINT_lws\expandafter {\romannumeral`&&@#2}{#1}}%
\long\def\XINT_lws #1#2{\XINT_lws_start {#2}#1\xint_bye }%
\long\def\xintlistwithsepnoexpand #1#2{\XINT_lws_start {#1}#2\xint_bye }%
\long\def\XINT_lws_start #1#2%
{%
    \xint_bye #2\XINT_lws_dont\xint_bye
    \XINT_lws_loop_a {#2}{#1}%
}%
\long\def\XINT_lws_dont\xint_bye\XINT_lws_loop_a #1#2{ }%
\long\def\XINT_lws_loop_a #1#2#3%
{%
    \xint_bye #3\XINT_lws_end\xint_bye
    \XINT_lws_loop_b {#1}{#2#3}{#2}%
}%
\long\def\XINT_lws_loop_b #1#2{\XINT_lws_loop_a {#1#2}}%
\long\def\XINT_lws_end\xint_bye\XINT_lws_loop_b #1#2#3{ #1}%
%    \end{macrocode}
% \subsection{\csh{xintNthElt}}
% \lverb+First included in release 1.06.
%
% \xintNthElt {i}{stuff f-expanding to {a}{b}...{z}} (or `tokens'
% abcd...z)returns the i th element (one pair of braces removed). The list is
% first f-expanded. The \xintNthEltNoExpand does no expansion of its second
% argument. Both variants expand the first argument inside \numexpr.
%
% With i = 0, the number of items is returned. This is different from \xintLen
% which is only for numbers (particularly, it checks the sign) and different
% from \xintLength which does not f-expand its argument.
%
% Negative values return the |i|th element from the end. Release 1.09m
% rewrote the initial bits of the code (which checked the sign of #1 and
% expanded or not #2), ome `improvements' made earlier in 1.09c were quite
% sub-efficient. Now uses \xint_UD$-zero$-minus$-fork, moved from xint.sty.+
%    \begin{macrocode}
\def\xintNthElt         {\romannumeral0\xintnthelt }%
\def\xintNthEltNoExpand {\romannumeral0\xintntheltnoexpand }%
\def\xintnthelt #1#2%
{%
    \expandafter\XINT_nthelt_a\the\numexpr #1\expandafter.%
    \expandafter{\romannumeral`&&@#2}%
}%
\def\xintntheltnoexpand #1%
{%
    \expandafter\XINT_nthelt_a\the\numexpr #1.%
}%
\def\XINT_nthelt_a #1#2.%
{%
    \xint_UDzerominusfork
        #1-{\XINT_nthelt_bzero}%
        0#1{\XINT_nthelt_bneg {#2}}%
         0-{\XINT_nthelt_bpos {#1#2}}%
    \krof
}%
\long\def\XINT_nthelt_bzero #1%
{%
     \XINT_length_loop 0.#1\xint_relax\xint_relax\xint_relax\xint_relax
                 \xint_relax\xint_relax\xint_relax\xint_relax\xint_bye
}%
\long\def\XINT_nthelt_bneg #1#2%
{%
     \expandafter\XINT_nthelt_loop_a\expandafter {\the\numexpr #1\expandafter}%
     \romannumeral0\xintrevwithbracesnoexpand {#2}%
          \xint_relax\xint_relax\xint_relax\xint_relax
          \xint_relax\xint_relax\xint_relax\xint_relax\xint_bye
}%
\long\def\XINT_nthelt_bpos #1#2%
{%
     \XINT_nthelt_loop_a {#1}#2\xint_relax\xint_relax\xint_relax\xint_relax
                    \xint_relax\xint_relax\xint_relax\xint_relax\xint_bye
}%
\def\XINT_nthelt_loop_a #1%
{%
    \ifnum #1>\xint_c_viii
        \expandafter\XINT_nthelt_loop_b
    \else
        \XINT_nthelt_getit
    \fi
    {#1}%
}%
\long\def\XINT_nthelt_loop_b #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_xint_relax #9\XINT_nthelt_silentend\xint_relax
    \expandafter\XINT_nthelt_loop_a\expandafter{\the\numexpr #1-\xint_c_viii}%
}%
\def\XINT_nthelt_silentend #1\xint_bye { }%
\def\XINT_nthelt_getit\fi #1%
{%
    \fi\expandafter\expandafter\expandafter\XINT_nthelt_finish
    \csname xint_gobble_\romannumeral\numexpr#1-\xint_c_i\endcsname
}%
\long\edef\XINT_nthelt_finish #1#2\xint_bye
   {\noexpand\xint_gob_til_xint_relax #1\noexpand\expandafter\space
                               \noexpand\xint_gobble_ii\xint_relax\space #1}%
%    \end{macrocode}
% \subsection{\csh{xintKeep}}
% \lverb+First included in release 1.09m.
%
% \xintKeep {i}{stuff f-expanding to {a}{b}...{z}} (or `tokens' abcd...z, but
% each naked token ends up braced in the output, if 0<i<length of token list)
% returns (in two expansion steps) the first i items from the list, which
% is first f-expanded. The i is expanded inside \numexpr. The variant
% \xintKeepNoExpand does not expand the list argument.
%
% With i = 0, the empty sequence is returned.
%
% With i<0, the last |i| items are returned (in the same order as in
% the original list) AND BRACES ARE NOT ADDED IF NOT ORIGINALLY PRESENT.
%
% With |i| equal to or bigger than the length of the (f-expanded) list,
% the full list is returned.
%
% 1.2a belatedly corrects the description of what this macro does for i<0 !
%
% I have this nagging feeling I should read this code which might be much
% improvable upon, but I just don't have time now (2015/10/19).+
%    \begin{macrocode}
\def\xintKeep         {\romannumeral0\xintkeep }%
\def\xintKeepNoExpand {\romannumeral0\xintkeepnoexpand }%
\def\xintkeep #1#2%
{%
    \expandafter\XINT_keep_a\the\numexpr #1\expandafter.%
    \expandafter{\romannumeral`&&@#2}%
}%
\def\xintkeepnoexpand #1%
{%
    \expandafter\XINT_keep_a\the\numexpr #1.%
}%
\def\XINT_keep_a #1#2.%
{%
    \xint_UDzerominusfork
        #1-{\expandafter\space\xint_gobble_i }%
        0#1{\XINT_keep_bneg_a {#2}}%
         0-{\XINT_keep_bpos {#1#2}}%
    \krof
}%
\long\def\XINT_keep_bneg_a #1#2%
{%
    \expandafter\XINT_keep_bneg_b \the\numexpr \xintLength{#2}-#1.{#2}%
}%
\def\XINT_keep_bneg_b #1#2.%
{%
    \xint_UDzerominusfork
        #1-{\xint_firstofone_thenstop }%
        0#1{\xint_firstofone_thenstop }%
         0-{\XINT_trim_bpos {#1#2}}%
    \krof
}%
\long\def\XINT_keep_bpos #1#2%
{%
     \XINT_keep_loop_a {#1}{}#2\xint_relax\xint_relax\xint_relax\xint_relax
          \xint_relax\xint_relax\xint_relax\xint_bye
}%
\def\XINT_keep_loop_a #1%
{%
    \ifnum #1>\xint_c_vi
        \expandafter\XINT_keep_loop_b
    \else
        \XINT_keep_finish
    \fi
    {#1}%
}%
\long\def\XINT_keep_loop_b #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_xint_relax #9\XINT_keep_enda\xint_relax
    \expandafter\XINT_keep_loop_c\expandafter{\the\numexpr #1-\xint_c_vii}%
    {{#3}{#4}{#5}{#6}{#7}{#8}{#9}}{#2}%
}%
\long\def\XINT_keep_loop_c #1#2#3{\XINT_keep_loop_a {#1}{#3#2}}%
\long\def\XINT_keep_enda\xint_relax
     \expandafter\XINT_keep_loop_c\expandafter #1#2#3#4\xint_bye
{%
     \XINT_keep_endb #4\W\W\W\W\W\W\Z #2{#3}%
}%
\def\XINT_keep_endb #1#2#3#4#5#6#7\Z
{%
    \xint_gob_til_W
    #1\XINT_keep_endc_
    #2\XINT_keep_endc_i
    #3\XINT_keep_endc_ii
    #4\XINT_keep_endc_iii
    #5\XINT_keep_endc_iv
    #6\XINT_keep_endc_v
    \W\XINT_keep_endc_vi\Z
}%
\long\def\XINT_keep_endc_    #1\Z #2#3#4#5#6#7#8#9{ #9}%
\long\def\XINT_keep_endc_i   #1\Z #2#3#4#5#6#7#8#9{ #9{#2}}%
\long\def\XINT_keep_endc_ii  #1\Z #2#3#4#5#6#7#8#9{ #9{#2}{#3}}%
\long\def\XINT_keep_endc_iii #1\Z #2#3#4#5#6#7#8#9{ #9{#2}{#3}{#4}}%
\long\def\XINT_keep_endc_iv  #1\Z #2#3#4#5#6#7#8#9{ #9{#2}{#3}{#4}{#5}}%
\long\def\XINT_keep_endc_v   #1\Z #2#3#4#5#6#7#8#9{ #9{#2}{#3}{#4}{#5}{#6}}%
\long\def\XINT_keep_endc_vi\Z #1#2#3#4#5#6#7#8{ #8{#1}{#2}{#3}{#4}{#5}{#6}}%
\long\def\XINT_keep_finish\fi #1#2#3#4#5#6#7#8#9\xint_bye
{%
    \fi\XINT_keep_finish_loop_a {#1}{}{#3}{#4}{#5}{#6}{#7}{#8}\Z {#2}%
}%
\def\XINT_keep_finish_loop_a #1%
{%
    \xint_gob_til_zero #1\XINT_keep_finish_z0%
    \expandafter\XINT_keep_finish_loop_b\expandafter {\the\numexpr #1-\xint_c_i}%
}%
\long\def\XINT_keep_finish_z0%
     \expandafter\XINT_keep_finish_loop_b\expandafter #1#2#3\Z #4{ #4#2}%
\long\def\XINT_keep_finish_loop_b #1#2#3%
{%
    \xint_gob_til_xint_relax #3\XINT_keep_finish_exit\xint_relax
    \XINT_keep_finish_loop_c {#1}{#2}{#3}%
}%
\long\def\XINT_keep_finish_exit\xint_relax
         \XINT_keep_finish_loop_c #1#2#3\Z #4{ #4#2}%
\long\def\XINT_keep_finish_loop_c #1#2#3%
        {\XINT_keep_finish_loop_a {#1}{#2{#3}}}%
%    \end{macrocode}
% \subsection{\csh{xintKeepUnbraced}}
% \lverb+1.2a. Same as \xintKeep but will not maintain brace pairs around
% the kept items upfront.+
%    \begin{macrocode}
\def\xintKeepUnbraced         {\romannumeral0\xintkeepunbraced }%
\def\xintKeepUnbracedNoExpand {\romannumeral0\xintkeepunbracednoexpand }%
\def\xintkeepunbraced #1#2%
{%
    \expandafter\XINT_keepunbraced_a\the\numexpr #1\expandafter.%
    \expandafter{\romannumeral`&&@#2}%
}%
\def\xintkeepnoexpand #1%
{%
    \expandafter\XINT_keepunbraced_a\the\numexpr #1.%
}%
\def\XINT_keepunbraced_a #1#2.%
{%
    \xint_UDzerominusfork
        #1-{\expandafter\space\xint_gobble_i }%
        0#1{\XINT_keep_bneg_a {#2}}%
         0-{\XINT_keepunbraced_bpos {#1#2}}%
    \krof
}%
\long\def\XINT_keepunbraced_bpos #1#2%
{%
     \XINT_keepunbraced_loop_a {#1}{}#2%
          \xint_relax\xint_relax\xint_relax\xint_relax
          \xint_relax\xint_relax\xint_relax\xint_bye
}%
\def\XINT_keepunbraced_loop_a #1%
{%
    \ifnum #1>\xint_c_vi
        \expandafter\XINT_keepunbraced_loop_b
    \else
        \XINT_keepunbraced_finish
    \fi
    {#1}%
}%
\long\def\XINT_keepunbraced_loop_b #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_xint_relax #9\XINT_keepunbraced_enda\xint_relax
    \expandafter\XINT_keepunbraced_loop_c\expandafter
    {\the\numexpr #1-\xint_c_vii}{#3}{#4}{#5}{#6}{#7}{#8}{#9}.{#2}%
}%
\long\def\XINT_keepunbraced_loop_c #1#2#3#4#5#6#7#8.#9%
    {\XINT_keepunbraced_loop_a {#1}{#9#2#3#4#5#6#7#8}}%
\long\def\XINT_keepunbraced_enda\xint_relax
     \expandafter\XINT_keepunbraced_loop_c\expandafter #1#2.#3#4\xint_bye
{%
     \XINT_keepunbraced_endb #4\W\W\W\W\W\W\Z #2{#3}%
}%
\def\XINT_keepunbraced_endb #1#2#3#4#5#6#7\Z
{%
    \xint_gob_til_W
    #1\XINT_keepunbraced_endc_
    #2\XINT_keepunbraced_endc_i
    #3\XINT_keepunbraced_endc_ii
    #4\XINT_keepunbraced_endc_iii
    #5\XINT_keepunbraced_endc_iv
    #6\XINT_keepunbraced_endc_v
    \W\XINT_keepunbraced_endc_vi\Z
}%
\long\def\XINT_keepunbraced_endc_    #1\Z #2#3#4#5#6#7#8#9{ #9}%
\long\def\XINT_keepunbraced_endc_i   #1\Z #2#3#4#5#6#7#8#9{ #9#2}%
\long\def\XINT_keepunbraced_endc_ii  #1\Z #2#3#4#5#6#7#8#9{ #9#2#3}%
\long\def\XINT_keepunbraced_endc_iii #1\Z #2#3#4#5#6#7#8#9{ #9#2#3#4}%
\long\def\XINT_keepunbraced_endc_iv  #1\Z #2#3#4#5#6#7#8#9{ #9#2#3#4#5}%
\long\def\XINT_keepunbraced_endc_v   #1\Z #2#3#4#5#6#7#8#9{ #9#2#3#4#5#6}%
\long\def\XINT_keepunbraced_endc_vi\Z #1#2#3#4#5#6#7#8{ #8#1#2#3#4#5#6}%
\long\def\XINT_keepunbraced_finish\fi #1#2#3#4#5#6#7#8#9\xint_bye
{%
    \fi\XINT_keepunbraced_finish_loop_a {#1}{}{#3}{#4}{#5}{#6}{#7}{#8}\Z {#2}%
}%
\def\XINT_keepunbraced_finish_loop_a #1%
{%
    \xint_gob_til_zero #1\XINT_keepunbraced_finish_z0%
    \expandafter\XINT_keepunbraced_finish_loop_b\expandafter
       {\the\numexpr #1-\xint_c_i}%
}%
\long\def\XINT_keepunbraced_finish_z0%
     \expandafter\XINT_keepunbraced_finish_loop_b\expandafter #1#2#3\Z #4{ #4#2}%
\long\def\XINT_keepunbraced_finish_loop_b #1#2#3%
{%
    \xint_gob_til_xint_relax #3\XINT_keepunbraced_finish_exit\xint_relax
    \XINT_keepunbraced_finish_loop_c {#1}{#2}{#3}%
}%
\long\def\XINT_keepunbraced_finish_exit\xint_relax
         \XINT_keepunbraced_finish_loop_c #1#2#3\Z #4{ #4#2}%
\long\def\XINT_keepunbraced_finish_loop_c #1#2#3%
        {\XINT_keepunbraced_finish_loop_a {#1}{#2#3}}%
%    \end{macrocode}
% \subsection{\csh{xintTrim}}
% \lverb+First included in release 1.09m.
%
% \xintTrim {i}{stuff f-expanding to {a}{b}...{z}} (or `tokens' abcd...z)
% returns (in two expansion steps) the sequence with the first i elements
% omitted. The list is first f-expanded. The i is expanded inside \numexpr.
% Variant \xintTrimNoExpand does not expand the list argument.
%
% With i = 0, the original (expanded) list is returned.
%
% With i<0, the last |i| items are suppressed. In that case the kept elements
% (coming form the tail) will be braced on output. With i>0, the fist |i|
% items are suppressed: the remaining ones are left as is.
%
% With |i| equal to or bigger than the length of the (f-expanded) list,
% the empty list is returned.+
%    \begin{macrocode}
\def\xintTrim         {\romannumeral0\xinttrim }%
\def\xintTrimNoExpand {\romannumeral0\xinttrimnoexpand }%
\def\xinttrim #1#2%
{%
    \expandafter\XINT_trim_a\the\numexpr #1\expandafter.%
    \expandafter{\romannumeral`&&@#2}%
}%
\def\xinttrimnoexpand #1%
{%
    \expandafter\XINT_trim_a\the\numexpr #1.%
}%
\def\XINT_trim_a #1#2.%
{%
    \xint_UDzerominusfork
        #1-{\xint_firstofone_thenstop }%
        0#1{\XINT_trim_bneg_a {#2}}%
         0-{\XINT_trim_bpos {#1#2}}%
    \krof
}%
\long\def\XINT_trim_bneg_a #1#2%
{%
    \expandafter\XINT_trim_bneg_b \the\numexpr \xintLength{#2}-#1.{#2}%
}%
\def\XINT_trim_bneg_b #1#2.%
{%
    \xint_UDzerominusfork
        #1-{\expandafter\space\xint_gobble_i }%
        0#1{\expandafter\space\xint_gobble_i }%
         0-{\XINT_keep_bpos {#1#2}}%
    \krof
}%
\long\def\XINT_trim_bpos #1#2%
{%
     \XINT_trim_loop_a {#1}#2\xint_relax\xint_relax\xint_relax\xint_relax
                    \xint_relax\xint_relax\xint_relax\xint_relax\xint_bye
}%
\def\XINT_trim_loop_a #1%
{%
    \ifnum #1>\xint_c_vii
        \expandafter\XINT_trim_loop_b
    \else
        \XINT_trim_finish
    \fi
    {#1}%
}%
\long\def\XINT_trim_loop_b #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_xint_relax #9\XINT_trim_silentend\xint_relax
    \expandafter\XINT_trim_loop_a\expandafter{\the\numexpr #1-\xint_c_viii}%
}%
\def\XINT_trim_silentend #1\xint_bye { }%
\def\XINT_trim_finish\fi #1%
{%
    \fi\expandafter\expandafter\expandafter\XINT_trim_finish_a
    \expandafter\expandafter\expandafter\space % avoids brace removal
    \csname xint_gobble_\romannumeral\numexpr#1\endcsname
}%
\long\def\XINT_trim_finish_a #1\xint_relax #2\xint_bye {#1}%
%    \end{macrocode}
% \subsection{\csh{xintTrimUnbraced}}
% \lverb+1.2a+
%    \begin{macrocode}
\def\xintTrimUnbraced         {\romannumeral0\xinttrimunbraced }%
\def\xintTrimUnbracedNoExpand {\romannumeral0\xinttrimunbracednoexpand }%
\def\xinttrimunbraced #1#2%
{%
    \expandafter\XINT_trimunbraced_a\the\numexpr #1\expandafter.%
    \expandafter{\romannumeral`&&@#2}%
}%
\def\xinttrimunbracednoexpand #1%
{%
    \expandafter\XINT_trimunbraced_a\the\numexpr #1.%
}%
\def\XINT_trimunbraced_a #1#2.%
{%
    \xint_UDzerominusfork
        #1-{\xint_firstofone_thenstop }%
        0#1{\XINT_trimunbraced_bneg_a {#2}}%
         0-{\XINT_trim_bpos {#1#2}}%
    \krof
}%
\long\def\XINT_trimunbraced_bneg_a #1#2%
{%
    \expandafter\XINT_trimunbraced_bneg_b \the\numexpr \xintLength{#2}-#1.{#2}%
}%
\def\XINT_trimunbraced_bneg_b #1#2.%
{%
    \xint_UDzerominusfork
        #1-{\expandafter\space\xint_gobble_i }%
        0#1{\expandafter\space\xint_gobble_i }%
         0-{\XINT_keepunbraced_bpos {#1#2}}%
    \krof
}%
%    \end{macrocode}
% \subsection{\csh{xintApply}}
% \lverb|\xintApply {\macro}{{a}{b}...{z}} returns {\macro{a}}...{\macro{b}}
% where each instance of \macro is f-expanded. The list itself is first
% f-expanded and may thus be a macro. Introduced with release 1.04.|
%    \begin{macrocode}
\def\xintApply         {\romannumeral0\xintapply }%
\def\xintApplyNoExpand {\romannumeral0\xintapplynoexpand }%
\long\def\xintapply #1#2%
{%
    \expandafter\XINT_apply\expandafter {\romannumeral`&&@#2}%
    {#1}%
}%
\long\def\XINT_apply #1#2{\XINT_apply_loop_a {}{#2}#1\xint_bye }%
\long\def\xintapplynoexpand #1#2{\XINT_apply_loop_a {}{#1}#2\xint_bye }%
\long\def\XINT_apply_loop_a #1#2#3%
{%
    \xint_bye #3\XINT_apply_end\xint_bye
    \expandafter
    \XINT_apply_loop_b
    \expandafter {\romannumeral`&&@#2{#3}}{#1}{#2}%
}%
\long\def\XINT_apply_loop_b #1#2{\XINT_apply_loop_a {#2{#1}}}%
\long\def\XINT_apply_end\xint_bye\expandafter\XINT_apply_loop_b
    \expandafter #1#2#3{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintApplyUnbraced}}
% \lverb|\xintApplyUnbraced {\macro}{{a}{b}...{z}} returns \macro{a}...\macro{z}
% where each instance of \macro is f-expanded using \romannumeral-`0. The second
% argument may be a macro as it is itself also f-expanded. No braces
% are added: this allows for example a non-expandable \def in \macro, without
% having to do \gdef. Introduced with release 1.06b.|
%    \begin{macrocode}
\def\xintApplyUnbraced {\romannumeral0\xintapplyunbraced }%
\def\xintApplyUnbracedNoExpand {\romannumeral0\xintapplyunbracednoexpand }%
\long\def\xintapplyunbraced #1#2%
{%
    \expandafter\XINT_applyunbr\expandafter {\romannumeral`&&@#2}%
    {#1}%
}%
\long\def\XINT_applyunbr #1#2{\XINT_applyunbr_loop_a {}{#2}#1\xint_bye }%
\long\def\xintapplyunbracednoexpand #1#2%
   {\XINT_applyunbr_loop_a {}{#1}#2\xint_bye }%
\long\def\XINT_applyunbr_loop_a #1#2#3%
{%
    \xint_bye #3\XINT_applyunbr_end\xint_bye
    \expandafter\XINT_applyunbr_loop_b
    \expandafter {\romannumeral`&&@#2{#3}}{#1}{#2}%
}%
\long\def\XINT_applyunbr_loop_b #1#2{\XINT_applyunbr_loop_a {#2#1}}%
\long\def\XINT_applyunbr_end\xint_bye\expandafter\XINT_applyunbr_loop_b
    \expandafter #1#2#3{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintSeq}}
% \lverb|1.09c. Without the optional argument puts stress on the input stack,
% should not be used to generated thousands of terms then.|
%    \begin{macrocode}
\def\xintSeq {\romannumeral0\xintseq }%
\def\xintseq #1{\XINT_seq_chkopt  #1\xint_bye }%
\def\XINT_seq_chkopt #1%
{%
    \ifx [#1\expandafter\XINT_seq_opt
       \else\expandafter\XINT_seq_noopt
    \fi  #1%
}%
\def\XINT_seq_noopt #1\xint_bye #2%
{%
    \expandafter\XINT_seq\expandafter
       {\the\numexpr#1\expandafter}\expandafter{\the\numexpr #2}%
}%
\def\XINT_seq #1#2%
{%
   \ifcase\ifnum #1=#2 0\else\ifnum #2>#1 1\else -1\fi\fi\space
      \expandafter\xint_firstoftwo_thenstop
   \or
      \expandafter\XINT_seq_p
   \else
      \expandafter\XINT_seq_n
   \fi
   {#2}{#1}%
}%
\def\XINT_seq_p #1#2%
{%
    \ifnum #1>#2
      \expandafter\expandafter\expandafter\XINT_seq_p
    \else
      \expandafter\XINT_seq_e
    \fi
    \expandafter{\the\numexpr #1-\xint_c_i}{#2}{#1}%
}%
\def\XINT_seq_n #1#2%
{%
    \ifnum #1<#2
      \expandafter\expandafter\expandafter\XINT_seq_n
    \else
      \expandafter\XINT_seq_e
    \fi
     \expandafter{\the\numexpr #1+\xint_c_i}{#2}{#1}%
}%
\def\XINT_seq_e #1#2#3{ }%
\def\XINT_seq_opt [\xint_bye #1]#2#3%
{%
    \expandafter\XINT_seqo\expandafter
    {\the\numexpr #2\expandafter}\expandafter
    {\the\numexpr #3\expandafter}\expandafter
    {\the\numexpr #1}%
}%
\def\XINT_seqo #1#2%
{%
   \ifcase\ifnum #1=#2 0\else\ifnum #2>#1 1\else -1\fi\fi\space
      \expandafter\XINT_seqo_a
   \or
      \expandafter\XINT_seqo_pa
   \else
      \expandafter\XINT_seqo_na
   \fi
   {#1}{#2}%
}%
\def\XINT_seqo_a #1#2#3{ {#1}}%
\def\XINT_seqo_o #1#2#3#4{ #4}%
\def\XINT_seqo_pa #1#2#3%
{%
    \ifcase\ifnum #3=\xint_c_ 0\else\ifnum #3>\xint_c_ 1\else -1\fi\fi\space
           \expandafter\XINT_seqo_o
    \or
           \expandafter\XINT_seqo_pb
    \else
           \xint_afterfi{\expandafter\space\xint_gobble_iv}%
    \fi
    {#1}{#2}{#3}{{#1}}%
}%
\def\XINT_seqo_pb #1#2#3%
{%
    \expandafter\XINT_seqo_pc\expandafter{\the\numexpr #1+#3}{#2}{#3}%
}%
\def\XINT_seqo_pc #1#2%
{%
    \ifnum #1>#2
        \expandafter\XINT_seqo_o
    \else
        \expandafter\XINT_seqo_pd
    \fi
    {#1}{#2}%
}%
\def\XINT_seqo_pd #1#2#3#4{\XINT_seqo_pb {#1}{#2}{#3}{#4{#1}}}%
\def\XINT_seqo_na #1#2#3%
{%
    \ifcase\ifnum #3=\xint_c_ 0\else\ifnum #3>\xint_c_ 1\else -1\fi\fi\space
        \expandafter\XINT_seqo_o
    \or
        \xint_afterfi{\expandafter\space\xint_gobble_iv}%
    \else
        \expandafter\XINT_seqo_nb
    \fi
    {#1}{#2}{#3}{{#1}}%
}%
\def\XINT_seqo_nb #1#2#3%
{%
    \expandafter\XINT_seqo_nc\expandafter{\the\numexpr #1+#3}{#2}{#3}%
}%
\def\XINT_seqo_nc #1#2%
{%
    \ifnum #1<#2
        \expandafter\XINT_seqo_o
    \else
        \expandafter\XINT_seqo_nd
    \fi
    {#1}{#2}%
}%
\def\XINT_seqo_nd #1#2#3#4{\XINT_seqo_nb {#1}{#2}{#3}{#4{#1}}}%
%    \end{macrocode}
%\subsection{\csh{xintloop}, \csh{xintbreakloop}, \csh{xintbreakloopanddo},
% \csh{xintloopskiptonext}}
% \lverb|1.09g [2013/11/22]. Made long with 1.09h.|
%    \begin{macrocode}
\long\def\xintloop #1#2\repeat {#1#2\xintloop_again\fi\xint_gobble_i {#1#2}}%
\long\def\xintloop_again\fi\xint_gobble_i #1{\fi
                             #1\xintloop_again\fi\xint_gobble_i {#1}}%
\long\def\xintbreakloop #1\xintloop_again\fi\xint_gobble_i #2{}%
\long\def\xintbreakloopanddo #1#2\xintloop_again\fi\xint_gobble_i #3{#1}%
\long\def\xintloopskiptonext #1\xintloop_again\fi\xint_gobble_i #2{%
                        #2\xintloop_again\fi\xint_gobble_i {#2}}%
%    \end{macrocode}
% \subsection{\csh{xintiloop}, \csh{xintiloopindex}, \csh{xintouteriloopindex},
%   \csh{xintbreakiloop}, \csh{xintbreakiloopanddo}, \csh{xintiloopskiptonext},
%  \csh{xintiloopskipandredo}}
% \lverb|1.09g [2013/11/22]. Made long with 1.09h.|
%    \begin{macrocode}
\def\xintiloop [#1+#2]{%
    \expandafter\xintiloop_a\the\numexpr #1\expandafter.\the\numexpr #2.}%
\long\def\xintiloop_a #1.#2.#3#4\repeat{%
    #3#4\xintiloop_again\fi\xint_gobble_iii {#1}{#2}{#3#4}}%
\def\xintiloop_again\fi\xint_gobble_iii #1#2{%
    \fi\expandafter\xintiloop_again_b\the\numexpr#1+#2.#2.}%
\long\def\xintiloop_again_b #1.#2.#3{%
    #3\xintiloop_again\fi\xint_gobble_iii {#1}{#2}{#3}}%
\long\def\xintbreakiloop #1\xintiloop_again\fi\xint_gobble_iii #2#3#4{}%
\long\def\xintbreakiloopanddo
     #1.#2\xintiloop_again\fi\xint_gobble_iii #3#4#5{#1}%
\long\def\xintiloopindex #1\xintiloop_again\fi\xint_gobble_iii #2%
                {#2#1\xintiloop_again\fi\xint_gobble_iii {#2}}%
\long\def\xintouteriloopindex #1\xintiloop_again
                         #2\xintiloop_again\fi\xint_gobble_iii #3%
   {#3#1\xintiloop_again #2\xintiloop_again\fi\xint_gobble_iii {#3}}%
\long\def\xintiloopskiptonext #1\xintiloop_again\fi\xint_gobble_iii #2#3{%
    \expandafter\xintiloop_again_b \the\numexpr#2+#3.#3.}%
\long\def\xintiloopskipandredo #1\xintiloop_again\fi\xint_gobble_iii #2#3#4{%
    #4\xintiloop_again\fi\xint_gobble_iii {#2}{#3}{#4}}%
%    \end{macrocode}
% \subsection{\csh{XINT_xflet}}
% \lverb|1.09e [2013/10/29]: we f-expand unbraced tokens and swallow arising
% space tokens until the dust settles.|
%    \begin{macrocode}
\def\XINT_xflet #1%
{%
    \def\XINT_xflet_macro {#1}\XINT_xflet_zapsp
}%
\def\XINT_xflet_zapsp
{%
    \expandafter\futurelet\expandafter\XINT_token
    \expandafter\XINT_xflet_sp?\romannumeral`&&@%
}%
\def\XINT_xflet_sp?
{%
    \ifx\XINT_token\XINT_sptoken
         \expandafter\XINT_xflet_zapsp
    \else\expandafter\XINT_xflet_zapspB
    \fi
}%
\def\XINT_xflet_zapspB
{%
    \expandafter\futurelet\expandafter\XINT_tokenB
    \expandafter\XINT_xflet_spB?\romannumeral`&&@%
}%
\def\XINT_xflet_spB?
{%
    \ifx\XINT_tokenB\XINT_sptoken
         \expandafter\XINT_xflet_zapspB
    \else\expandafter\XINT_xflet_eq?
    \fi
}%
\def\XINT_xflet_eq?
{%
    \ifx\XINT_token\XINT_tokenB
         \expandafter\XINT_xflet_macro
    \else\expandafter\XINT_xflet_zapsp
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintApplyInline}}
% \lverb|1.09a: \xintApplyInline\macro{{a}{b}...{z}} has the same effect as
% executing \macro{a} and then applying again \xintApplyInline to the shortened
% list {{b}...{z}} until nothing is left. This is a non-expandable command
% which will result in quicker code than using \xintApplyUnbraced. It f-expands
% its second (list) argument first, which may thus be encapsulated in a macro.
%
% Rewritten in 1.09c. Nota bene: uses catcode 3 Z as privated list terminator.|
%    \begin{macrocode}
\catcode`Z 3
\long\def\xintApplyInline #1#2%
{%
  \long\expandafter\def\expandafter\XINT_inline_macro
  \expandafter ##\expandafter 1\expandafter {#1{##1}}%
  \XINT_xflet\XINT_inline_b #2Z% this Z has catcode 3
}%
\def\XINT_inline_b
{%
    \ifx\XINT_token Z\expandafter\xint_gobble_i
    \else\expandafter\XINT_inline_d\fi
}%
\long\def\XINT_inline_d #1%
{%
  \long\def\XINT_item{{#1}}\XINT_xflet\XINT_inline_e
}%
\def\XINT_inline_e
{%
    \ifx\XINT_token Z\expandafter\XINT_inline_w
    \else\expandafter\XINT_inline_f\fi
}%
\def\XINT_inline_f
{%
  \expandafter\XINT_inline_g\expandafter{\XINT_inline_macro {##1}}%
}%
\long\def\XINT_inline_g #1%
{%
   \expandafter\XINT_inline_macro\XINT_item
   \long\def\XINT_inline_macro ##1{#1}\XINT_inline_d
}%
\def\XINT_inline_w #1%
{%
   \expandafter\XINT_inline_macro\XINT_item
}%
%    \end{macrocode}
% \subsection{\csh{xintFor}, \csh{xintFor*}, \csh{xintBreakFor}, \csh{xintBreakForAndDo}}
% \lverb|1.09c [2013/10/09]: a new kind of loop which uses macro parameters
% #1, #2, #3, #4 rather than macros; while not expandable it survives executing
% code closing groups, like what happens in an alignment with the $& character.
% When inserted in a macro for later use, the # character must be doubled.
%
% The non-star variant works on a csv list, which it expands once, the
% star variant works on a token list, which it (repeatedly) f-expands.
%
% 1.09e adds \XINT_forever with \xintintegers, \xintdimensions, \xintrationals
% and \xintBreakFor, \xintBreakForAndDo, \xintifForFirst, \xintifForLast. On
% this occasion \xint_firstoftwo and \xint_secondoftwo are made long.
%
% 1.09f: rewrites large parts of \xintFor code in order to filter the comma
% separated list via \xintCSVtoList which gets rid of spaces. The #1 in
% \XINT_for_forever? has an initial space token which serves two purposes:
% preventing brace stripping, and stopping the expansion made by \xintcsvtolist.
% If the \XINT_forever branch is taken, the added space will not be a problem
% there.
%
% 1.09f rewrites (2013/11/03) the code which now allows all macro parameters
% from #1 to #9 in \xintFor, \xintFor*, and \XINT_forever.|
%    \begin{macrocode}
\def\XINT_tmpa #1#2{\ifnum #2<#1 \xint_afterfi {{#########2}}\fi}%
\def\XINT_tmpb #1#2{\ifnum #1<#2 \xint_afterfi {{#########2}}\fi}%
\def\XINT_tmpc #1%
{%
    \expandafter\edef \csname XINT_for_left#1\endcsname
               {\xintApplyUnbraced {\XINT_tmpa #1}{123456789}}%
    \expandafter\edef \csname XINT_for_right#1\endcsname
               {\xintApplyUnbraced {\XINT_tmpb #1}{123456789}}%
}%
\xintApplyInline \XINT_tmpc {123456789}%
\long\def\xintBreakFor      #1Z{}%
\long\def\xintBreakForAndDo #1#2Z{#1}%
\def\xintFor {\let\xintifForFirst\xint_firstoftwo
              \futurelet\XINT_token\XINT_for_ifstar }%
\def\XINT_for_ifstar {\ifx\XINT_token*\expandafter\XINT_forx
                                 \else\expandafter\XINT_for \fi }%
\catcode`U 3 % with numexpr
\catcode`V 3 % with xintfrac.sty (xint.sty not enough)
\catcode`D 3 % with dimexpr
\def\XINT_flet_zapsp
{%
    \futurelet\XINT_token\XINT_flet_sp?
}%
\def\XINT_flet_sp?
{%
    \ifx\XINT_token\XINT_sptoken
         \xint_afterfi{\expandafter\XINT_flet_zapsp\romannumeral0}%
    \else\expandafter\XINT_flet_macro
    \fi
}%
\long\def\XINT_for #1#2in#3#4#5%
{%
    \expandafter\XINT_toks\expandafter
        {\expandafter\XINT_for_d\the\numexpr #2\relax {#5}}%
    \def\XINT_flet_macro {\expandafter\XINT_for_forever?\space}%
    \expandafter\XINT_flet_zapsp #3Z%
}%
\def\XINT_for_forever? #1Z%
{%
    \ifx\XINT_token U\XINT_to_forever\fi
    \ifx\XINT_token V\XINT_to_forever\fi
    \ifx\XINT_token D\XINT_to_forever\fi
    \expandafter\the\expandafter\XINT_toks\romannumeral0\xintcsvtolist {#1}Z%
}%
\def\XINT_to_forever\fi #1\xintcsvtolist #2{\fi \XINT_forever #2}%
\long\def\XINT_forx *#1#2in#3#4#5%
{%
    \expandafter\XINT_toks\expandafter
       {\expandafter\XINT_forx_d\the\numexpr #2\relax {#5}}%
    \XINT_xflet\XINT_forx_forever? #3Z%
}%
\def\XINT_forx_forever?
{%
    \ifx\XINT_token U\XINT_to_forxever\fi
    \ifx\XINT_token V\XINT_to_forxever\fi
    \ifx\XINT_token D\XINT_to_forxever\fi
    \XINT_forx_empty?
}%
\def\XINT_to_forxever\fi #1\XINT_forx_empty? {\fi \XINT_forever }%
\catcode`U 11
\catcode`D 11
\catcode`V 11
\def\XINT_forx_empty?
{%
    \ifx\XINT_token Z\expandafter\xintBreakFor\fi
    \the\XINT_toks
}%
\long\def\XINT_for_d #1#2#3%
{%
  \long\def\XINT_y ##1##2##3##4##5##6##7##8##9{#2}%
  \XINT_toks {{#3}}%
  \long\edef\XINT_x {\noexpand\XINT_y \csname XINT_for_left#1\endcsname
                     \the\XINT_toks   \csname XINT_for_right#1\endcsname }%
  \XINT_toks {\XINT_x\let\xintifForFirst\xint_secondoftwo\XINT_for_d #1{#2}}%
  \futurelet\XINT_token\XINT_for_last?
}%
\long\def\XINT_forx_d #1#2#3%
{%
  \long\def\XINT_y ##1##2##3##4##5##6##7##8##9{#2}%
  \XINT_toks {{#3}}%
  \long\edef\XINT_x {\noexpand\XINT_y \csname XINT_for_left#1\endcsname
                     \the\XINT_toks   \csname XINT_for_right#1\endcsname }%
  \XINT_toks {\XINT_x\let\xintifForFirst\xint_secondoftwo\XINT_forx_d #1{#2}}%
  \XINT_xflet\XINT_for_last?
}%
\def\XINT_for_last?
{%
    \let\xintifForLast\xint_secondoftwo
    \ifx\XINT_token Z\let\xintifForLast\xint_firstoftwo
        \xint_afterfi{\xintBreakForAndDo{\XINT_x\xint_gobble_i Z}}\fi
    \the\XINT_toks
}%
%    \end{macrocode}
% \subsection{\csh{XINT_forever}, \csh{xintintegers}, \csh{xintdimensions}, \csh{xintrationals}}
% \lverb|New with 1.09e. But this used inadvertently \xintiadd/\xintimul which
% have the unnecessary \xintnum overhead. Changed in 1.09f to use
% \xintiiadd/\xintiimul which do not have this overhead. Also 1.09f uses
% \xintZapSpacesB for the \xintrationals case to get rid of leading and ending
% spaces in the #4 and #5 delimited parameters of \XINT_forever_opt_a
% (for \xintintegers and \xintdimensions this is not necessary, due to the use
% of \numexpr resp. \dimexpr in \XINT_?expr_Ua, resp.\XINT_?expr_Da).|
%    \begin{macrocode}
\catcode`U 3
\catcode`D 3
\catcode`V 3
\let\xintegers      U%
\let\xintintegers   U%
\let\xintdimensions D%
\let\xintrationals  V%
\def\XINT_forever #1%
{%
  \expandafter\XINT_forever_a
  \csname XINT_?expr_\ifx#1UU\else\ifx#1DD\else V\fi\fi a\expandafter\endcsname
  \csname XINT_?expr_\ifx#1UU\else\ifx#1DD\else V\fi\fi i\expandafter\endcsname
  \csname XINT_?expr_\ifx#1UU\else\ifx#1DD\else V\fi\fi \endcsname
}%
\catcode`U 11
\catcode`D 11
\catcode`V 11
\def\XINT_?expr_Ua #1#2%
   {\expandafter{\expandafter\numexpr\the\numexpr #1\expandafter\relax
                              \expandafter\relax\expandafter}%
    \expandafter{\the\numexpr #2}}%
\def\XINT_?expr_Da #1#2%
   {\expandafter{\expandafter\dimexpr\number\dimexpr #1\expandafter\relax
                 \expandafter s\expandafter p\expandafter\relax\expandafter}%
    \expandafter{\number\dimexpr #2}}%
\catcode`Z 11
\def\XINT_?expr_Va #1#2%
{%
    \expandafter\XINT_?expr_Vb\expandafter
          {\romannumeral`&&@\xintrawwithzeros{\xintZapSpacesB{#2}}}%
          {\romannumeral`&&@\xintrawwithzeros{\xintZapSpacesB{#1}}}%
}%
\catcode`Z 3
\def\XINT_?expr_Vb #1#2{\expandafter\XINT_?expr_Vc #2.#1.}%
\def\XINT_?expr_Vc #1/#2.#3/#4.%
{%
     \xintifEq {#2}{#4}%
       {\XINT_?expr_Vf {#3}{#1}{#2}}%
       {\expandafter\XINT_?expr_Vd\expandafter
        {\romannumeral0\xintiimul {#2}{#4}}%
        {\romannumeral0\xintiimul {#1}{#4}}%
        {\romannumeral0\xintiimul {#2}{#3}}%
       }%
}%
\def\XINT_?expr_Vd #1#2#3{\expandafter\XINT_?expr_Ve\expandafter {#2}{#3}{#1}}%
\def\XINT_?expr_Ve #1#2{\expandafter\XINT_?expr_Vf\expandafter {#2}{#1}}%
\def\XINT_?expr_Vf #1#2#3{{#2/#3}{{0}{#1}{#2}{#3}}}%
\def\XINT_?expr_Ui {{\numexpr 1\relax}{1}}%
\def\XINT_?expr_Di {{\dimexpr 0pt\relax}{65536}}%
\def\XINT_?expr_Vi {{1/1}{0111}}%
\def\XINT_?expr_U #1#2%
   {\expandafter{\expandafter\numexpr\the\numexpr #1+#2\relax\relax}{#2}}%
\def\XINT_?expr_D #1#2%
   {\expandafter{\expandafter\dimexpr\the\numexpr #1+#2\relax sp\relax}{#2}}%
\def\XINT_?expr_V #1#2{\XINT_?expr_Vx #2}%
\def\XINT_?expr_Vx #1#2%
{%
     \expandafter\XINT_?expr_Vy\expandafter
        {\romannumeral0\xintiiadd {#1}{#2}}{#2}%
}%
\def\XINT_?expr_Vy #1#2#3#4%
{%
     \expandafter{\romannumeral0\xintiiadd {#3}{#1}/#4}{{#1}{#2}{#3}{#4}}%
}%
\def\XINT_forever_a #1#2#3#4%
{%
    \ifx #4[\expandafter\XINT_forever_opt_a
       \else\expandafter\XINT_forever_b
    \fi #1#2#3#4%
}%
\def\XINT_forever_b #1#2#3Z{\expandafter\XINT_forever_c\the\XINT_toks #2#3}%
\long\def\XINT_forever_c #1#2#3#4#5%
    {\expandafter\XINT_forever_d\expandafter #2#4#5{#3}Z}%
\def\XINT_forever_opt_a #1#2#3[#4+#5]#6Z%
{%
    \expandafter\expandafter\expandafter
    \XINT_forever_opt_c\expandafter\the\expandafter\XINT_toks
    \romannumeral`&&@#1{#4}{#5}#3%
}%
\long\def\XINT_forever_opt_c #1#2#3#4#5#6{\XINT_forever_d #2{#4}{#5}#6{#3}Z}%
\long\def\XINT_forever_d #1#2#3#4#5%
{%
  \long\def\XINT_y ##1##2##3##4##5##6##7##8##9{#5}%
  \XINT_toks {{#2}}%
  \long\edef\XINT_x {\noexpand\XINT_y \csname XINT_for_left#1\endcsname
                     \the\XINT_toks   \csname XINT_for_right#1\endcsname }%
  \XINT_x
  \let\xintifForFirst\xint_secondoftwo
  \expandafter\XINT_forever_d\expandafter #1\romannumeral`&&@#4{#2}{#3}#4{#5}%
}%
%    \end{macrocode}
% \subsection{\csh{xintForpair}, \csh{xintForthree}, \csh{xintForfour}}
% \lverb|1.09c.
% 
% [2013/11/02] 1.09f \xintForpair delegate to \xintCSVtoList and its
% \xintZapSpacesB the handling of spaces. Does not share code with \xintFor
% anymore.
%
% [2013/11/03] 1.09f: \xintForpair extended to accept #1#2, #2#3 etc... up to
% #8#9, \xintForthree, #1#2#3 up to #7#8#9, \xintForfour id. |
%    \begin{macrocode}
\catcode`j 3
\long\def\xintForpair #1#2#3in#4#5#6%
{%
    \let\xintifForFirst\xint_firstoftwo
    \XINT_toks  {\XINT_forpair_d #2{#6}}%
    \expandafter\the\expandafter\XINT_toks #4jZ%
}%
\long\def\XINT_forpair_d #1#2#3(#4)#5%
{%
  \long\def\XINT_y ##1##2##3##4##5##6##7##8##9{#2}%
  \XINT_toks \expandafter{\romannumeral0\xintcsvtolist{ #4}}%
  \long\edef\XINT_x {\noexpand\XINT_y \csname XINT_for_left#1\endcsname
      \the\XINT_toks \csname XINT_for_right\the\numexpr#1+\xint_c_i\endcsname}%
  \let\xintifForLast\xint_secondoftwo
  \ifx #5j\expandafter\xint_firstoftwo
     \else\expandafter\xint_secondoftwo
  \fi
  {\let\xintifForLast\xint_firstoftwo
   \xintBreakForAndDo {\XINT_x \xint_gobble_i Z}}%
  \XINT_x
  \let\xintifForFirst\xint_secondoftwo\XINT_forpair_d #1{#2}%
}%
\long\def\xintForthree #1#2#3in#4#5#6%
{%
    \let\xintifForFirst\xint_firstoftwo
    \XINT_toks  {\XINT_forthree_d #2{#6}}%
    \expandafter\the\expandafter\XINT_toks #4jZ%
}%
\long\def\XINT_forthree_d #1#2#3(#4)#5%
{%
  \long\def\XINT_y ##1##2##3##4##5##6##7##8##9{#2}%
  \XINT_toks \expandafter{\romannumeral0\xintcsvtolist{ #4}}%
  \long\edef\XINT_x {\noexpand\XINT_y \csname XINT_for_left#1\endcsname
      \the\XINT_toks \csname XINT_for_right\the\numexpr#1+\xint_c_ii\endcsname}%
  \let\xintifForLast\xint_secondoftwo
  \ifx #5j\expandafter\xint_firstoftwo
     \else\expandafter\xint_secondoftwo
  \fi
  {\let\xintifForLast\xint_firstoftwo
   \xintBreakForAndDo {\XINT_x \xint_gobble_i Z}}%
  \XINT_x
  \let\xintifForFirst\xint_secondoftwo\XINT_forthree_d #1{#2}%
}%
\long\def\xintForfour #1#2#3in#4#5#6%
{%
    \let\xintifForFirst\xint_firstoftwo
    \XINT_toks  {\XINT_forfour_d #2{#6}}%
    \expandafter\the\expandafter\XINT_toks #4jZ%
}%
\long\def\XINT_forfour_d #1#2#3(#4)#5%
{%
  \long\def\XINT_y ##1##2##3##4##5##6##7##8##9{#2}%
  \XINT_toks \expandafter{\romannumeral0\xintcsvtolist{ #4}}%
  \long\edef\XINT_x {\noexpand\XINT_y \csname XINT_for_left#1\endcsname
     \the\XINT_toks \csname XINT_for_right\the\numexpr#1+\xint_c_iii\endcsname}%
  \let\xintifForLast\xint_secondoftwo
  \ifx #5j\expandafter\xint_firstoftwo
     \else\expandafter\xint_secondoftwo
  \fi
  {\let\xintifForLast\xint_firstoftwo
   \xintBreakForAndDo {\XINT_x \xint_gobble_i Z}}%
  \XINT_x
  \let\xintifForFirst\xint_secondoftwo\XINT_forfour_d #1{#2}%
}%
\catcode`Z 11
\catcode`j 11
%    \end{macrocode}
% \subsection{\csh{xintAssign}, \csh{xintAssignArray}, \csh{xintDigitsOf}}
% \lverb|\xintAssign {a}{b}..{z}\to\A\B...\Z resp. \xintAssignArray
% {a}{b}..{z}\to\U. 
%
% \xintDigitsOf=\xintAssignArray.
%
% 1.1c 2015/09/12 has (belatedly) corrected some "features" of
% \xintAssign which didn't like the case of a space right before the "\to", or
% the case with the first token not an opening brace and the subsequent
% material containing brace groups. The new code handles gracefully these
% situations.|
%    \begin{macrocode}
\def\xintAssign{\def\XINT_flet_macro {\XINT_assign_fork}\XINT_flet_zapsp }%
\def\XINT_assign_fork
{%
    \let\XINT_assign_def\def
    \ifx\XINT_token[\expandafter\XINT_assign_opt
               \else\expandafter\XINT_assign_a
    \fi
}%
\def\XINT_assign_opt [#1]%
{%
    \ifcsname #1def\endcsname
      \expandafter\let\expandafter\XINT_assign_def \csname #1def\endcsname
    \else
      \expandafter\let\expandafter\XINT_assign_def \csname xint#1def\endcsname
    \fi
    \XINT_assign_a
}%
\long\def\XINT_assign_a #1\to
{%
    \def\XINT_flet_macro{\XINT_assign_b}%
    \expandafter\XINT_flet_zapsp\romannumeral`&&@#1\xint_relax\to
}%
\long\def\XINT_assign_b
{%
    \ifx\XINT_token\bgroup
         \expandafter\XINT_assign_c
    \else\expandafter\XINT_assign_f
    \fi
}%
\long\def\XINT_assign_f #1\xint_relax\to #2%
{%
    \XINT_assign_def #2{#1}%
}%
\long\def\XINT_assign_c #1%
{%
    \def\xint_temp {#1}%
    \ifx\xint_temp\xint_brelax
        \expandafter\XINT_assign_e
    \else
        \expandafter\XINT_assign_d
    \fi
}%
\long\def\XINT_assign_d #1\to #2%
{%
    \expandafter\XINT_assign_def\expandafter #2\expandafter{\xint_temp}%
    \XINT_assign_c #1\to 
}%
\def\XINT_assign_e #1\to {}%
\def\xintRelaxArray #1%
{%
    \edef\XINT_restoreescapechar {\escapechar\the\escapechar\relax}%
    \escapechar -1
    \expandafter\def\expandafter\xint_arrayname\expandafter {\string #1}%
    \XINT_restoreescapechar
    \xintiloop [\csname\xint_arrayname 0\endcsname+-1]
      \global
      \expandafter\let\csname\xint_arrayname\xintiloopindex\endcsname\relax
      \ifnum \xintiloopindex > \xint_c_
    \repeat
    \global\expandafter\let\csname\xint_arrayname 00\endcsname\relax
    \global\let #1\relax
}%
\def\xintAssignArray{\def\XINT_flet_macro {\XINT_assignarray_fork}%
                     \XINT_flet_zapsp }%
\def\XINT_assignarray_fork
{%
    \let\XINT_assignarray_def\def
    \ifx\XINT_token[\expandafter\XINT_assignarray_opt
               \else\expandafter\XINT_assignarray
    \fi
}%
\def\XINT_assignarray_opt [#1]%
{%
    \ifcsname #1def\endcsname
      \expandafter\let\expandafter\XINT_assignarray_def \csname #1def\endcsname
    \else
      \expandafter\let\expandafter\XINT_assignarray_def
                                  \csname xint#1def\endcsname
    \fi
    \XINT_assignarray
}%
\long\def\XINT_assignarray #1\to #2%
{%
    \edef\XINT_restoreescapechar {\escapechar\the\escapechar\relax }%
    \escapechar -1
    \expandafter\def\expandafter\xint_arrayname\expandafter {\string #2}%
    \XINT_restoreescapechar
    \def\xint_itemcount {0}%
    \expandafter\XINT_assignarray_loop \romannumeral`&&@#1\xint_relax
    \csname\xint_arrayname 00\expandafter\endcsname
    \csname\xint_arrayname 0\expandafter\endcsname
    \expandafter {\xint_arrayname}#2%
}%
\long\def\XINT_assignarray_loop #1%
{%
    \def\xint_temp {#1}%
    \ifx\xint_brelax\xint_temp
       \expandafter\def\csname\xint_arrayname 0\expandafter\endcsname
                   \expandafter{\the\numexpr\xint_itemcount}%
       \expandafter\expandafter\expandafter\XINT_assignarray_end
    \else
       \expandafter\def\expandafter\xint_itemcount\expandafter
                   {\the\numexpr\xint_itemcount+\xint_c_i}%
       \expandafter\XINT_assignarray_def
          \csname\xint_arrayname\xint_itemcount\expandafter\endcsname
             \expandafter{\xint_temp }%
       \expandafter\XINT_assignarray_loop
    \fi
}%
\def\XINT_assignarray_end #1#2#3#4%
{%
    \def #4##1%
    {%
        \romannumeral0\expandafter #1\expandafter{\the\numexpr ##1}%
    }%
    \def #1##1%
    {%
        \ifnum ##1<\xint_c_
            \xint_afterfi {\xintError:ArrayIndexIsNegative\space }%
        \else
        \xint_afterfi {%
              \ifnum ##1>#2
                  \xint_afterfi {\xintError:ArrayIndexBeyondLimit\space }%
              \else\xint_afterfi
       {\expandafter\expandafter\expandafter\space\csname #3##1\endcsname}%
              \fi}%
        \fi
     }%
}%
\let\xintDigitsOf\xintAssignArray
\let\XINT_tmpa\relax \let\XINT_tmpb\relax \let\XINT_tmpc\relax
\XINT_restorecatcodes_endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xinttools>\relax
%\def<*xintcore>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xinttools>
%<*xintcore>
%
% \StoreCodelineNo {xinttools}
%
% \section{Package \xintcorenameimp implementation}
% \label{sec:coreimp}
%
% \localtableofcontents
%
% Got split off from \xintnameimp with release |1.1|. Release |1.1| also added
% the new macro |\xintiiDivRound|. The package does not load
% \xinttoolsnameimp.
%
% \begin{framed}
%   The core arithmetic routines have been entirely rewritten for release
%   |1.2|.
%
%   The commenting continues (\xintdocdate) to be very sparse: actually it got
%   worse than ever with release |1.2|. I will possibly add comments at a
%   later date, but for the time being the new routines are not commented at
%   all.
% \end{framed}
%
% Also, with |1.2|, |\xintAdd| etc... have been left undefined control
% sequences: only |\xintiAdd| and |\xintiiAdd| (etc...) are provided via
% \xintcorenameimp. It was announced a long time ago that |\xintAdd| etc...
% were to be removed from \xintnameimp and only defined by \xintfracnameimp.
%
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
%
% The code for reload detection was initially copied from \textsc{Heiko
% Oberdiek}'s packages, then modified.
%
% The method for catcodes was also initially directly inspired by these
% packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xintcore.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xintkernel.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintcore}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintcore.sty
      \ifx\w\relax % but xintkernel.sty not yet loaded.
         \def\z{\endgroup\input xintkernel.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xintkernel.sty not yet loaded.
            \def\z{\endgroup\RequirePackage{xintkernel}}%
          \fi
      \else
        \aftergroup\endinput % xintkernel already loaded.
      \fi
    \fi
  \fi
\z%
\XINTsetupcatcodes% defined in xintkernel.sty
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\XINT_providespackage
\ProvidesPackage{xintcore}%
  [2015/11/18 v1.2d Expandable arithmetic on big integers (jfB)]%
%    \end{macrocode}
% \subsection{Counts for holding needed constants}
%    \begin{macrocode}
\ifdefined\m@ne\let\xint_c_mone\m@ne
          \else\csname newcount\endcsname\xint_c_mone \xint_c_mone -1 \fi
\newcount\xint_c_x^viii                  \xint_c_x^viii   100000000
\newcount\xint_c_x^ix                      \xint_c_x^ix  1000000000
\newcount\xint_c_x^viii_mone        \xint_c_x^viii_mone    99999999
\newcount\xint_c_xii_e_viii          \xint_c_xii_e_viii  1200000000
\newcount\xint_c_xi_e_viii_mone  \xint_c_xi_e_viii_mone  1099999999
\newcount\xint_c_xii_e_viii_mone\xint_c_xii_e_viii_mone  1199999999
%    \end{macrocode}
% \subsection{\csh{xintNum}}
% \lverb|&
% For example \xintNum {----+-+++---+----000000000000003}$\ 
% 1.05 defines \xintiNum, which allows redefinition of \xintNum by xintfrac.sty
% Slightly modified in 1.06b (\R->\xint_relax) to avoid initial re-scan of
% input stack (while still allowing empty #1). In versions earlier than 1.09a
% it was entirely up to the user to apply \xintnum; starting with 1.09a
% arithmetic
% macros of xint.sty (like earlier already xintfrac.sty with its own \xintnum)
% make use of \xintnum. This allows arguments to
% be count registers, or even \numexpr arbitrary long expressions (with the
% trick of braces, see the user documentation).
%
% Note (10/2015): I should take time to revisit this.|
%    \begin{macrocode}
\def\xintiNum {\romannumeral0\xintinum }%
\def\xintinum #1%
{%
    \expandafter\XINT_num_loop
    \romannumeral`&&@#1\xint_relax\xint_relax\xint_relax\xint_relax
                      \xint_relax\xint_relax\xint_relax\xint_relax\Z
}%
\let\xintNum\xintiNum \let\xintnum\xintinum
\def\XINT_num #1%
{%
    \XINT_num_loop #1\xint_relax\xint_relax\xint_relax\xint_relax
                     \xint_relax\xint_relax\xint_relax\xint_relax\Z
}%
\def\XINT_num_loop #1#2#3#4#5#6#7#8%
{%
    \xint_gob_til_xint_relax #8\XINT_num_end\xint_relax
    \XINT_num_NumEight #1#2#3#4#5#6#7#8%
}%
\edef\XINT_num_end\xint_relax\XINT_num_NumEight #1\xint_relax #2\Z
{%
    \noexpand\expandafter\space\noexpand\the\numexpr #1+\xint_c_\relax
}%
\def\XINT_num_NumEight #1#2#3#4#5#6#7#8%
{%
    \ifnum \numexpr #1#2#3#4#5#6#7#8+\xint_c_= \xint_c_
      \xint_afterfi {\expandafter\XINT_num_keepsign_a
                     \the\numexpr #1#2#3#4#5#6#7#81\relax}%
    \else
      \xint_afterfi {\expandafter\XINT_num_finish
                     \the\numexpr #1#2#3#4#5#6#7#8\relax}%
    \fi
}%
\def\XINT_num_keepsign_a #1%
{%
    \xint_gob_til_one#1\XINT_num_gobacktoloop 1\XINT_num_keepsign_b
}%
\def\XINT_num_gobacktoloop 1\XINT_num_keepsign_b {\XINT_num_loop }%
\def\XINT_num_keepsign_b #1{\XINT_num_loop -}%
\def\XINT_num_finish #1\xint_relax #2\Z { #1}%
%    \end{macrocode}
% \subsection{Zeroes}
% \lverb|Changed for 1.2 which has a base model of eight digits rather than
% four for the basic operations.|
%    \begin{macrocode}
\edef\XINT_cuz_small #1#2#3#4#5#6#7#8%
{%
    \noexpand\expandafter\space\noexpand\the\numexpr #1#2#3#4#5#6#7#8\relax
}%
%%%%%%%%%%%%
\def\XINT_cuz #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_R #9\XINT_cuz_e \R
    \xint_gob_til_eightzeroes #1#2#3#4#5#6#7#8\XINT_cuz_z 00000000%
    \XINT_cuz_clean #1#2#3#4#5#6#7#8#9%
}%
\edef\XINT_cuz_clean #1#2#3#4#5#6#7#8#9\R 
   {\noexpand\expandafter\space\noexpand\the\numexpr #1#2#3#4#5#6#7#8\relax #9}%
\edef\XINT_cuz_e\R #1\XINT_cuz_clean #2\R
   {\noexpand\expandafter\space\noexpand\the\numexpr #2\relax }%
\def\XINT_cuz_z 00000000\XINT_cuz_clean 00000000{\XINT_cuz }%
%%%%%%%%%%%%
\def\XINT_cuz_byviii #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_R #9\XINT_cuz_byviii_e \R
    \xint_gob_til_eightzeroes #1#2#3#4#5#6#7#8\XINT_cuz_byviii_z 00000000%
    \XINT_cuz_byviii_clean #1#2#3#4#5#6#7#8#9%
}%
\def\XINT_cuz_byviii_clean #1\R { #1}%
\def\XINT_cuz_byviii_e\R #1\XINT_cuz_byviii_clean #2\R{ #2}%
\def\XINT_cuz_byviii_z 00000000\XINT_cuz_byviii_clean 00000000{\XINT_cuz_byviii}%
%    \end{macrocode}
% \subsection{Blocks of eight digits}
% \lverb|Lingua of release 1.2.|
%    \begin{macrocode}
\def\XINT_zeroes_forviii #1#2#3#4#5#6#7#8%
{%
    \xint_gob_til_R #8\XINT_zeroes_forviii_end\R\XINT_zeroes_forviii
}%
\edef\XINT_zeroes_forviii_end\R\XINT_zeroes_forviii #1#2#3#4#5#6#7#8#9\W
{%
    \noexpand\expandafter\space\noexpand\xint_gob_til_one #2#3#4#5#6#7#8%
}%
%%%%%%%%%%%%
\def\XINT_rsepbyviii #1#2#3#4#5#6#7#8%
{%
    \XINT_rsepbyviii_b {#1#2#3#4#5#6#7#8}%
}%
\def\XINT_rsepbyviii_b #1#2#3#4#5#6#7#8#9%
{%
    #2#3#4#5#6#7#8#9\expandafter!\the\numexpr
    1#1\expandafter.\the\numexpr 1\XINT_rsepbyviii
}%
\def\XINT_rsepbyviii_end_B #1\relax #2#3{#2.}%
\def\XINT_rsepbyviii_end_A #11#2\expandafter #3\relax #4#5{#2.1#5.}%
%%%%%%%%%%%%
\def\XINT_sepandrev
{%
    \expandafter\XINT_sepandrev_a\the\numexpr 1\XINT_rsepbyviii
}%
\def\XINT_sepandrev_a {\XINT_sepandrev_b {}}%
\def\XINT_sepandrev_b #1#2.#3.#4.#5.#6.#7.#8.#9.%
{%
    \xint_gob_til_R #9\XINT_sepandrev_end\R
    \XINT_sepandrev_b {#9!#8!#7!#6!#5!#4!#3!#2!#1}%
}%
\def\XINT_sepandrev_end\R\XINT_sepandrev_b #1#2\W {\XINT_sepandrev_done #1}%
\def\XINT_sepandrev_done  #11#2!{ }%
%%%%%%%%%%%%
\def\XINT_sepandrev_andcount 
{%
    \expandafter\XINT_sepandrev_andcount_a\the\numexpr 1\XINT_rsepbyviii
}%
\def\XINT_sepandrev_andcount_a {\XINT_sepandrev_andcount_b 0.{}}%
\def\XINT_sepandrev_andcount_b #1.#2#3.#4.#5.#6.#7.#8.#9.%
{%
    \xint_gob_til_R #9\XINT_sepandrev_andcount_end\R
    \expandafter\XINT_sepandrev_andcount_b \the\numexpr #1+\xint_c_xiv.%
    {#9!#8!#7!#6!#5!#4!#3!#2}%
}%
\def\XINT_sepandrev_andcount_end\R
    \expandafter\XINT_sepandrev_andcount_b\the\numexpr #1+\xint_c_xiv.#2#3#4\W 
{\expandafter\XINT_sepandrev_andcount_done\the\numexpr \xint_c_ii*#3+#1.#2}%
\edef\XINT_sepandrev_andcount_done #1.#21#3!%
    {\noexpand\expandafter\space\noexpand\the\numexpr #1-#3.}%
%    \end{macrocode}
% \lverb|Needed ending pattern: 1\Z!1\R!1\R!1\R!1\R!1\R!1\R!1\R!1\R!\W. The
% \romannumeral in unrevbyviii_a is for special effects. I must document when
% needed and used.|
%    \begin{macrocode}
\def\XINT_unrevbyviii #11#2!1#3!1#4!1#5!1#6!1#7!1#8!1#9!%
{%
    \xint_gob_til_R #9\XINT_unrevbyviii_a\R
    \XINT_unrevbyviii {#9#8#7#6#5#4#3#2#1}%
}%
\edef\XINT_unrevbyviii_a\R\XINT_unrevbyviii #1#2\W
    {\noexpand\expandafter\space
     \noexpand\romannumeral`&&@\noexpand\xint_gob_til_Z #1}%
%    \end{macrocode}
% \lverb|Can work with ending pattern: 1\Z!1\R!1\R!1\R!1\R!1\R!1\R!\W but the
% longer one of unrevbyviii is ok here too. Used currently (1.2) only by
% addition, now (1.2c) with long ending pattern. Does the final clean up of
% leading zeroes contrarily to general \XINT_unrevbyviii.|
%    \begin{macrocode}
\def\XINT_smallunrevbyviii 1#1!1#2!1#3!1#4!1#5!1#6!1#7!1#8!#9\W%
{%
    \expandafter\XINT_cuz_small\xint_gob_til_Z #8#7#6#5#4#3#2#1%
}%
%    \end{macrocode}
% \subsection{Blocks of eight, for needs of v1.2 \csh{xintiiDivision}.}
%    \begin{macrocode}
\def\XINT_sepbyviii_andcount 
{%
    \expandafter\XINT_sepbyviii_andcount_a\the\numexpr\XINT_sepbyviii
}%
\def\XINT_sepbyviii #1#2#3#4#5#6#7#8%
{%
    1#1#2#3#4#5#6#7#8\expandafter!\the\numexpr\XINT_sepbyviii
}%
\def\XINT_sepbyviii_end #1\relax {\relax\XINT_sepbyviii_andcount_end!}%
\def\XINT_sepbyviii_andcount_a {\XINT_sepbyviii_andcount_b \xint_c_.}%
\def\XINT_sepbyviii_andcount_b #1.#2!#3!#4!#5!#6!#7!#8!#9!%
{%
    #2\expandafter!\the\numexpr#3\expandafter!\the\numexpr#4\expandafter
    !\the\numexpr#5\expandafter!\the\numexpr#6\expandafter!\the\numexpr
    #7\expandafter
    !\the\numexpr#8\expandafter!\the\numexpr#9\expandafter!\the\numexpr
    \expandafter\XINT_sepbyviii_andcount_b\the\numexpr #1+\xint_c_viii.%
}%
\def\XINT_sepbyviii_andcount_end #1\XINT_sepbyviii_andcount_b\the\numexpr 
    #2+\xint_c_viii.#3#4\W {\expandafter.\the\numexpr #2+#3.}%
%%%%%%%%%%%%
\def\XINT_rev_nounsep #1#2!#3!#4!#5!#6!#7!#8!#9!%
{%
    \xint_gob_til_R #9\XINT_rev_nounsep_end\R
    \XINT_rev_nounsep {#9!#8!#7!#6!#5!#4!#3!#2!#1}%
}%
\def\XINT_rev_nounsep_end\R\XINT_rev_nounsep #1#2\W {\XINT_rev_nounsep_done #1}%
\def\XINT_rev_nounsep_done  #11{ 1}%
%%%%%%%%%%%%
\def\XINT_sepbyviii_Z #1#2#3#4#5#6#7#8%
{%
    1#1#2#3#4#5#6#7#8\expandafter!\the\numexpr\XINT_sepbyviii_Z
}%
\def\XINT_sepbyviii_Z_end #1\relax {\relax\Z!}%
%%%%%%%%%%%%
\def\XINT_unsep_cuzsmall #11#2!1#3!1#4!1#5!1#6!1#7!1#8!1#9!%
{%
    \xint_gob_til_R #9\XINT_unsep_cuzsmall_end\R
    \XINT_unsep_cuzsmall {#1#2#3#4#5#6#7#8#9}%
}%
\def\XINT_unsep_cuzsmall_end\R
    \XINT_unsep_cuzsmall #1{\XINT_unsep_cuzsmall_done #1}%
\def\XINT_unsep_cuzsmall_done  #1\R #2\W{\XINT_cuz_small #1}%
\def\XINT_unsep_delim {1\R!1\R!1\R!1\R!1\R!1\R!1\R!1\R!\W}%
%%%%%%%%%%%%
\def\XINT_div_unsepQ #11#2!1#3!1#4!1#5!1#6!1#7!1#8!1#9!%
{%
    \xint_gob_til_R #9\XINT_div_unsepQ_end\R
    \XINT_div_unsepQ {#1#2#3#4#5#6#7#8#9}%
}%
\def\XINT_div_unsepQ_end\R\XINT_div_unsepQ #1{\XINT_div_unsepQ_x #1}%
\def\XINT_div_unsepQ_x #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_R #9\XINT_div_unsepQ_e \R
    \xint_gob_til_eightzeroes #1#2#3#4#5#6#7#8\XINT_div_unsepQ_y 00000000%
    \expandafter\XINT_div_unsepQ_done \the\numexpr #1#2#3#4#5#6#7#8.#9%
}%
\def\XINT_div_unsepQ_e\R\xint_gob_til_eightzeroes #1\XINT_div_unsepQ_y #2\W
    {\the\numexpr #1\relax \Z}%
\def\XINT_div_unsepQ_y #1.#2\R #3\W{\XINT_cuz_small #2\Z}%
\def\XINT_div_unsepQ_done #1.#2\R #3\W { #1#2\Z}%
%%%%%%%%%%%%
\def\XINT_div_unsepR #11#2!1#3!1#4!1#5!1#6!1#7!1#8!1#9!%
{%
    \xint_gob_til_R #9\XINT_div_unsepR_end\R
    \XINT_div_unsepR {#1#2#3#4#5#6#7#8#9}%
}%
\def\XINT_div_unsepR_end\R\XINT_div_unsepR #1{\XINT_div_unsepR_done #1}%
\def\XINT_div_unsepR_done  #1\R #2\W {\XINT_cuz #1\R}%
%    \end{macrocode}
% \subsection{\csh{xintReverseDigits}}
% \lverb|v1.2. Needed now by \xintLDg.|
%    \begin{macrocode}
\def\XINT_microrevsep #1#2#3#4#5#6#7#8%
{%
    1#8#7#6#5#4#3#2#1\expandafter!\the\numexpr\XINT_microrevsep
}%
\def\XINT_microrevsep_end #1\W #2\expandafter #3\Z{#2!}%
\def\xintReverseDigits {\romannumeral0\xintreversedigits }%
\def\xintreversedigits #1{\expandafter\XINT_reversedigits\romannumeral`&&@#1\Z}%
\def\XINT_reversedigits #1%
{%
    \xint_UDsignfork
      #1{\expandafter\xint_minus_thenstop\romannumeral0\XINT_reversedigits_a}%
       -{\XINT_reversedigits_a #1}%
    \krof
}%
\def\XINT_reversedigits_a #1\Z 
{%    
    \expandafter\XINT_revdigits_a\the\numexpr\expandafter\XINT_microrevsep
    \romannumeral`&&@#1{\XINT_microrevsep_end\W}\XINT_microrevsep_end
      \XINT_microrevsep_end\XINT_microrevsep_end
      \XINT_microrevsep_end\XINT_microrevsep_end
      \XINT_microrevsep_end\XINT_microrevsep_end\Z
    1\Z!1\R!1\R!1\R!1\R!1\R!1\R!1\R!1\R!\W  
}%
\def\XINT_revdigits_a {\XINT_revdigits_b {}}%
\def\XINT_revdigits_b #11#2!1#3!1#4!1#5!1#6!1#7!1#8!1#9!%
{%
    \xint_gob_til_R #9\XINT_revdigits_end\R
                      \XINT_revdigits_b {#9#8#7#6#5#4#3#2#1}%
}%
\edef\XINT_revdigits_end\R\XINT_revdigits_b #1#2\W 
   {\noexpand\expandafter\space\noexpand\xint_gob_til_Z #1}%
%    \end{macrocode}
% \subsection{\csh{xintSgn}, \csh{xintiiSgn}, \csh{XINT_Sgn}, \csh{XINT_cntSgn}}
% \lverb|&
% Changed in 1.05. Earlier code was unnecessarily strange. 1.09a with \xintnum
%
% 1.09i defines \XINT_Sgn and \XINT_cntSgn (was \XINT__Sgn in 1.09i) for reasons
% of internal optimizations.
%
% xintfrac.sty will overwrite \xintsgn with use of \xintraw rather than
% \xintnum, naturally.|
%    \begin{macrocode}
\def\xintiiSgn {\romannumeral0\xintiisgn }%
\def\xintiisgn #1%
{%
    \expandafter\XINT_sgn \romannumeral`&&@#1\Z%
}%
\def\xintSgn {\romannumeral0\xintsgn }%
\def\xintsgn #1%
{%
    \expandafter\XINT_sgn \romannumeral0\xintnum{#1}\Z%
}%
\def\XINT_sgn #1#2\Z
{%
    \xint_UDzerominusfork
      #1-{ 0}%
      0#1{ -1}%
       0-{ 1}%
    \krof
}%
\def\XINT_Sgn #1#2\Z
{%
    \xint_UDzerominusfork
      #1-{0}%
      0#1{-1}%
       0-{1}%
    \krof
}%
\def\XINT_cntSgn #1#2\Z
{%
    \xint_UDzerominusfork
      #1-\xint_c_
      0#1\xint_c_mone
       0-\xint_c_i
    \krof
}%
%    \end{macrocode}
% \subsection{\csh{xintiOpp}, \csh{xintiiOpp}}
%    \begin{macrocode}
\def\xintiiOpp {\romannumeral0\xintiiopp }%
\def\xintiiopp #1%
{%
    \expandafter\XINT_opp \romannumeral`&&@#1%
}%
\def\xintiOpp {\romannumeral0\xintiopp }%
\def\xintiopp #1%
{%
    \expandafter\XINT_opp \romannumeral0\xintnum{#1}%
}%
\def\XINT_Opp #1{\romannumeral0\XINT_opp #1}%
\def\XINT_opp #1%
{%
    \xint_UDzerominusfork
      #1-{ 0}%      zero
      0#1{ }%     negative
       0-{ -#1}%  positive
    \krof
}%
%    \end{macrocode}
% \subsection{\csh{xintiAbs}, \csh{xintiiAbs}}
% \lverb|Release 1.09a has now \xintiabs which does \xintnum and this is
% inherited by DecSplit, by Sqr, and macros of xintgcd.sty. Attention, car ces
% macros de toute faon doivent passer  la valeur absolue et donc en profite
% pour faire le \xintnum, mais pour optimisation sans overhead il vaut mieux
% utiliser \xintiiAbs ou autre point d'accs.|
%    \begin{macrocode}
\def\xintiiAbs {\romannumeral0\xintiiabs }%
\def\xintiiabs #1%
{%
    \expandafter\XINT_abs \romannumeral`&&@#1%
}%
\def\xintiAbs {\romannumeral0\xintiabs }%
\def\xintiabs #1%
{%
    \expandafter\XINT_abs \romannumeral0\xintnum{#1}%
}%
\def\XINT_Abs #1{\romannumeral0\XINT_abs #1}%
\def\XINT_abs #1%
{%
    \xint_UDsignfork
      #1{ }%
       -{ #1}%
    \krof
}%
%    \end{macrocode}
% \subsection{\csh{xintFDg}, \csh{xintiiFDg}}
% \lverb|&
% FIRST DIGIT. Code simplified in 1.05.
% And prepared for redefinition by xintfrac to parse through \xintNum. Version
% 1.09a inserts the \xintnum already here.|
%    \begin{macrocode}
\def\xintiiFDg {\romannumeral0\xintiifdg }%
\def\xintiifdg #1%
{%
    \expandafter\XINT_fdg \romannumeral`&&@#1\W\Z
}%
\def\xintFDg {\romannumeral0\xintfdg }%
\def\xintfdg #1%
{%
    \expandafter\XINT_fdg \romannumeral0\xintnum{#1}\W\Z
}%
\def\XINT_FDg #1{\romannumeral0\XINT_fdg #1\W\Z }%
\def\XINT_fdg #1#2#3\Z
{%
    \xint_UDzerominusfork
      #1-{ 0}%   zero
      0#1{ #2}%  negative
       0-{ #1}%  positive
    \krof
}%
%    \end{macrocode}
% \subsection{\csh{xintLDg}, \csh{xintiiLDg}}
% \lverb|&
% LAST DIGIT. Simplified in 1.05. And prepared for extension by xintfrac
%    to parse through \xintNum. Release 1.09a adds the \xintnum already here,
%    and this propagates to \xintOdd, etc... 1.09e The \xintiiLDg is for
%    defining \xintiiOdd which is used once (currently) elsewhere .
%
%    bug fix (1.1b): \xintiiLDg is needed by the division macros next, thus
%    it needs to be in the xintcore.sty.
%
% Rewritten for 1.2.|
%    \begin{macrocode}
\def\xintLDg {\romannumeral0\xintldg }%
\def\xintldg #1{\xintiildg {\xintNum{#1}}}%
\def\xintiiLDg {\romannumeral0\xintiildg }%
\def\xintiildg #1%
{%
    \expandafter\XINT_ldg_done\romannumeral0%
    \expandafter\XINT_revdigits_a\the\numexpr\expandafter\XINT_microrevsep
    \romannumeral0\expandafter\XINT_abs 
    \romannumeral`&&@#1{\XINT_microrevsep_end\W}\XINT_microrevsep_end
      \XINT_microrevsep_end\XINT_microrevsep_end
      \XINT_microrevsep_end\XINT_microrevsep_end
      \XINT_microrevsep_end\XINT_microrevsep_end\Z
    1\Z!1\R!1\R!1\R!1\R!1\R!1\R!1\R!1\R!\W  
    \Z
}%
\def\XINT_ldg_done #1#2\Z { #1}%
%    \end{macrocode}
% \subsection{\csh{xintDouble}}
% \lverb|v1.08. Rewritten for v1.2.|
%    \begin{macrocode}
\def\xintDouble {\romannumeral0\xintdouble }%
\def\xintdouble #1%
{%
     \expandafter\XINT_dbl\romannumeral`&&@#1\Z
}%
\def\XINT_dbl #1%
{%
    \xint_UDzerominusfork
      #1-\XINT_dbl_zero
      0#1\XINT_dbl_neg
       0-{\XINT_dbl_pos #1}%
    \krof
}%
\def\XINT_dbl_zero #1\Z { 0}%
\def\XINT_dbl_neg
   {\expandafter\xint_minus_thenstop\romannumeral0\XINT_dbl_pos }%
\def\XINT_dbl_pos #1\Z 
{%
    \expandafter\XINT_dbl_pos_aa
    \romannumeral0\expandafter\XINT_sepandrev
    \romannumeral0\XINT_zeroes_forviii #1\R\R\R\R\R\R\R\R{10}0000001\W
    #1\XINT_rsepbyviii_end_A 2345678%
      \XINT_rsepbyviii_end_B 2345678\relax XX%
    \R.\R.\R.\R.\R.\R.\R.\R.\W 1\Z!%
    1\R!1\R!1\R!1\R!1\R!1\R!1\R!1\R!\W
}%
\def\XINT_dbl_pos_aa
{%
    \expandafter\XINT_mul_out\the\numexpr\XINT_verysmallmul 0.2!%
}%
%    \end{macrocode}
% \subsection{\csh{xintHalf}}
% \lverb|v1.08. Rewritten for v1.2.|
%    \begin{macrocode}
\def\xintHalf {\romannumeral0\xinthalf }%
\def\xinthalf #1%
{%
     \expandafter\XINT_half\romannumeral`&&@#1\Z
}%
\def\XINT_half #1%
{%
    \xint_UDzerominusfork
      #1-\XINT_half_zero
      0#1\XINT_half_neg
       0-{\XINT_half_pos #1}%
    \krof
}%
\def\XINT_half_zero #1\Z { 0}%
\def\XINT_half_neg {\expandafter\XINT_opp\romannumeral0\XINT_half_pos }%
\def\XINT_half_pos #1\Z
{%
    \expandafter\XINT_half_pos_a
    \romannumeral0\expandafter\XINT_sepandrev
    \romannumeral0\XINT_zeroes_forviii #1\R\R\R\R\R\R\R\R{10}0000001\W
    #1\XINT_rsepbyviii_end_A 2345678%
      \XINT_rsepbyviii_end_B 2345678\relax XX%
    \R.\R.\R.\R.\R.\R.\R.\R.\W 
    1\Z!%
    1\R!1\R!1\R!1\R!1\R!1\R!1\R!1\R!\W
}%
\def\XINT_half_pos_a 
   {\expandafter\XINT_half_pos_b\the\numexpr\XINT_verysmallmul 0.5!}%
\def\XINT_half_pos_b 1#1#2#3#4#5#6#7#8!1#9%
{%
    \xint_gob_til_Z #9\XINT_half_small \Z
    \XINT_mul_out 1#1#2#3#4#5#6#7!1#9%
}%
\edef\XINT_half_small \Z\XINT_mul_out 1#1!#2\W
{%
    \noexpand\expandafter\space\noexpand\the\numexpr #1\relax
}%
%    \end{macrocode}
% \subsection{\csh{xintDec}}
% \lverb|v1.08. Rewritten for v1.2.|
%    \begin{macrocode}
\def\xintDec {\romannumeral0\xintdec }%
\def\xintdec #1%
{%
     \expandafter\XINT_dec\romannumeral`&&@#1\Z 
}%
\def\XINT_dec #1%
{%
    \xint_UDzerominusfork
      #1-\XINT_dec_zero
      0#1\XINT_dec_neg
       0-{\XINT_dec_pos #1}%
    \krof
}%
\def\XINT_dec_zero #1\Z { -1}%
\def\XINT_dec_neg
   {\expandafter\xint_minus_thenstop\romannumeral0\XINT_inc_pos }%
\def\XINT_dec_pos #1\Z 
{%
    \expandafter\XINT_dec_pos_aa
    \romannumeral0\expandafter\XINT_sepandrev
    \romannumeral0\XINT_zeroes_forviii #1\R\R\R\R\R\R\R\R{10}0000001\W
    #1\XINT_rsepbyviii_end_A 2345678%
      \XINT_rsepbyviii_end_B 2345678\relax XX%
    \R.\R.\R.\R.\R.\R.\R.\R.\W
    \Z!\Z!\Z!\Z!\W
}%
\def\XINT_dec_pos_aa {\XINT_sub_aa 100000001!\Z!\Z!\Z!\Z!\W }%
%    \end{macrocode}
% \subsection{\csh{xintInc}}
% \lverb!v1.08. Rewritten for v1.2.!
%    \begin{macrocode}
\def\xintInc {\romannumeral0\xintinc }%
\def\xintinc #1%
{%
     \expandafter\XINT_inc\romannumeral`&&@#1\Z
}%
\def\XINT_inc #1%
{%
    \xint_UDzerominusfork
      #1-\XINT_inc_zero
      0#1\XINT_inc_neg
       0-{\XINT_inc_pos #1}%
    \krof
}%
\def\XINT_inc_zero #1\Z { 1}%
\def\XINT_inc_neg {\expandafter\XINT_opp\romannumeral0\XINT_dec_pos }%
%    \end{macrocode}
% \lverb|1.2d interface to addition has changed.|
%    \begin{macrocode}
\def\XINT_inc_pos #1\Z
{%
    \expandafter\XINT_inc_pos_aa
    \romannumeral0\expandafter\XINT_sepandrev
    \romannumeral0\XINT_zeroes_forviii #1\R\R\R\R\R\R\R\R{10}0000001\W
    #1\XINT_rsepbyviii_end_A 2345678%
      \XINT_rsepbyviii_end_B 2345678\relax XX%
    \R.\R.\R.\R.\R.\R.\R.\R.\W
    1\Z!1\Z!1\Z!1\Z!1\Z!\W
    1\R!1\R!1\R!1\R!1\R!1\R!1\R!1\R!\W
}%
\def\XINT_inc_pos_aa {\XINT_add_aa 100000001!1\Z!1\Z!1\Z!1\Z!\W }%
%    \end{macrocode}
% \subsection{Core arithmetic}
% \lverb|The four operations have been rewritten entirely for release v1.2.
% The new routines works with separated blocks of eight digits. They all measure
% first the lengths of the arguments, even addition and subtraction (this was
% not the case with xintcore.sty 1.1 or earlier.)
%
% The technique of chaining \the\numexpr induces a limitation on the
% maximal size depending on the size of the input save stack and the maximum
% expansion depth. For the current (TL2015) settings (5000, resp. 10000), the
% induced limit for addition of numbers is at 19968 and for multiplication
% it is observed to be 19959 (valid as of 2015/10/07).
%
% Side remark: I tested that \the\numexpr was more efficient than \number. But
% it reduced the allowable numbers for addition from 19976 digits to 19968
% digits.|
% 
% \subsection{\csbh{xintiAdd}, \csbh{xintiiAdd}}
%    \begin{macrocode}
\def\xintiAdd    {\romannumeral0\xintiadd }%
\def\xintiadd  #1{\expandafter\XINT_iadd\romannumeral0\xintnum{#1}\Z }%
\def\xintiiAdd   {\romannumeral0\xintiiadd }%
\def\xintiiadd #1{\expandafter\XINT_iiadd\romannumeral`&&@#1\Z  }%
\def\XINT_iiadd #1#2\Z #3%
{%
    \expandafter\XINT_add_nfork\expandafter #1\romannumeral`&&@#3\Z #2\Z
}%
\def\XINT_iadd #1#2\Z #3%
{%
    \expandafter\XINT_add_nfork\expandafter #1\romannumeral0\xintnum{#3}\Z #2\Z
}%
\def\XINT_add_fork #1#2\Z #3\Z {\XINT_add_nfork #1#3\Z #2\Z}%
\def\XINT_add_nfork #1#2%
{%
    \xint_UDzerofork
      #1\XINT_add_firstiszero
      #2\XINT_add_secondiszero
       0{}%
    \krof
    \xint_UDsignsfork
          #1#2\XINT_add_minusminus
           #1-\XINT_add_minusplus
           #2-\XINT_add_plusminus
            --\XINT_add_plusplus
    \krof #1#2%
}%
\def\XINT_add_firstiszero  #1\krof 0#2#3\Z #4\Z { #2#3}%
\def\XINT_add_secondiszero #1\krof #20#3\Z #4\Z { #2#4}%
\def\XINT_add_minusminus   #1#2%
   {\expandafter\xint_minus_thenstop\romannumeral0\XINT_add_pp_a {}{}}%
\def\XINT_add_minusplus    #1#2{\XINT_sub_mm_a {}#2}%
\def\XINT_add_plusminus    #1#2%
   {\expandafter\XINT_opp\romannumeral0\XINT_sub_mm_a #1{}}%
\def\XINT_add_pp_a #1#2#3\Z
{%
  \expandafter\XINT_add_pp_b
      \romannumeral0\expandafter\XINT_sepandrev_andcount
      \romannumeral0\XINT_zeroes_forviii #2#3\R\R\R\R\R\R\R\R{10}0000001\W
      #2#3\XINT_rsepbyviii_end_A 2345678%
        \XINT_rsepbyviii_end_B 2345678\relax\xint_c_ii\xint_c_iii
        \R.\xint_c_vi\R.\xint_c_v\R.\xint_c_iv\R.\xint_c_iii
        \R.\xint_c_ii\R.\xint_c_i\R.\xint_c_\W
   \X #1%
}%
\let\XINT_add_plusplus \XINT_add_pp_a
%    \end{macrocode}
% \lverb|I have been annoyed since the preparation of 1.2 release that
% addition sometimes had the (pre-reverse) output with a final 1! (now 1\Z!)
% sometimes not. It didn' matter for addition itself if it executes the final
% reverse as the 1! was then be swallowed. But if one wants to call addition
% repeatedly or from another routine such as \XINT_mul_loop, keeping reverse
% format, this is annoying. Finally for 1.2c I decide (2015/11/14) to impose
% always the ending 1! (or rather 1\Z!, which thus does not need to be put in
% the pattern for _unrevbyviii). I take this opportunity to move the ending
% pattern needed by \XINT_add_out to \XINT_add_pp_b, thus replacing a final
% fetch of the complete output to clean up the \Z's and \W at the end of the
% input. This was also needed to make \XINT_mul_loop callable directly
% independently of whether the first argument is only one 10^8 digit long.
%
% Impacted callers: \XINT_mul_loop (and through it square and pow) and
% \XINT_inc_pos_ the latter must insert the pattern previously found in
% \XINT_add_out as it calls \XINT_add_aa directly.
%
% I also modify addition to use 1\Z!1\Z!1\Z!1\Z!\W as input delimiter (earlier
% version had \Z!\Z!\Z!\Z!\Z!\W but four are enough and we now have 1's). The
% rationale is that multiplication and now addition always set the output
% (before reversal) to be followed by 1\Z!, thus it makes sense for 1\Z! to
% also serve as (part of) delimiting inputs. Earlier, addition had \Z! for
% input, but this can not be put on output by a \numexpr, hence it used 1! on
% output, but this is not a good delimiter as the 1! may and will arise in
% number part, thus one had to use !1! or 1!\W etc... to use it. With 1\Z !
% things are more unified and facilitate doing repeated additions and
% multiplications maintaining things reversed.|
%    \begin{macrocode}
\def\XINT_add_pp_b #1.#2\X #3\Z
{%
    \expandafter\XINT_add_checklengths
    \the\numexpr #1\expandafter.%
    \romannumeral0\expandafter\XINT_sepandrev_andcount
    \romannumeral0\XINT_zeroes_forviii #3\R\R\R\R\R\R\R\R{10}0000001\W
    #3\XINT_rsepbyviii_end_A 2345678%
      \XINT_rsepbyviii_end_B 2345678\relax\xint_c_ii\xint_c_iii
        \R.\xint_c_vi\R.\xint_c_v\R.\xint_c_iv\R.\xint_c_iii
        \R.\xint_c_ii\R.\xint_c_i\R.\xint_c_\W
     1\Z!1\Z!1\Z!1\Z!\W #21\Z!1\Z!1\Z!1\Z!\W
     1\R!1\R!1\R!1\R!1\R!1\R!1\R!1\R!\W 
}%
%    \end{macrocode}
% \lverb|I keep #1.#2. to check if at most 6 + 6 base 10^8 digits which can be
% treated faster for final reverse. But is this overhead at all useful ? |
%    \begin{macrocode}
\def\XINT_add_checklengths #1.#2.%
{%
    \ifnum #2>#1 
       \expandafter\XINT_add_exchange
    \else
       \expandafter\XINT_add_A
    \fi
    #1.#2.%
}%
\def\XINT_add_exchange #1.#2.#3\W #4\W
{%
    \XINT_add_A #2.#1.#4\W #3\W
}%
\def\XINT_add_A #1.#2.%
{%
    \ifnum #1>\xint_c_vi
          \expandafter\XINT_add_aa
    \else \expandafter\XINT_add_aa_small
    \fi
}%
\def\XINT_add_aa {\expandafter\XINT_add_out\the\numexpr\XINT_add_a \xint_c_ii}%
\def\XINT_add_out{\expandafter\XINT_cuz_small\romannumeral0\XINT_unrevbyviii {}}%
\def\XINT_add_aa_small 
    {\expandafter\XINT_smallunrevbyviii\the\numexpr\XINT_add_a \xint_c_ii}%
%    \end{macrocode}
% \lverb|2 as first token of #1 stands for "no carry", 3 will mean a carry (we are adding
% 1<8digits> to 1<8digits>.) Version 1.2c has terminators of the shape 1\Z!,
% replacing the \Z! used in 1.2.|
%    \begin{macrocode}
\def\XINT_add_a #1!#2!#3!#4!#5\W #6!#7!#8!#9!%
{%
    \XINT_add_b #1!#6!#2!#7!#3!#8!#4!#9!#5\W
}%
\def\XINT_add_b #11#2#3!#4!%
{%
    \xint_gob_til_Z #2\XINT_add_bi \Z
    \expandafter\XINT_add_c\the\numexpr#1+1#2#3+#4-\xint_c_ii.%
}%
\def\XINT_add_bi\Z\expandafter\XINT_add_c
    \the\numexpr#1+#2+#3-\xint_c_ii.#4!#5!#6!#7!#8!#9!\W
{%
    \XINT_add_k #1#3!#5!#7!#9!%
}%
\def\XINT_add_c #1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_add_d #1%
}%
\def\XINT_add_d #11#2#3!#4!%
{%
    \xint_gob_til_Z #2\XINT_add_di \Z
    \expandafter\XINT_add_e\the\numexpr#1+1#2#3+#4-\xint_c_ii.%
}%
\def\XINT_add_di\Z\expandafter\XINT_add_e
    \the\numexpr#1+#2+#3-\xint_c_ii.#4!#5!#6!#7!#8\W
{%
    \XINT_add_k #1#3!#5!#7!%
}%
\def\XINT_add_e #1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_add_f #1%
}%
\def\XINT_add_f #11#2#3!#4!%
{%
    \xint_gob_til_Z #2\XINT_add_fi \Z
    \expandafter\XINT_add_g\the\numexpr#1+1#2#3+#4-\xint_c_ii.%
}%
\def\XINT_add_fi\Z\expandafter\XINT_add_g
    \the\numexpr#1+#2+#3-\xint_c_ii.#4!#5!#6\W
{%
    \XINT_add_k #1#3!#5!%
}%
\def\XINT_add_g #1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_add_h #1%
}%
\def\XINT_add_h #11#2#3!#4!%
{%
    \xint_gob_til_Z #2\XINT_add_hi \Z
    \expandafter\XINT_add_i\the\numexpr#1+1#2#3+#4-\xint_c_ii.%
}%
\def\XINT_add_hi\Z
    \expandafter\XINT_add_i\the\numexpr#1+#2+#3-\xint_c_ii.#4\W
{%
    \XINT_add_k #1#3!%
}%
\def\XINT_add_i #1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_add_a #1%
}%
%    \end{macrocode}
% \lverb|These ending routines modified in 1.2c in order to clean up here (and
% not via \XINT_add_out) the tokens up to the final \W, and to always have a
% final 1\Z! (1.2 version had a final 1! not 1\Z!, and only under certain
% circumstances): when the two operands have the same length and the addition
% creates no carry or more generally when we had a carry propagating to the
% last block but the final addition created no carry, we end up in
% \XINT_add_ke with an empty #1 and a \numexpr to stop. This is why we put
% 1\Z! (1.2 had 1!, but 1\Z! is also used by multiplication on output)
% in that case, and now with 1.2c for all other cases as well.|
%    \begin{macrocode}
\def\XINT_add_k #1{\if #12\expandafter\XINT_add_ke\else\expandafter\XINT_add_l \fi}%
\def\XINT_add_ke #11\Z #2\W {\XINT_add_kf #11\Z!}%
\def\XINT_add_kf 1{1\relax }%
\def\XINT_add_l 1#1#2{\xint_gob_til_Z #1\XINT_add_lf \Z \XINT_add_m 1#1#2}%
\def\XINT_add_lf #1\W {1\relax 00000001!1\Z!}%
\def\XINT_add_m #1!{\expandafter\XINT_add_n\the\numexpr\xint_c_i+#1.}%
\def\XINT_add_n #1#2.{1#2\expandafter!\the\numexpr\XINT_add_o #1}%
%    \end{macrocode}
% \lverb|Here 2 stands for "carry", and 1 for "no carry" (we have been adding
% 1 to 1<8digits>.)|
%    \begin{macrocode}
\def\XINT_add_o #1{\if #12\expandafter\XINT_add_l\else\expandafter\XINT_add_ke \fi}%
%    \end{macrocode}
% \subsection{\csh{xintiSub}, \csh{xintiiSub}}
% \lverb|Entirely rewritten for v1.2.|
%    \begin{macrocode}
\def\xintiiSub   {\romannumeral0\xintiisub }%
\def\xintiisub #1{\expandafter\XINT_iisub\romannumeral`&&@#1\Z  }%
\def\XINT_iisub #1#2\Z #3%
{%
    \expandafter\XINT_sub_nfork\expandafter #1\romannumeral`&&@#3\Z #2\Z
}%
\def\xintiSub    {\romannumeral0\xintisub }%
\def\xintisub #1{\expandafter\XINT_isub\romannumeral0\xintnum{#1}\Z }%
\def\XINT_isub #1#2\Z #3%
{%
   \expandafter\XINT_sub_nfork\expandafter #1\romannumeral0\xintnum{#3}\Z #2\Z
}%
\def\XINT_sub_nfork #1#2%
{%
    \xint_UDzerofork
      #1\XINT_sub_firstiszero
      #2\XINT_sub_secondiszero
       0{}%
    \krof
    \xint_UDsignsfork
          #1#2\XINT_sub_minusminus
           #1-\XINT_sub_minusplus
           #2-\XINT_sub_plusminus
            --\XINT_sub_plusplus
    \krof #1#2%
}%
\def\XINT_sub_firstiszero  #1\krof 0#2#3\Z #4\Z {\XINT_opp #2#3}%
\def\XINT_sub_secondiszero #1\krof #20#3\Z #4\Z { #2#4}%
\def\XINT_sub_plusminus    #1#2{\XINT_add_pp_a #1{}}%
\def\XINT_sub_plusplus   #1#2%
   {\expandafter\XINT_opp\romannumeral0\XINT_sub_mm_a #1#2}%
\def\XINT_sub_minusplus    #1#2%
   {\expandafter\xint_minus_thenstop\romannumeral0\XINT_add_pp_a {}#2}%
\def\XINT_sub_minusminus #1#2{\XINT_sub_mm_a {}{}}%
\def\XINT_sub_mm_a  #1#2#3\Z 
{%
  \expandafter\XINT_sub_mm_b
      \romannumeral0\expandafter\XINT_sepandrev_andcount
      \romannumeral0\XINT_zeroes_forviii #2#3\R\R\R\R\R\R\R\R{10}0000001\W
      #2#3\XINT_rsepbyviii_end_A 2345678%
        \XINT_rsepbyviii_end_B 2345678\relax\xint_c_ii\xint_c_iii
      \R.\xint_c_vi\R.\xint_c_v\R.\xint_c_iv\R.\xint_c_iii
      \R.\xint_c_ii\R.\xint_c_i\R.\xint_c_\W
  \X #1%
}%
\def\XINT_sub_mm_b #1.#2\X #3\Z
{%
    \expandafter\XINT_sub_checklengths
    \the\numexpr #1\expandafter.%
    \romannumeral0\expandafter\XINT_sepandrev_andcount
    \romannumeral0\XINT_zeroes_forviii #3\R\R\R\R\R\R\R\R{10}0000001\W
    #3\XINT_rsepbyviii_end_A 2345678%
      \XINT_rsepbyviii_end_B 2345678\relax \xint_c_ii\xint_c_iii
      \R.\xint_c_vi\R.\xint_c_v\R.\xint_c_iv\R.\xint_c_iii
      \R.\xint_c_ii\R.\xint_c_i\R.\xint_c_\W
    \Z!\Z!\Z!\Z!\W #2\Z!\Z!\Z!\Z!\W
}%
\def\XINT_sub_checklengths #1.#2.% 
{%
    \ifnum #2>#1
       \expandafter\XINT_sub_exchange
    \else
       \expandafter\XINT_sub_aa
    \fi
}%
\def\XINT_sub_exchange #1\W #2\W
{%
    \expandafter\XINT_opp\romannumeral0\XINT_sub_aa #2\W #1\W
}%
\def\XINT_sub_aa {\expandafter\XINT_sub_out\the\numexpr\XINT_sub_a \xint_c_i }%
\def\XINT_sub_out #1\Z #2#3\W
{%
    \if-#2\expandafter\XINT_sub_startrescue\fi
    \expandafter\XINT_cuz_small
    \romannumeral0\XINT_unrevbyviii {}#11\Z!1\R!1\R!1\R!1\R!1\R!1\R!1\R!1\R!\W
}%
%    \end{macrocode}
% \lverb|The routine starting with \XINT_sub_a requires the first argument to
% be at most as long as second argument.|
%    \begin{macrocode}
\def\XINT_sub_a #1!#2!#3!#4!#5\W #6!#7!#8!#9!%
{%
    \XINT_sub_b #1!#6!#2!#7!#3!#8!#4!#9!#5\W
}%
\def\XINT_sub_b #1#2#3!#4!%
{%
    \xint_gob_til_Z #2\XINT_sub_bi \Z
    \expandafter\XINT_sub_c\the\numexpr#1+1#4-#3-\xint_c_i.%
}%
\def\XINT_sub_c 1#1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_sub_d #1%
}%
\def\XINT_sub_d #1#2#3!#4!%
{%
    \xint_gob_til_Z #2\XINT_sub_di \Z
    \expandafter\XINT_sub_e\the\numexpr#1+1#4-#3-\xint_c_i.%
}%
\def\XINT_sub_e 1#1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_sub_f #1%
}%
\def\XINT_sub_f #1#2#3!#4!%
{%
    \xint_gob_til_Z #2\XINT_sub_fi \Z
    \expandafter\XINT_sub_g\the\numexpr#1+1#4-#3-\xint_c_i.%
}%
\def\XINT_sub_g 1#1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_sub_h #1%
}%
\def\XINT_sub_h #1#2#3!#4!%
{%
    \xint_gob_til_Z #2\XINT_sub_hi \Z
    \expandafter\XINT_sub_i\the\numexpr#1+1#4-#3-\xint_c_i.%
}%
\def\XINT_sub_i 1#1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_sub_a #1%
}%
\def\XINT_sub_bi\Z
    \expandafter\XINT_sub_c\the\numexpr#1+1#2-#3.#4!#5!#6!#7!#8!#9!\W
{%
    \XINT_sub_k #1#2!#5!#7!#9!%
}%
\def\XINT_sub_di\Z
    \expandafter\XINT_sub_e\the\numexpr#1+1#2-#3.#4!#5!#6!#7!#8\W
{%
    \XINT_sub_k #1#2!#5!#7!%
}%
\def\XINT_sub_fi\Z
    \expandafter\XINT_sub_g\the\numexpr#1+1#2-#3.#4!#5!#6\W
{%
    \XINT_sub_k #1#2!#5!%
}%
\def\XINT_sub_hi\Z
    \expandafter\XINT_sub_i\the\numexpr#1+1#2-#3.#4\W
{%
    \XINT_sub_k #1#2!%
}%
%    \end{macrocode}
% \lverb|First input terminated. Have we reached the end of second
% (necessarily at least as long) input? If not, then we are certain that even
% if there is carry it will not propagate beyond the end of second input. But
% it may propagate along chains of 00000000. And if its goes to the final
% block which is just 1<00000001>!, we will have at least those eight zeros to
% clean up. But not more than those eight followed by the leading zeroes of
% next to last block (which will be leading block of final output). On the
% other hand if we have also reached the end of the second input, then if
% first input was smaller there might be arbitrarily many zeroes to clean up,
% if it was larger, we will have to rescue the whole thing.|
%    \begin{macrocode}
\def\XINT_sub_k #1#2%
{%
    \xint_gob_til_Z #2\XINT_sub_p\Z \XINT_sub_l #1#2%
}%
%    \end{macrocode}
% \lverb|Here second input was longer. The carry if there is one will be
% extinguished before the end. 1.2c wants subtraction to output before final
% reversal the blocks with the same 1\Z! terminator as addition and
% multiplication. CANCELED FOR THE TIME BEING.
%
% 2015/11/15. I discover with shame that Release 1.2 of 10/10 had a bad bad
% bad bad bug in case of long stretches of zeroes, for example with
% \xintiiSub {10000000112345678}{12345679} which returned 99999999 .... sorry.
%
% I was rewriting inner entry to subtraction to look a bit more for
% input/output as addition and multiplication but I will now rather quickly
% leave everything standing and issue a bugfix release asap.|
%    \begin{macrocode}
\def\XINT_sub_l #1{\xint_UDzerofork #1\XINT_sub_l_carry 0\XINT_sub_l_nocarry\krof}%
\def\XINT_sub_l_nocarry 1{1\relax }%
\def\XINT_sub_l_carry #1!{\expandafter\XINT_sub_m\the\numexpr 1#1-\xint_c_i!}%
\def\XINT_sub_m 1#1{\xint_UDzerofork #1\XINT_sub_n_carry 0\XINT_sub_n_nocarry\krof}%
\def\XINT_sub_n_carry #1!{1#1\expandafter!\the\numexpr\XINT_sub_l_carry }%
\def\XINT_sub_n_nocarry #1!#2#3!%
{%
    \xint_gob_til_Z #2\xint_gob_til_eightzeroes #1\XINT_sub_n_zero
    00000000\xint_gob_til_Z\Z 1\relax #1!#2#3!%
}%
\def\XINT_sub_n_zero 00000000\xint_gob_til_Z\Z 1\relax 00000000!{1!}%
%    \end{macrocode}
% \lverb|Here we are in the situation were the two inputs had the same length
% in base 10^8. If #1=0 we bitterly discover that first input was greater than
% second input despite having same length (in base 10^8). The \numexpr will
% expand beyond the -1 or 1. If #1=1 we had no carry but perhaps the result
% will have plenty of zeroes to clean-up. The result might even be simply zero.|
%    \begin{macrocode}
\def\XINT_sub_p\Z\XINT_sub_l #1#2\W
{%
    \xint_UDzerofork
       #1{-1\relax\Z -\W}%
        0{1\relax \XINT_cuz_byviii!\Z 0\W\R }%
    \krof
}%
\def\XINT_sub_startrescue\expandafter\XINT_cuz_small
    \romannumeral0\XINT_unrevbyviii #1#2\Z!#3\W
{%
    \expandafter\XINT_sub_rescue_finish
    \the\numexpr\XINT_sub_rescue_a #2!%
    1\Z!1\R!1\R!1\R!1\R!1\R!1\R!1\R!1\R!\W \R
}%
\def\XINT_sub_rescue_finish 
   {\expandafter-\romannumeral0\expandafter\XINT_cuz\romannumeral0\XINT_unrevbyviii {}}%
\def\XINT_sub_rescue_a #1!%
{%
    \expandafter\XINT_sub_rescue_c\the\numexpr \xint_c_xii_e_viii-#1.%
}%
\def\XINT_sub_rescue_c 1#1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_sub_rescue_d #1%
}%
\def\XINT_sub_rescue_d #1#2#3!%
{%
    \xint_gob_til_minus #2\XINT_sub_rescue_z -%
    \expandafter\XINT_sub_rescue_c\the\numexpr \xint_c_xii_e_viii_mone-#2#3+#1.%
}%
\def\XINT_sub_rescue_z #1.{1!}%
%    \end{macrocode}
% \subsection{\csh{xintiMul}, \csh{xintiiMul}}
% \lverb|Completely rewritten for v1.2.|
%    \begin{macrocode}
\def\xintiMul {\romannumeral0\xintimul }%
\def\xintimul #1%
{%
    \expandafter\XINT_imul\romannumeral0\xintnum{#1}\Z
}%
\def\XINT_imul #1#2\Z #3%
{%
    \expandafter\XINT_mul_nfork\expandafter #1\romannumeral0\xintnum{#3}\Z #2\Z
}%
\def\xintiiMul {\romannumeral0\xintiimul }%
\def\xintiimul #1%
{%
    \expandafter\XINT_iimul\romannumeral`&&@#1\Z
}%
\def\XINT_iimul #1#2\Z #3%
{%
    \expandafter\XINT_mul_nfork\expandafter #1\romannumeral`&&@#3\Z #2\Z
}%
%    \end{macrocode}
% \lverb|I have changed the fork, and it complicates matters elsewhere.|
%    \begin{macrocode}
\def\XINT_mul_fork #1#2\Z #3\Z{\XINT_mul_nfork #1#3\Z #2\Z}%
\def\XINT_mul_nfork #1#2%
{%
    \xint_UDzerofork
      #1\XINT_mul_zero
      #2\XINT_mul_zero
       0{}%
    \krof
    \xint_UDsignsfork
          #1#2\XINT_mul_minusminus
           #1-\XINT_mul_minusplus
           #2-\XINT_mul_plusminus
            --\XINT_mul_plusplus
    \krof #1#2%
}%
\def\XINT_mul_zero  #1\krof #2#3\Z #4\Z { 0}%
\def\XINT_mul_minusminus   #1#2{\XINT_mul_plusplus {}{}}%
\def\XINT_mul_minusplus    #1#2%
   {\expandafter\xint_minus_thenstop\romannumeral0\XINT_mul_plusplus {}#2}%
\def\XINT_mul_plusminus    #1#2%
   {\expandafter\xint_minus_thenstop\romannumeral0\XINT_mul_plusplus #1{}}%
\def\XINT_mul_plusplus #1#2#3\Z
{%
  \expandafter\XINT_mul_pre_b
      \romannumeral0\expandafter\XINT_sepandrev_andcount
      \romannumeral0\XINT_zeroes_forviii #2#3\R\R\R\R\R\R\R\R{10}0000001\W
      #2#3\XINT_rsepbyviii_end_A 2345678%
        \XINT_rsepbyviii_end_B 2345678\relax\xint_c_ii\xint_c_iii
        \R.\xint_c_vi\R.\xint_c_v\R.\xint_c_iv\R.\xint_c_iii
        \R.\xint_c_ii\R.\xint_c_i\R.\xint_c_\W
  \W #1%
}%
\def\XINT_mul_pre_b #1.#2\W #3\Z
{%
    \expandafter\XINT_mul_checklengths
    \the\numexpr #1\expandafter.%
    \romannumeral0\expandafter\XINT_sepandrev_andcount
    \romannumeral0\XINT_zeroes_forviii #3\R\R\R\R\R\R\R\R{10}0000001\W
    #3\XINT_rsepbyviii_end_A 2345678%
      \XINT_rsepbyviii_end_B 2345678\relax\xint_c_ii\xint_c_iii
        \R.\xint_c_vi\R.\xint_c_v\R.\xint_c_iv\R.\xint_c_iii
        \R.\xint_c_ii\R.\xint_c_i\R.\xint_c_\W
     1\Z!\W #21\Z!%
    1\R!1\R!1\R!1\R!1\R!1\R!1\R!1\R!\W
}%
%    \end{macrocode}
% \lverb|Cooking recipe, 2015/10/05.|
%    \begin{macrocode}
\def\XINT_mul_checklengths #1.#2.%
{%
    \ifnum #2=\xint_c_i\expandafter\XINT_mul_smallbyfirst\fi
    \ifnum #1=\xint_c_i\expandafter\XINT_mul_smallbysecond\fi
    \ifnum #2<#1
       \ifnum \numexpr (#2-\xint_c_i)*(#1-#2)<383
          \XINT_mul_exchange
       \fi
    \else
       \ifnum \numexpr (#1-\xint_c_i)*(#2-#1)>383
          \XINT_mul_exchange
       \fi
    \fi
    \XINT_mul_start
}%
\def\XINT_mul_smallbyfirst #1\XINT_mul_start 1#2!1\Z!\W
{%
    \ifnum#2=\xint_c_i\expandafter\XINT_mul_oneisone\fi
    \ifnum#2<\xint_c_xxii\expandafter\XINT_mul_verysmall\fi 
    \expandafter\XINT_mul_out\the\numexpr\XINT_smallmul 1#2!%
}%
\def\XINT_mul_smallbysecond #1\XINT_mul_start #2\W 1#3!1\Z!% 
{%
    \ifnum#3=\xint_c_i\expandafter\XINT_mul_oneisone\fi
    \ifnum#3<\xint_c_xxii\expandafter\XINT_mul_verysmall\fi 
    \expandafter\XINT_mul_out\the\numexpr\XINT_smallmul 1#3!#2%
}%
\def\XINT_mul_oneisone #1!{\XINT_mul_out }%
\def\XINT_mul_verysmall\expandafter\XINT_mul_out
                       \the\numexpr\XINT_smallmul 1#1!%
    {\expandafter\XINT_mul_out\the\numexpr\XINT_verysmallmul 0.#1!}%
\def\XINT_mul_exchange #1\XINT_mul_start #2\W #31\Z!%
   {\fi\fi\XINT_mul_start #31\Z!\W #2}% 
%    \end{macrocode}
% \lverb|1.2c: earlier version of addition had sometimes a final 1!, but not
% in all cases. Version 1.2c of \XINT_add_a always has an ending 1\Z!, which
% is thus expected by \XINT_mul_loop.|
%    \begin{macrocode}
\def\XINT_mul_start
   {\expandafter\XINT_mul_out\the\numexpr\XINT_mul_loop 100000000!1\Z!\W}%
\def\XINT_mul_out 
   {\expandafter\XINT_cuz_small\romannumeral0\XINT_unrevbyviii {}}%
%    \end{macrocode}
% \lverb|The 1.2 \XINT_mul_loop could *not* be called directly with a small
% multiplicand, due to problems caused in case the addition done in
% \XINT_mul_a produced only 1 block the second one being either empty or a 1!
% which had to be handled by \XINT_mul_loop and \XINT_mul_e. But
% \XINT_mul_loop was only called via \xintiiMul for arguments with at least 2
% digits in base 10^8, thus no problem. But this made it annoying for
% \xintiiPow and \xintiiSqr which had to check if the intended multiplier had
% only 1 digit in base 10^8. It also made it annoying to create recursive
% algorithms which did multiplications maintaining the result reverses, for
% iterative use of output as input.
%
% Finally on 2015/11/14 during 1.2c preparation I modified the addition to
% *always* have the ending 1\Z!.\numexpr expands even through spaces to find
% operators and even something like 1<space>\Z will try to expand the \Z. Thus
% we have to not forget that #2 in \XINT_mul_e might be \Z! (a #2=1\Z! in
% \XINT_mul_a hence \XINT_add_a is no problem). Again this can only happen if
% we use \XINT_mul_loop directly with a small first argument (in place of
% smallmul). Anyway, now the routine \XINT_mul_loop can handle a small #2,
% with no black magic with delimiters and checking if #1 empty, although it
% never happens when called via \xintiiMul.
%
% The delimiting patterns for addition was changed to use 1\Z! to fit what is
% used on output (by necessity).|
%    \begin{macrocode}
\def\XINT_mul_loop #1\W #2\W 1#3!%
{%
    \xint_gob_til_Z #3\XINT_mul_e \Z
    \expandafter\XINT_mul_a\the\numexpr \XINT_smallmul 1#3!#2\W 
    #1\W #2\W
}%
%    \end{macrocode}
% \lverb|Each of #1 and #2 brings its 1\Z! for \XINT_add_a.|
%    \begin{macrocode}
\def\XINT_mul_a #1\W #2\W
{%
    \expandafter\XINT_mul_b\the\numexpr
    \XINT_add_a \xint_c_ii #21\Z!1\Z!1\Z!\W #11\Z!1\Z!1\Z!\W\W
}%
\def\XINT_mul_b 1#1!{1#1\expandafter!\the\numexpr\XINT_mul_loop }%
\def\XINT_mul_e\Z #1\W 1#2\W #3\W {1\relax #2}%
%    \end{macrocode}
% \lverb|1.2 small and mini multiplication in base 10^8 with carry. Used by
% the main multiplication routines. But division, float factorial, etc.. have
% their own variants as they need output with specific constraints.|
%    \begin{macrocode}
\def\XINT_minimulwc_a 1#1.#2.#3!#4#5#6#7#8.%
{%
    \expandafter\XINT_minimulwc_b
    \the\numexpr \xint_c_x^ix+#1+#3*#8.#3*#4#5#6#7+#2*#8.#2*#4#5#6#7.%
}%
\def\XINT_minimulwc_b 1#1#2#3#4#5#6.#7.%
{%
    \expandafter\XINT_minimulwc_c 
    \the\numexpr \xint_c_x^ix+#1#2#3#4#5+#7.#6.%
}%
\def\XINT_minimulwc_c 1#1#2#3#4#5#6.#7.#8.%
{%
    1#6#7\expandafter!%
    \the\numexpr\expandafter\XINT_smallmul_a
    \the\numexpr \xint_c_x^viii+#1#2#3#4#5+#8.%
}%
\def\XINT_smallmul 1#1#2#3#4#5!{\XINT_smallmul_a 100000000.#1#2#3#4.#5!}%
\def\XINT_smallmul_a #1.#2.#3!1#4!%
{%
    \xint_gob_til_Z #4\XINT_smallmul_e\Z
    \XINT_minimulwc_a #1.#2.#3!#4.#2.#3!%
}%
\def\XINT_smallmul_e\Z\XINT_minimulwc_a 1#1.#2\Z #3!%
    {\xint_gob_til_eightzeroes #1\XINT_smallmul_f 000000001\relax #1!1\Z!}%
\def\XINT_smallmul_f 000000001\relax 00000000!1{1\relax}%
%    \end{macrocode}
% \lverb|This is multiplication by 1 up to 21. Last time I checked it is never
% called with a wasteful multiplicand of 1.|
%    \begin{macrocode}
\def\XINT_verysmallmul #1.#2!1#3!%
{%
    \xint_gob_til_Z #3\XINT_verysmallmul_e\Z
    \expandafter\XINT_verysmallmul_a
    \the\numexpr #2*#3+#1.#2!%
}%
\def\XINT_verysmallmul_e\Z\expandafter\XINT_verysmallmul_a\the\numexpr
    #1+#2#3.#4!%
{\xint_gob_til_zero #2\XINT_verysmallmul_f 0\xint_c_x^viii+#2#3!1\Z!}%
\def\XINT_verysmallmul_f #1!1{1\relax}%
\def\XINT_verysmallmul_a #1#2.%
{%
    \unless\ifnum #1#2<\xint_c_x^ix
    \expandafter\XINT_verysmallmul_bi\else
    \expandafter\XINT_verysmallmul_bj\fi
    \the\numexpr \xint_c_x^ix+#1#2.%
}%
\def\XINT_verysmallmul_bj{\expandafter\XINT_verysmallmul_cj }%
\def\XINT_verysmallmul_cj 1#1#2.%
    {1#2\expandafter!\the\numexpr\XINT_verysmallmul #1.}%
\def\XINT_verysmallmul_bi\the\numexpr\xint_c_x^ix+#1#2#3.%
    {1#3\expandafter!\the\numexpr\XINT_verysmallmul #1#2.}%
%    \end{macrocode}
% \lverb|Used by division and by squaring, not by multiplication itself.
% Attention, returns least significant 1<8digits> first.|
%    \begin{macrocode}
\def\XINT_minimul_a #1.#2!#3#4#5#6#7!%
{%
    \expandafter\XINT_minimul_b
    \the\numexpr \xint_c_x^viii+#2*#7.#2*#3#4#5#6+#1*#7.#1*#3#4#5#6.%
}%
\def\XINT_minimul_b 1#1#2#3#4#5.#6.%
{%
    \expandafter\XINT_minimul_c 
    \the\numexpr \xint_c_x^ix+#1#2#3#4+#6.#5.%
}%
\def\XINT_minimul_c 1#1#2#3#4#5#6.#7.#8.%
{%
    1#6#7\expandafter!\the\numexpr \xint_c_x^viii+#1#2#3#4#5+#8!%
}%
%    \end{macrocode}
% \subsection{\csh{xintiSqr}, \csh{xintiiSqr}}
% \lverb|Rewritten for v1.2.|
%    \begin{macrocode}
\def\xintiiSqr {\romannumeral0\xintiisqr }%
\def\xintiisqr #1%
{%
    \expandafter\XINT_sqr\romannumeral0\xintiiabs{#1}\Z
}%
\def\xintiSqr {\romannumeral0\xintisqr }%
\def\xintisqr #1%
{%
    \expandafter\XINT_sqr\romannumeral0\xintiabs{#1}\Z
}%
\def\XINT_sqr #1\Z
{%
    \expandafter\XINT_sqr_a
      \romannumeral0\expandafter\XINT_sepandrev_andcount
      \romannumeral0\XINT_zeroes_forviii #1\R\R\R\R\R\R\R\R{10}0000001\W
      #1\XINT_rsepbyviii_end_A 2345678%
        \XINT_rsepbyviii_end_B 2345678\relax\xint_c_ii\xint_c_iii
        \R.\xint_c_vi\R.\xint_c_v\R.\xint_c_iv\R.\xint_c_iii
        \R.\xint_c_ii\R.\xint_c_i\R.\xint_c_\W
      \Z
}%
%    \end{macrocode}
% \lverb|1.2c \XINT_mul_loop can be called directly even with small arguments,
% thus the following is not anymore a necessity. The 1!\R in \XINT_sqr_start
% is to obey the new calling pattern of \XINT_mul_loop.|
%    \begin{macrocode}
\def\XINT_sqr_a #1.%
{% 
    \ifnum #1=\xint_c_i \expandafter\XINT_sqr_small
                   \else\expandafter\XINT_sqr_start\fi
}%
\def\XINT_sqr_small 1#1#2#3#4#5!\Z 
{%
    \ifnum #1#2#3#4#5<46341 \expandafter\XINT_sqr_verysmall\fi
    \expandafter\XINT_sqr_small_out
    \the\numexpr\XINT_minimul_a #1#2#3#4.#5!#1#2#3#4#5!%
}%
\edef\XINT_sqr_verysmall
    \expandafter\XINT_sqr_small_out\the\numexpr\XINT_minimul_a #1!#2!%
    {\noexpand\expandafter\space\noexpand\the\numexpr #2*#2\relax}%
\def\XINT_sqr_small_out 1#1!1#2!%
{%
    \XINT_cuz #2#1\R
}%
\def\XINT_sqr_start #1\Z
{%
    \expandafter\XINT_mul_out
    \the\numexpr\XINT_mul_loop 100000000!1\Z!\W #11\Z!\W #11\Z!%
    1\R!1\R!1\R!1\R!1\R!1\R!1\R!1\R!\W
}%
%    \end{macrocode}
% \subsection{\csh{xintiPow}, \csh{xintiiPow}}
% \lverb|&
% The exponent is not limited but with current default settings of tex memory,
% with xint 1.2, the maximal exponent for 2^N is N = 2^17 = 131072.|
%    \begin{macrocode}
\def\xintiiPow {\romannumeral0\xintiipow }%
\def\xintiipow #1%
{%
    \expandafter\xint_pow\romannumeral`&&@#1\Z%
}%
\def\xintiPow {\romannumeral0\xintipow }%
\def\xintipow #1%
{%
    \expandafter\xint_pow\romannumeral0\xintnum{#1}\Z%
}%
\def\xint_pow #1#2\Z
{%
    \xint_UDsignfork
      #1\XINT_pow_Aneg
       -\XINT_pow_Anonneg
    \krof
       #1{#2}%
}%
\def\XINT_pow_Aneg #1#2#3%
{%
   \expandafter\XINT_pow_Aneg_\expandafter{\the\numexpr #3}#2\Z
}%
\def\XINT_pow_Aneg_ #1%
{%
   \ifodd #1
       \expandafter\XINT_pow_Aneg_Bodd
   \fi
   \XINT_pow_Anonneg_ {#1}%
}%
\def\XINT_pow_Aneg_Bodd #1%
{%
    \expandafter\XINT_opp\romannumeral0\XINT_pow_Anonneg_
}%
%    \end{macrocode}
% \lverb|B = #3, faire le xpxp. Modified with 1.06: use of \numexpr.|
%    \begin{macrocode}
\def\XINT_pow_Anonneg #1#2#3%
{%
   \expandafter\XINT_pow_Anonneg_\expandafter {\the\numexpr #3}#1#2\Z
}%
%    \end{macrocode}
% \lverb+#1 = B, #2 = |A|. Modifi pour v1.1, car utilisait \XINT_Cmp, ce qui
% d'ailleurs n'tait sans doute pas super efficace, et m'obligeait  mettre
% \xintCmp dans xintcore. Donc ici A est dj #2#3 et il y a un \Z aprs.+
%    \begin{macrocode}
\def\XINT_pow_Anonneg_ #1#2#3\Z
{%
    \if\relax #3\relax\xint_dothis
                      {\ifcase #2 \expandafter\XINT_pow_AisZero
                               \or\expandafter\XINT_pow_AisOne
                             \else\expandafter\XINT_pow_AatleastTwo
                       \fi }\fi
    \xint_orthat \XINT_pow_AatleastTwo {#1}{#2#3}%
}%
\def\XINT_pow_AisOne #1#2{ 1}%
%    \end{macrocode}
% \lverb|#1 = B|
%    \begin{macrocode}
\def\XINT_pow_AisZero #1#2%
{%
     \ifcase\XINT_cntSgn #1\Z
         \xint_afterfi { 1}%
     \or
         \xint_afterfi { 0}%
     \else
         \xint_afterfi {\xintError:DivisionByZero\space 0}%
     \fi
}%
\def\XINT_pow_AatleastTwo #1%
{%
    \ifcase\XINT_cntSgn #1\Z
        \expandafter\XINT_pow_BisZero
    \or
        \expandafter\XINT_pow_I_in
    \else
        \expandafter\XINT_pow_BisNegative
    \fi
    {#1}%
}%
\edef\XINT_pow_BisNegative #1#2%
    {\noexpand\xintError:FractionRoundedToZero\space 0}%
\def\XINT_pow_BisZero #1#2{ 1}%
%    \end{macrocode}
% \lverb|B = #1 > 0, A = #2 > 1. Earlier code checked if size of B did not
% exceed a given limit (for example 131000).|
%    \begin{macrocode}
\def\XINT_pow_I_in #1#2%
{%
    \expandafter\XINT_pow_I_loop
    \the\numexpr #1\expandafter.%
    \romannumeral0\expandafter\XINT_sepandrev
    \romannumeral0\XINT_zeroes_forviii #2\R\R\R\R\R\R\R\R{10}0000001\W
    #2\XINT_rsepbyviii_end_A 2345678%
      \XINT_rsepbyviii_end_B 2345678\relax XX%
    \R.\R.\R.\R.\R.\R.\R.\R.\W  1\Z!\W
    1\R!1\R!1\R!1\R!1\R!1\R!1\R!1\R!\W
}%
\def\XINT_pow_I_loop #1.%
{%
    \ifnum #1 = \xint_c_i\expandafter\XINT_pow_I_exit\fi
    \ifodd #1
       \expandafter\XINT_pow_II_in
    \else
       \expandafter\XINT_pow_I_squareit
    \fi #1.%
}%
\def\XINT_pow_I_exit \ifodd #1\fi #2.#3\W {\XINT_mul_out #3}%
%    \end{macrocode}
% \lverb|The 1.2c \XINT_mul_loop can be called directly even with small
% arguments, hence the "butcheckifsmall" is not a necessity as it was earlier
% with 1.2. On 2^30, it does bring roughly a 40$char37 $space time gain
% though, and 30$char37 $space gain for 2^60. The overhead on big computations
% should be negligible.|
%    \begin{macrocode}
\def\XINT_pow_I_squareit #1.#2\W%
{%
    \expandafter\XINT_pow_I_loop
    \the\numexpr #1/\xint_c_ii\expandafter.%
    \the\numexpr\XINT_pow_mulbutcheckifsmall #2\W #2\W
}%
\def\XINT_pow_mulbutcheckifsmall #1!1#2%
{%
    \xint_gob_til_Z #2\XINT_pow_mul_small\Z
    \XINT_mul_loop 100000000!1\Z!\W #1!1#2%
}%
\def\XINT_pow_mul_small\Z \XINT_mul_loop 100000000!1\Z!\W 1#1!1\Z!\W
{%
    \XINT_smallmul 1#1!%
}%
\def\XINT_pow_II_in #1.#2\W 
{%
    \expandafter\XINT_pow_II_loop 
    \the\numexpr #1/\xint_c_ii-\xint_c_i\expandafter.%
    \the\numexpr\XINT_pow_mulbutcheckifsmall #2\W #2\W #2\W
}%
\def\XINT_pow_II_loop #1.%
{%
    \ifnum #1 = \xint_c_i\expandafter\XINT_pow_II_exit\fi
    \ifodd #1
       \expandafter\XINT_pow_II_odda
    \else
       \expandafter\XINT_pow_II_even
    \fi #1.%
}%
\def\XINT_pow_II_exit\ifodd #1\fi #2.#3\W #4\W 
{%
    \expandafter\XINT_mul_out 
    \the\numexpr\XINT_pow_mulbutcheckifsmall #4\W #3%
}%
\def\XINT_pow_II_even #1.#2\W
{%
    \expandafter\XINT_pow_II_loop
    \the\numexpr #1/\xint_c_ii\expandafter.%
    \the\numexpr\XINT_pow_mulbutcheckifsmall #2\W #2\W
}%
\def\XINT_pow_II_odda #1.#2\W #3\W
{%
    \expandafter\XINT_pow_II_oddb
    \the\numexpr #1/\xint_c_ii-\xint_c_i\expandafter.%
    \the\numexpr\XINT_pow_mulbutcheckifsmall #3\W #2\W #2\W
}%
\def\XINT_pow_II_oddb #1.#2\W #3\W 
{%
    \expandafter\XINT_pow_II_loop
    \the\numexpr #1\expandafter.%
    \the\numexpr\XINT_pow_mulbutcheckifsmall #3\W #3\W #2\W
}%
%    \end{macrocode}
% \subsection{\csh{xintiFac}, \csh{xintiiFac}}
% \lverb|Moved to xintcore.sty with release 1.2 (to be usable by \bnumexpr).
%
% The routine has been partially rewritten with release 1.2 to exploit the new
% inner structure of multiplication. I impose an intrinsic limit of the
% argument at maximal value 9999. Anyhow with current default settings of the
% etex memory and the current 1.2 routine (last commit: eada1b1), the maximal
% possible computation is 5971! (which has 19956 digits). Also, I add
% \xintiiFac which does only \romannumeral-`0 and not \numexpr on its
% argument. This is for a silly slight optimization of the \xintiiexpr (and
% \bnumexpr) parsers. If the argument is >=2^31 an arithmetic overflow will
% occur in the \ifnum. This is not as good as in the \numexpr, but well.
%
% 2015/11/14 added note on the implementation: we can roughly estimate for big
% n that we do n/2 "small" multiplications of numbers of size k log(k) with k
% along a step 2 arithmetic sequence up to n. Each small multiplication should
% have a linear cost O(k log(k)) (as we maintain the reversed representation)
% hence a total cost of O(n^2 log(n)); and this seems to be confirmed
% experimentally, or rather on computing n! for n=100, 200, ..., 2000 I
% obtained a good fit (only roughly 20$char37 $space variation) of the
% computation time with the square of the length of n! -- to the extent the
% big variability of \pdfelapsedtime allows to draw any conclusion -- I did
% not repeat the computations at least 100 times as I should have. With an
% approach based on binary splitting n!=AB and A=[n/2]! each of A and B will
% be of size n/2 log(n), but xint schoolbook multiplication in TeX is worse
% than quadratic due to penalty when TeX needs to fetch arguments and it
% didn't seem promising. I didn't even test. Binary splitting is good when a
% fast multiplication is available.
%
% No wait! incredibly a very naive five lines of code implementation of binary
% splitting approach with recursive uses of \xintiiMul is only about 1.6x--2x
% slower in the range N=200 to 2000 ! this seems to say that the reversing
% done by \xintiiMul both on input and for output is quite efficient. The best
% case seems to be around N=1000, hence multiplication of 500 digits numbers,
% after that the impact of over-quadratic computation time seems to show: for
% N=4000, the naive binary splitting approach is about 3.4x slower than the
% naive iterated small multiplications as here (naturally with sub-quadratic
% multiplication that would be otherwise).|
%    \begin{macrocode}
\def\xintiFac {\romannumeral0\xintifac }%
\def\xintifac #1%
{%
    \expandafter\XINT_fac_fork\expandafter {\the\numexpr#1}%
}%
\def\xintiiFac {\romannumeral0\xintiifac }%
\def\xintiifac #1%
{%
    \expandafter\XINT_fac_fork\expandafter {\romannumeral`&&@#1}%
}%
\let\xintFac\xintiFac \let\xintfac\xintifac
\def\XINT_fac_fork #1%
{%
    \ifcase\XINT_cntSgn #1\Z
       \xint_afterfi{\expandafter\space\expandafter 1\xint_gobble_i }%
    \or
       \expandafter\XINT_fac_checksize
    \else
       \xint_afterfi{\expandafter\xintError:FactorialOfNegativeNumber
                \expandafter\space\expandafter 1\xint_gobble_i }%
    \fi
    {#1}%
}%
\def\XINT_fac_checksize #1%
{%
    \ifnum #1>9999
         \xint_dothis{\expandafter\xintError:FactorialOfTooBigNumber
                      \expandafter\space\expandafter 1\xint_gob_til_W }\fi
    \ifnum #1>465 \xint_dothis{\XINT_fac_bigloop_a   #1.}\fi
    \ifnum #1>101 \xint_dothis{\XINT_fac_medloop_a   #1.\XINT_mul_out}\fi
                  \xint_orthat{\XINT_fac_smallloop_a #1.\XINT_mul_out}%
    1\R!1\R!1\R!1\R!1\R!1\R!1\R!1\R!\W
}%
\def\XINT_fac_bigloop_a #1.%
{%
    \expandafter\XINT_fac_bigloop_b \the\numexpr 
    #1+\xint_c_i-\xint_c_ii*((#1-464)/\xint_c_ii).#1.%
}%
\def\XINT_fac_bigloop_b #1.#2.%
{%
    \expandafter\XINT_fac_medloop_a
        \the\numexpr #1-\xint_c_i.{\XINT_fac_bigloop_loop #1.#2.}%
}%
\def\XINT_fac_bigloop_loop #1.#2.%
{%
    \ifnum #1>#2 \expandafter\XINT_fac_bigloop_exit\fi
    \expandafter\XINT_fac_bigloop_loop
    \the\numexpr #1+\xint_c_ii\expandafter.%
    \the\numexpr #2\expandafter.\the\numexpr\XINT_fac_bigloop_mul #1!%
}%
\def\XINT_fac_bigloop_exit #1!{\XINT_mul_out}%
\def\XINT_fac_bigloop_mul #1!%
{%
    \expandafter\XINT_smallmul
        \the\numexpr \xint_c_x^viii+#1*(#1+\xint_c_i)!%
}%
\def\XINT_fac_medloop_a #1.%
{%
    \expandafter\XINT_fac_medloop_b
        \the\numexpr #1+\xint_c_i-\xint_c_iii*((#1-100)/\xint_c_iii).#1.%
}%
\def\XINT_fac_medloop_b #1.#2.%
{%
    \expandafter\XINT_fac_smallloop_a
        \the\numexpr #1-\xint_c_i.{\XINT_fac_medloop_loop #1.#2.}%
}%
\def\XINT_fac_medloop_loop #1.#2.%
{%
    \ifnum #1>#2 \expandafter\XINT_fac_loop_exit\fi
    \expandafter\XINT_fac_medloop_loop
    \the\numexpr #1+\xint_c_iii\expandafter.%
    \the\numexpr #2\expandafter.\the\numexpr\XINT_fac_medloop_mul #1!%
}%
\def\XINT_fac_medloop_mul #1!%
{%
    \expandafter\XINT_smallmul
    \the\numexpr 
        \xint_c_x^viii+#1*(#1+\xint_c_i)*(#1+\xint_c_ii)!%
}%
\def\XINT_fac_smallloop_a #1.%
{%
    \csname 
       XINT_fac_smallloop_\the\numexpr #1-\xint_c_iv*(#1/\xint_c_iv)\relax
    \endcsname #1.%
}%
\expandafter\def\csname XINT_fac_smallloop_1\endcsname #1.%
{%
    \XINT_fac_smallloop_loop 2.#1.100000001!1\Z!%
}%
\expandafter\def\csname XINT_fac_smallloop_-2\endcsname #1.%
{%
    \XINT_fac_smallloop_loop 3.#1.100000002!1\Z!%
}%
\expandafter\def\csname XINT_fac_smallloop_-1\endcsname #1.%
{%
    \XINT_fac_smallloop_loop 4.#1.100000006!1\Z!%
}%
\expandafter\def\csname XINT_fac_smallloop_0\endcsname #1.%
{%
    \XINT_fac_smallloop_loop 5.#1.1000000024!1\Z!%
}%
\def\XINT_fac_smallloop_loop #1.#2.%
{%
    \ifnum #1>#2 \expandafter\XINT_fac_loop_exit\fi
    \expandafter\XINT_fac_smallloop_loop
    \the\numexpr #1+\xint_c_iv\expandafter.%
    \the\numexpr #2\expandafter.\the\numexpr\XINT_fac_smallloop_mul #1!%
}%
\def\XINT_fac_smallloop_mul #1!%
{%
    \expandafter\XINT_smallmul
    \the\numexpr 
        \xint_c_x^viii+#1*(#1+\xint_c_i)*(#1+\xint_c_ii)*(#1+\xint_c_iii)!%
}%
\def\XINT_fac_loop_exit #1!#2\Z!#3{#3#2\Z!}%
%    \end{macrocode}
% \subsection{\csh{xintiDivision}, \csh{xintiQuo}, \csh{xintiRem},
% \csh{xintiiDivision}, \csh{xintiiQuo}, \csh{xintiiRem}}
% \lverb|Completely rewritten for v1.2.
%
% WARNING: some comments below try to describe the flow of tokens but they
% date back to xint 1.09j and I updated them on the fly while doing the 1.2
% version. As the routine now works in base 10^8, not 10^4 and "drops" the
% quotient digits,rather than store them upfront as the earlier code, I may
% well have not correctly converted all such comments. At the last minute some
% previously #1 became stuff like #1#2#3#4, then of course the old comments
% describing what the macro parameters stand for are necessarily wrong.
%
% Side remark: the way tokens are grouped was not essentially modified in
% v1.2, although the situation has changed. It was fine-tuned in xint
% v1.0/v1.1 but the context has changed, and perhaps I should revisit this.
% As a corollary to the fact that quotient digits are now left behind thanks
% to the chains of \numexpr, some  macros which in v1.0/v1.1 fetched up to 9
% parameters now need handle less such parameters. Thus, some rationale for
% the way the code was structured has disappeared.
%
% v1.2 2015/10/15 had a bad bug which got corrected in v1.2b of 2015/10/29: a
% divisor starting with 99999999xyz... would cause a failure, simply because
% it was attempted to use the \XINT_div_mini routine with a divisor of
% 1+99999999=100000000 having 9 digits. Fortunately the origin of the bug was
% easy to find out. Too bad that my obviously very deficient test files
% did not detect it.|
%    \begin{macrocode}
\def\xintiiQuo {\romannumeral0\xintiiquo }%
\def\xintiiRem {\romannumeral0\xintiirem }%
\def\xintiiquo {\expandafter\xint_firstoftwo_thenstop\romannumeral0\xintiidivision }%
\def\xintiirem {\expandafter\xint_secondoftwo_thenstop\romannumeral0\xintiidivision }%
\def\xintiQuo {\romannumeral0\xintiquo }%
\def\xintiRem {\romannumeral0\xintirem }%
\def\xintiquo {\expandafter\xint_firstoftwo_thenstop\romannumeral0\xintidivision }%
\def\xintirem {\expandafter\xint_secondoftwo_thenstop\romannumeral0\xintidivision }%
\let\xintQuo\xintiQuo\let\xintquo\xintiquo % deprecated
\let\xintRem\xintiRem\let\xintrem\xintirem % deprecated
%    \end{macrocode}
% \lverb-#1 = A, #2 = B. On calcule le quotient et le reste dans la division
% euclidienne de A par B: A=BQ+R, 0<= R < |B|.-
%    \begin{macrocode}
\def\xintiDivision {\romannumeral0\xintidivision }%
\def\xintidivision #1{\expandafter\XINT_idivision\romannumeral0\xintnum{#1}\Z }%
\def\XINT_idivision #1#2\Z #3{\expandafter\XINT_iidivision_a\expandafter #1%
                             \romannumeral0\xintnum{#3}\Z #2\Z }%
\def\xintiiDivision   {\romannumeral0\xintiidivision }%
\def\xintiidivision  #1{\expandafter\XINT_iidivision \romannumeral`&&@#1\Z }%
\def\XINT_iidivision #1#2\Z #3{\expandafter\XINT_iidivision_a\expandafter #1%
                             \romannumeral`&&@#3\Z #2\Z }%
\def\XINT_iidivision_a #1#2% #1 de A, #2 de B.
{%
    \if0#2\xint_dothis\XINT_iidivision_divbyzero\fi
    \if0#1\xint_dothis\XINT_iidivision_aiszero\fi
    \if-#2\xint_dothis{\expandafter\XINT_iidivision_bneg
                       \romannumeral0\XINT_iidivision_bpos #1}\fi
    \xint_orthat{\XINT_iidivision_bpos #1#2}%
}%
\def\XINT_iidivision_divbyzero #1\Z #2\Z {\xintError:DivisionByZero{0}{0}}%
\def\XINT_iidivision_aiszero #1\Z #2\Z {{0}{0}}%
\def\XINT_iidivision_bneg #1% q->-q, r unchanged
                          {\expandafter{\romannumeral0\XINT_opp #1}}%
\def\XINT_iidivision_bpos #1%
{%
    \xint_UDsignfork
            #1\XINT_iidivision_aneg
             -{\XINT_iidivision_apos #1}%
    \krof
}%
\def\XINT_iidivision_apos #1#2\Z #3\Z{\XINT_div_prepare {#2}{#1#3}}%
\def\XINT_iidivision_aneg #1\Z #2\Z
   {\expandafter
    \XINT_iidivision_aneg_b\romannumeral0\XINT_div_prepare {#1}{#2}{#1}}%
\def\XINT_iidivision_aneg_b #1#2{\if0\XINT_Sgn #2\Z
                              \expandafter\XINT_iidivision_aneg_rzero
                           \else
                              \expandafter\XINT_iidivision_aneg_rpos
                           \fi {#1}{#2}}%
\def\XINT_iidivision_aneg_rzero #1#2#3{{-#1}{0}}% necessarily q was >0
\def\XINT_iidivision_aneg_rpos #1%
{%
    \expandafter\XINT_iidivision_aneg_end\expandafter
               {\expandafter-\romannumeral0\xintinc {#1}}% q-> -(1+q)
}%
\def\XINT_iidivision_aneg_end #1#2#3%
{%
     \expandafter\xint_exchangetwo_keepbraces
     \expandafter{\romannumeral0\XINT_sub_mm_a {}{}#3\Z #2\Z}{#1}% r-> b-r
}%
%%%%%%%%%%%%
\def\XINT_div_prepare #1%
{%
    \XINT_div_prepare_a #1\R\R\R\R\R\R\R\R {10}0000001\W !{#1}%
}%
\def\XINT_div_prepare_a #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_R #9\XINT_div_prepare_small\R
    \XINT_div_prepare_b #9%
}%
%%%%%%%%%%%%
\def\XINT_div_prepare_small\R #1!#2%
{%
    \ifcase #2
    \or\expandafter\XINT_div_BisOne
    \or\expandafter\XINT_div_BisTwo
    \else\expandafter\XINT_div_small_a
    \fi {#2}%
}%
\def\XINT_div_BisOne #1#2{{#2}{0}}%
\def\XINT_div_BisTwo #1#2%
{%
    \expandafter\expandafter\expandafter\XINT_div_BisTwo_a
    \ifodd\xintLDg{#2} \expandafter1\else \expandafter0\fi {#2}%
}%
\def\XINT_div_BisTwo_a #1#2%
{%
    \expandafter{\romannumeral0\xinthalf {#2}}{#1}%
}%
\def\XINT_div_small_a #1#2%
{%
    \expandafter\XINT_div_small_b 
    \the\numexpr #1/\xint_c_ii\expandafter
    .\the\numexpr \xint_c_x^viii+#1\expandafter!%
    \romannumeral0%
    \XINT_div_small_ba #2\R\R\R\R\R\R\R\R{10}0000001\W
       #2\XINT_sepbyviii_Z_end 2345678\relax
}%
\def\XINT_div_small_b #1!#2{#2#1!}%
\def\XINT_div_small_ba #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_R #9\XINT_div_smallsmall\R
    \expandafter\XINT_div_dosmalldiv
    \the\numexpr\expandafter\XINT_sepbyviii_Z
           \romannumeral0\XINT_zeroes_forviii 
    #1#2#3#4#5#6#7#8#9%
}%
\def\XINT_div_smallsmall\R
    \expandafter\XINT_div_dosmalldiv
    \the\numexpr\expandafter\XINT_sepbyviii_Z
    \romannumeral0\XINT_zeroes_forviii #1\R #2\relax 
   {{\XINT_div_dosmallsmall}{#1}}%
\def\XINT_div_dosmallsmall #1.1#2!#3%
{%
    \expandafter\XINT_div_smallsmallend
    \the\numexpr (#3+#1)/#2-\xint_c_i.#2.#3.%
}%
\def\XINT_div_smallsmallend #1.#2.#3.{\expandafter
    {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #3-#1*#2}}%
\def\XINT_div_dosmalldiv 
    {{\expandafter\XINT_sdiv_out\the\numexpr\XINT_smalldivx_a}}%
%%%%%%%%%%%%
\def\XINT_div_prepare_b 
   {\expandafter\XINT_div_prepare_c\romannumeral0\XINT_zeroes_forviii }%
\def\XINT_div_prepare_c #1!%
{%
     \XINT_div_prepare_d  #1.00000000!{#1}%
}%
\def\XINT_div_prepare_d #1#2#3#4#5#6#7#8#9%
{%
    \expandafter\XINT_div_prepare_e\xint_gob_til_dot #1#2#3#4#5#6#7#8#9!%
}%
\def\XINT_div_prepare_e #1!#2!#3#4%
{%
    \XINT_div_prepare_f #4#3\X {#1}{#3}%
}%
%    \end{macrocode}
% \lverb|attention qu'on calcule ici x'=x+1 (x = huit premiers chiffres du
% diviseur) et que si x=99999999, x' aura donc 9 chiffres, pas compatible avec
% div_mini (avant 1.2, x avait 4 chiffres, et on faisait la division avec x'
% dans un \numexpr). Bon, facile  dire aprs avoir laiss passer ce bug dans
% v1.2. C'est le problme lorsqu'au lieu de tout refaire  partir de zro on
% recycle d'anciennes routines qui avaient un contexte diffrent.|
%    \begin{macrocode}
\def\XINT_div_prepare_f #1#2#3#4#5#6#7#8#9\X
{%
    \expandafter\XINT_div_prepare_g
     \the\numexpr  #1#2#3#4#5#6#7#8+\xint_c_i\expandafter
    .\the\numexpr (#1#2#3#4#5#6#7#8+\xint_c_i)/\xint_c_ii\expandafter
    .\the\numexpr #1#2#3#4#5#6#7#8\expandafter
    .\romannumeral0\XINT_sepandrev_andcount
    #1#2#3#4#5#6#7#8#9\XINT_rsepbyviii_end_A 2345678%
                      \XINT_rsepbyviii_end_B 2345678%
    \relax\xint_c_ii\xint_c_iii
        \R.\xint_c_vi\R.\xint_c_v\R.\xint_c_iv\R.\xint_c_iii
        \R.\xint_c_ii\R.\xint_c_i\R.\xint_c_\W 
    \X
}%
\def\XINT_div_prepare_g #1.#2.#3.#4.#5\X #6#7#8%
{%
    \expandafter\XINT_div_prepare_h
    \the\numexpr\expandafter\XINT_sepbyviii_andcount
    \romannumeral0\XINT_zeroes_forviii #8#7\R\R\R\R\R\R\R\R{10}0000001\W 
    #8#7\XINT_sepbyviii_end 2345678\relax
     \xint_c_vii!\xint_c_vi!\xint_c_v!\xint_c_iv!%
     \xint_c_iii!\xint_c_ii!\xint_c_i!\xint_c_\W 
    {#1}{#2}{#3}{#4}{#5}{#6}%
}%
\def\XINT_div_prepare_h #11.#2.#3#4#5#6%#7#8%
{%
    \XINT_div_start_a {#2}{#6}{#1}{#3}{#4}{#5}%{#7}{#8}%
}%
%    \end{macrocode}
% \lverb|L, K, A, x',y,x, B, c. Attention que K est diminu de 1 plus loin.
% Comme xint 1.2 a dj repr K=1, on a ici au minimum K=2. Attention B est 
% l'envers, A est  l'endroit et les deux avec sparateurs. Attention que ce
% n'est pas ici qu'on boucle mais en \XINT_div_I_a.|
%    \begin{macrocode}
\def\XINT_div_start_a #1#2%
{%
    \ifnum #1 < #2
      \expandafter\XINT_div_zeroQ
    \else
      \expandafter\XINT_div_start_b
    \fi
    {#1}{#2}%
}%
\def\XINT_div_zeroQ #1#2#3#4#5#6#7%
{%
    \expandafter\XINT_div_zeroQ_end
    \romannumeral0\XINT_unsep_cuzsmall
    #31\R!1\R!1\R!1\R!1\R!1\R!1\R!1\R!\W .%
}%
\def\XINT_div_zeroQ_end #1.#2%
    {\expandafter{\expandafter0\expandafter}\XINT_div_cleanR #1#2.}%
%    \end{macrocode}
% \lverb|L, K, A, x',y,x, B, c->K.A.x{LK{x'y}x}Bc|
%    \begin{macrocode}
\def\XINT_div_start_b #1#2#3#4#5#6%
{%
    \expandafter\XINT_div_finish\the\numexpr
    \XINT_div_start_c {#2}.#3.{#6}{{#1}{#2}{{#4}{#5}}{#6}}%
}%
\def\XINT_div_finish
{%
    \expandafter\XINT_div_finish_a \romannumeral`&&@\XINT_div_unsepQ
}%
\def\XINT_div_finish_a #1\Z #2.{\XINT_div_finish_b #2.{#1}}%
%    \end{macrocode}
% \lverb|Ici ce sont routines de fin. Le reste dj nettoy. R.Qc.|
%    \begin{macrocode}
\def\XINT_div_finish_b #1%
{%
    \if0#1%
       \expandafter\XINT_div_finish_bRzero
    \else
       \expandafter\XINT_div_finish_bRpos
    \fi
    #1%
}%
\def\XINT_div_finish_bRzero 0.#1#2{{#1}{0}}%
\def\XINT_div_finish_bRpos #1.#2#3%
{% 
    \expandafter\xint_exchangetwo_keepbraces\XINT_div_cleanR  #1#3.{#2}%
}%
\def\XINT_div_cleanR #100000000.{{#1}}%
%    \end{macrocode}
% \lverb|Kalpha.A.x{LK{x'y}x}, B, c, au dbut #2=alpha est vide. On fait une
% boucle pour prendre K units de A (on a au moins L gal  K) et les mettre
% dans alpha.|
%    \begin{macrocode}
\def\XINT_div_start_c #1%
{%
    \ifnum #1>\xint_c_vi 
       \expandafter\XINT_div_start_ca
    \else
       \expandafter\XINT_div_start_cb
    \fi {#1}%
}%
\def\XINT_div_start_ca #1#2.#3!#4!#5!#6!#7!#8!#9!%
{%
    \expandafter\XINT_div_start_c\expandafter
    {\the\numexpr #1-\xint_c_vii}#2#3!#4!#5!#6!#7!#8!#9!.%
}%
\def\XINT_div_start_cb #1%
   {\csname XINT_div_start_c_\romannumeral\numexpr#1\endcsname}%
\def\XINT_div_start_c_i   #1.#2!%
    {\XINT_div_start_c_   #1#2!.}%
\def\XINT_div_start_c_ii  #1.#2!#3!%
    {\XINT_div_start_c_   #1#2!#3!.}%
\def\XINT_div_start_c_iii #1.#2!#3!#4!%
    {\XINT_div_start_c_   #1#2!#3!#4!.}%
\def\XINT_div_start_c_iv  #1.#2!#3!#4!#5!%
    {\XINT_div_start_c_   #1#2!#3!#4!#5!.}%
\def\XINT_div_start_c_v   #1.#2!#3!#4!#5!#6!%
    {\XINT_div_start_c_   #1#2!#3!#4!#5!#6!.}%
\def\XINT_div_start_c_vi  #1.#2!#3!#4!#5!#6!#7!%
    {\XINT_div_start_c_   #1#2!#3!#4!#5!#6!#7!.}%
%    \end{macrocode}
% \lverb|#1=a, #2=alpha (de longueur K,  l'endroit).#3=reste de A.#4=x,
% #5={LK{x'y}x},#6=B,c -> a, x, alpha, B, {00000000}, L, K, {x'y},x,
% alpha'=reste de A, Bc.|
%    \begin{macrocode}
\def\XINT_div_start_c_ 1#1!#2.#3.#4#5#6%
{%
    \XINT_div_I_a {#1}{#4}{1#1!#2}{#6}{00000000}#5{#3}{#6}%
}%
%    \end{macrocode}
% \lverb|Ceci est le point de retour de la boucle principale. a, x, alpha, B,
% q0, L, K, {x'y}, x, alpha', Bc |
%    \begin{macrocode}
\def\XINT_div_I_a #1#2%
{%
    \expandafter\XINT_div_I_b\the\numexpr #1/#2.{#1}{#2}%
}%
\def\XINT_div_I_b #1%
{%
    \xint_gob_til_zero #1\XINT_div_I_czero 0\XINT_div_I_c #1%
}%
%    \end{macrocode}
% \lverb|On intercepte petit quotient nul: #1=a, x, alpha, B, #5=q0, L, K,
%    {x'y}, x, alpha', Bc -> on lche un q puis {alpha} L, K, {x'y}, x,
%    alpha', Bc.|
%    \begin{macrocode}
\def\XINT_div_I_czero 0\XINT_div_I_c 0.#1#2#3#4#5{1#5\XINT_div_I_g {#3}}%
\def\XINT_div_I_c #1.#2#3%
{%
    \expandafter\XINT_div_I_da\the\numexpr #2-#1*#3.#1.{#2}{#3}%
}%
%    \end{macrocode}
% \lverb|r.q.alpha, B, q0, L, K, {x'y}, x, alpha', Bc|
%    \begin{macrocode}
\def\XINT_div_I_da #1.%
{%
    \ifnum #1>\xint_c_ix
       \expandafter\XINT_div_I_dP
    \else
       \ifnum #1<\xint_c_
        \expandafter\expandafter\expandafter\XINT_div_I_dN
       \else
        \expandafter\expandafter\expandafter\XINT_div_I_db
       \fi
    \fi
}%
%    \end{macrocode}
% \lverb|attention trs mauvaises notations avec _b et _db.|
%    \begin{macrocode}
\def\XINT_div_I_dN #1.%
{%
    \expandafter\XINT_div_I_b\the\numexpr #1-\xint_c_i.%
}%
\def\XINT_div_I_db #1.#2#3#4#5%
{%
    \expandafter\XINT_div_I_dc\expandafter #1%
    \romannumeral0\expandafter\XINT_div_sub\expandafter
       {\romannumeral0\XINT_rev_nounsep {}#4\R!\R!\R!\R!\R!\R!\R!\R!\W}%
       {\the\numexpr\XINT_div_verysmallmul #1!#51\Z!}%
    \Z {#4}{#5}%
}%
%    \end{macrocode}
% \lverb|La soustraction spciale renvoie simplement - si le chiffre q est
% trop grand. On invoque dans ce cas I_dP.|
%    \begin{macrocode}
\def\XINT_div_I_dc #1#2%
{%
    \if-#2\expandafter\XINT_div_I_dd\else\expandafter\XINT_div_I_de\fi
     #1#2%
}%
\def\XINT_div_I_dd #1-\Z
{%
    \if #11\expandafter\XINT_div_I_dz\fi
    \expandafter\XINT_div_I_dP\the\numexpr #1-\xint_c_i.XX%
}%
\def\XINT_div_I_dz #1XX#2#3#4%
{%
    1#4\XINT_div_I_g {#2}%
}%
\def\XINT_div_I_de #1#2\Z #3#4#5{1#5+#1\XINT_div_I_g {#2}}%
%    \end{macrocode}
% \lverb|q.alpha, B, q0, L, K, {x'y},x, alpha'Bc (q=0 has been intercepted)
%        -> 1nouveauq.nouvel alpha, L, K, {x'y}, x, alpha',Bc|
%    \begin{macrocode}
\def\XINT_div_I_dP #1.#2#3#4#5#6%
{%
    1#6+#1\expandafter\XINT_div_I_g\expandafter
    {\romannumeral0\expandafter\XINT_div_sub\expandafter
      {\romannumeral0\XINT_rev_nounsep {}#4\R!\R!\R!\R!\R!\R!\R!\R!\W}%
      {\the\numexpr\XINT_div_verysmallmul #1!#51\Z!}%
    }%
}%
%    \end{macrocode}
% \lverb|1#1=nouveau q. nouvel alpha, L, K, {x'y},x,alpha', BQc|
%    \begin{macrocode}
%    \end{macrocode}
% \lverb|#1=q,#2=nouvel alpha,#3=L, #4=K, #5={x'y}, #6=x, #7= alpha',#8=B,
% c -> on laisse q puis {x'y}alpha.alpha'.{{x'y}xKL}Bc|
%    \begin{macrocode}
\def\XINT_div_I_g #1#2#3#4#5#6#7%
{%
     \expandafter !\the\numexpr
     \ifnum#2=#3
          \expandafter\XINT_div_exittofinish
     \else
          \expandafter\XINT_div_I_h
     \fi
     {#4}#1.#6.{{#4}{#5}{#3}{#2}}{#7}%
}%
%    \end{macrocode}
% \lverb|{x'y}alpha.alpha'.{{x'y}xKL}Bc -> Attention retour  l'envoyeur ici
% par terminaison des \the\numexpr. On doit reprendre le Q dj sorti, qui n'a
% plus de sparateurs, ni de leading 1. Ensuite R sans leading zeros.c|
%    \begin{macrocode}
\def\XINT_div_exittofinish #1#2.#3.#4#5%
{%
    1\expandafter\expandafter\expandafter!\expandafter\XINT_unsep_delim
    \romannumeral0\XINT_div_unsepR #2#31\R!1\R!1\R!1\R!1\R!1\R!1\R!1\R!\W.%
}%
%    \end{macrocode}
% \lverb|ATTENTION DESCRIPTION OBSOLTE. #1={x'y}alpha.#2!#3=reste de A.
% #4={{x'y},x,K,L},#5=B,c devient {x'y},alpha sur K+4 chiffres.B,
% {{x'y},x,K,L}, #6= nouvel alpha',B,c|
%    \begin{macrocode}
\def\XINT_div_I_h #1.#2!#3.#4#5%
{%
    \XINT_div_II_b #1#2!.{#5}{#4}{#3}{#5}%
}%
%    \end{macrocode}
% \lverb|{x'y}alpha.B, {{x'y},x,K,L}, nouveau alpha',B,c|
%    \begin{macrocode}
\def\XINT_div_II_b #11#2!#3!%
{%
    \xint_gob_til_eightzeroes #2\XINT_div_II_skipc 00000000%
    \XINT_div_II_c #1{1#2}{#3}%
}%
%    \end{macrocode}
% \lverb|x'y{100000000}{1<8>}reste de alpha.#6=B,#7={{x'y},x,K,L}, alpha',B,
% c -> {x'y}x,K,L ( diminuer de 4), {alpha sur
% K}B{q1=00000000}{alpha'}B,c|
%    \begin{macrocode}
\def\XINT_div_II_skipc 00000000\XINT_div_II_c #1#2#3#4#5.#6#7%
{%
    \XINT_div_II_k #7{#4!#5}{#6}{00000000}%
}%
%    \end{macrocode}
% \lverb|x'ya->1qx'yalpha.B, {{x'y},x,K,L}, nouveau alpha',B, c. En fait,
% attention, ici #3 et #4 sont les 16 premiers chiffres du numrateur,sous la
% forme blocs 1<8chiffres>.
%
% ATTENTION!
%
% 2015/10/29 :j'avais introduit un bug ici dans v1.2 2015/10/15, car
% \XINT_div_mini veut un diviseur de huit chiffres, or si le dnominateur B
% dbute par x=99999999, on aura x'=100000000, d'o videmment un bug. Bon il
% faut intercepter x'=100000000.
%
% I need to recognize x'=100000000 in some not too penalizing way. Anyway,
% will try to optimize some other day.|
%    \begin{macrocode}
\def\XINT_div_II_c #1#2#3#4%
{%
     \expandafter\XINT_div_II_d\the\numexpr\XINT_div_xmini
     #1.#2!#3!#4!{#1}{#2}#3!#4!%
}%
\def\XINT_div_xmini #1%
{%  
    \xint_gob_til_one #1\XINT_div_xmini_a 1\XINT_div_mini #1%
}%
\def\XINT_div_xmini_a 1\XINT_div_mini 1#1%
{%
    \xint_gob_til_zero #1\XINT_div_xmini_b 0\XINT_div_mini 1#1%
}%
\def\XINT_div_xmini_b 0\XINT_div_mini 10#1#2#3#4#5#6#7%
{%  
    \xint_gob_til_zero #7\XINT_div_xmini_c 0\XINT_div_mini 10#1#2#3#4#5#6#7%
}%
%    \end{macrocode}
% \lverb|x'=10^8 and we return #1=1<8digits>.|
%    \begin{macrocode}
\def\XINT_div_xmini_c 0\XINT_div_mini 100000000.50000000!#1!#2!{#1!}%
%    \end{macrocode}
% \lverb|1 suivi de q1 sur huit chiffres! #2=x', #3=y, #4=alpha.#5=B,
% {{x'y},x,K,L}, alpha', B, c --> nouvel alpha.x',y,B,q1,{{x'y},x,K,L},
% alpha', B, c |
%    \begin{macrocode}
\def\XINT_div_II_d 1#1#2#3#4#5!#6#7#8.#9%
{%
    \expandafter\XINT_div_II_e
    \romannumeral0\expandafter\XINT_div_sub\expandafter
      {\romannumeral0\XINT_rev_nounsep {}#8\R!\R!\R!\R!\R!\R!\R!\R!\W}%
      {\the\numexpr\XINT_div_smallmul_a 100000000.#1#2#3#4.#5!#91\Z!}%
    .{#6}{#7}{#9}{#1#2#3#4#5}%
}%
%    \end{macrocode}
% \lverb|alpha.x',y,B,q1, {{x'y},x,K,L}, alpha', B, c. Attention la
% soustraction spciale doit maintenir les blocs 1<8>!|
%    \begin{macrocode}
\def\XINT_div_II_e 1#1!%
{%
    \xint_gob_til_eightzeroes #1\XINT_div_II_skipf 00000000%
    \XINT_div_II_f 1#1!%
}%
%    \end{macrocode}
% \lverb|100000000!alpha sur K chiffres.#2=x',#3=y,#4=B,#5=q1, #6={{x'y},x,K,L},
% #7=alpha',Bc -> {x'y}x,K,L ( diminuer de 1),
% {alpha sur K}B{q1}{alpha'}Bc|
%    \begin{macrocode}
\def\XINT_div_II_skipf 00000000\XINT_div_II_f 100000000!#1.#2#3#4#5#6%
{%
    \XINT_div_II_k #6{#1}{#4}{#5}%
}%
%    \end{macrocode}
% \lverb|1<a1>!1<a2>!, alpha (sur K+1 blocs de 8). x', y, B, q1, {{x'y},x,K,L},
% alpha', B,c.
%
% Here also we are dividing with x' which could be 10^8 in the exceptional
% case x=99999999. Must intercept it before sending to \XINT_div_mini.|
%    \begin{macrocode}
\def\XINT_div_II_f #1!#2!#3.%
{%
    \XINT_div_II_fa {#1!#2!}{#1!#2!#3}%
}%
\def\XINT_div_II_fa #1#2#3#4%
{%
    \expandafter\XINT_div_II_g \the\numexpr\XINT_div_xmini #3.#4!#1{#2}%
}%
%    \end{macrocode}
% \lverb|#1=q, #2=alpha (K+4), #3=B, #4=q1, {{x'y},x,K,L}, alpha', BQc
%        -> 1 puis nouveau q sur 8 chiffres. nouvel alpha sur K blocs,
%        B, {{x'y},x,K,L}, alpha',Bc |
%    \begin{macrocode}
\def\XINT_div_II_g 1#1#2#3#4#5!#6#7#8%
{%
    \expandafter \XINT_div_II_h
    \the\numexpr 1#1#2#3#4#5+#8\expandafter\expandafter\expandafter
    .\expandafter\expandafter\expandafter
    {\expandafter\xint_gob_til_exclam
     \romannumeral0\expandafter\XINT_div_sub\expandafter
       {\romannumeral0\XINT_rev_nounsep {}#6\R!\R!\R!\R!\R!\R!\R!\R!\W}%
       {\the\numexpr\XINT_div_smallmul_a 100000000.#1#2#3#4.#5!#71\Z!}}%
    {#7}%
}%
%    \end{macrocode}
% \lverb|1 puis nouveau q sur 8 chiffres, #2=nouvel alpha sur K blocs,
% #3=B, #4={{x'y},x,K,L} avec L  ajuster,  alpha', BQc
% -> {x'y}x,K,L  diminuer de 1, {alpha}B{q}, alpha', BQc|
%    \begin{macrocode}
\def\XINT_div_II_h 1#1.#2#3#4%
{%
    \XINT_div_II_k #4{#2}{#3}{#1}%
}%
%    \end{macrocode}
% \lverb|{x'y}x,K,L  diminuer de 1, alpha, B{q}alpha',Bc
%        ->nouveau L.K,x',y,x,alpha.B,q,alpha',B,c
%        ->{LK{x'y}x},x,a,alpha.B,q,alpha',B,c|
%    \begin{macrocode}
\def\XINT_div_II_k #1#2#3#4#5%
{%
    \expandafter\XINT_div_II_l \the\numexpr #4-\xint_c_i.{#3}#1{#2}#5.%
}%
\def\XINT_div_II_l #1.#2#3#4#51#6!%
{%
    \XINT_div_II_m {{#1}{#2}{{#3}{#4}}{#5}}{#5}{#6}1#6!%
}%
%    \end{macrocode}
% \lverb|{LK{x'y}x},x,a,alpha.B{q}alpha'B -> a, x, alpha, B, q,
% L, K, {x'y}, x, alpha', Bc |
%    \begin{macrocode}
\def\XINT_div_II_m #1#2#3#4.#5#6%
{%
     \XINT_div_I_a {#3}{#2}{#4}{#5}{#6}#1%
}%
%    \end{macrocode}
% \lverb|This multiplication is exactly like \XINT_smallmul, but it always
% keeps the ending carry. For optimization I duplicated the whole code.|
%    \begin{macrocode}
\def\XINT_div_minimulwc_a 1#1.#2.#3!#4#5#6#7#8.%
{%
    \expandafter\XINT_div_minimulwc_b
    \the\numexpr \xint_c_x^ix+#1+#3*#8.#3*#4#5#6#7+#2*#8.#2*#4#5#6#7.%
}%
\def\XINT_div_minimulwc_b 1#1#2#3#4#5#6.#7.%
{%
    \expandafter\XINT_div_minimulwc_c 
    \the\numexpr \xint_c_x^ix+#1#2#3#4#5+#7.#6.%
}%
\def\XINT_div_minimulwc_c 1#1#2#3#4#5#6.#7.#8.%
{%
    1#6#7\expandafter!%
    \the\numexpr\expandafter\XINT_div_smallmul_a
    \the\numexpr \xint_c_x^viii+#1#2#3#4#5+#8.%
}%
\def\XINT_div_smallmul_a #1.#2.#3!1#4!%
{%
    \xint_gob_til_Z #4\XINT_div_smallmul_e\Z
    \XINT_div_minimulwc_a #1.#2.#3!#4.#2.#3!%
}%
\def\XINT_div_smallmul_e\Z\XINT_div_minimulwc_a 1#1.#2\Z #3!{1\relax #1!}%
%    \end{macrocode}
% \lverb|Special very small multiplication for division. We only need to cater
% for multiplicands from 1 to 9. The ending is different from standard
% verysmallmul, a zero carry is not suppressed. And no final 1\Z! is added. If
% #1=1 let's not forget to add the 100000000! at the end.|
%    \begin{macrocode}
\def\XINT_div_verysmallmul #1%
   {\xint_gob_til_one #1\XINT_div_verysmallisone 1\XINT_div_verysmallmul_a 0.#1}%
\def\XINT_div_verysmallisone 1\XINT_div_verysmallmul_a 0.1!1#11\Z!%
   {1\relax #1100000000!}%
\def\XINT_div_verysmallmul_a #1.#2!1#3!%
{%
    \xint_gob_til_Z #3\XINT_div_verysmallmul_e\Z
    \expandafter\XINT_div_verysmallmul_b
    \the\numexpr \xint_c_x^ix+#2*#3+#1.#2!%
}%
\def\XINT_div_verysmallmul_b 1#1#2.%
    {1#2\expandafter!\the\numexpr\XINT_div_verysmallmul_a #1.}%
\def\XINT_div_verysmallmul_e\Z #1\Z +#2#3!{1\relax 0000000#2!}%
%    \end{macrocode}
% \lverb|Special subtraction for division purposes.|
%    \begin{macrocode}
\def\XINT_div_sub #1#2% 
{%
    \expandafter\XINT_div_sub_clean
    \the\numexpr\expandafter\XINT_div_sub_a\expandafter
    1#2\Z!\Z!\Z!\Z!\Z!\W #1\Z!\Z!\Z!\Z!\Z!\W
}%
\def\XINT_div_sub_clean #1-#2#3\W
{%
    \if1#2\expandafter\XINT_rev_nounsep\else\expandafter\XINT_div_sub_neg\fi
    {}#1\R!\R!\R!\R!\R!\R!\R!\R!\W 
}%
\def\XINT_div_sub_neg #1\W { -}%
\def\XINT_div_sub_a #1!#2!#3!#4!#5\W #6!#7!#8!#9!%
{%
    \XINT_div_sub_b #1!#6!#2!#7!#3!#8!#4!#9!#5\W
}%
\def\XINT_div_sub_b #1#2#3!#4!%
{%
    \xint_gob_til_Z #4\XINT_div_sub_bi \Z
    \expandafter\XINT_div_sub_c\the\numexpr#1-#3+1#4-\xint_c_i.%
}%
\def\XINT_div_sub_c 1#1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_div_sub_d #1%
}%
\def\XINT_div_sub_d #1#2#3!#4!%
{%
    \xint_gob_til_Z #4\XINT_div_sub_di \Z
    \expandafter\XINT_div_sub_e\the\numexpr#1-#3+1#4-\xint_c_i.%
}%
\def\XINT_div_sub_e 1#1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_div_sub_f #1%
}%
\def\XINT_div_sub_f #1#2#3!#4!%
{%
    \xint_gob_til_Z #4\XINT_div_sub_fi \Z
    \expandafter\XINT_div_sub_g\the\numexpr#1-#3+1#4-\xint_c_i.%
}%
\def\XINT_div_sub_g 1#1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_div_sub_h #1%
}%
\def\XINT_div_sub_h #1#2#3!#4!%
{%
    \xint_gob_til_Z #4\XINT_div_sub_hi \Z
    \expandafter\XINT_div_sub_i\the\numexpr#1-#3+1#4-\xint_c_i.%
}%
\def\XINT_div_sub_i 1#1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_div_sub_a #1%
}%
\def\XINT_div_sub_bi\Z
    \expandafter\XINT_div_sub_c\the\numexpr#1-#2+#3.#4!#5!#6!#7!#8!#9!\Z !\W
{%
    \XINT_div_sub_l #1#2!#5!#7!#9!%
}%
\def\XINT_div_sub_di\Z
    \expandafter\XINT_div_sub_e\the\numexpr#1-#2+#3.#4!#5!#6!#7!#8\W
{%
    \XINT_div_sub_l #1#2!#5!#7!%
}%
\def\XINT_div_sub_fi\Z
    \expandafter\XINT_div_sub_g\the\numexpr#1-#2+#3.#4!#5!#6\W
{%
    \XINT_div_sub_l #1#2!#5!%
}%
\def\XINT_div_sub_hi\Z
    \expandafter\XINT_div_sub_i\the\numexpr#1-#2+#3.#4\W
{%
    \XINT_div_sub_l #1#2!%
}%
\def\XINT_div_sub_l #1%
{%
   \xint_UDzerofork
      #1{-2\relax}%
       0\XINT_div_sub_r
   \krof
}%
\def\XINT_div_sub_r #1!%
{%
    -\ifnum 0#1=\xint_c_ 1\else2\fi\relax
}%
%%%%%%%%%%%%
\def\XINT_sdiv_out #1\Z #2\W%
    {\expandafter
     {\romannumeral0\XINT_unsep_cuzsmall#11\R!1\R!1\R!1\R!1\R!1\R!1\R!1\R!\W}%
     {#2}}%
\def\XINT_smalldivx_a #1.1#2!1#3!%
{%
    \expandafter\XINT_smalldivx_b
    \the\numexpr (#3+#1)/#2-\xint_c_i!#1.#2!#3!%
}%
\def\XINT_smalldivx_b #1!%
{%
    \if0#1\else
          \xint_c_x^viii+#1\xint_afterfi{\expandafter!\the\numexpr}\fi
    \XINT_smalldiv_c #1!%
}%
\def\XINT_smalldiv_c #1!#2.#3!#4!%
{%
    \expandafter\XINT_smalldiv_d\the\numexpr #4-#1*#3!#2.#3!%
}%
\def\XINT_smalldiv_d #1!#2!#3#4!%
{%
    \xint_gob_til_Z #4\XINT_smalldiv_end \Z
    \XINT_smalldiv_e #1!#2!#3#4!%
}%
\def\XINT_smalldiv_end\Z\XINT_smalldiv_e #1!#2!1\Z!{1!\Z #1\W }%
\def\XINT_smalldiv_e #1!#2.#3!%
{%
    \expandafter\XINT_smalldiv_f\the\numexpr
    \xint_c_xi_e_viii_mone+#1*\xint_c_x^viii/#3!#2.#3!#1!%
}%
\def\XINT_smalldiv_f 1#1#2#3#4#5#6!#7.#8!%
{%
     \xint_gob_til_zero #1\XINT_smalldiv_fz 0%
     \expandafter\XINT_smalldiv_g
     \the\numexpr\XINT_minimul_a #2#3#4#5.#6!#8!#2#3#4#5#6!#7.#8!%
}%
\def\XINT_smalldiv_fz 0%
    \expandafter\XINT_smalldiv_g\the\numexpr\XINT_minimul_a
    9999.9999!#1!99999999!#2!0!1#3!%
{%
    \XINT_smalldiv_i .#3!\xint_c_!#2!%
}%
\def\XINT_smalldiv_g 1#1!1#2!#3!#4!#5!#6!%
{%
    \expandafter\XINT_smalldiv_h
    \the\numexpr 1#6-#1.#2!#5!#3!#4!%
}%
\def\XINT_smalldiv_h 1#1#2.#3!#4!%
{%
    \expandafter\XINT_smalldiv_i
    \the\numexpr #4-#3+#1-\xint_c_i.#2!%
}%
\def\XINT_smalldiv_i #1.#2!#3!#4.#5!%
{%
    \expandafter\XINT_smalldiv_j
    \the\numexpr (#1#2+#4)/#5-\xint_c_i!#3!#1#2!#4.#5!%
}%
\def\XINT_smalldiv_j #1!#2!%
{%
    \xint_c_x^viii+#1+#2\expandafter!\the\numexpr\XINT_smalldiv_k 
    #1!%
}%
\def\XINT_smalldiv_k #1!#2!#3.#4!%
{%
    \expandafter\XINT_smalldiv_d\the\numexpr #2-#1*#4!#3.#4!%
}%
%    \end{macrocode}
% \lverb|Cette routine fait la division euclidienne d'un nombre de seize
% chiffres par #1 = C = diviseur sur huit chiffres >= 10^7, avec #2 = sa
% moiti utilise dans \numexpr pour contrebalancer l'arrondi
% (ARRRRRRGGGGGHHHH) fait par /. Le nombre divis XY = X*10^8+Y se prsente
% sous la forme 1<8chiffres>!1<8chiffres>! avec plus significatif en premier.
%
% ATTENTION UNIQUEMENT UTILIS POUR DES SITUATIONS O IL EST GARANTI QUE X < C
% !! le quotient euclidien de X*10^8+Y par C sera donc < 10^8. Il sera
% renvoy sous la forme 1<8chiffres>.|
%    \begin{macrocode}
\def\XINT_div_mini #1.#2!1#3!%
{%
    \expandafter\XINT_div_mini_a\the\numexpr
    \xint_c_xi_e_viii_mone+#3*\xint_c_x^viii/#1!#1.#2!#3!%
}%
%    \end{macrocode}
% \lverb|Note (2015/10/08). Attention  la diffrence dans l'ordre des
% arguments avec ce que je vois en dans \XINT_smalldiv_f. Je ne me souviens
% plus du tout s'il y a une raison quelconque.|
%    \begin{macrocode}
\def\XINT_div_mini_a 1#1#2#3#4#5#6!#7.#8!%
{%
     \xint_gob_til_zero #1\XINT_div_mini_w 0%
     \expandafter\XINT_div_mini_b
     \the\numexpr\XINT_minimul_a #2#3#4#5.#6!#7!#2#3#4#5#6!#7.#8!%
}%
\def\XINT_div_mini_w 0%
    \expandafter\XINT_div_mini_b\the\numexpr\XINT_minimul_a
    9999.9999!#1!99999999!#2.#3!00000000!#4!%
{%
    \xint_c_x^viii_mone+(#4+#3)/#2!%
}%
\def\XINT_div_mini_b 1#1!1#2!#3!#4!#5!#6!%
{%
    \expandafter\XINT_div_mini_c
    \the\numexpr 1#6-#1.#2!#5!#3!#4!%
}%
\def\XINT_div_mini_c 1#1#2.#3!#4!%
{%
    \expandafter\XINT_div_mini_d
    \the\numexpr #4-#3+#1-\xint_c_i.#2!%
}%
\def\XINT_div_mini_d #1.#2!#3!#4.#5!%
{%
    \xint_c_x^viii_mone+#3+(#1#2+#5)/#4!%
}%
%    \end{macrocode}
% \subsection{\csh{xintiDivRound}, \csh{xintiiDivRound}}
% \lverb|v1.1, transferred from first release of bnumexpr. Rewritten for v1.2.|
%    \begin{macrocode}
\def\xintiDivRound    {\romannumeral0\xintidivround }%
\def\xintidivround  #1%
   {\expandafter\XINT_idivround\romannumeral0\xintnum{#1}\Z }%
\def\xintiiDivRound   {\romannumeral0\xintiidivround }%
\def\xintiidivround #1{\expandafter\XINT_iidivround \romannumeral`&&@#1\Z }%
\def\XINT_idivround #1#2\Z #3%
    {\expandafter\XINT_iidivround_a\expandafter #1%
                 \romannumeral0\xintnum{#3}\Z #2\Z }%
\def\XINT_iidivround #1#2\Z #3%
    {\expandafter\XINT_iidivround_a\expandafter #1\romannumeral`&&@#3\Z #2\Z }%
\def\XINT_iidivround_a #1#2% #1 de A, #2 de B.
{%
    \if0#2\xint_dothis\XINT_iidivround_divbyzero\fi
    \if0#1\xint_dothis\XINT_iidivround_aiszero\fi
    \if-#2\xint_dothis{\XINT_iidivround_bneg #1}\fi
          \xint_orthat{\XINT_iidivround_bpos #1#2}%
}%
\def\XINT_iidivround_divbyzero #1\Z #2\Z {\xintError:DivisionByZero\space 0}%
\def\XINT_iidivround_aiszero   #1\Z #2\Z { 0}%
\def\XINT_iidivround_bpos #1%
{%
    \xint_UDsignfork
            #1{\xintiiopp\XINT_iidivround_pos {}}%
             -{\XINT_iidivround_pos #1}%
    \krof
}%
\def\XINT_iidivround_bneg #1%
{%
    \xint_UDsignfork
            #1{\XINT_iidivround_pos {}}%
             -{\xintiiopp\XINT_iidivround_pos #1}%
    \krof
}%
\def\XINT_iidivround_pos #1#2\Z #3\Z
{%
    \expandafter\XINT_iidivround_pos_a
    \romannumeral0\XINT_div_prepare {#2}{#1#30}%
}%
%    \end{macrocode}
% \lverb|The 1.2c interface to addition changed, the \Z's are now 1\Z's here.
% Will have to come back here for improvements. The 1\Z!1\Z!1\Z!1\Z!\W are for
% the addition which is done if rounding up.|
%    \begin{macrocode}
\def\XINT_iidivround_pos_a #1#2%
{%
    \expandafter\XINT_iidivround_pos_b
    \romannumeral0\expandafter\XINT_sepandrev
      \romannumeral0\XINT_zeroes_forviii #1\R\R\R\R\R\R\R\R{10}0000001\W
    #1\XINT_rsepbyviii_end_A 2345678\XINT_rsepbyviii_end_B 2345678\relax XX%
    \R.\R.\R.\R.\R.\R.\R.\R.\W
    1\Z!1\Z!1\Z!1\Z!\W\R
}%
\def\XINT_iidivround_pos_b 1#1#2#3#4#5#6#7#8!1#9%
{%
    \xint_gob_til_Z #9\XINT_iidivround_small\Z
    \ifnum #8>\xint_c_iv
              \expandafter\XINT_iidivround_pos_up
    \else     \expandafter\XINT_iidivround_pos_finish
    \fi
    1#1#2#3#4#5#6#70!1#9%
}%
\def\XINT_iidivround_pos_up 
{%
    \expandafter\XINT_iidivround_pos_finish
    \the\numexpr\XINT_add_a\xint_c_ii 100000010!1\Z!1\Z!1\Z!1\Z!\W
}%
%    \end{macrocode}
% \lverb|2015/11/17 Damn'ed. I added a bug in \XINT_iidivround_pos_finish when
% I was preparing 1.2c and was still doing modifications to the format for
% calling \XINT_add_a, and then I did a hurried release because I had found a
% bug in the subtraction from release 1.2. The 1.2c pattern #2\R was only ok
% if addition had been executed else obviously we have many extra 1\Z!'s. And
% we have to inject an explicit 1\Z! for unrevbyviii. Sadly xint.pdf itself
% obviously did not have a single example of an integer division not rounded
% up ... Anyway, 1.2d then.
%
% Why wasn't the 1.2c typo detected ? mainly because my main test file
% compared with usage of bigintcalc which has no macro for rounded division,
% hence \xintiiDivision was tested but not \xintiiDivRound. And my newer
% generic test files somehow only tested \xintiiDivision also. Of course I
% have separate test files for \xintiiDivRound, but they were used at the time
% of first creation of this macro. In the future I must have a test suite
% which will have entries for all macros and will be integrated to the last
% pre-build before release... the description of the macros in xint.pdf
% usually contain at least one example, but there are lacunae.|
%    \begin{macrocode}
\def\XINT_iidivround_pos_finish #10!#21\Z!#3\R
{%
    \expandafter\XINT_cuz_small\romannumeral0\XINT_unrevbyviii {}%
     #1!#21\Z!1\R!1\R!1\R!1\R!1\R!1\R!1\R!1\R!\W 
}%
\def\XINT_iidivround_small\Z\ifnum #1>#2\fi 1#30!#4\W\R
{%
    \ifnum #1>\xint_c_iv
              \expandafter\XINT_iidivround_small_up
    \else     \expandafter\XINT_iidivround_small_trunc
    \fi {#3}%
}%
\edef\XINT_iidivround_small_up #1%
    {\noexpand\expandafter\space\noexpand\the\numexpr #1+\xint_c_i\relax }%
\edef\XINT_iidivround_small_trunc #1%
    {\noexpand\expandafter\space\noexpand\the\numexpr #1\relax }%
%    \end{macrocode}
% \subsection{\csh{xintiDivTrunc}, \csh{xintiiDivTrunc}}
%    \begin{macrocode}
\def\xintiDivTrunc    {\romannumeral0\xintidivtrunc }%
\def\xintidivtrunc  #1{\expandafter\XINT_iidivtrunc\romannumeral0\xintnum{#1}\Z }%
\def\xintiiDivTrunc   {\romannumeral0\xintiidivtrunc }%
\def\xintiidivtrunc #1{\expandafter\XINT_iidivtrunc \romannumeral`&&@#1\Z }%
\def\XINT_iidivtrunc #1#2\Z #3{\expandafter\XINT_iidivtrunc_a\expandafter #1%
                             \romannumeral`&&@#3\Z #2\Z }%
\def\XINT_iidivtrunc_a #1#2% #1 de A, #2 de B.
{%
    \if0#2\xint_dothis\XINT_iidivround_divbyzero\fi
    \if0#1\xint_dothis\XINT_iidivround_aiszero\fi
    \if-#2\xint_dothis{\XINT_iidivtrunc_bneg #1}\fi
          \xint_orthat{\XINT_iidivtrunc_bpos #1#2}%
}%
\def\XINT_iidivtrunc_bpos #1%
{%
    \xint_UDsignfork
            #1{\xintiiopp\XINT_iidivtrunc_pos {}}%
             -{\XINT_iidivtrunc_pos #1}%
    \krof
}%
\def\XINT_iidivtrunc_bneg #1%
{%
    \xint_UDsignfork
            #1{\XINT_iidivtrunc_pos {}}%
             -{\xintiiopp\XINT_iidivtrunc_pos #1}%
    \krof
}%
\def\XINT_iidivtrunc_pos #1#2\Z #3\Z%
    {\expandafter\xint_firstoftwo_thenstop
     \romannumeral0\XINT_div_prepare {#2}{#1#3}}%
%    \end{macrocode}
% \subsection{\csh{xintiMod}, \csh{xintiiMod}}
%    \begin{macrocode}
\def\xintiMod    {\romannumeral0\xintimod }%
\def\xintimod  #1{\expandafter\XINT_iimod\romannumeral0\xintnum{#1}\Z }%
\def\xintiiMod   {\romannumeral0\xintiimod }%
\def\xintiimod #1{\expandafter\XINT_iimod \romannumeral`&&@#1\Z }%
\def\XINT_iimod #1#2\Z #3{\expandafter\XINT_iimod_a\expandafter #1%
                             \romannumeral`&&@#3\Z #2\Z }%
\def\XINT_iimod_a #1#2% #1 de A, #2 de B.
{%
    \if0#2\xint_dothis\XINT_iidivround_divbyzero\fi
    \if0#1\xint_dothis\XINT_iidivround_aiszero\fi
    \if-#2\xint_dothis{\XINT_iimod_bneg #1}\fi
          \xint_orthat{\XINT_iimod_bpos #1#2}%
}%
\def\XINT_iimod_bpos #1%
{%
    \xint_UDsignfork
            #1{\xintiiopp\XINT_iimod_pos {}}%
             -{\XINT_iimod_pos #1}%
    \krof
}%
\def\XINT_iimod_bneg #1%
{%
    \xint_UDsignfork
            #1{\xintiiopp\XINT_iimod_pos {}}%
             -{\XINT_iimod_pos #1}%
    \krof
}%
\def\XINT_iimod_pos #1#2\Z #3\Z%
    {\expandafter\xint_secondoftwo_thenstop\romannumeral0\XINT_div_prepare
      {#2}{#1#3}}%
%    \end{macrocode}
% \subsection{``Load \xintfracnameimp'' macros}
% \lverb|Originally was used in \xintiiexpr. Transferred from xintfrac for 1.1.|
%    \begin{macrocode}
\catcode`! 11
\def\xintAbs {\Did_you_mean_iiAbs?or_load_xintfrac!}%
\def\xintOpp {\Did_you_mean_iiOpp?or_load_xintfrac!}%
\def\xintAdd {\Did_you_mean_iiAdd?or_load_xintfrac!}%
\def\xintSub {\Did_you_mean_iiSub?or_load_xintfrac!}%
\def\xintMul {\Did_you_mean_iiMul?or_load_xintfrac!}%
\def\xintPow {\Did_you_mean_iiPow?or_load_xintfrac!}%
\def\xintSqr {\Did_you_mean_iiSqr?or_load_xintfrac!}%
\XINT_restorecatcodes_endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xintcore>\relax
%\def<*xint>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xintcore>
%<*xint>
% \StoreCodelineNo {xintcore}
%
% \section{Package \xintnameimp implementation}
% \label{sec:xintimp}
%
% \localtableofcontents
% 
% With release |1.1| the core arithmetic routines |\xintiiAdd|,
% |\xintiiSub|, |\xintiiMul|, |\xintiiQuo|, |\xintiiPow| were separated to be
% the main component of the then new
% \xintcorenameimp. 
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xint.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xintcore.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xint}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintcore.sty
      \ifx\w\relax % but xintkernel.sty not yet loaded.
         \def\z{\endgroup\input xintcore.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xintcore.sty not yet loaded.
            \def\z{\endgroup\RequirePackage{xintcore}}%
          \fi
      \else
        \aftergroup\endinput % xint already loaded.
      \fi
    \fi
  \fi
\z%
\XINTsetupcatcodes% defined in xintkernel.sty (loaded by xintcore.sty)
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\XINT_providespackage
\ProvidesPackage{xint}%
  [2015/11/18 v1.2d Expandable operations on big integers (jfB)]%
%    \end{macrocode}
% \subsection{More token management}
%    \begin{macrocode}
\long\def\xint_firstofthree  #1#2#3{#1}%
\long\def\xint_secondofthree #1#2#3{#2}%
\long\def\xint_thirdofthree  #1#2#3{#3}%
\long\def\xint_firstofthree_thenstop  #1#2#3{ #1}% 1.09i
\long\def\xint_secondofthree_thenstop #1#2#3{ #2}%
\long\def\xint_thirdofthree_thenstop  #1#2#3{ #3}%
\edef\xint_cleanupzeros_andstop #1#2#3#4%
{%
    \noexpand\expandafter\space\noexpand\the\numexpr #1#2#3#4\relax
}%
%    \end{macrocode}
% \subsection{\csh{xintSgnFork}}
% \lverb|Expandable three-way fork added in 1.07. The argument #1 must expand
% to non-self-ending -1,0 or 1. 1.09i with _thenstop.|
%    \begin{macrocode}
\def\xintSgnFork {\romannumeral0\xintsgnfork }%
\def\xintsgnfork #1%
{%
    \ifcase #1 \expandafter\xint_secondofthree_thenstop
            \or\expandafter\xint_thirdofthree_thenstop
          \else\expandafter\xint_firstofthree_thenstop
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintIsOne}, \csh{xintiiIsOne}}
% \lverb|Added in 1.03. 1.09a defines \xintIsOne. 1.1a adds \xintiiIsOne.|
%    \begin{macrocode}
\def\xintiiIsOne   {\romannumeral0\xintiiisone }%
\def\xintiiisone #1{\expandafter\XINT_isone\romannumeral`&&@#1\W\Z }%
\def\xintIsOne   {\romannumeral0\xintisone }%
\def\xintisone #1{\expandafter\XINT_isone\romannumeral0\xintnum{#1}\W\Z }%
\def\XINT_isOne #1{\romannumeral0\XINT_isone #1\W\Z }%
\def\XINT_isone #1#2%
{%
    \xint_gob_til_one #1\XINT_isone_b 1%
    \expandafter\space\expandafter 0\xint_gob_til_Z #2%
}%
\def\XINT_isone_b #1\xint_gob_til_Z #2%
{%
    \xint_gob_til_W #2\XINT_isone_yes \W
    \expandafter\space\expandafter 0\xint_gob_til_Z
}%
\def\XINT_isone_yes #1\Z { 1}%
%    \end{macrocode}
% \subsection{\csh{xintRev}}
% \lverb|&
% \xintRev: expands fully its argument \romannumeral-`0, and checks the sign.
% However this last aspect does not appear like a very useful thing. And despite
% the fact that a special check is made for a sign, actually the input is not
% given to \xintnum, contrarily to \xintLen. This is all a bit incoherent.
% Should be fixed.
%
% 1.2 has \xintReverseDigits and I thus make \xintRev an alias. Remarks above
% not addressed.|
%    \begin{macrocode}
\let\xintRev\xintReverseDigits
%    \end{macrocode}
% \subsection{\csh{xintLen}}
% \lverb|\xintLen is ONLY for (possibly long) integers. Gets extended to
% fractions by xintfrac.sty|
%    \begin{macrocode}
\def\xintLen {\romannumeral0\xintlen }%
\def\xintlen #1%
{%
    \expandafter\XINT_len_fork
    \romannumeral0\xintnum{#1}\xint_relax\xint_relax\xint_relax\xint_relax
                      \xint_relax\xint_relax\xint_relax\xint_relax\xint_bye
}%
\def\XINT_Len #1% variant which does not expand via \xintnum.
{%
    \romannumeral0\XINT_len_fork
    #1\xint_relax\xint_relax\xint_relax\xint_relax
      \xint_relax\xint_relax\xint_relax\xint_relax\xint_bye
}%
\def\XINT_len_fork #1%
{%
    \expandafter\XINT_length_loop
    \xint_UDsignfork
      #1{0.}%
       -{0.#1}%
    \krof
}%
%    \end{macrocode}
% \subsection{\csh{xintBool}, \csh{xintToggle}}
% \lverb|1.09c|
%    \begin{macrocode}
\def\xintBool #1{\romannumeral`&&@%
                 \csname if#1\endcsname\expandafter1\else\expandafter0\fi }%
\def\xintToggle #1{\romannumeral`&&@\iftoggle{#1}{1}{0}}%
%    \end{macrocode}
% \subsection{\csh{xintifSgn}, \csh{xintiiifSgn}}
% \lverb|Expandable three-way fork added in 1.09a. Branches expandably
% depending on whether <0, =0, >0. Choice of branch guaranteed in two steps.
%
% 1.09i has \xint_firstofthreeafterstop (now _thenstop) etc for faster
% expansion.
%
% 1.1 adds \xintiiifSgn for optimization in xintexpr-essions. Should I move
% them to xintcore? (for bnumexpr)|
%    \begin{macrocode}
\def\xintifSgn {\romannumeral0\xintifsgn }%
\def\xintifsgn #1%
{%
    \ifcase \xintSgn{#1}
               \expandafter\xint_secondofthree_thenstop
            \or\expandafter\xint_thirdofthree_thenstop
          \else\expandafter\xint_firstofthree_thenstop
    \fi
}%
\def\xintiiifSgn {\romannumeral0\xintiiifsgn }%
\def\xintiiifsgn #1%
{%
    \ifcase \xintiiSgn{#1}
               \expandafter\xint_secondofthree_thenstop
            \or\expandafter\xint_thirdofthree_thenstop
          \else\expandafter\xint_firstofthree_thenstop
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintifZero}, \csh{xintifNotZero}, \csh{xintiiifZero}, \csh{xintiiifNotZero}}
% \lverb|Expandable two-way fork added in 1.09a. Branches expandably depending on
% whether the argument is zero (branch A) or not (branch B). 1.09i restyling. By
% the way it appears (not thoroughly tested, though) that \if tests are faster
% than \ifnum tests. 1.1 adds ii  versions.|
%    \begin{macrocode}
\def\xintifZero {\romannumeral0\xintifzero }%
\def\xintifzero #1%
{%
    \if0\xintSgn{#1}%
       \expandafter\xint_firstoftwo_thenstop
    \else
       \expandafter\xint_secondoftwo_thenstop
    \fi
}%
\def\xintifNotZero {\romannumeral0\xintifnotzero }%
\def\xintifnotzero #1%
{%
    \if0\xintSgn{#1}%
       \expandafter\xint_secondoftwo_thenstop
    \else
       \expandafter\xint_firstoftwo_thenstop
    \fi
}%
\def\xintiiifZero {\romannumeral0\xintiiifzero }%
\def\xintiiifzero #1%
{%
    \if0\xintiiSgn{#1}%
       \expandafter\xint_firstoftwo_thenstop
    \else
       \expandafter\xint_secondoftwo_thenstop
    \fi
}%
\def\xintiiifNotZero {\romannumeral0\xintiiifnotzero }%
\def\xintiiifnotzero #1%
{%
    \if0\xintiiSgn{#1}%
       \expandafter\xint_secondoftwo_thenstop
    \else
       \expandafter\xint_firstoftwo_thenstop
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintifOne},\csh{xintiiifOne}}
% \lverb|added in 1.09i. 1.1a adds \xintiiifOne.|
%    \begin{macrocode}
\def\xintiiifOne {\romannumeral0\xintiiifone }%
\def\xintiiifone #1%
{%
    \if1\xintiiIsOne{#1}%
       \expandafter\xint_firstoftwo_thenstop
    \else
       \expandafter\xint_secondoftwo_thenstop
    \fi
}%
\def\xintifOne {\romannumeral0\xintifone }%
\def\xintifone #1%
{%
    \if1\xintIsOne{#1}%
       \expandafter\xint_firstoftwo_thenstop
    \else
       \expandafter\xint_secondoftwo_thenstop
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintifTrueAelseB}, \csh{xintifFalseAelseB}}
% \lverb|1.09i. Warning, \xintifTrueFalse, \xintifTrue deprecated, to be
% removed|
%    \begin{macrocode}
\let\xintifTrueAelseB\xintifNotZero
\let\xintifFalseAelseB\xintifZero
\let\xintifTrue\xintifNotZero
\let\xintifTrueFalse\xintifNotZero
%    \end{macrocode}
% \subsection{\csh{xintifCmp}, \csh{xintiiifCmp}}
% \lverb|1.09e
% \xintifCmp {n}{m}{if n<m}{if n=m}{if n>m}. 1.1a adds ii variant|
%    \begin{macrocode}
\def\xintifCmp {\romannumeral0\xintifcmp }%
\def\xintifcmp #1#2%
{%
    \ifcase\xintCmp {#1}{#2}
               \expandafter\xint_secondofthree_thenstop
            \or\expandafter\xint_thirdofthree_thenstop
          \else\expandafter\xint_firstofthree_thenstop
    \fi
}%
\def\xintiiifCmp {\romannumeral0\xintiiifcmp }%
\def\xintiiifcmp #1#2%
{%
    \ifcase\xintiiCmp {#1}{#2}
               \expandafter\xint_secondofthree_thenstop
            \or\expandafter\xint_thirdofthree_thenstop
          \else\expandafter\xint_firstofthree_thenstop
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintifEq}, \csh{xintiiifEq}}
% \lverb|1.09a \xintifEq {n}{m}{YES if n=m}{NO if n<>m}. 1.1a adds ii variant|
%    \begin{macrocode}
\def\xintifEq {\romannumeral0\xintifeq }%
\def\xintifeq #1#2%
{%
    \if0\xintCmp{#1}{#2}%
               \expandafter\xint_firstoftwo_thenstop
          \else\expandafter\xint_secondoftwo_thenstop
    \fi
}%
\def\xintiiifEq {\romannumeral0\xintiiifeq }%
\def\xintiiifeq #1#2%
{%
    \if0\xintiiCmp{#1}{#2}%
               \expandafter\xint_firstoftwo_thenstop
          \else\expandafter\xint_secondoftwo_thenstop
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintifGt}, \csh{xintiiifGt}}
% \lverb|1.09a \xintifGt {n}{m}{YES if n>m}{NO if n<=m}. 1.1a adds ii variant|
%    \begin{macrocode}
\def\xintifGt {\romannumeral0\xintifgt }%
\def\xintifgt #1#2%
{%
    \if1\xintCmp{#1}{#2}%
               \expandafter\xint_firstoftwo_thenstop
          \else\expandafter\xint_secondoftwo_thenstop
    \fi
}%
\def\xintiiifGt {\romannumeral0\xintiiifgt }%
\def\xintiiifgt #1#2%
{%
    \if1\xintiiCmp{#1}{#2}%
               \expandafter\xint_firstoftwo_thenstop
          \else\expandafter\xint_secondoftwo_thenstop
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintifLt}, \csh{xintiiifLt}}
% \lverb|1.09a \xintifLt {n}{m}{YES if n<m}{NO if n>=m}. Restyled in 1.09i.
% 1.1a adds ii variant|
%    \begin{macrocode}
\def\xintifLt {\romannumeral0\xintiflt }%
\def\xintiflt #1#2%
{%
    \ifnum\xintCmp{#1}{#2}<\xint_c_
          \expandafter\xint_firstoftwo_thenstop
    \else \expandafter\xint_secondoftwo_thenstop
    \fi
}%
\def\xintiiifLt {\romannumeral0\xintiiiflt }%
\def\xintiiiflt #1#2%
{%
    \ifnum\xintiiCmp{#1}{#2}<\xint_c_
          \expandafter\xint_firstoftwo_thenstop
    \else \expandafter\xint_secondoftwo_thenstop
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintifOdd}, \csh{xintiiifOdd}}
% \lverb|1.09e. Restyled in 1.09i. 1.1a adds \xintiiifOdd.|
%    \begin{macrocode}
\def\xintiiifOdd {\romannumeral0\xintiiifodd }%
\def\xintiiifodd #1%
{%
    \if\xintiiOdd{#1}1%
       \expandafter\xint_firstoftwo_thenstop
    \else
       \expandafter\xint_secondoftwo_thenstop
    \fi
}%
\def\xintifOdd {\romannumeral0\xintifodd }%
\def\xintifodd #1%
{%
    \if\xintOdd{#1}1%
       \expandafter\xint_firstoftwo_thenstop
    \else
       \expandafter\xint_secondoftwo_thenstop
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintCmp}, \csh{xintiiCmp}}
% \lverb|Faster than doing the full subtraction.|
%    \begin{macrocode}
\def\xintCmp    {\romannumeral0\xintcmp }%
\def\xintcmp   #1{\expandafter\XINT_icmp\romannumeral0\xintnum{#1}\Z }%
\def\xintiiCmp   {\romannumeral0\xintiicmp }%
\def\xintiicmp #1{\expandafter\XINT_iicmp\romannumeral`&&@#1\Z  }%
\def\XINT_iicmp #1#2\Z #3%
{%
    \expandafter\XINT_cmp_nfork\expandafter #1\romannumeral`&&@#3\Z #2\Z
}%
%    \end{macrocode}
% \lverb|New fork of 1.2 makes it less convenient here for \XINT_cmp_pre and
% \XINT_Cmp, which just avoided the \romannumeral-`0. Nanosecond loss ? I
% vaguely recalled that for \xintNewExpr things, I did need another name such
% as \XINT_cmp for \xintiiCmp.|
%    \begin{macrocode}
\let\XINT_Cmp    \xintiiCmp
\def\XINT_icmp #1#2\Z #3%
{%
    \expandafter\XINT_cmp_nfork\expandafter #1\romannumeral0\xintnum{#3}\Z #2\Z
}%
\def\XINT_cmp_nfork #1#2%
{%
    \xint_UDzerofork
      #1\XINT_cmp_firstiszero
      #2\XINT_cmp_secondiszero
       0{}%
    \krof
    \xint_UDsignsfork
          #1#2\XINT_cmp_minusminus
           #1-\XINT_cmp_minusplus
           #2-\XINT_cmp_plusminus
            --\XINT_cmp_plusplus
    \krof #1#2%
}%
\def\XINT_cmp_firstiszero  #1\krof 0#2#3\Z #4\Z
{%
    \xint_UDzerominusfork
      #2-{ 0}%
      0#2{ 1}%
       0-{ -1}%
    \krof
}%    
\def\XINT_cmp_secondiszero #1\krof #20#3\Z #4\Z
{%
    \xint_UDzerominusfork
      #2-{ 0}%
      0#2{ -1}%
       0-{ 1}%
    \krof
}%    
\def\XINT_cmp_plusminus    #1\Z #2\Z{ 1}%
\def\XINT_cmp_minusplus    #1\Z #2\Z{ -1}%
\def\XINT_cmp_minusminus 
    --{\expandafter\XINT_opp\romannumeral0\XINT_cmp_plusplus {}{}}%
\def\XINT_cmp_plusplus  #1#2#3\Z 
{%
  \expandafter\XINT_cmp_pp
      \romannumeral0\expandafter\XINT_sepandrev_andcount
      \romannumeral0\XINT_zeroes_forviii #2#3\R\R\R\R\R\R\R\R{10}0000001\W
      #2#3\XINT_rsepbyviii_end_A 2345678%
        \XINT_rsepbyviii_end_B 2345678\relax\xint_c_ii\xint_c_iii
      \R.\xint_c_vi\R.\xint_c_v\R.\xint_c_iv\R.\xint_c_iii
      \R.\xint_c_ii\R.\xint_c_i\R.\xint_c_\W
  \X #1%
}%
\def\XINT_cmp_pp #1.#2\X #3\Z
{%
    \expandafter\XINT_cmp_checklengths
    \the\numexpr #1\expandafter.%
    \romannumeral0\expandafter\XINT_sepandrev_andcount
    \romannumeral0\XINT_zeroes_forviii #3\R\R\R\R\R\R\R\R{10}0000001\W
    #3\XINT_rsepbyviii_end_A 2345678%
      \XINT_rsepbyviii_end_B 2345678\relax \xint_c_ii\xint_c_iii
      \R.\xint_c_vi\R.\xint_c_v\R.\xint_c_iv\R.\xint_c_iii
      \R.\xint_c_ii\R.\xint_c_i\R.\xint_c_\W
    \Z!\Z!\Z!\Z!\Z!\W #2\Z!\Z!\Z!\Z!\Z!\W
}%
\def\XINT_cmp_checklengths #1.#2.% 
{%
    \ifnum #1=#2
       \expandafter\xint_firstoftwo
    \else
       \expandafter\xint_secondoftwo
    \fi
    \XINT_cmp_aa {\XINT_cmp_distinctlengths {#1}{#2}}%
}%
\def\XINT_cmp_distinctlengths #1#2#3\W #4\W
{%
    \ifnum #1>#2
        \expandafter\xint_firstoftwo
    \else
        \expandafter\xint_secondoftwo
    \fi
    { -1}{ 1}%
}%
%%%%%%%%%%%%
\def\XINT_cmp_aa {\expandafter\XINT_cmp_w\the\numexpr\XINT_cmp_a \xint_c_i }%
%%%%%%%%%%%%
\def\XINT_cmp_a #1!#2!#3!#4!#5\W #6!#7!#8!#9!%
{%
    \XINT_cmp_b #1!#6!#2!#7!#3!#8!#4!#9!#5\W
}%
\def\XINT_cmp_b #1#2#3!#4!%
{%
    \xint_gob_til_Z #2\XINT_cmp_bi \Z
    \expandafter\XINT_cmp_c\the\numexpr#1+1#4-#3-\xint_c_i.%
}%
\def\XINT_cmp_c 1#1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_cmp_d #1%
}%
\def\XINT_cmp_d #1#2#3!#4!%
{%
    \xint_gob_til_Z #2\XINT_cmp_di \Z
    \expandafter\XINT_cmp_e\the\numexpr#1+1#4-#3-\xint_c_i.%
}%
\def\XINT_cmp_e 1#1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_cmp_f #1%
}%
\def\XINT_cmp_f #1#2#3!#4!%
{%
    \xint_gob_til_Z #2\XINT_cmp_fi \Z
    \expandafter\XINT_cmp_g\the\numexpr#1+1#4-#3-\xint_c_i.%
}%
\def\XINT_cmp_g 1#1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_cmp_h #1%
}%
\def\XINT_cmp_h #1#2#3!#4!%
{%
    \xint_gob_til_Z #2\XINT_cmp_hi \Z
    \expandafter\XINT_cmp_i\the\numexpr#1+1#4-#3-\xint_c_i.%
}%
\def\XINT_cmp_i 1#1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_cmp_a #1%
}%
\def\XINT_cmp_bi\Z
    \expandafter\XINT_cmp_c\the\numexpr#1+1#2-#3.#4!#5!#6!#7!#8!#9!\Z !\W
{%
    \XINT_cmp_k #1#2!#5!#7!#9!%
}%
\def\XINT_cmp_di\Z
    \expandafter\XINT_cmp_e\the\numexpr#1+1#2-#3.#4!#5!#6!#7!#8\W
{%
    \XINT_cmp_k #1#2!#5!#7!%
}%
\def\XINT_cmp_fi\Z
    \expandafter\XINT_cmp_g\the\numexpr#1+1#2-#3.#4!#5!#6\W
{%
    \XINT_cmp_k #1#2!#5!%
}%
\def\XINT_cmp_hi\Z
    \expandafter\XINT_cmp_i\the\numexpr#1+1#2-#3.#4\W
{%
    \XINT_cmp_k #1#2!%
}%
%%%%%%%%%%%%
\def\XINT_cmp_k #1#2\W
{%
   \xint_UDzerofork
      #1{-1\relax \XINT_cmp_greater}%
       0{-1\relax \XINT_cmp_lessorequal}%
   \krof
}%
\def\XINT_cmp_w #1-1#2{#2#11\Z!\W}%
\def\XINT_cmp_greater #1\Z!\W{ 1}%
\def\XINT_cmp_lessorequal 1#1!%
    {\xint_gob_til_Z #1\XINT_cmp_equal\Z
     \xint_gob_til_eightzeroes #1\XINT_cmp_continue 00000000%
     \XINT_cmp_less }%
\def\XINT_cmp_less #1\W { -1}%
\def\XINT_cmp_continue 00000000\XINT_cmp_less {\XINT_cmp_lessorequal }%
\def\XINT_cmp_equal\Z\xint_gob_til_eightzeroes\Z\XINT_cmp_continue
    00000000\XINT_cmp_less\W { 0}%
%    \end{macrocode}
% \subsection{\csh{xintEq}, \csh{xintGt}, \csh{xintLt}}
% \lverb|1.09a.|
%    \begin{macrocode}
\def\xintEq {\romannumeral0\xinteq }\def\xinteq #1#2{\xintifeq{#1}{#2}{1}{0}}%
\def\xintGt {\romannumeral0\xintgt }\def\xintgt #1#2{\xintifgt{#1}{#2}{1}{0}}%
\def\xintLt {\romannumeral0\xintlt }\def\xintlt #1#2{\xintiflt{#1}{#2}{1}{0}}%
%    \end{macrocode}
% \subsection{\csh{xintNeq}, \csh{xintGtorEq}, \csh{xintLtorEq}}
% \lverb|1.1. Pour xintexpr. No lowercase macros|
%    \begin{macrocode}
\def\xintLtorEq #1#2{\romannumeral0\xintifgt {#1}{#2}{0}{1}}%
\def\xintGtorEq #1#2{\romannumeral0\xintiflt {#1}{#2}{0}{1}}%
\def\xintNeq    #1#2{\romannumeral0\xintifeq {#1}{#2}{0}{1}}%
%    \end{macrocode}
% \subsection{\csh{xintiiEq}, \csh{xintiiGt}, \csh{xintiiLt}}
% \lverb|1.1a Pour \xintiiexpr. No lowercase macros.|
%    \begin{macrocode}
\def\xintiiEq #1#2{\romannumeral0\xintiiifeq{#1}{#2}{1}{0}}%
\def\xintiiGt #1#2{\romannumeral0\xintiiifgt{#1}{#2}{1}{0}}%
\def\xintiiLt #1#2{\romannumeral0\xintiiiflt{#1}{#2}{1}{0}}%
%    \end{macrocode}
% \subsection{\csh{xintiiNeq}, \csh{xintiiGtorEq}, \csh{xintiiLtorEq}}
% \lverb|1.1a. Pour \xintiiexpr. No lowercase macros.|
%    \begin{macrocode}
\def\xintiiLtorEq #1#2{\romannumeral0\xintiiifgt {#1}{#2}{0}{1}}%
\def\xintiiGtorEq #1#2{\romannumeral0\xintiiiflt {#1}{#2}{0}{1}}%
\def\xintiiNeq    #1#2{\romannumeral0\xintiiifeq {#1}{#2}{0}{1}}%
%    \end{macrocode}
% \subsection{\csh{xintIsZero}, \csh{xintIsNotZero}, \csh{xintiiIsZero},
% \csh{xintiiIsNotZero}}
% \lverb|1.09a. restyled in 1.09i. 1.1 adds \xintiiIsZero, etc... for
% optimization in \xintexpr|
%    \begin{macrocode}
\def\xintIsZero {\romannumeral0\xintiszero }%
\def\xintiszero #1{\if0\xintSgn{#1}\xint_afterfi{ 1}\else\xint_afterfi{ 0}\fi}%
\def\xintIsNotZero {\romannumeral0\xintisnotzero }%
\def\xintisnotzero
          #1{\if0\xintSgn{#1}\xint_afterfi{ 0}\else\xint_afterfi{ 1}\fi}%
\def\xintiiIsZero {\romannumeral0\xintiiiszero }%
\def\xintiiiszero #1{\if0\xintiiSgn{#1}\xint_afterfi{ 1}\else\xint_afterfi{ 0}\fi}%
\def\xintiiIsNotZero {\romannumeral0\xintiiisnotzero }%
\def\xintiiisnotzero
          #1{\if0\xintiiSgn{#1}\xint_afterfi{ 0}\else\xint_afterfi{ 1}\fi}%
%    \end{macrocode}
% \subsection{\csh{xintIsTrue}, \csh{xintNot}, \csh{xintIsFalse}}
% \lverb|1.09c|
%    \begin{macrocode}
\let\xintIsTrue\xintIsNotZero
\let\xintNot\xintIsZero
\let\xintIsFalse\xintIsZero
%    \end{macrocode}
% \subsection{\csh{xintAND}, \csh{xintOR}, \csh{xintXOR}}
% \lverb|1.09a. Embarrasing bugs in \xintAND and \xintOR which inserted a space
% token corrected in 1.09i. \xintxor restyled with \if (faster) in 1.09i|
%    \begin{macrocode}
\def\xintAND {\romannumeral0\xintand }%
\def\xintand #1#2{\if0\xintSgn{#1}\expandafter\xint_firstoftwo
                             \else\expandafter\xint_secondoftwo\fi
                  { 0}{\xintisnotzero{#2}}}%
\def\xintOR {\romannumeral0\xintor }%
\def\xintor #1#2{\if0\xintSgn{#1}\expandafter\xint_firstoftwo
                            \else\expandafter\xint_secondoftwo\fi
                 {\xintisnotzero{#2}}{ 1}}%
\def\xintXOR {\romannumeral0\xintxor }%
\def\xintxor #1#2{\if\xintIsZero{#1}\xintIsZero{#2}%
                     \xint_afterfi{ 0}\else\xint_afterfi{ 1}\fi }%
%    \end{macrocode}
% \subsection{\csh{xintANDof}}
% \lverb|New with 1.09a. \xintANDof works also with an empty list.|
%    \begin{macrocode}
\def\xintANDof      {\romannumeral0\xintandof }%
\def\xintandof    #1{\expandafter\XINT_andof_a\romannumeral`&&@#1\relax }%
\def\XINT_andof_a #1{\expandafter\XINT_andof_b\romannumeral`&&@#1\Z }%
\def\XINT_andof_b #1%
           {\xint_gob_til_relax #1\XINT_andof_e\relax\XINT_andof_c #1}%
\def\XINT_andof_c #1\Z
           {\xintifTrueAelseB {#1}{\XINT_andof_a}{\XINT_andof_no}}%
\def\XINT_andof_no #1\relax { 0}%
\def\XINT_andof_e #1\Z { 1}%
%    \end{macrocode}
% \subsection{\csh{xintORof}}
% \lverb|New with 1.09a. Works also with an empty list.|
%    \begin{macrocode}
\def\xintORof      {\romannumeral0\xintorof }%
\def\xintorof    #1{\expandafter\XINT_orof_a\romannumeral`&&@#1\relax }%
\def\XINT_orof_a #1{\expandafter\XINT_orof_b\romannumeral`&&@#1\Z }%
\def\XINT_orof_b #1%
           {\xint_gob_til_relax #1\XINT_orof_e\relax\XINT_orof_c #1}%
\def\XINT_orof_c #1\Z
           {\xintifTrueAelseB {#1}{\XINT_orof_yes}{\XINT_orof_a}}%
\def\XINT_orof_yes #1\relax { 1}%
\def\XINT_orof_e #1\Z { 0}%
%    \end{macrocode}
% \subsection{\csh{xintXORof}}
% \lverb|New with 1.09a. Works with an empty list, too. \XINT_xorof_c more
% efficient in 1.09i|
%    \begin{macrocode}
\def\xintXORof      {\romannumeral0\xintxorof }%
\def\xintxorof    #1{\expandafter\XINT_xorof_a\expandafter
                     0\romannumeral`&&@#1\relax }%
\def\XINT_xorof_a #1#2{\expandafter\XINT_xorof_b\romannumeral`&&@#2\Z #1}%
\def\XINT_xorof_b #1%
           {\xint_gob_til_relax #1\XINT_xorof_e\relax\XINT_xorof_c #1}%
\def\XINT_xorof_c #1\Z #2%
           {\xintifTrueAelseB {#1}{\if #20\xint_afterfi{\XINT_xorof_a 1}%
                                   \else\xint_afterfi{\XINT_xorof_a 0}\fi}%
                                  {\XINT_xorof_a #2}%
           }%
\def\XINT_xorof_e #1\Z #2{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintGeq}, \csh{xintiiGeq}}
% \lverb|&
% PLUS GRAND OU GAL
% attention compare les **valeurs absolues**|
%    \begin{macrocode}
\def\xintGeq    {\romannumeral0\xintgeq }%
\def\xintgeq   #1{\expandafter\XINT_geq\romannumeral0\xintnum{#1}\Z }%
\def\xintiiGeq   {\romannumeral0\xintiigeq }%
\def\xintiigeq #1{\expandafter\XINT_iigeq\romannumeral`&&@#1\Z  }%
\def\XINT_iigeq #1#2\Z #3%
{%
    \expandafter\XINT_geq_fork\expandafter #1\romannumeral`&&@#3\Z #2\Z
}%
\let\XINT_geq_pre \xintiigeq % TEMPORAIRE
\let\XINT_Geq \xintGeq       % TEMPORAIRE ATTENTION FAIT xintNum
\def\XINT_geq #1#2\Z #3%
{%
    \expandafter\XINT_geq_fork\expandafter #1\romannumeral0\xintnum{#3}\Z #2\Z
}%
\def\XINT_geq_fork #1#2%
{%
    \xint_UDzerofork
      #1\XINT_geq_firstiszero
      #2\XINT_geq_secondiszero
       0{}%
    \krof
    \xint_UDsignsfork
          #1#2\XINT_geq_minusminus
           #1-\XINT_geq_minusplus
           #2-\XINT_geq_plusminus
            --\XINT_geq_plusplus
    \krof #1#2%
}%
\def\XINT_geq_firstiszero  #1\krof 0#2#3\Z #4\Z 
                              {\xint_UDzerofork #2{ 1}0{ 0}\krof }%
\def\XINT_geq_secondiszero #1\krof #20#3\Z #4\Z { 1}%
\def\XINT_geq_plusminus    #1-{\XINT_geq_plusplus #1{}}%
\def\XINT_geq_minusplus    -#1{\XINT_geq_plusplus {}#1}%
\def\XINT_geq_minusminus    --{\XINT_geq_plusplus  {}{}}%
\def\XINT_geq_plusplus #1#2#3\Z #4\Z {\XINT_geq_pp #1#4\Z #2#3\Z }%
\def\XINT_geq_pp #1\Z
{%
  \expandafter\XINT_geq_pp_a
      \romannumeral0\expandafter\XINT_sepandrev_andcount
      \romannumeral0\XINT_zeroes_forviii #1\R\R\R\R\R\R\R\R{10}0000001\W
      #1\XINT_rsepbyviii_end_A 2345678%
        \XINT_rsepbyviii_end_B 2345678\relax\xint_c_ii\xint_c_iii
      \R.\xint_c_vi\R.\xint_c_v\R.\xint_c_iv\R.\xint_c_iii
      \R.\xint_c_ii\R.\xint_c_i\R.\xint_c_\W
  \X
}%
\def\XINT_geq_pp_a #1.#2\X #3\Z
{%
    \expandafter\XINT_geq_checklengths
    \the\numexpr #1\expandafter.%
    \romannumeral0\expandafter\XINT_sepandrev_andcount
    \romannumeral0\XINT_zeroes_forviii #3\R\R\R\R\R\R\R\R{10}0000001\W
    #3\XINT_rsepbyviii_end_A 2345678%
      \XINT_rsepbyviii_end_B 2345678\relax \xint_c_ii\xint_c_iii
      \R.\xint_c_vi\R.\xint_c_v\R.\xint_c_iv\R.\xint_c_iii
      \R.\xint_c_ii\R.\xint_c_i\R.\xint_c_\W
    \Z!\Z!\Z!\Z!\Z!\W #2\Z!\Z!\Z!\Z!\Z!\W
}%
\def\XINT_geq_checklengths #1.#2.% 
{%
    \ifnum #1=#2
       \expandafter\xint_firstoftwo
    \else
       \expandafter\xint_secondoftwo
    \fi
    \XINT_geq_aa {\XINT_geq_distinctlengths {#1}{#2}}
}%
\def\XINT_geq_distinctlengths #1#2#3\W #4\W
{%
    \ifnum #1>#2
        \expandafter\xint_firstoftwo
    \else
        \expandafter\xint_secondoftwo
    \fi
    { 1}{ 0}%
}%
%%%%%%%%%%%%
\def\XINT_geq_aa {\expandafter\XINT_geq_w\the\numexpr\XINT_geq_a \xint_c_i }%
%%%%%%%%%%%%
\def\XINT_geq_a #1!#2!#3!#4!#5\W #6!#7!#8!#9!%
{%
    \XINT_geq_b #1!#6!#2!#7!#3!#8!#4!#9!#5\W
}%
\def\XINT_geq_b #1#2#3!#4!%
{%
    \xint_gob_til_Z #2\XINT_geq_bi \Z
    \expandafter\XINT_geq_c\the\numexpr#1+1#4-#3-\xint_c_i.%
}%
\def\XINT_geq_c 1#1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_geq_d #1%
}%
\def\XINT_geq_d #1#2#3!#4!%
{%
    \xint_gob_til_Z #2\XINT_geq_di \Z
    \expandafter\XINT_geq_e\the\numexpr#1+1#4-#3-\xint_c_i.%
}%
\def\XINT_geq_e 1#1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_geq_f #1%
}%
\def\XINT_geq_f #1#2#3!#4!%
{%
    \xint_gob_til_Z #2\XINT_geq_fi \Z
    \expandafter\XINT_geq_g\the\numexpr#1+1#4-#3-\xint_c_i.%
}%
\def\XINT_geq_g 1#1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_geq_h #1%
}%
\def\XINT_geq_h #1#2#3!#4!%
{%
    \xint_gob_til_Z #2\XINT_geq_hi \Z
    \expandafter\XINT_geq_i\the\numexpr#1+1#4-#3-\xint_c_i.%
}%
\def\XINT_geq_i 1#1#2.%
{%
    1#2\expandafter!\the\numexpr\XINT_geq_a #1%
}%
\def\XINT_geq_bi\Z
    \expandafter\XINT_geq_c\the\numexpr#1+1#2-#3.#4!#5!#6!#7!#8!#9!\Z !\W
{%
    \XINT_geq_k #1#2!#5!#7!#9!%
}%
\def\XINT_geq_di\Z
    \expandafter\XINT_geq_e\the\numexpr#1+1#2-#3.#4!#5!#6!#7!#8\W
{%
    \XINT_geq_k #1#2!#5!#7!%
}%
\def\XINT_geq_fi\Z
    \expandafter\XINT_geq_g\the\numexpr#1+1#2-#3.#4!#5!#6\W
{%
    \XINT_geq_k #1#2!#5!%
}%
\def\XINT_geq_hi\Z
    \expandafter\XINT_geq_i\the\numexpr#1+1#2-#3.#4\W
{%
    \XINT_geq_k #1#2!%
}%
%%%%%%%%%%%%
\def\XINT_geq_k #1#2\W
{%
   \xint_UDzerofork
      #1{-1\relax { 0}}%
       0{-1\relax { 1}}%
   \krof
}%
\def\XINT_geq_w #1-1#2{#2}%
%    \end{macrocode}
% \subsection{\csh{xintiMax}, \csh{xintiiMax}}
% \lverb|&
% The rationale is that it is more efficient than using \xintCmp.
% 1.03 makes the code a tiny bit slower but easier to re-use for fractions.
% Note: actually since 1.08a code for fractions does not all reduce to these
% entry points, so perhaps I should revert the changes made in 1.03. Release
% 1.09a has \xintnum added into \xintiMax.
%
% 1.1 adds the missing \xintiiMax. Using \xintMax and not \xintiMax in xint is
% deprecated.
%
% 1.2 REMOVES \xintMax, \xintMin, \xintMaxof, \xintMinof.|
%    \begin{macrocode}
\def\xintiMax {\romannumeral0\xintimax }%
\def\xintimax #1%
{%
    \expandafter\xint_max\expandafter {\romannumeral0\xintnum{#1}}%
}%
\def\xint_max #1#2%
{%
    \expandafter\XINT_max_pre\expandafter {\romannumeral0\xintnum{#2}}{#1}%
}%
\def\xintiiMax {\romannumeral0\xintiimax }%
\def\xintiimax #1%
{%
    \expandafter\xint_iimax\expandafter {\romannumeral`&&@#1}%
}%
\def\xint_iimax #1#2%
{%
    \expandafter\XINT_max_pre\expandafter {\romannumeral`&&@#2}{#1}%
}%
\def\XINT_max_pre #1#2{\XINT_max_fork #1\Z #2\Z {#2}{#1}}%
\def\XINT_Max #1#2{\romannumeral0\XINT_max_fork #2\Z #1\Z {#1}{#2}}%
%    \end{macrocode}
% \lverb|&
% #3#4 vient du *premier*,
% #1#2 vient du *second*|
%    \begin{macrocode}
\def\XINT_max_fork #1#2\Z #3#4\Z
{%
    \xint_UDsignsfork
          #1#3\XINT_max_minusminus  % A < 0, B < 0
           #1-\XINT_max_minusplus   % B < 0, A >= 0
           #3-\XINT_max_plusminus   % A < 0, B >= 0
            --{\xint_UDzerosfork
                      #1#3\XINT_max_zerozero % A = B = 0
                       #10\XINT_max_zeroplus % B = 0, A > 0
                       #30\XINT_max_pluszero % A = 0, B > 0
                        00\XINT_max_plusplus % A, B > 0
                      \krof }%
    \krof
    {#2}{#4}#1#3%
}%
%    \end{macrocode}
% \lverb|&
% A = #4#2, B = #3#1|
%    \begin{macrocode}
\def\XINT_max_zerozero  #1#2#3#4{\xint_firstoftwo_thenstop }%
\def\XINT_max_zeroplus  #1#2#3#4{\xint_firstoftwo_thenstop }%
\def\XINT_max_pluszero  #1#2#3#4{\xint_secondoftwo_thenstop }%
\def\XINT_max_minusplus #1#2#3#4{\xint_firstoftwo_thenstop }%
\def\XINT_max_plusminus #1#2#3#4{\xint_secondoftwo_thenstop }%
\def\XINT_max_plusplus  #1#2#3#4%
{%
    \ifodd\XINT_Geq {#4#2}{#3#1}
      \expandafter\xint_firstoftwo_thenstop
    \else
      \expandafter\xint_secondoftwo_thenstop
    \fi
}%
%    \end{macrocode}
% \lverb+#3=-, #4=-, #1 = |B| = -B, #2 = |A| = -A+
%    \begin{macrocode}
\def\XINT_max_minusminus #1#2#3#4%
{%
    \ifodd\XINT_Geq {#1}{#2}
      \expandafter\xint_firstoftwo_thenstop
    \else
      \expandafter\xint_secondoftwo_thenstop
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintiMaxof}, \csh{xintiiMaxof}}
% \lverb|New with 1.09a. 1.2 has NO MORE \xintMaxof, requires \xintfracname.
% 1.2a adds \xintiiMaxof, as \xintiiMaxof:csv is not public.|
%    \begin{macrocode}
\def\xintiMaxof      {\romannumeral0\xintimaxof }%
\def\xintimaxof    #1{\expandafter\XINT_imaxof_a\romannumeral`&&@#1\relax }%
\def\XINT_imaxof_a #1{\expandafter\XINT_imaxof_b\romannumeral0\xintnum{#1}\Z }%
\def\XINT_imaxof_b #1\Z #2%
           {\expandafter\XINT_imaxof_c\romannumeral`&&@#2\Z {#1}\Z}%
\def\XINT_imaxof_c #1%
           {\xint_gob_til_relax #1\XINT_imaxof_e\relax\XINT_imaxof_d #1}%
\def\XINT_imaxof_d #1\Z
           {\expandafter\XINT_imaxof_b\romannumeral0\xintimax {#1}}%
\def\XINT_imaxof_e #1\Z #2\Z { #2}%
\def\xintiiMaxof      {\romannumeral0\xintiimaxof }%
\def\xintiimaxof    #1{\expandafter\XINT_iimaxof_a\romannumeral`&&@#1\relax }%
\def\XINT_iimaxof_a #1{\expandafter\XINT_iimaxof_b\romannumeral`&&@#1\Z }%
\def\XINT_iimaxof_b #1\Z #2%
           {\expandafter\XINT_iimaxof_c\romannumeral`&&@#2\Z {#1}\Z}%
\def\XINT_iimaxof_c #1%
           {\xint_gob_til_relax #1\XINT_iimaxof_e\relax\XINT_iimaxof_d #1}%
\def\XINT_iimaxof_d #1\Z
           {\expandafter\XINT_iimaxof_b\romannumeral0\xintiimax {#1}}%
\def\XINT_iimaxof_e #1\Z #2\Z { #2}%
%    \end{macrocode}
% \subsection{\csh{xintiMin}, \csh{xintiiMin}}
% \lverb|\xintnum added New with 1.09a. I add \xintiiMin in 1.1 and mark as
% deprecated \xintMin, renamed \xintiMin. \xintMin NOW REMOVED (1.2, as
% \xintMax, \xintMaxof), only provided by \xintfracnameimp.|
%    \begin{macrocode}
\def\xintiMin {\romannumeral0\xintimin }%
\def\xintimin #1%
{%
    \expandafter\xint_min\expandafter {\romannumeral0\xintnum{#1}}%
}%
\def\xint_min #1#2%
{%
    \expandafter\XINT_min_pre\expandafter {\romannumeral0\xintnum{#2}}{#1}%
}%
\def\xintiiMin {\romannumeral0\xintiimin }%
\def\xintiimin #1%
{%
    \expandafter\xint_iimin\expandafter {\romannumeral`&&@#1}%
}%
\def\xint_iimin #1#2%
{%
    \expandafter\XINT_min_pre\expandafter {\romannumeral`&&@#2}{#1}%
}%
\def\XINT_min_pre #1#2{\XINT_min_fork #1\Z #2\Z {#2}{#1}}%
\def\XINT_Min #1#2{\romannumeral0\XINT_min_fork #2\Z #1\Z {#1}{#2}}%
%    \end{macrocode}
% \lverb|&
% #3#4 vient du *premier*,
% #1#2 vient du *second*|
%    \begin{macrocode}
\def\XINT_min_fork #1#2\Z #3#4\Z
{%
    \xint_UDsignsfork
          #1#3\XINT_min_minusminus  % A < 0, B < 0
           #1-\XINT_min_minusplus   % B < 0, A >= 0
           #3-\XINT_min_plusminus   % A < 0, B >= 0
            --{\xint_UDzerosfork
                      #1#3\XINT_min_zerozero % A = B = 0
                       #10\XINT_min_zeroplus % B = 0, A > 0
                       #30\XINT_min_pluszero % A = 0, B > 0
                        00\XINT_min_plusplus % A, B > 0
                      \krof }%
    \krof
    {#2}{#4}#1#3%
}%
%    \end{macrocode}
% \lverb|&
% A = #4#2, B = #3#1|
%    \begin{macrocode}
\def\XINT_min_zerozero  #1#2#3#4{\xint_firstoftwo_thenstop }%
\def\XINT_min_zeroplus  #1#2#3#4{\xint_secondoftwo_thenstop }%
\def\XINT_min_pluszero  #1#2#3#4{\xint_firstoftwo_thenstop }%
\def\XINT_min_minusplus #1#2#3#4{\xint_secondoftwo_thenstop }%
\def\XINT_min_plusminus #1#2#3#4{\xint_firstoftwo_thenstop }%
\def\XINT_min_plusplus  #1#2#3#4%
{%
    \ifodd\XINT_Geq {#4#2}{#3#1}
      \expandafter\xint_secondoftwo_thenstop
    \else
      \expandafter\xint_firstoftwo_thenstop
    \fi
}%
%    \end{macrocode}
% \lverb+#3=-, #4=-, #1 = |B| = -B, #2 = |A| = -A+
%    \begin{macrocode}
\def\XINT_min_minusminus #1#2#3#4%
{%
    \ifodd\XINT_Geq {#1}{#2}
      \expandafter\xint_secondoftwo_thenstop
    \else
      \expandafter\xint_firstoftwo_thenstop
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintiMinof}, \csh{xintiiMinof}}
% \lverb|1.09a. 1.2a adds \xintiiMinof which was lacking.|
%    \begin{macrocode}
\def\xintiMinof      {\romannumeral0\xintiminof }%
\def\xintiminof    #1{\expandafter\XINT_iminof_a\romannumeral`&&@#1\relax }%
\def\XINT_iminof_a #1{\expandafter\XINT_iminof_b\romannumeral0\xintnum{#1}\Z }%
\def\XINT_iminof_b #1\Z #2%
           {\expandafter\XINT_iminof_c\romannumeral`&&@#2\Z {#1}\Z}%
\def\XINT_iminof_c #1%
           {\xint_gob_til_relax #1\XINT_iminof_e\relax\XINT_iminof_d #1}%
\def\XINT_iminof_d #1\Z
           {\expandafter\XINT_iminof_b\romannumeral0\xintimin {#1}}%
\def\XINT_iminof_e #1\Z #2\Z { #2}%
\def\xintiiMinof      {\romannumeral0\xintiiminof }%
\def\xintiiminof    #1{\expandafter\XINT_iiminof_a\romannumeral`&&@#1\relax }%
\def\XINT_iiminof_a #1{\expandafter\XINT_iiminof_b\romannumeral`&&@#1\Z }%
\def\XINT_iiminof_b #1\Z #2%
           {\expandafter\XINT_iiminof_c\romannumeral`&&@#2\Z {#1}\Z}%
\def\XINT_iiminof_c #1%
           {\xint_gob_til_relax #1\XINT_iiminof_e\relax\XINT_iiminof_d #1}%
\def\XINT_iiminof_d #1\Z
           {\expandafter\XINT_iiminof_b\romannumeral0\xintiimin {#1}}%
\def\XINT_iiminof_e #1\Z #2\Z { #2}%
%    \end{macrocode}
% \subsection{\csh{xintiiSum}}
% \lverb|&
% \xintiiSum {{a}{b}...{z}}$\ 
% \xintiiSumExpr {a}{b}...{z}\relax$\ 
% 1.03 (drastically) simplifies and makes the routines more efficient (for big
% computations). Also the way \xintSum and \xintSumExpr ...\relax are related.
% has been modified. Now \xintSumExpr \z \relax is accepted input when
% \z expands to a list of braced terms (prior only \xintSum {\z} or \xintSum \z
% was possible).
%
% 1.09a does NOT add the \xintnum overhead. 1.09h renames \xintiSum to
% \xintiiSum to correctly reflect this.
%
% The xint 1.0x routine could benefit from the fact that addition and
% subtraction did not check the lengths of the arguments and were able to do
% their job independently of the order (but not at equal speed). Thus it was
% possible to add separately positive and negative summands and do one big
% subtraction at the end, keeping during all that time the intermediate result
% in reverse order suitable for both addition and subtraction. The lazy
% programmer being a bit tired after the 95$% rewrite of xintcore has not
% tried to do the same with the new model. Thus we just do stupidly repeated
% additions. The code is thus much shorter... and in fact I just copied the
% routine for products and changed products to sums.|
%    \begin{macrocode}
\def\xintiiSum {\romannumeral0\xintiisum }%
\def\xintiisum #1{\xintiisumexpr #1\relax }%
\def\xintiiSumExpr {\romannumeral0\xintiisumexpr }%
\def\xintiisumexpr {\expandafter\XINT_sumexpr\romannumeral`&&@}%
\def\XINT_sumexpr {\XINT_sum_loop_a 0\Z }%
\def\XINT_sum_loop_a #1\Z #2%
    {\expandafter\XINT_sum_loop_b \romannumeral`&&@#2\Z #1\Z \Z}%
\def\XINT_sum_loop_b #1%
    {\xint_gob_til_relax #1\XINT_sum_finished\relax\XINT_sum_loop_c #1}%
\def\XINT_sum_loop_c
    {\expandafter\XINT_sum_loop_a\romannumeral0\XINT_add_fork }%
\def\XINT_sum_finished #1\Z #2\Z \Z { #2}%
%    \end{macrocode}
% \subsection{\csh{xintiiPrd}}
% \lverb|&
% \xintiiPrd {{a}...{z}}$\ 
% \xintiiPrdExpr {a}...{z}\relax$\ 
% Release 1.02 modified the product routine.  The earlier version was faster in
% situations where each new term is bigger than the product of all previous
% terms, a situation which arises in the algorithm for computing powers. The
% 1.02 version was changed to be more efficient on big products, where the new
% term is small compared to what has been computed so far (the power algorithm
% now has its own product routine).
%
% Finally, the 1.03 version just simplifies everything as the multiplication now
% decides what is best, with the price of a little overhead. So the code has
% been dramatically reduced here.
%
% In 1.03 I also modify the way \xintPrd and \xintPrdExpr ...\relax are
% related. Now \xintPrdExpr \z \relax is accepted input when \z expands
% to a list of braced terms (prior only \xintPrd {\z} or \xintPrd \z was
% possible).
%
% In 1.06a I suddenly decide that \xintProductExpr was a silly name, and as the
% package is new and certainly not used, I decide I may just switch to
% \xintPrdExpr which I should have used from the beginning.
%
%  1.09a does NOT add the \xintnum overhead. 1.09h renames \xintiPrd to
%  \xintiiPrd to correctly reflect this.|
%    \begin{macrocode}
\def\xintiiPrd {\romannumeral0\xintiiprd }%
\def\xintiiprd #1{\xintiiprdexpr #1\relax }%
\def\xintiiPrdExpr {\romannumeral0\xintiiprdexpr }%
\def\xintiiprdexpr {\expandafter\XINT_prdexpr\romannumeral`&&@}%
\def\XINT_prdexpr {\XINT_prod_loop_a 1\Z }%
\def\XINT_prod_loop_a #1\Z #2%
    {\expandafter\XINT_prod_loop_b  \romannumeral`&&@#2\Z #1\Z \Z}%
\def\XINT_prod_loop_b #1%
    {\xint_gob_til_relax #1\XINT_prod_finished\relax\XINT_prod_loop_c #1}%
\def\XINT_prod_loop_c
    {\expandafter\XINT_prod_loop_a\romannumeral0\XINT_mul_fork }%
\def\XINT_prod_finished\relax\XINT_prod_loop_c #1\Z #2\Z \Z { #2}%
%    \end{macrocode}
% \lverb|&
% &
% -----------------------------------------------------------------$\ 
% -----------------------------------------------------------------$\ 
% DECIMAL OPERATIONS: FIRST DIGIT, LASTDIGIT, (<- moved to xintcore 
% because xintiiLDg need by division macros)
% ODDNESS,
% MULTIPLICATION BY TEN, QUOTIENT BY TEN, QUOTIENT OR
% MULTIPLICATION BY POWER OF TEN, SPLIT OPERATION.|
% \subsection{\csh{xintMON}, \csh{xintMMON}, \csh{xintiiMON}, \csh{xintiiMMON}}
% \lverb|&
% MINUS ONE TO THE POWER N and (-1)^{N-1}|
%    \begin{macrocode}
\def\xintiiMON {\romannumeral0\xintiimon }%
\def\xintiimon #1%
{%
    \ifodd\xintiiLDg {#1}
        \xint_afterfi{ -1}%
    \else
        \xint_afterfi{ 1}%
    \fi
}%
\def\xintiiMMON {\romannumeral0\xintiimmon }%
\def\xintiimmon #1%
{%
    \ifodd\xintiiLDg {#1}
        \xint_afterfi{ 1}%
    \else
        \xint_afterfi{ -1}%
    \fi
}%
\def\xintMON {\romannumeral0\xintmon }%
\def\xintmon #1%
{%
    \ifodd\xintLDg {#1}
        \xint_afterfi{ -1}%
    \else
        \xint_afterfi{ 1}%
    \fi
}%
\def\xintMMON {\romannumeral0\xintmmon }%
\def\xintmmon #1%
{%
    \ifodd\xintLDg {#1}
        \xint_afterfi{ 1}%
    \else
        \xint_afterfi{ -1}%
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintOdd}, \csh{xintiiOdd}, \csh{xintEven}, \csh{xintiiEven}}
% \lverb|1.05 has \xintiOdd, whereas \xintOdd parses through \xintNum.
% Inadvertently, 1.09a redefined \xintiLDg hence \xintiOdd also parsed through
% \xintNum. Anyway, having a \xintOdd and a \xintiOdd was silly. Removed in
% 1.09f, now only \xintOdd and \xintiiOdd. 1.1: \xintEven and \xintiiEven
% added for \xintiiexpr.|
%    \begin{macrocode}
\def\xintiiOdd {\romannumeral0\xintiiodd }%
\def\xintiiodd #1%
{%
    \ifodd\xintiiLDg{#1}
        \xint_afterfi{ 1}%
    \else
        \xint_afterfi{ 0}%
    \fi
}%
\def\xintiiEven {\romannumeral0\xintiieven }%
\def\xintiieven #1%
{%
    \ifodd\xintiiLDg{#1}
        \xint_afterfi{ 0}%
    \else
        \xint_afterfi{ 1}%
    \fi
}%
\def\xintOdd {\romannumeral0\xintodd }%
\def\xintodd #1%
{%
    \ifodd\xintLDg{#1}
        \xint_afterfi{ 1}%
    \else
        \xint_afterfi{ 0}%
    \fi
}%
\def\xintEven {\romannumeral0\xinteven }%
\def\xinteven #1%
{%
    \ifodd\xintLDg{#1}
        \xint_afterfi{ 0}%
    \else
        \xint_afterfi{ 1}%
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintDSL}}
% \lverb|&
% DECIMAL SHIFT LEFT (=MULTIPLICATION PAR 10)|
%    \begin{macrocode}
\def\xintDSL {\romannumeral0\xintdsl }%
\def\xintdsl #1%
{%
    \expandafter\XINT_dsl \romannumeral`&&@#1\Z
}%
\def\XINT_DSL #1{\romannumeral0\XINT_dsl #1\Z }%
\def\XINT_dsl #1%
{%
    \xint_gob_til_zero #1\xint_dsl_zero 0\XINT_dsl_ #1%
}%
\def\xint_dsl_zero 0\XINT_dsl_ 0#1\Z { 0}%
\def\XINT_dsl_ #1\Z { #10}%
%    \end{macrocode}
% \subsection{\csh{xintDSR}}
% \lverb|&
% DECIMAL SHIFT RIGHT (=DIVISION PAR 10). Release 1.06b which replaced all @'s
% by
% underscores left undefined the \xint_minus used in \XINT_dsr_b, and this bug
% was fixed only later in release 1.09b|
%    \begin{macrocode}
\def\xintDSR {\romannumeral0\xintdsr }%
\def\xintdsr #1%
{%
    \expandafter\XINT_dsr_a\expandafter {\romannumeral`&&@#1}\W\Z
}%
\def\XINT_DSR #1{\romannumeral0\XINT_dsr_a {#1}\W\Z }%
\def\XINT_dsr_a
{%
    \expandafter\XINT_dsr_b\romannumeral0\xintreverseorder
}%
\def\XINT_dsr_b #1#2#3\Z
{%
    \xint_gob_til_W #2\xint_dsr_onedigit\W
    \xint_gob_til_minus #2\xint_dsr_onedigit-%
    \expandafter\XINT_dsr_removew
    \romannumeral0\xintreverseorder {#2#3}%
}%
\def\xint_dsr_onedigit #1\xintreverseorder #2{ 0}%
\def\XINT_dsr_removew #1\W { }%
%    \end{macrocode}
% \subsection{\csh{xintDSH}, \csh{xintDSHr}}
% \lverb+DECIMAL SHIFTS \xintDSH {x}{A}$\ 
% si x <= 0, fait A -> A.10^(|x|). v1.03 corrige l'oversight pour A=0.$\ 
% si x >  0, et A >=0, fait A -> quo(A,10^(x))$\ 
% si x >  0, et A < 0, fait A -> -quo(-A,10^(x))$\ 
% (donc pour x > 0 c'est comme DSR itr x fois)$\ 
% \xintDSHr donne le `reste' (si x<=0 donne zro).
%
% Release 1.06 now feeds x to a \numexpr first. I will have to revise this code
% at some point.+
%    \begin{macrocode}
\def\xintDSHr {\romannumeral0\xintdshr }%
\def\xintdshr #1%
{%
    \expandafter\XINT_dshr_checkxpositive \the\numexpr #1\relax\Z
}%
\def\XINT_dshr_checkxpositive #1%
{%
    \xint_UDzerominusfork
      0#1\XINT_dshr_xzeroorneg
      #1-\XINT_dshr_xzeroorneg
       0-\XINT_dshr_xpositive
    \krof #1%
}%
\def\XINT_dshr_xzeroorneg #1\Z #2{ 0}%
\def\XINT_dshr_xpositive #1\Z
{%
    \expandafter\xint_secondoftwo_thenstop\romannumeral0\xintdsx {#1}%
}%
\def\xintDSH {\romannumeral0\xintdsh }%
\def\xintdsh #1#2%
{%
    \expandafter\xint_dsh\expandafter {\romannumeral`&&@#2}{#1}%
}%
\def\xint_dsh #1#2%
{%
    \expandafter\XINT_dsh_checksignx \the\numexpr #2\relax\Z {#1}%
}%
\def\XINT_dsh_checksignx #1%
{%
    \xint_UDzerominusfork
      #1-\XINT_dsh_xiszero
      0#1\XINT_dsx_xisNeg_checkA     % on passe direct dans DSx
       0-{\XINT_dsh_xisPos #1}%
    \krof
}%
\def\XINT_dsh_xiszero #1\Z #2{ #2}%
\def\XINT_dsh_xisPos #1\Z #2%
{%
    \expandafter\xint_firstoftwo_thenstop
    \romannumeral0\XINT_dsx_checksignA #2\Z {#1}% via DSx
}%
%    \end{macrocode}
% \subsection{\csh{xintDSx}}
% \lverb+Je fais cette routine pour la version 1.01, aprs modification de
% \xintDecSplit. Dornavant \xintDSx fera appel  \xintDecSplit et de mme
% \xintDSH fera appel  \xintDSx. J'ai donc supprim entirement l'ancien code
% de \xintDSH et re-crit entirement celui de \xintDecSplit pour x positif.
%
% --> Attention le cas x=0 est trait dans la mme catgorie que x > 0 <--$\ 
% si x < 0, fait A -> A.10^(|x|)$\ 
% si x >=  0, et A >=0, fait A -> {quo(A,10^(x))}{rem(A,10^(x))}$\ 
% si x >=  0, et A < 0, d'abord on calcule {quo(-A,10^(x))}{rem(-A,10^(x))}$\ 
%    puis, si le premier n'est pas nul on lui donne le signe -$\ 
%          si le premier est nul on donne le signe - au second.
%
% On peut donc toujours reconstituer l'original A par 10^x Q \pm R
% o il faut prendre le signe plus si Q est positif ou nul et le signe moins si
% Q est strictement ngatif.
%
% Release 1.06 has a faster and more compactly coded \XINT_dsx_zeroloop.
% Also, x is now given to a \numexpr. The earlier code should be then
% simplified, but I leave as is for the time being.
%
% Release 1.07 modified the coding of \XINT_dsx_zeroloop, to avoid impacting the
% input stack. Indeed the truncating, rounding, and conversion to float routines
% all use internally \XINT_dsx_zeroloop (via \XINT_dsx_addzerosnofuss), and they
% were thus roughly limited to generating N = 8 times the input save stack size
% digits. On TL2012 and TL2013, this means 40000 = 8x5000 digits. Although
% generating more than 40000 digits is more like a one shot thing, I wanted to
% open the possibility of outputting tens of thousands of digits to faile, thus
% I re-organized \XINT_dsx_zeroloop.
%
% January 5, 2014: but it is only with the new division implementation of 1.09j
% and also with its special \xintXTrunc routine that the possibility mentioned
% in the last paragraph has become a concrete one in terms of computation time.+
%    \begin{macrocode}
\def\xintDSx {\romannumeral0\xintdsx }%
\def\xintdsx #1#2%
{%
    \expandafter\xint_dsx\expandafter {\romannumeral`&&@#2}{#1}%
}%
\def\xint_dsx #1#2%
{%
    \expandafter\XINT_dsx_checksignx \the\numexpr #2\relax\Z {#1}%
}%
\def\XINT_DSx #1#2{\romannumeral0\XINT_dsx_checksignx #1\Z {#2}}%
\def\XINT_dsx #1#2{\XINT_dsx_checksignx #1\Z {#2}}%
\def\XINT_dsx_checksignx #1%
{%
    \xint_UDzerominusfork
      #1-\XINT_dsx_xisZero
      0#1\XINT_dsx_xisNeg_checkA
       0-{\XINT_dsx_xisPos #1}%
    \krof
}%
\def\XINT_dsx_xisZero #1\Z #2{ {#2}{0}}% attention comme x > 0
\def\XINT_dsx_xisNeg_checkA #1\Z #2%
{%
    \XINT_dsx_xisNeg_checkA_ #2\Z {#1}%
}%
\def\XINT_dsx_xisNeg_checkA_ #1#2\Z #3%
{%
    \xint_gob_til_zero #1\XINT_dsx_xisNeg_Azero 0%
    \XINT_dsx_xisNeg_checkx {#3}{#3}{}\Z {#1#2}%
}%
\def\XINT_dsx_xisNeg_Azero #1\Z #2{ 0}%
\def\XINT_dsx_xisNeg_checkx #1%
{%
    \ifnum #1>1000000
       \xint_afterfi
       {\xintError:TooBigDecimalShift
        \expandafter\space\expandafter 0\xint_gobble_iv }%
    \else
       \expandafter \XINT_dsx_zeroloop
    \fi
}%
\def\XINT_dsx_addzerosnofuss #1{\XINT_dsx_zeroloop {#1}{}\Z }%
\def\XINT_dsx_zeroloop #1#2%
{%
    \ifnum #1<\xint_c_ix \XINT_dsx_exita\fi
    \expandafter\XINT_dsx_zeroloop\expandafter
        {\the\numexpr #1-\xint_c_viii}{#200000000}%
}%
\def\XINT_dsx_exita\fi\expandafter\XINT_dsx_zeroloop
{%
    \fi\expandafter\XINT_dsx_exitb
}%
\def\XINT_dsx_exitb #1#2%
{%
    \expandafter\expandafter\expandafter
    \XINT_dsx_addzeros\csname xint_gobble_\romannumeral -#1\endcsname #2%
}%
\def\XINT_dsx_addzeros #1\Z #2{ #2#1}%
\def\XINT_dsx_xisPos #1\Z #2%
{%
    \XINT_dsx_checksignA #2\Z {#1}%
}%
\def\XINT_dsx_checksignA #1%
{%
    \xint_UDzerominusfork
      #1-\XINT_dsx_AisZero
      0#1\XINT_dsx_AisNeg
       0-{\XINT_dsx_AisPos #1}%
    \krof
}%
\def\XINT_dsx_AisZero #1\Z #2{ {0}{0}}%
\def\XINT_dsx_AisNeg #1\Z #2%
{%
    \expandafter\XINT_dsx_AisNeg_dosplit_andcheckfirst
    \romannumeral0\XINT_split_checksizex {#2}{#1}%
}%
\def\XINT_dsx_AisNeg_dosplit_andcheckfirst #1%
{%
    \XINT_dsx_AisNeg_checkiffirstempty #1\Z
}%
\def\XINT_dsx_AisNeg_checkiffirstempty #1%
{%
    \xint_gob_til_Z #1\XINT_dsx_AisNeg_finish_zero\Z
    \XINT_dsx_AisNeg_finish_notzero #1%
}%
\def\XINT_dsx_AisNeg_finish_zero\Z
    \XINT_dsx_AisNeg_finish_notzero\Z #1%
{%
    \expandafter\XINT_dsx_end
    \expandafter {\romannumeral0\XINT_num {-#1}}{0}%
}%
\def\XINT_dsx_AisNeg_finish_notzero #1\Z #2%
{%
    \expandafter\XINT_dsx_end
    \expandafter {\romannumeral0\XINT_num {#2}}{-#1}%
}%
\def\XINT_dsx_AisPos #1\Z #2%
{%
    \expandafter\XINT_dsx_AisPos_finish
    \romannumeral0\XINT_split_checksizex {#2}{#1}%
}%
\def\XINT_dsx_AisPos_finish #1#2%
{%
    \expandafter\XINT_dsx_end
    \expandafter {\romannumeral0\XINT_num {#2}}%
                 {\romannumeral0\XINT_num {#1}}%
}%
\edef\XINT_dsx_end #1#2%
{%
    \noexpand\expandafter\space\noexpand\expandafter{#2}{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintDecSplit}, \csh{xintDecSplitL}, \csh{xintDecSplitR}}
% \lverb!DECIMAL SPLIT
%
% The macro \xintDecSplit {x}{A} first replaces A with |A| (*)
% This macro cuts the number into two pieces L and R. The concatenation LR
% always reproduces |A|, and R may be empty or have leading zeros. The
% position of the cut is specified by the first argument x. If x is zero or
% positive the cut location is x slots to the left of the right end of the
% number. If x becomes equal to or larger than the length of the number then L
% becomes empty. If x is negative the location of the cut is |x| slots to the
% right of the left end of the number.
%
% (*) warning: this may change in a future version. Only the behavior
% for A non-negative is guaranteed to remain the same.
%
% v1.05a: \XINT_split_checksizex does not compute the length anymore, rather the
% error will be from a \numexpr; but the limit of 999999999 does not make much
% sense.
%
% v1.06: Improvements in \XINT_split_fromleft_loop, \XINT_split_fromright_loop
% and related macros. More readable coding, speed gains.
% Also, I now feed immediately a \numexpr with x. Some simplifications should
% probably be made to the code, which is kept as is for the time being.
%
% 1.09e pays attention to the use of xintiabs which acquired in 1.09a the
% xintnum overhead. So xintiiabs rather without that overhead.
% !
%    \begin{macrocode}
\def\xintDecSplitL {\romannumeral0\xintdecsplitl }%
\def\xintDecSplitR {\romannumeral0\xintdecsplitr }%
\def\xintdecsplitl
{%
    \expandafter\xint_firstoftwo_thenstop
    \romannumeral0\xintdecsplit
}%
\def\xintdecsplitr
{%
    \expandafter\xint_secondoftwo_thenstop
    \romannumeral0\xintdecsplit
}%
\def\xintDecSplit {\romannumeral0\xintdecsplit }%
\def\xintdecsplit #1#2%
{%
    \expandafter \xint_split \expandafter
    {\romannumeral0\xintiiabs {#2}}{#1}%  fait expansion de A
}%
\def\xint_split #1#2%
{%
    \expandafter\XINT_split_checksizex\expandafter{\the\numexpr #2}{#1}%
}%
\def\XINT_split_checksizex #1% 999999999 is anyhow very big, could be reduced
{%
    \ifnum\numexpr\XINT_Abs{#1}>999999999
       \xint_afterfi {\xintError:TooBigDecimalSplit\XINT_split_bigx }%
    \else
       \expandafter\XINT_split_xfork
    \fi
    #1\Z
}%
\def\XINT_split_bigx  #1\Z #2%
{%
    \ifcase\XINT_cntSgn #1\Z
    \or \xint_afterfi { {}{#2}}% positive big x
    \else
        \xint_afterfi { {#2}{}}% negative big x
    \fi
}%
\def\XINT_split_xfork #1%
{%
    \xint_UDzerominusfork
      #1-\XINT_split_zerosplit
      0#1\XINT_split_fromleft
       0-{\XINT_split_fromright #1}%
    \krof
}%
\def\XINT_split_zerosplit #1\Z #2{ {#2}{}}%
\def\XINT_split_fromleft  #1\Z #2%
{%
    \XINT_split_fromleft_loop {#1}{}#2\W\W\W\W\W\W\W\W\Z
}%
\def\XINT_split_fromleft_loop #1%
{%
    \ifnum #1<\xint_c_viii\XINT_split_fromleft_exita\fi
    \expandafter\XINT_split_fromleft_loop_perhaps\expandafter
    {\the\numexpr #1-\xint_c_viii\expandafter}\XINT_split_fromleft_eight
}%
\def\XINT_split_fromleft_eight #1#2#3#4#5#6#7#8#9{#9{#1#2#3#4#5#6#7#8#9}}%
\def\XINT_split_fromleft_loop_perhaps #1#2%
{%
    \xint_gob_til_W #2\XINT_split_fromleft_toofar\W
    \XINT_split_fromleft_loop {#1}%
}%
\def\XINT_split_fromleft_toofar\W\XINT_split_fromleft_loop #1#2#3\Z
{%
    \XINT_split_fromleft_toofar_b #2\Z
}%
\def\XINT_split_fromleft_toofar_b #1\W #2\Z { {#1}{}}%
\def\XINT_split_fromleft_exita\fi
    \expandafter\XINT_split_fromleft_loop_perhaps\expandafter #1#2%
   {\fi \XINT_split_fromleft_exitb #1}%
\def\XINT_split_fromleft_exitb\the\numexpr #1-\xint_c_viii\expandafter
{%
    \csname XINT_split_fromleft_endsplit_\romannumeral #1\endcsname
}%
\def\XINT_split_fromleft_endsplit_ #1#2\W #3\Z { {#1}{#2}}%
\def\XINT_split_fromleft_endsplit_i #1#2%
                {\XINT_split_fromleft_checkiftoofar #2{#1#2}}%
\def\XINT_split_fromleft_endsplit_ii #1#2#3%
                {\XINT_split_fromleft_checkiftoofar #3{#1#2#3}}%
\def\XINT_split_fromleft_endsplit_iii #1#2#3#4%
                {\XINT_split_fromleft_checkiftoofar #4{#1#2#3#4}}%
\def\XINT_split_fromleft_endsplit_iv #1#2#3#4#5%
                {\XINT_split_fromleft_checkiftoofar #5{#1#2#3#4#5}}%
\def\XINT_split_fromleft_endsplit_v #1#2#3#4#5#6%
                {\XINT_split_fromleft_checkiftoofar #6{#1#2#3#4#5#6}}%
\def\XINT_split_fromleft_endsplit_vi #1#2#3#4#5#6#7%
                {\XINT_split_fromleft_checkiftoofar #7{#1#2#3#4#5#6#7}}%
\def\XINT_split_fromleft_endsplit_vii #1#2#3#4#5#6#7#8%
                {\XINT_split_fromleft_checkiftoofar #8{#1#2#3#4#5#6#7#8}}%
\def\XINT_split_fromleft_checkiftoofar #1#2#3\W #4\Z
{%
    \xint_gob_til_W #1\XINT_split_fromleft_wenttoofar\W
    \space {#2}{#3}%
}%
\def\XINT_split_fromleft_wenttoofar\W\space #1%
{%
    \XINT_split_fromleft_wenttoofar_b #1\Z
}%
\def\XINT_split_fromleft_wenttoofar_b #1\W #2\Z { {#1}}%
\def\XINT_split_fromright #1\Z #2%
{%
    \expandafter \XINT_split_fromright_a \expandafter
    {\romannumeral0\xintreverseorder {#2}}{#1}{#2}%
}%
\def\XINT_split_fromright_a #1#2%
{%
    \XINT_split_fromright_loop {#2}{}#1\W\W\W\W\W\W\W\W\Z
}%
\def\XINT_split_fromright_loop #1%
{%
    \ifnum #1<\xint_c_viii\XINT_split_fromright_exita\fi
    \expandafter\XINT_split_fromright_loop_perhaps\expandafter
    {\the\numexpr #1-\xint_c_viii\expandafter }\XINT_split_fromright_eight
}%
\def\XINT_split_fromright_eight #1#2#3#4#5#6#7#8#9{#9{#9#8#7#6#5#4#3#2#1}}%
\def\XINT_split_fromright_loop_perhaps #1#2%
{%
    \xint_gob_til_W #2\XINT_split_fromright_toofar\W
    \XINT_split_fromright_loop {#1}%
}%
\def\XINT_split_fromright_toofar\W\XINT_split_fromright_loop #1#2#3\Z { {}}%
\def\XINT_split_fromright_exita\fi
    \expandafter\XINT_split_fromright_loop_perhaps\expandafter #1#2%
    {\fi \XINT_split_fromright_exitb #1}%
\def\XINT_split_fromright_exitb\the\numexpr #1-\xint_c_viii\expandafter
{%
    \csname XINT_split_fromright_endsplit_\romannumeral #1\endcsname
}%
\edef\XINT_split_fromright_endsplit_ #1#2\W #3\Z #4%
{%
    \noexpand\expandafter\space\noexpand\expandafter
    {\noexpand\romannumeral0\noexpand\xintreverseorder {#2}}{#1}%
}%
\def\XINT_split_fromright_endsplit_i   #1#2%
            {\XINT_split_fromright_checkiftoofar #2{#2#1}}%
\def\XINT_split_fromright_endsplit_ii  #1#2#3%
            {\XINT_split_fromright_checkiftoofar #3{#3#2#1}}%
\def\XINT_split_fromright_endsplit_iii #1#2#3#4%
            {\XINT_split_fromright_checkiftoofar #4{#4#3#2#1}}%
\def\XINT_split_fromright_endsplit_iv  #1#2#3#4#5%
            {\XINT_split_fromright_checkiftoofar #5{#5#4#3#2#1}}%
\def\XINT_split_fromright_endsplit_v   #1#2#3#4#5#6%
            {\XINT_split_fromright_checkiftoofar #6{#6#5#4#3#2#1}}%
\def\XINT_split_fromright_endsplit_vi  #1#2#3#4#5#6#7%
            {\XINT_split_fromright_checkiftoofar #7{#7#6#5#4#3#2#1}}%
\def\XINT_split_fromright_endsplit_vii #1#2#3#4#5#6#7#8%
            {\XINT_split_fromright_checkiftoofar #8{#8#7#6#5#4#3#2#1}}%
\def\XINT_split_fromright_checkiftoofar #1%
{%
    \xint_gob_til_W #1\XINT_split_fromright_wenttoofar\W
    \XINT_split_fromright_endsplit_
}%
\def\XINT_split_fromright_wenttoofar\W\XINT_split_fromright_endsplit_ #1\Z #2%
    { {}{#2}}%
%    \end{macrocode}
% \subsection{\csh{xintiiSqrt}, \csh{xintiiSqrtR}, \csh{xintiiSquareRoot}}
% \lverb|v1.08. 1.09a uses \xintnum.
%
% Some overhead was added inadvertently in 1.09a to inner routines when
% \xintiquo and \xintidivision were also promoted to use \xintnum; release 1.09f
% thus uses \xintiiquo and \xintiidivision which avoid this \xintnum overhead.
%
% 1.09j replaced the previous long \ifcase from \XINT_sqrt_c by some nested
% \ifnum's.
% 
% 1.1 Ajout de \xintiiSqrt et \xintiiSquareRoot.
%
% 1.1a ajoute \xintiiSqrtR, which provides the rounded, not truncated square
% root.|
%    \begin{macrocode}
\def\xintiiSqrt  {\romannumeral0\xintiisqrt  }%
\def\xintiiSqrtR {\romannumeral0\xintiisqrtr }%
\def\xintiiSquareRoot {\romannumeral0\xintiisquareroot }%
\def\xintiSqrt        {\romannumeral0\xintisqrt        }%
\def\xintiSquareRoot  {\romannumeral0\xintisquareroot  }%
\def\xintisqrt   {\expandafter\XINT_sqrt_post\romannumeral0\xintisquareroot   }%
\def\xintiisqrt  {\expandafter\XINT_sqrt_post\romannumeral0\xintiisquareroot  }%
\def\xintiisqrtr {\expandafter\XINT_sqrtr_post\romannumeral0\xintiisquareroot }%
\def\XINT_sqrt_post #1#2{\XINT_dec_pos #1\Z }%
%    \end{macrocode}
% \lverb|N = (#1)^2 - #2 avec #1 le plus petit possible et #2>0 (hence #2<2*#1).
% (#1-.5)^2=#1^2-#1+.25=N+#2-#1+.25. Si 0<#2<#1, <= N-0.75<N, donc rounded->#1
% si #2>=#1, (#1-.5)^2>=N+.25>N, donc rounded->#1-1.|
%    \begin{macrocode}
\def\XINT_sqrtr_post #1#2{\xintiiifLt {#2}{#1}{ #1}{\XINT_dec_pos #1\Z}}%
\def\xintisquareroot #1%
   {\expandafter\XINT_sqrt_checkin\romannumeral0\xintnum{#1}\Z }%
\def\xintiisquareroot #1{\expandafter\XINT_sqrt_checkin\romannumeral`&&@#1\Z }%
\def\XINT_sqrt_checkin #1%
{%
    \xint_UDzerominusfork
     #1-\XINT_sqrt_iszero
     0#1\XINT_sqrt_isneg
      0-{\XINT_sqrt #1}%
    \krof
}%
\def\XINT_sqrt_iszero #1\Z { 11}%
\edef\XINT_sqrt_isneg #1\Z {\noexpand\xintError:RootOfNegative\space 11}%
\def\XINT_sqrt #1\Z
{%
    \expandafter\XINT_sqrt_start\expandafter {\romannumeral0\xintlength {#1}}{#1}%
}%
\def\XINT_sqrt_start #1%
{%
    \ifnum #1<\xint_c_x
       \expandafter\XINT_sqrt_small_a
    \else
       \expandafter\XINT_sqrt_big_a
    \fi
    {#1}%
}%
\def\XINT_sqrt_small_a #1{\XINT_sqrt_a {#1}\XINT_sqrt_small_d }%
\def\XINT_sqrt_big_a   #1{\XINT_sqrt_a {#1}\XINT_sqrt_big_d   }%
\def\XINT_sqrt_a #1%
{%
   \ifodd #1
     \expandafter\XINT_sqrt_bB
   \else
     \expandafter\XINT_sqrt_bA
   \fi
   {#1}%
}%
\def\XINT_sqrt_bA #1#2#3%
{%
    \XINT_sqrt_bA_b #3\Z #2{#1}{#3}%
}%
\def\XINT_sqrt_bA_b #1#2#3\Z
{%
    \XINT_sqrt_c {#1#2}%
}%
\def\XINT_sqrt_bB #1#2#3%
{%
    \XINT_sqrt_bB_b #3\Z #2{#1}{#3}%
}%
\def\XINT_sqrt_bB_b #1#2\Z
{%
    \XINT_sqrt_c #1%
}%
\def\XINT_sqrt_c #1#2%
{%
    \expandafter #2\expandafter
    {\the\numexpr\ifnum #1>\xint_c_iii
                 \ifnum #1>\xint_c_viii
                 \ifnum #1>15 \ifnum #1>24 \ifnum #1>35
                 \ifnum #1>48 \ifnum #1>63 \ifnum #1>80
      10\else 9\fi \else 8\fi \else 7\fi \else 6\fi
        \else 5\fi \else 4\fi \else 3\fi \else 2\fi \relax }%
}%
\def\XINT_sqrt_small_d #1#2%
{%
   \expandafter\XINT_sqrt_small_e\expandafter
   {\the\numexpr #1\ifcase \numexpr #2/\xint_c_ii-\xint_c_i\relax
                   \or 0\or 00\or 000\or 0000\fi }%
}%
\def\XINT_sqrt_small_e #1#2%
{%
   \expandafter\XINT_sqrt_small_f\expandafter {\the\numexpr #1*#1-#2}{#1}%
}%
\def\XINT_sqrt_small_f #1#2%
{%
   \expandafter\XINT_sqrt_small_g\expandafter
   {\the\numexpr ((#1+#2)/(\xint_c_ii*#2))-\xint_c_i}{#1}{#2}%
}%
\def\XINT_sqrt_small_g #1%
{%
    \ifnum #1>\xint_c_
       \expandafter\XINT_sqrt_small_h
    \else
       \expandafter\XINT_sqrt_small_end
    \fi
    {#1}%
}%
\def\XINT_sqrt_small_h #1#2#3%
{%
    \expandafter\XINT_sqrt_small_f\expandafter
    {\the\numexpr #2-\xint_c_ii*#1*#3+#1*#1\expandafter}\expandafter
    {\the\numexpr #3-#1}%
}%
\def\XINT_sqrt_small_end #1#2#3{ {#3}{#2}}%
\def\XINT_sqrt_big_d #1#2%
{%
   \ifodd #2
     \expandafter\expandafter\expandafter\XINT_sqrt_big_eB
   \else
     \expandafter\expandafter\expandafter\XINT_sqrt_big_eA
   \fi
   \expandafter {\the\numexpr #2/\xint_c_ii }{#1}%
}%
\def\XINT_sqrt_big_eA  #1#2#3%
{%
    \XINT_sqrt_big_eA_a #3\Z {#2}{#1}{#3}%
}%
\def\XINT_sqrt_big_eA_a #1#2#3#4#5#6#7#8#9\Z
{%
    \XINT_sqrt_big_eA_b {#1#2#3#4#5#6#7#8}%
}%
\def\XINT_sqrt_big_eA_b #1#2%
{%
    \expandafter\XINT_sqrt_big_f
    \romannumeral0\XINT_sqrt_small_e {#2000}{#1}{#1}%
}%
\def\XINT_sqrt_big_eB #1#2#3%
{%
    \XINT_sqrt_big_eB_a #3\Z {#2}{#1}{#3}%
}%
\def\XINT_sqrt_big_eB_a #1#2#3#4#5#6#7#8#9%
{%
    \XINT_sqrt_big_eB_b {#1#2#3#4#5#6#7#8#9}%
}%
\def\XINT_sqrt_big_eB_b #1#2\Z #3%
{%
    \expandafter\XINT_sqrt_big_f
    \romannumeral0\XINT_sqrt_small_e {#30000}{#1}{#1}%
}%
\def\XINT_sqrt_big_f #1#2#3#4%
{%
   \expandafter\XINT_sqrt_big_f_a\expandafter
   {\the\numexpr #2+#3\expandafter}\expandafter
   {\romannumeral0\XINT_dsx_addzerosnofuss
                    {\numexpr #4-\xint_c_iv\relax}{#1}}{#4}%
}%
\def\XINT_sqrt_big_f_a #1#2#3#4%
{%
   \expandafter\XINT_sqrt_big_g\expandafter
   {\romannumeral0\xintiisub
       {\XINT_dsx_addzerosnofuss
        {\numexpr \xint_c_ii*#3-\xint_c_viii\relax}{#1}}{#4}}%
   {#2}{#3}%
}%
\def\XINT_sqrt_big_g #1#2%
{%
    \expandafter\XINT_sqrt_big_j
    \romannumeral0\xintiidivision{#1}{\romannumeral0\XINT_dbl_pos #2\Z}{#2}%
}%
\def\XINT_sqrt_big_j #1%
{%
    \if0\XINT_Sgn #1\Z
          \expandafter \XINT_sqrt_big_end
    \else \expandafter \XINT_sqrt_big_k
    \fi {#1}%
}%
\def\XINT_sqrt_big_k #1#2#3%
{%
    \expandafter\XINT_sqrt_big_l\expandafter
    {\romannumeral0\xintiisub {#3}{#1}}%
    {\romannumeral0\xintiiadd {#2}{\xintiiSqr {#1}}}%
}%
\def\XINT_sqrt_big_l #1#2%
{%
   \expandafter\XINT_sqrt_big_g\expandafter
   {#2}{#1}%
}%
\def\XINT_sqrt_big_end #1#2#3#4{ {#3}{#2}}%
%    \end{macrocode}
% \subsection{\csh{xintiiE}}
% \lverb|Originally was used in \xintiiexpr. Transferred from xintfrac for 1.1.|
%    \begin{macrocode}
\def\xintiiE {\romannumeral0\xintiie }% used in \xintMod.
\def\xintiie #1#2%
   {\expandafter\XINT_iie\the\numexpr #2\expandafter.\expandafter{\romannumeral`&&@#1}}%
\def\XINT_iie #1.#2{\ifnum#1>\xint_c_ \xint_dothis{\xint_dsh {#2}{-#1}}\fi
                    \xint_orthat{ #2}}%
%    \end{macrocode}
% \subsection{``Load \xintfracnameimp'' macros}
% \lverb|Originally was used in \xintiiexpr. Transferred from xintfrac for 1.1.|
%    \begin{macrocode}
\catcode`! 11
\def\xintMax {\Did_you_mean_iiMax?or_load_xintfrac!}%
\def\xintMin {\Did_you_mean_iiMin?or_load_xintfrac!}%
\def\xintMaxof {\Did_you_mean_iMaxof?or_load_xintfrac!}%
\def\xintMinof {\Did_you_mean_iMinof?or_load_xintfrac!}%
\def\xintSum {\Did_you_mean_iiSum?or_load_xintfrac!}%
\def\xintPrd {\Did_you_mean_iiPrd?or_load_xintfrac!}%
\def\xintPrdExpr {\Did_you_mean_iiPrdExpr?or_load_xintfrac!}%
\def\xintSumExpr {\Did_you_mean_iiSumExpr?or_load_xintfrac!}%
\XINT_restorecatcodes_endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xint>\relax
%\def<*xintbinhex>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xint>
%<*xintbinhex>
%
% \StoreCodelineNo {xint}
%
% \section{Package \xintbinhexnameimp implementation}
% \label{sec:binheximp}
%
% \localtableofcontents
%
% The commenting is currently (\xintdocdate) very sparse.
%
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
%
% The code for reload detection was initially copied from \textsc{Heiko
% Oberdiek}'s packages, then modified.
%
% The method for catcodes was also initially directly inspired by these
% packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xintbinhex.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xintcore.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintbinhex}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintbinhex.sty
      \ifx\w\relax % but xintcore.sty not yet loaded.
         \def\z{\endgroup\input xintcore.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xintcore.sty not yet loaded.
            \def\z{\endgroup\RequirePackage{xintcore}}%
          \fi
      \else
        \aftergroup\endinput % xintbinhex already loaded.
      \fi
    \fi
  \fi
\z%
\XINTsetupcatcodes% defined in xintkernel.sty
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\XINT_providespackage
\ProvidesPackage{xintbinhex}%
  [2015/11/18 v1.2d Expandable binary and hexadecimal conversions (jfB)]%
%    \end{macrocode}
% \subsection{Constants, etc...}
% \lverb!v1.08!
%    \begin{macrocode}
\newcount\xint_c_ii^xv  \xint_c_ii^xv   32768
\newcount\xint_c_ii^xvi \xint_c_ii^xvi  65536
\newcount\xint_c_x^v    \xint_c_x^v    100000
\def\XINT_tmpa #1{\ifx\relax#1\else
  \expandafter\edef\csname XINT_sdth_#1\endcsname
  {\ifcase #1 0\or 1\or 2\or 3\or 4\or 5\or 6\or 7\or
              8\or 9\or A\or B\or C\or D\or E\or F\fi}%
  \expandafter\XINT_tmpa\fi }%
\XINT_tmpa {0}{1}{2}{3}{4}{5}{6}{7}{8}{9}{10}{11}{12}{13}{14}{15}\relax
\def\XINT_tmpa #1{\ifx\relax#1\else
  \expandafter\edef\csname XINT_sdtb_#1\endcsname
  {\ifcase #1
   0000\or 0001\or 0010\or 0011\or 0100\or 0101\or 0110\or 0111\or
   1000\or 1001\or 1010\or 1011\or 1100\or 1101\or 1110\or 1111\fi}%
  \expandafter\XINT_tmpa\fi }%
\XINT_tmpa {0}{1}{2}{3}{4}{5}{6}{7}{8}{9}{10}{11}{12}{13}{14}{15}\relax
\let\XINT_tmpa\relax
\expandafter\def\csname XINT_sbtd_0000\endcsname {0}%
\expandafter\def\csname XINT_sbtd_0001\endcsname {1}%
\expandafter\def\csname XINT_sbtd_0010\endcsname {2}%
\expandafter\def\csname XINT_sbtd_0011\endcsname {3}%
\expandafter\def\csname XINT_sbtd_0100\endcsname {4}%
\expandafter\def\csname XINT_sbtd_0101\endcsname {5}%
\expandafter\def\csname XINT_sbtd_0110\endcsname {6}%
\expandafter\def\csname XINT_sbtd_0111\endcsname {7}%
\expandafter\def\csname XINT_sbtd_1000\endcsname {8}%
\expandafter\def\csname XINT_sbtd_1001\endcsname {9}%
\expandafter\def\csname XINT_sbtd_1010\endcsname {10}%
\expandafter\def\csname XINT_sbtd_1011\endcsname {11}%
\expandafter\def\csname XINT_sbtd_1100\endcsname {12}%
\expandafter\def\csname XINT_sbtd_1101\endcsname {13}%
\expandafter\def\csname XINT_sbtd_1110\endcsname {14}%
\expandafter\def\csname XINT_sbtd_1111\endcsname {15}%
\expandafter\let\csname XINT_sbth_0000\expandafter\endcsname
                \csname XINT_sbtd_0000\endcsname
\expandafter\let\csname XINT_sbth_0001\expandafter\endcsname
                \csname XINT_sbtd_0001\endcsname
\expandafter\let\csname XINT_sbth_0010\expandafter\endcsname
                \csname XINT_sbtd_0010\endcsname
\expandafter\let\csname XINT_sbth_0011\expandafter\endcsname
                \csname XINT_sbtd_0011\endcsname
\expandafter\let\csname XINT_sbth_0100\expandafter\endcsname
                \csname XINT_sbtd_0100\endcsname
\expandafter\let\csname XINT_sbth_0101\expandafter\endcsname
                \csname XINT_sbtd_0101\endcsname
\expandafter\let\csname XINT_sbth_0110\expandafter\endcsname
                \csname XINT_sbtd_0110\endcsname
\expandafter\let\csname XINT_sbth_0111\expandafter\endcsname
                \csname XINT_sbtd_0111\endcsname
\expandafter\let\csname XINT_sbth_1000\expandafter\endcsname
                \csname XINT_sbtd_1000\endcsname
\expandafter\let\csname XINT_sbth_1001\expandafter\endcsname
                \csname XINT_sbtd_1001\endcsname
\expandafter\def\csname XINT_sbth_1010\endcsname {A}%
\expandafter\def\csname XINT_sbth_1011\endcsname {B}%
\expandafter\def\csname XINT_sbth_1100\endcsname {C}%
\expandafter\def\csname XINT_sbth_1101\endcsname {D}%
\expandafter\def\csname XINT_sbth_1110\endcsname {E}%
\expandafter\def\csname XINT_sbth_1111\endcsname {F}%
\expandafter\def\csname XINT_shtb_0\endcsname {0000}%
\expandafter\def\csname XINT_shtb_1\endcsname {0001}%
\expandafter\def\csname XINT_shtb_2\endcsname {0010}%
\expandafter\def\csname XINT_shtb_3\endcsname {0011}%
\expandafter\def\csname XINT_shtb_4\endcsname {0100}%
\expandafter\def\csname XINT_shtb_5\endcsname {0101}%
\expandafter\def\csname XINT_shtb_6\endcsname {0110}%
\expandafter\def\csname XINT_shtb_7\endcsname {0111}%
\expandafter\def\csname XINT_shtb_8\endcsname {1000}%
\expandafter\def\csname XINT_shtb_9\endcsname {1001}%
\def\XINT_shtb_A {1010}%
\def\XINT_shtb_B {1011}%
\def\XINT_shtb_C {1100}%
\def\XINT_shtb_D {1101}%
\def\XINT_shtb_E {1110}%
\def\XINT_shtb_F {1111}%
\def\XINT_shtb_G {}%
\def\XINT_smallhex #1%
{%
    \expandafter\XINT_smallhex_a\expandafter
    {\the\numexpr (#1+\xint_c_viii)/\xint_c_xvi-\xint_c_i}{#1}%
}%
\def\XINT_smallhex_a #1#2%
{%
    \csname XINT_sdth_#1\expandafter\expandafter\expandafter\endcsname
    \csname XINT_sdth_\the\numexpr #2-\xint_c_xvi*#1\endcsname
}%
\def\XINT_smallbin #1%
{%
    \expandafter\XINT_smallbin_a\expandafter
    {\the\numexpr (#1+\xint_c_viii)/\xint_c_xvi-\xint_c_i}{#1}%
}%
\def\XINT_smallbin_a #1#2%
{%
    \csname XINT_sdtb_#1\expandafter\expandafter\expandafter\endcsname
    \csname XINT_sdtb_\the\numexpr #2-\xint_c_xvi*#1\endcsname
}%
%    \end{macrocode}
% \subsection{\csh{XINT_OQ}}
% \lverb|Moved with release 1.2 from xintcore 1.1 as it is used only here.
% Will be probably suppressed once I review the code of xintbinhex.|
%    \begin{macrocode}
\def\XINT_OQ #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_R #9\XINT_OQ_end_a\R\XINT_OQ {#9#8#7#6#5#4#3#2#1}%
}%
\def\XINT_OQ_end_a\R\XINT_OQ #1#2\Z
{%
    \XINT_OQ_end_b #1\Z
}%
\def\XINT_OQ_end_b #1#2#3#4#5#6#7#8%
{%
    \xint_gob_til_R
            #8\XINT_OQ_end_viii
            #7\XINT_OQ_end_vii
            #6\XINT_OQ_end_vi
            #5\XINT_OQ_end_v
            #4\XINT_OQ_end_iv
            #3\XINT_OQ_end_iii
            #2\XINT_OQ_end_ii
            \R\XINT_OQ_end_i
            \Z #2#3#4#5#6#7#8%
}%
\def\XINT_OQ_end_viii #1\Z #2#3#4#5#6#7#8#9\Z { #9}%
\def\XINT_OQ_end_vii  #1\Z #2#3#4#5#6#7#8#9\Z { #8#90000000}%
\def\XINT_OQ_end_vi   #1\Z #2#3#4#5#6#7#8#9\Z { #7#8#9000000}%
\def\XINT_OQ_end_v    #1\Z #2#3#4#5#6#7#8#9\Z { #6#7#8#900000}%
\def\XINT_OQ_end_iv   #1\Z #2#3#4#5#6#7#8#9\Z { #5#6#7#8#90000}%
\def\XINT_OQ_end_iii  #1\Z #2#3#4#5#6#7#8#9\Z { #4#5#6#7#8#9000}%
\def\XINT_OQ_end_ii   #1\Z #2#3#4#5#6#7#8#9\Z { #3#4#5#6#7#8#900}%
\def\XINT_OQ_end_i      \Z #1#2#3#4#5#6#7#8\Z { #1#2#3#4#5#6#7#80}%
%    \end{macrocode}
% \subsection{\csh{xintDecToHex}, \csh{xintDecToBin}}
% \lverb!v1.08!
%    \begin{macrocode}
\def\xintDecToHex {\romannumeral0\xintdectohex }%
\def\xintdectohex #1%
        {\expandafter\XINT_dth_checkin\romannumeral`&&@#1\W\W\W\W \T}%
\def\XINT_dth_checkin #1%
{%
    \xint_UDsignfork
       #1\XINT_dth_N
        -{\XINT_dth_P #1}%
     \krof
}%
\def\XINT_dth_N {\expandafter\xint_minus_thenstop\romannumeral0\XINT_dth_P }%
\def\XINT_dth_P {\expandafter\XINT_dth_III\romannumeral`&&@\XINT_dtbh_I {0.}}%
\def\xintDecToBin {\romannumeral0\xintdectobin }%
\def\xintdectobin #1%
        {\expandafter\XINT_dtb_checkin\romannumeral`&&@#1\W\W\W\W \T }%
\def\XINT_dtb_checkin #1%
{%
    \xint_UDsignfork
       #1\XINT_dtb_N
        -{\XINT_dtb_P #1}%
     \krof
}%
\def\XINT_dtb_N {\expandafter\xint_minus_thenstop\romannumeral0\XINT_dtb_P }%
\def\XINT_dtb_P {\expandafter\XINT_dtb_III\romannumeral`&&@\XINT_dtbh_I {0.}}%
\def\XINT_dtbh_I #1#2#3#4#5%
{%
    \xint_gob_til_W #5\XINT_dtbh_II_a\W\XINT_dtbh_I_a  {}{#2#3#4#5}#1\Z.%
}%
\def\XINT_dtbh_II_a\W\XINT_dtbh_I_a #1#2{\XINT_dtbh_II_b #2}%
\def\XINT_dtbh_II_b #1#2#3#4%
{%
    \xint_gob_til_W
      #1\XINT_dtbh_II_c
      #2\XINT_dtbh_II_ci
      #3\XINT_dtbh_II_cii
      \W\XINT_dtbh_II_ciii #1#2#3#4%
}%
\def\XINT_dtbh_II_c \W\XINT_dtbh_II_ci
                    \W\XINT_dtbh_II_cii
                    \W\XINT_dtbh_II_ciii \W\W\W\W {{}}%
\def\XINT_dtbh_II_ci #1\XINT_dtbh_II_ciii #2\W\W\W
   {\XINT_dtbh_II_d {}{#2}{0}}%
\def\XINT_dtbh_II_cii\W\XINT_dtbh_II_ciii #1#2\W\W
   {\XINT_dtbh_II_d {}{#1#2}{00}}%
\def\XINT_dtbh_II_ciii #1#2#3\W
   {\XINT_dtbh_II_d {}{#1#2#3}{000}}%
\def\XINT_dtbh_I_a #1#2#3.%
{%
    \xint_gob_til_Z #3\XINT_dtbh_I_z\Z
    \expandafter\XINT_dtbh_I_b\the\numexpr #2+#30000.{#1}%
}%
\def\XINT_dtbh_I_b #1.%
{%
    \expandafter\XINT_dtbh_I_c\the\numexpr
    (#1+\xint_c_ii^xv)/\xint_c_ii^xvi-\xint_c_i.#1.%
}%
\def\XINT_dtbh_I_c #1.#2.%
{%
    \expandafter\XINT_dtbh_I_d\expandafter
    {\the\numexpr #2-\xint_c_ii^xvi*#1}{#1}%
}%
\def\XINT_dtbh_I_d #1#2#3{\XINT_dtbh_I_a {#3#1.}{#2}}%
\def\XINT_dtbh_I_z\Z\expandafter\XINT_dtbh_I_b\the\numexpr #1+#2.%
{%
    \ifnum #1=\xint_c_ \expandafter\XINT_dtbh_I_end_zb\fi
    \XINT_dtbh_I_end_za {#1}%
}%
\def\XINT_dtbh_I_end_za #1#2{\XINT_dtbh_I {#2#1.}}%
\def\XINT_dtbh_I_end_zb\XINT_dtbh_I_end_za #1#2{\XINT_dtbh_I {#2}}%
\def\XINT_dtbh_II_d #1#2#3#4.%
{%
    \xint_gob_til_Z #4\XINT_dtbh_II_z\Z
    \expandafter\XINT_dtbh_II_e\the\numexpr #2+#4#3.{#1}{#3}%
}%
\def\XINT_dtbh_II_e #1.%
{%
    \expandafter\XINT_dtbh_II_f\the\numexpr
        (#1+\xint_c_ii^xv)/\xint_c_ii^xvi-\xint_c_i.#1.%
}%
\def\XINT_dtbh_II_f #1.#2.%
{%
    \expandafter\XINT_dtbh_II_g\expandafter
    {\the\numexpr #2-\xint_c_ii^xvi*#1}{#1}%
}%
\def\XINT_dtbh_II_g #1#2#3{\XINT_dtbh_II_d {#3#1.}{#2}}%
\def\XINT_dtbh_II_z\Z\expandafter\XINT_dtbh_II_e\the\numexpr #1+#2.%
{%
    \ifnum #1=\xint_c_ \expandafter\XINT_dtbh_II_end_zb\fi
    \XINT_dtbh_II_end_za {#1}%
}%
\def\XINT_dtbh_II_end_za #1#2#3{{}#2#1.\Z.}%
\def\XINT_dtbh_II_end_zb\XINT_dtbh_II_end_za #1#2#3{{}#2\Z.}%
\def\XINT_dth_III #1#2.%
{%
    \xint_gob_til_Z #2\XINT_dth_end\Z
    \expandafter\XINT_dth_III\expandafter
    {\romannumeral`&&@\XINT_dth_small #2.#1}%
}%
\def\XINT_dth_small #1.%
{%
    \expandafter\XINT_smallhex\expandafter
    {\the\numexpr (#1+\xint_c_ii^vii)/\xint_c_ii^viii-\xint_c_i\expandafter}%
    \romannumeral`&&@\expandafter\XINT_smallhex\expandafter
    {\the\numexpr
    #1-((#1+\xint_c_ii^vii)/\xint_c_ii^viii-\xint_c_i)*\xint_c_ii^viii}%
}%
\def\XINT_dth_end\Z\expandafter\XINT_dth_III\expandafter #1#2\T
{%
    \XINT_dth_end_b #1%
}%
\def\XINT_dth_end_b #1.{\XINT_dth_end_c }%
\def\XINT_dth_end_c #1{\xint_gob_til_zero #1\XINT_dth_end_d 0\space #1}%
\def\XINT_dth_end_d 0\space 0#1%
{%
    \xint_gob_til_zero #1\XINT_dth_end_e 0\space #1%
}%
\def\XINT_dth_end_e 0\space 0#1%
{%
    \xint_gob_til_zero #1\XINT_dth_end_f 0\space #1%
}%
\def\XINT_dth_end_f 0\space 0{ }%
\def\XINT_dtb_III #1#2.%
{%
    \xint_gob_til_Z #2\XINT_dtb_end\Z
    \expandafter\XINT_dtb_III\expandafter
    {\romannumeral`&&@\XINT_dtb_small #2.#1}%
}%
\def\XINT_dtb_small #1.%
{%
    \expandafter\XINT_smallbin\expandafter
    {\the\numexpr (#1+\xint_c_ii^vii)/\xint_c_ii^viii-\xint_c_i\expandafter}%
    \romannumeral`&&@\expandafter\XINT_smallbin\expandafter
    {\the\numexpr
    #1-((#1+\xint_c_ii^vii)/\xint_c_ii^viii-\xint_c_i)*\xint_c_ii^viii}%
}%
\def\XINT_dtb_end\Z\expandafter\XINT_dtb_III\expandafter #1#2\T
{%
    \XINT_dtb_end_b #1%
}%
\def\XINT_dtb_end_b #1.{\XINT_dtb_end_c }%
\def\XINT_dtb_end_c #1#2#3#4#5#6#7#8%
{%
    \expandafter\XINT_dtb_end_d\the\numexpr #1#2#3#4#5#6#7#8\relax
}%
\edef\XINT_dtb_end_d #1#2#3#4#5#6#7#8#9%
{%
    \noexpand\expandafter\space\noexpand\the\numexpr #1#2#3#4#5#6#7#8#9\relax
}%
%    \end{macrocode}
% \subsection{\csh{xintHexToDec}}
% \lverb!v1.08!
%    \begin{macrocode}
\def\xintHexToDec {\romannumeral0\xinthextodec }%
\def\xinthextodec #1%
        {\expandafter\XINT_htd_checkin\romannumeral`&&@#1\W\W\W\W \T }%
\def\XINT_htd_checkin #1%
{%
    \xint_UDsignfork
       #1\XINT_htd_neg
        -{\XINT_htd_I {0000}#1}%
     \krof
}%
\def\XINT_htd_neg {\expandafter\xint_minus_thenstop
                   \romannumeral0\XINT_htd_I {0000}}%
\def\XINT_htd_I #1#2#3#4#5%
{%
    \xint_gob_til_W #5\XINT_htd_II_a\W
    \XINT_htd_I_a  {}{"#2#3#4#5}#1\Z\Z\Z\Z
}%
\def\XINT_htd_II_a \W\XINT_htd_I_a #1#2{\XINT_htd_II_b #2}%
\def\XINT_htd_II_b "#1#2#3#4%
{%
    \xint_gob_til_W
      #1\XINT_htd_II_c
      #2\XINT_htd_II_ci
      #3\XINT_htd_II_cii
      \W\XINT_htd_II_ciii #1#2#3#4%
}%
\def\XINT_htd_II_c \W\XINT_htd_II_ci
                   \W\XINT_htd_II_cii
                   \W\XINT_htd_II_ciii \W\W\W\W #1\Z\Z\Z\Z\T
{%
    \expandafter\xint_cleanupzeros_andstop
    \romannumeral0\XINT_rord_main {}#1%
      \xint_relax
        \xint_bye\xint_bye\xint_bye\xint_bye
        \xint_bye\xint_bye\xint_bye\xint_bye
      \xint_relax
}%
\def\XINT_htd_II_ci #1\XINT_htd_II_ciii
                      #2\W\W\W {\XINT_htd_II_d {}{"#2}{\xint_c_xvi}}%
\def\XINT_htd_II_cii\W\XINT_htd_II_ciii
                      #1#2\W\W {\XINT_htd_II_d {}{"#1#2}{\xint_c_ii^viii}}%
\def\XINT_htd_II_ciii #1#2#3\W {\XINT_htd_II_d {}{"#1#2#3}{\xint_c_ii^xii}}%
\def\XINT_htd_I_a #1#2#3#4#5#6%
{%
    \xint_gob_til_Z #3\XINT_htd_I_end_a\Z
    \expandafter\XINT_htd_I_b\the\numexpr
    #2+\xint_c_ii^xvi*#6#5#4#3+\xint_c_x^ix\relax {#1}%
}%
\def\XINT_htd_I_b 1#1#2#3#4#5#6#7#8#9{\XINT_htd_I_c {#1#2#3#4#5}{#9#8#7#6}}%
\def\XINT_htd_I_c #1#2#3{\XINT_htd_I_a {#3#2}{#1}}%
\def\XINT_htd_I_end_a\Z\expandafter\XINT_htd_I_b\the\numexpr #1+#2\relax
{%
    \expandafter\XINT_htd_I_end_b\the\numexpr \xint_c_x^v+#1\relax
}%
\def\XINT_htd_I_end_b 1#1#2#3#4#5%
{%
    \xint_gob_til_zero #1\XINT_htd_I_end_bz0%
    \XINT_htd_I_end_c #1#2#3#4#5%
}%
\def\XINT_htd_I_end_c #1#2#3#4#5#6{\XINT_htd_I {#6#5#4#3#2#1000}}%
\def\XINT_htd_I_end_bz0\XINT_htd_I_end_c 0#1#2#3#4%
{%
    \xint_gob_til_zeros_iv #1#2#3#4\XINT_htd_I_end_bzz 0000%
    \XINT_htd_I_end_D {#4#3#2#1}%
}%
\def\XINT_htd_I_end_D  #1#2{\XINT_htd_I {#2#1}}%
\def\XINT_htd_I_end_bzz 0000\XINT_htd_I_end_D #1{\XINT_htd_I }%
\def\XINT_htd_II_d #1#2#3#4#5#6#7%
{%
    \xint_gob_til_Z #4\XINT_htd_II_end_a\Z
    \expandafter\XINT_htd_II_e\the\numexpr
    #2+#3*#7#6#5#4+\xint_c_x^viii\relax {#1}{#3}%
}%
\def\XINT_htd_II_e 1#1#2#3#4#5#6#7#8{\XINT_htd_II_f {#1#2#3#4}{#5#6#7#8}}%
\def\XINT_htd_II_f #1#2#3{\XINT_htd_II_d {#2#3}{#1}}%
\def\XINT_htd_II_end_a\Z\expandafter\XINT_htd_II_e
    \the\numexpr #1+#2\relax #3#4\T
{%
    \XINT_htd_II_end_b #1#3%
}%
\edef\XINT_htd_II_end_b #1#2#3#4#5#6#7#8%
{%
    \noexpand\expandafter\space\noexpand\the\numexpr #1#2#3#4#5#6#7#8\relax
}%
%    \end{macrocode}
% \subsection{\csh{xintBinToDec}}
% \lverb!v1.08!
%    \begin{macrocode}
\def\xintBinToDec {\romannumeral0\xintbintodec }%
\def\xintbintodec #1{\expandafter\XINT_btd_checkin
                     \romannumeral`&&@#1\W\W\W\W\W\W\W\W \T }%
\def\XINT_btd_checkin #1%
{%
    \xint_UDsignfork
       #1\XINT_btd_neg
        -{\XINT_btd_I {000000}#1}%
     \krof
}%
\def\XINT_btd_neg {\expandafter\xint_minus_thenstop
                               \romannumeral0\XINT_btd_I {000000}}%
\def\XINT_btd_I #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_W #9\XINT_btd_II_a {#2#3#4#5#6#7#8#9}\W
    \XINT_btd_I_a {}{\csname XINT_sbtd_#2#3#4#5\endcsname*\xint_c_xvi+%
                     \csname XINT_sbtd_#6#7#8#9\endcsname}%
    #1\Z\Z\Z\Z\Z\Z
}%
\def\XINT_btd_II_a #1\W\XINT_btd_I_a #2#3{\XINT_btd_II_b #1}%
\def\XINT_btd_II_b #1#2#3#4#5#6#7#8%
{%
    \xint_gob_til_W
      #1\XINT_btd_II_c
      #2\XINT_btd_II_ci
      #3\XINT_btd_II_cii
      #4\XINT_btd_II_ciii
      #5\XINT_btd_II_civ
      #6\XINT_btd_II_cv
      #7\XINT_btd_II_cvi
      \W\XINT_btd_II_cvii #1#2#3#4#5#6#7#8%
}%
\def\XINT_btd_II_c #1\XINT_btd_II_cvii \W\W\W\W\W\W\W\W #2\Z\Z\Z\Z\Z\Z\T
{%
    \expandafter\XINT_btd_II_c_end
    \romannumeral0\XINT_rord_main {}#2%
      \xint_relax
        \xint_bye\xint_bye\xint_bye\xint_bye
        \xint_bye\xint_bye\xint_bye\xint_bye
      \xint_relax
}%
\edef\XINT_btd_II_c_end #1#2#3#4#5#6%
{%
    \noexpand\expandafter\space\noexpand\the\numexpr #1#2#3#4#5#6\relax
}%
\def\XINT_btd_II_ci  #1\XINT_btd_II_cvii #2\W\W\W\W\W\W\W
   {\XINT_btd_II_d {}{#2}{\xint_c_ii }}%
\def\XINT_btd_II_cii #1\XINT_btd_II_cvii #2\W\W\W\W\W\W
   {\XINT_btd_II_d {}{\csname XINT_sbtd_00#2\endcsname }{\xint_c_iv }}%
\def\XINT_btd_II_ciii #1\XINT_btd_II_cvii #2\W\W\W\W\W
   {\XINT_btd_II_d {}{\csname XINT_sbtd_0#2\endcsname }{\xint_c_viii }}%
\def\XINT_btd_II_civ #1\XINT_btd_II_cvii #2\W\W\W\W
   {\XINT_btd_II_d {}{\csname XINT_sbtd_#2\endcsname}{\xint_c_xvi }}%
\def\XINT_btd_II_cv #1\XINT_btd_II_cvii #2#3#4#5#6\W\W\W
{%
    \XINT_btd_II_d {}{\csname XINT_sbtd_#2#3#4#5\endcsname*\xint_c_ii+%
                          #6}{\xint_c_ii^v }%
}%
\def\XINT_btd_II_cvi #1\XINT_btd_II_cvii #2#3#4#5#6#7\W\W
{%
    \XINT_btd_II_d {}{\csname XINT_sbtd_#2#3#4#5\endcsname*\xint_c_iv+%
                      \csname XINT_sbtd_00#6#7\endcsname}{\xint_c_ii^vi }%
}%
\def\XINT_btd_II_cvii #1#2#3#4#5#6#7\W
{%
    \XINT_btd_II_d {}{\csname XINT_sbtd_#1#2#3#4\endcsname*\xint_c_viii+%
                      \csname XINT_sbtd_0#5#6#7\endcsname}{\xint_c_ii^vii }%
}%
\def\XINT_btd_II_d #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_Z #4\XINT_btd_II_end_a\Z
    \expandafter\XINT_btd_II_e\the\numexpr
    #2+(\xint_c_x^ix+#3*#9#8#7#6#5#4)\relax {#1}{#3}%
}%
\def\XINT_btd_II_e 1#1#2#3#4#5#6#7#8#9{\XINT_btd_II_f {#1#2#3}{#4#5#6#7#8#9}}%
\def\XINT_btd_II_f #1#2#3{\XINT_btd_II_d {#2#3}{#1}}%
\def\XINT_btd_II_end_a\Z\expandafter\XINT_btd_II_e
    \the\numexpr #1+(#2\relax #3#4\T
{%
    \XINT_btd_II_end_b #1#3%
}%
\edef\XINT_btd_II_end_b #1#2#3#4#5#6#7#8#9%
{%
    \noexpand\expandafter\space\noexpand\the\numexpr #1#2#3#4#5#6#7#8#9\relax
}%
\def\XINT_btd_I_a #1#2#3#4#5#6#7#8%
{%
    \xint_gob_til_Z #3\XINT_btd_I_end_a\Z
    \expandafter\XINT_btd_I_b\the\numexpr
    #2+\xint_c_ii^viii*#8#7#6#5#4#3+\xint_c_x^ix\relax {#1}%
}%
\def\XINT_btd_I_b 1#1#2#3#4#5#6#7#8#9{\XINT_btd_I_c {#1#2#3}{#9#8#7#6#5#4}}%
\def\XINT_btd_I_c #1#2#3{\XINT_btd_I_a {#3#2}{#1}}%
\def\XINT_btd_I_end_a\Z\expandafter\XINT_btd_I_b
    \the\numexpr #1+\xint_c_ii^viii #2\relax
{%
    \expandafter\XINT_btd_I_end_b\the\numexpr 1000+#1\relax
}%
\def\XINT_btd_I_end_b 1#1#2#3%
{%
    \xint_gob_til_zeros_iii #1#2#3\XINT_btd_I_end_bz 000%
    \XINT_btd_I_end_c #1#2#3%
}%
\def\XINT_btd_I_end_c #1#2#3#4{\XINT_btd_I {#4#3#2#1000}}%
\def\XINT_btd_I_end_bz 000\XINT_btd_I_end_c 000{\XINT_btd_I }%
%    \end{macrocode}
% \subsection{\csh{xintBinToHex}}
% \lverb!v1.08!
%    \begin{macrocode}
\def\xintBinToHex {\romannumeral0\xintbintohex }%
\def\xintbintohex #1%
{%
    \expandafter\XINT_bth_checkin
                     \romannumeral0\expandafter\XINT_num_loop
                     \romannumeral`&&@#1\xint_relax\xint_relax
                                       \xint_relax\xint_relax
                     \xint_relax\xint_relax\xint_relax\xint_relax\Z
    \R\R\R\R\R\R\R\R\Z \W\W\W\W\W\W\W\W
}%
\def\XINT_bth_checkin #1%
{%
    \xint_UDsignfork
       #1\XINT_bth_N
        -{\XINT_bth_P #1}%
     \krof
}%
\def\XINT_bth_N {\expandafter\xint_minus_thenstop\romannumeral0\XINT_bth_P }%
\def\XINT_bth_P {\expandafter\XINT_bth_I\expandafter{\expandafter}%
                 \romannumeral0\XINT_OQ {}}%
\def\XINT_bth_I #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_W #9\XINT_bth_end_a\W
    \expandafter\expandafter\expandafter
    \XINT_bth_I
    \expandafter\expandafter\expandafter
    {\csname XINT_sbth_#9#8#7#6\expandafter\expandafter\expandafter\endcsname
     \csname XINT_sbth_#5#4#3#2\endcsname #1}%
}%
\def\XINT_bth_end_a\W \expandafter\expandafter\expandafter
    \XINT_bth_I       \expandafter\expandafter\expandafter #1%
{%
    \XINT_bth_end_b #1%
}%
\def\XINT_bth_end_b  #1\endcsname #2\endcsname #3%
{%
    \xint_gob_til_zero #3\XINT_bth_end_z 0\space #3%
}%
\def\XINT_bth_end_z0\space 0{ }%
%    \end{macrocode}
% \subsection{\csh{xintHexToBin}}
% \lverb!v1.08!
%    \begin{macrocode}
\def\xintHexToBin {\romannumeral0\xinthextobin }%
\def\xinthextobin #1%
{%
    \expandafter\XINT_htb_checkin\romannumeral`&&@#1GGGGGGGG\T
}%
\def\XINT_htb_checkin #1%
{%
    \xint_UDsignfork
       #1\XINT_htb_N
        -{\XINT_htb_P #1}%
     \krof
}%
\def\XINT_htb_N {\expandafter\xint_minus_thenstop\romannumeral0\XINT_htb_P }%
\def\XINT_htb_P {\XINT_htb_I_a {}}%
\def\XINT_htb_I_a #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_G #9\XINT_htb_II_a G%
    \expandafter\expandafter\expandafter
    \XINT_htb_I_b
    \expandafter\expandafter\expandafter
    {\csname XINT_shtb_#2\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#3\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#4\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#5\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#6\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#7\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#8\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#9\endcsname }{#1}%
}%
\def\XINT_htb_I_b #1#2{\XINT_htb_I_a {#2#1}}%
\def\XINT_htb_II_a G\expandafter\expandafter\expandafter\XINT_htb_I_b
{%
    \expandafter\expandafter\expandafter \XINT_htb_II_b
}%
\def\XINT_htb_II_b #1#2#3\T
{%
    \XINT_num_loop #2#1%
    \xint_relax\xint_relax\xint_relax\xint_relax
    \xint_relax\xint_relax\xint_relax\xint_relax\Z
}%
%    \end{macrocode}
% \subsection{\csh{xintCHexToBin}}
% \lverb!v1.08!
%    \begin{macrocode}
\def\xintCHexToBin {\romannumeral0\xintchextobin }%
\def\xintchextobin #1%
{%
    \expandafter\XINT_chtb_checkin\romannumeral`&&@#1%
    \R\R\R\R\R\R\R\R\Z \W\W\W\W\W\W\W\W
}%
\def\XINT_chtb_checkin #1%
{%
    \xint_UDsignfork
       #1\XINT_chtb_N
        -{\XINT_chtb_P #1}%
     \krof
}%
\def\XINT_chtb_N {\expandafter\xint_minus_thenstop\romannumeral0\XINT_chtb_P }%
\def\XINT_chtb_P {\expandafter\XINT_chtb_I\expandafter{\expandafter}%
                  \romannumeral0\XINT_OQ {}}%
\def\XINT_chtb_I #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_W #9\XINT_chtb_end_a\W
    \expandafter\expandafter\expandafter
    \XINT_chtb_I
    \expandafter\expandafter\expandafter
    {\csname XINT_shtb_#9\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#8\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#7\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#6\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#5\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#4\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#3\expandafter\expandafter\expandafter\endcsname
     \csname XINT_shtb_#2\endcsname
     #1}%
}%
\def\XINT_chtb_end_a\W\expandafter\expandafter\expandafter
    \XINT_chtb_I\expandafter\expandafter\expandafter #1%
{%
    \XINT_chtb_end_b #1%
    \xint_relax\xint_relax\xint_relax\xint_relax
    \xint_relax\xint_relax\xint_relax\xint_relax\Z
}%
\def\XINT_chtb_end_b #1\W#2\W#3\W#4\W#5\W#6\W#7\W#8\W\endcsname
{%
    \XINT_num_loop
}%
\XINT_restorecatcodes_endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xintbinhex>\relax
%\def<*xintgcd>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xintbinhex>
%<*xintgcd>
%
% \StoreCodelineNo {xintbinhex}
%
% \section{Package \xintgcdnameimp implementation}
% \label{sec:gcdimp}
%
% \localtableofcontents
%
% The commenting is currently (\xintdocdate) very sparse. Release |1.09h| has
% modified a bit the |\xintTypesetEuclideAlgorithm| and
% |\xintTypesetBezoutAlgorithm| layout with respect to line indentation in
% particular. And they use the \xinttoolsnameimp |\xintloop| rather than the
% Plain \TeX{} or \LaTeX{}'s |\loop|.
%
% Since |1.1| the package only loads \xintcorenameimp, not \xintnameimp. And
% for the |\xintTypesetEuclideAlgorithm| and |\xintTypesetBezoutAlgorithm|
% macros to be functional the package \xinttoolsnameimp needs to be loaded
% explicitely by the user.
%
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
%
% The code for reload detection was initially copied from \textsc{Heiko
% Oberdiek}'s packages, then modified.
%
% The method for catcodes was also initially directly inspired by these
% packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xintgcd.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xintcore.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintgcd}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintgcd.sty
      \ifx\w\relax % but xintcore.sty not yet loaded.
         \def\z{\endgroup\input xintcore.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xintcore.sty not yet loaded.
            \def\z{\endgroup\RequirePackage{xintcore}}%
          \fi
      \else
        \aftergroup\endinput % xintgcd already loaded.
      \fi
    \fi
  \fi
\z%
\XINTsetupcatcodes% defined in xintkernel.sty
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\XINT_providespackage
\ProvidesPackage{xintgcd}%
  [2015/11/18 v1.2d Euclide algorithm with xint package (jfB)]%
%    \end{macrocode}
% \subsection{\csh{xintGCD}, \csh{xintiiGCD}}
% \lverb|The macros of 1.09a benefits from the \xintnum which has been inserted
% inside \xintiabs in \xintnameimp;
% this is a little overhead but is more convenient for the
% user and also makes it easier to use into \xintexpr-essions. 1.1a adds
% \xintiiGCD mainly for \xintiiexpr benefit. Perhaps one should always have
% had ONLY ii versions from the beginning. And perhaps for sake of
% consistency, \xintGCD should be named \xintiGCD? too late.|
%    \begin{macrocode}
\def\xintGCD {\romannumeral0\xintgcd }%
\def\xintgcd #1%
{%
    \expandafter\XINT_gcd\expandafter{\romannumeral0\xintiabs {#1}}%
}%
\def\XINT_gcd #1#2%
{%
    \expandafter\XINT_gcd_fork\romannumeral0\xintiabs {#2}\Z #1\Z
}%
\def\xintiiGCD {\romannumeral0\xintiigcd }%
\def\xintiigcd #1%
{%
    \expandafter\XINT_iigcd\expandafter{\romannumeral0\xintiiabs {#1}}%
}%
\def\XINT_iigcd #1#2%
{%
    \expandafter\XINT_gcd_fork\romannumeral0\xintiiabs {#2}\Z #1\Z
}%
%    \end{macrocode}
% \lverb|&
% Ici #3#4=A, #1#2=B|
%    \begin{macrocode}
\def\XINT_gcd_fork #1#2\Z #3#4\Z
{%
    \xint_UDzerofork
      #1\XINT_gcd_BisZero
      #3\XINT_gcd_AisZero
       0\XINT_gcd_loop
    \krof
    {#1#2}{#3#4}%
}%
\def\XINT_gcd_AisZero #1#2{ #1}%
\def\XINT_gcd_BisZero #1#2{ #2}%
\def\XINT_gcd_CheckRem #1#2\Z
{%
    \xint_gob_til_zero #1\xint_gcd_end0\XINT_gcd_loop {#1#2}%
}%
\def\xint_gcd_end0\XINT_gcd_loop #1#2{ #2}%
%    \end{macrocode}
% \lverb|#1=B, #2=A|
%    \begin{macrocode}
\def\XINT_gcd_loop #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT_gcd_CheckRem
    \expandafter\xint_secondoftwo
    \romannumeral0\XINT_div_prepare {#1}{#2}\Z
    {#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintLCM}, \csh{xintiiLCM}}
% \lverb|New with 1.09a. Inadvertent use of \xintiQuo which was promoted at the
% same time to add the \xintnum overhead. So with 1.09f \xintiiQuo without the
% overhead. However \xintiabs has the \xintnum thing. The advantage is that we
% can thus use lcm in \xintexpr. The disadvantage is that this has overhead in
% \xintiiexpr. Thus 1.1a has \xintiiLCM.|
%    \begin{macrocode}
\def\xintLCM {\romannumeral0\xintlcm}%
\def\xintlcm #1%
{%
    \expandafter\XINT_lcm\expandafter{\romannumeral0\xintiabs {#1}}%
}%
\def\XINT_lcm #1#2%
{%
    \expandafter\XINT_lcm_fork\romannumeral0\xintiabs {#2}\Z #1\Z
}%
\def\xintiiLCM {\romannumeral0\xintiilcm}%
\def\xintiilcm #1%
{%
    \expandafter\XINT_iilcm\expandafter{\romannumeral0\xintiiabs {#1}}%
}%
\def\XINT_iilcm #1#2%
{%
    \expandafter\XINT_lcm_fork\romannumeral0\xintiiabs {#2}\Z #1\Z
}%
\def\XINT_lcm_fork #1#2\Z #3#4\Z
{%
    \xint_UDzerofork
      #1\XINT_lcm_BisZero
      #3\XINT_lcm_AisZero
       0\expandafter
    \krof
    \XINT_lcm_notzero\expandafter{\romannumeral0\XINT_gcd_loop {#1#2}{#3#4}}%
    {#1#2}{#3#4}%
}%
\def\XINT_lcm_AisZero #1#2#3#4#5{ 0}%
\def\XINT_lcm_BisZero #1#2#3#4#5{ 0}%
\def\XINT_lcm_notzero #1#2#3{\xintiimul {#2}{\xintiiQuo{#3}{#1}}}%
%    \end{macrocode}
% \subsection{\csh{xintBezout}}
% \lverb|1.09a inserts use of \xintnum|
%    \begin{macrocode}
\def\xintBezout {\romannumeral0\xintbezout }%
\def\xintbezout #1%
{%
    \expandafter\xint_bezout\expandafter {\romannumeral0\xintnum{#1}}%
}%
\def\xint_bezout #1#2%
{%
    \expandafter\XINT_bezout_fork \romannumeral0\xintnum{#2}\Z #1\Z
}%
%    \end{macrocode}
% \lverb|#3#4 = A, #1#2=B|
%    \begin{macrocode}
\def\XINT_bezout_fork #1#2\Z #3#4\Z
{%
    \xint_UDzerosfork
     #1#3\XINT_bezout_botharezero
      #10\XINT_bezout_secondiszero
      #30\XINT_bezout_firstiszero
       00{\xint_UDsignsfork
          #1#3\XINT_bezout_minusminus % A < 0, B < 0
           #1-\XINT_bezout_minusplus  % A > 0, B < 0
           #3-\XINT_bezout_plusminus  % A < 0, B > 0
            --\XINT_bezout_plusplus   % A > 0, B > 0
         \krof }%
    \krof
    {#2}{#4}#1#3{#3#4}{#1#2}% #1#2=B, #3#4=A
}%
\edef\XINT_bezout_botharezero #1#2#3#4#5#6%
{%
    \noexpand\xintError:NoBezoutForZeros\space {0}{0}{0}{0}{0}%
}%
%    \end{macrocode}
% \lverb|&
% attention premire entre doit tre ici (-1)^n donc 1$\ 
% #4#2 = 0 = A, B = #3#1|
%    \begin{macrocode}
\def\XINT_bezout_firstiszero #1#2#3#4#5#6%
{%
    \xint_UDsignfork
      #3{ {0}{#3#1}{0}{1}{#1}}%
       -{ {0}{#3#1}{0}{-1}{#1}}%
    \krof
}%
%    \end{macrocode}
% \lverb|#4#2 = A, B = #3#1 = 0|
%    \begin{macrocode}
\def\XINT_bezout_secondiszero #1#2#3#4#5#6%
{%
    \xint_UDsignfork
       #4{ {#4#2}{0}{-1}{0}{#2}}%
        -{ {#4#2}{0}{1}{0}{#2}}%
    \krof
}%
%    \end{macrocode}
% \lverb|#4#2= A < 0, #3#1 = B < 0|
%    \begin{macrocode}
\def\XINT_bezout_minusminus #1#2#3#4%
{%
    \expandafter\XINT_bezout_mm_post
    \romannumeral0\XINT_bezout_loop_a 1{#1}{#2}1001%
}%
\def\XINT_bezout_mm_post #1#2%
{%
    \expandafter\XINT_bezout_mm_postb\expandafter
    {\romannumeral0\xintiiopp{#2}}{\romannumeral0\xintiiopp{#1}}%
}%
\def\XINT_bezout_mm_postb #1#2%
{%
    \expandafter\XINT_bezout_mm_postc\expandafter {#2}{#1}%
}%
\edef\XINT_bezout_mm_postc #1#2#3#4#5%
{%
    \space {#4}{#5}{#1}{#2}{#3}%
}%
%    \end{macrocode}
% \lverb|minusplus  #4#2= A > 0, B < 0|
%    \begin{macrocode}
\def\XINT_bezout_minusplus #1#2#3#4%
{%
    \expandafter\XINT_bezout_mp_post
    \romannumeral0\XINT_bezout_loop_a 1{#1}{#4#2}1001%
}%
\def\XINT_bezout_mp_post #1#2%
{%
    \expandafter\XINT_bezout_mp_postb\expandafter
      {\romannumeral0\xintiiopp {#2}}{#1}%
}%
\edef\XINT_bezout_mp_postb #1#2#3#4#5%
{%
    \space {#4}{#5}{#2}{#1}{#3}%
}%
%    \end{macrocode}
% \lverb|plusminus  A < 0, B > 0|
%    \begin{macrocode}
\def\XINT_bezout_plusminus #1#2#3#4%
{%
    \expandafter\XINT_bezout_pm_post
    \romannumeral0\XINT_bezout_loop_a 1{#3#1}{#2}1001%
}%
\def\XINT_bezout_pm_post #1%
{%
    \expandafter \XINT_bezout_pm_postb \expandafter
        {\romannumeral0\xintiiopp{#1}}%
}%
\edef\XINT_bezout_pm_postb #1#2#3#4#5%
{%
    \space {#4}{#5}{#1}{#2}{#3}%
}%
%    \end{macrocode}
% \lverb|plusplus|
%    \begin{macrocode}
\def\XINT_bezout_plusplus #1#2#3#4%
{%
    \expandafter\XINT_bezout_pp_post
    \romannumeral0\XINT_bezout_loop_a 1{#3#1}{#4#2}1001%
}%
%    \end{macrocode}
% \lverb|la parit (-1)^N est en #1, et on la jette ici.|
%    \begin{macrocode}
\edef\XINT_bezout_pp_post #1#2#3#4#5%
{%
    \space {#4}{#5}{#1}{#2}{#3}%
}%
%    \end{macrocode}
% \lverb|&
% n = 0: 1BAalpha(0)beta(0)alpha(-1)beta(-1)$\ 
% n gnral:
% {(-1)^n}{r(n-1)}{r(n-2)}{alpha(n-1)}{beta(n-1)}{alpha(n-2)}{beta(n-2)}$\ 
% #2 = B, #3 = A|
%    \begin{macrocode}
\def\XINT_bezout_loop_a #1#2#3%
{%
    \expandafter\XINT_bezout_loop_b
    \expandafter{\the\numexpr -#1\expandafter }%
    \romannumeral0\XINT_div_prepare {#2}{#3}{#2}%
}%
%    \end{macrocode}
% \lverb|&
% Le q(n) a ici une existence phmre, dans le version Bezout Algorithm
% il faudra le conserver. On voudra  la fin
% {{q(n)}{r(n)}{alpha(n)}{beta(n)}}.
% De plus ce n'est plus (-1)^n que l'on veut mais n. (ou dans un autre ordre)$\ 
% {-(-1)^n}{q(n)}{r(n)}{r(n-1)}{alpha(n-1)}{beta(n-1)}{alpha(n-2)}{beta(n-2)}|
%    \begin{macrocode}
\def\XINT_bezout_loop_b #1#2#3#4#5#6#7#8%
{%
    \expandafter \XINT_bezout_loop_c \expandafter
        {\romannumeral0\xintiiadd{\XINT_mul_fork #5\Z #2\Z}{#7}}%
        {\romannumeral0\xintiiadd{\XINT_mul_fork #6\Z #2\Z}{#8}}%
    {#1}{#3}{#4}{#5}{#6}%
}%
%    \end{macrocode}
% \lverb|{alpha(n)}{->beta(n)}{-(-1)^n}{r(n)}{r(n-1)}{alpha(n-1)}{beta(n-1)}|
%    \begin{macrocode}
\def\XINT_bezout_loop_c #1#2%
{%
    \expandafter \XINT_bezout_loop_d \expandafter
        {#2}{#1}%
}%
%    \end{macrocode}
% \lverb|{beta(n)}{alpha(n)}{(-1)^(n+1)}{r(n)}{r(n-1)}{alpha(n-1)}{beta(n-1)}|
%    \begin{macrocode}
\def\XINT_bezout_loop_d #1#2#3#4#5%
{%
    \XINT_bezout_loop_e #4\Z {#3}{#5}{#2}{#1}%
}%
%    \end{macrocode}
% \lverb|r(n)\Z {(-1)^(n+1)}{r(n-1)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}|
%    \begin{macrocode}
\def\XINT_bezout_loop_e #1#2\Z
{%
    \xint_gob_til_zero #1\xint_bezout_loop_exit0\XINT_bezout_loop_f
    {#1#2}%
}%
%    \end{macrocode}
% \lverb|{r(n)}{(-1)^(n+1)}{r(n-1)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}|
%    \begin{macrocode}
\def\XINT_bezout_loop_f #1#2%
{%
    \XINT_bezout_loop_a {#2}{#1}%
}%
%    \end{macrocode}
% \lverb|{(-1)^(n+1)}{r(n)}{r(n-1)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}
% et itration|
%    \begin{macrocode}
\def\xint_bezout_loop_exit0\XINT_bezout_loop_f #1#2%
{%
    \ifcase #2
    \or  \expandafter\XINT_bezout_exiteven
    \else\expandafter\XINT_bezout_exitodd
    \fi
}%
\edef\XINT_bezout_exiteven #1#2#3#4#5%
{%
    \space {#5}{#4}{#1}%
}%
\edef\XINT_bezout_exitodd #1#2#3#4#5%
{%
    \space {-#5}{-#4}{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintEuclideAlgorithm}}
% \lverb|&
% Pour Euclide:
% {N}{A}{D=r(n)}{B}{q1}{r1}{q2}{r2}{q3}{r3}....{qN}{rN=0}$\ 
% u<2n> = u<2n+3>u<2n+2> + u<2n+4>  la n ime tape|
%    \begin{macrocode}
\def\xintEuclideAlgorithm {\romannumeral0\xinteuclidealgorithm }%
\def\xinteuclidealgorithm #1%
{%
    \expandafter \XINT_euc \expandafter{\romannumeral0\xintiabs {#1}}%
}%
\def\XINT_euc #1#2%
{%
    \expandafter\XINT_euc_fork \romannumeral0\xintiabs {#2}\Z #1\Z
}%
%    \end{macrocode}
% \lverb|Ici #3#4=A, #1#2=B|
%    \begin{macrocode}
\def\XINT_euc_fork #1#2\Z #3#4\Z
{%
    \xint_UDzerofork
      #1\XINT_euc_BisZero
      #3\XINT_euc_AisZero
       0\XINT_euc_a
    \krof
    {0}{#1#2}{#3#4}{{#3#4}{#1#2}}{}\Z
}%
%    \end{macrocode}
% \lverb|&
% Le {} pour protger {{A}{B}} si on s'arrte aprs une tape (B divise
% A).
% On va renvoyer:$\ 
% {N}{A}{D=r(n)}{B}{q1}{r1}{q2}{r2}{q3}{r3}....{qN}{rN=0}|
%    \begin{macrocode}
\def\XINT_euc_AisZero #1#2#3#4#5#6{ {1}{0}{#2}{#2}{0}{0}}%
\def\XINT_euc_BisZero #1#2#3#4#5#6{ {1}{0}{#3}{#3}{0}{0}}%
%    \end{macrocode}
% \lverb|&
% {n}{rn}{an}{{qn}{rn}}...{{A}{B}}{}\Z$\ 
%  a(n) = r(n-1). Pour n=0 on a juste {0}{B}{A}{{A}{B}}{}\Z$\ 
% \XINT_div_prepare {u}{v} divise v par u|
%    \begin{macrocode}
\def\XINT_euc_a #1#2#3%
{%
    \expandafter\XINT_euc_b
    \expandafter {\the\numexpr #1+1\expandafter }%
    \romannumeral0\XINT_div_prepare {#2}{#3}{#2}%
}%
%    \end{macrocode}
% \lverb|{n+1}{q(n+1)}{r(n+1)}{rn}{{qn}{rn}}...|
%    \begin{macrocode}
\def\XINT_euc_b #1#2#3#4%
{%
    \XINT_euc_c #3\Z {#1}{#3}{#4}{{#2}{#3}}%
}%
%    \end{macrocode}
% \lverb|r(n+1)\Z {n+1}{r(n+1)}{r(n)}{{q(n+1)}{r(n+1)}}{{qn}{rn}}...$\ 
% Test si r(n+1) est nul.|
%    \begin{macrocode}
\def\XINT_euc_c #1#2\Z
{%
    \xint_gob_til_zero #1\xint_euc_end0\XINT_euc_a
}%
%    \end{macrocode}
% \lverb|&
% {n+1}{r(n+1)}{r(n)}{{q(n+1)}{r(n+1)}}...{}\Z
% Ici r(n+1) = 0. On arrte on se prpare  inverser
% {n+1}{0}{r(n)}{{q(n+1)}{r(n+1)}}.....{{q1}{r1}}{{A}{B}}{}\Z$\ 
% On veut renvoyer: {N=n+1}{A}{D=r(n)}{B}{q1}{r1}{q2}{r2}{q3}{r3}....{qN}{rN=0}|
%    \begin{macrocode}
\def\xint_euc_end0\XINT_euc_a #1#2#3#4\Z%
{%
    \expandafter\xint_euc_end_
    \romannumeral0%
    \XINT_rord_main {}#4{{#1}{#3}}%
    \xint_relax
      \xint_bye\xint_bye\xint_bye\xint_bye
      \xint_bye\xint_bye\xint_bye\xint_bye
    \xint_relax
}%
\edef\xint_euc_end_ #1#2#3%
{%
    \space {#1}{#3}{#2}%
}%
%    \end{macrocode}
% \subsection{\csh{xintBezoutAlgorithm}}
% \lverb|&
% Pour Bezout: objectif, renvoyer$\ 
% {N}{A}{0}{1}{D=r(n)}{B}{1}{0}{q1}{r1}{alpha1=q1}{beta1=1}$\ 
%       {q2}{r2}{alpha2}{beta2}....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}$\ 
% alpha0=1, beta0=0, alpha(-1)=0, beta(-1)=1|
%    \begin{macrocode}
\def\xintBezoutAlgorithm {\romannumeral0\xintbezoutalgorithm }%
\def\xintbezoutalgorithm #1%
{%
    \expandafter \XINT_bezalg \expandafter{\romannumeral0\xintiabs {#1}}%
}%
\def\XINT_bezalg #1#2%
{%
    \expandafter\XINT_bezalg_fork \romannumeral0\xintiabs {#2}\Z #1\Z
}%
%    \end{macrocode}
% \lverb|Ici #3#4=A, #1#2=B|
%    \begin{macrocode}
\def\XINT_bezalg_fork #1#2\Z #3#4\Z
{%
    \xint_UDzerofork
      #1\XINT_bezalg_BisZero
      #3\XINT_bezalg_AisZero
       0\XINT_bezalg_a
    \krof
    0{#1#2}{#3#4}1001{{#3#4}{#1#2}}{}\Z
}%
\def\XINT_bezalg_AisZero #1#2#3\Z{ {1}{0}{0}{1}{#2}{#2}{1}{0}{0}{0}{0}{1}}%
\def\XINT_bezalg_BisZero #1#2#3#4\Z{ {1}{0}{0}{1}{#3}{#3}{1}{0}{0}{0}{0}{1}}%
%    \end{macrocode}
% \lverb|&
% pour prparer l'tape n+1 il faut
% {n}{r(n)}{r(n-1)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}&
%                    {{q(n)}{r(n)}{alpha(n)}{beta(n)}}...
% division de #3 par #2|
%    \begin{macrocode}
\def\XINT_bezalg_a #1#2#3%
{%
    \expandafter\XINT_bezalg_b
    \expandafter {\the\numexpr #1+1\expandafter }%
    \romannumeral0\XINT_div_prepare {#2}{#3}{#2}%
}%
%    \end{macrocode}
% \lverb|&
% {n+1}{q(n+1)}{r(n+1)}{r(n)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}...|
%    \begin{macrocode}
\def\XINT_bezalg_b #1#2#3#4#5#6#7#8%
{%
    \expandafter\XINT_bezalg_c\expandafter
     {\romannumeral0\xintiiadd {\xintiiMul {#6}{#2}}{#8}}%
     {\romannumeral0\xintiiadd {\xintiiMul {#5}{#2}}{#7}}%
     {#1}{#2}{#3}{#4}{#5}{#6}%
}%
%    \end{macrocode}
% \lverb|&
% {beta(n+1)}{alpha(n+1)}{n+1}{q(n+1)}{r(n+1)}{r(n)}{alpha(n)}{beta(n}}|
%    \begin{macrocode}
\def\XINT_bezalg_c #1#2#3#4#5#6%
{%
    \expandafter\XINT_bezalg_d\expandafter {#2}{#3}{#4}{#5}{#6}{#1}%
}%
%    \end{macrocode}
% \lverb|{alpha(n+1)}{n+1}{q(n+1)}{r(n+1)}{r(n)}{beta(n+1)}|
%    \begin{macrocode}
\def\XINT_bezalg_d #1#2#3#4#5#6#7#8%
{%
    \XINT_bezalg_e #4\Z {#2}{#4}{#5}{#1}{#6}{#7}{#8}{{#3}{#4}{#1}{#6}}%
}%
%    \end{macrocode}
% \lverb|r(n+1)\Z {n+1}{r(n+1)}{r(n)}{alpha(n+1)}{beta(n+1)}$\ 
%                              {alpha(n)}{beta(n)}{q,r,alpha,beta(n+1)}$\ 
% Test si r(n+1) est nul.|
%    \begin{macrocode}
\def\XINT_bezalg_e #1#2\Z
{%
    \xint_gob_til_zero #1\xint_bezalg_end0\XINT_bezalg_a
}%
%    \end{macrocode}
% \lverb|&
% Ici r(n+1) = 0. On arrte on se prpare  inverser.$\ 
% {n+1}{r(n+1)}{r(n)}{alpha(n+1)}{beta(n+1)}{alpha(n)}{beta(n)}$\ 
%                     {q,r,alpha,beta(n+1)}...{{A}{B}}{}\Z$\ 
% On veut renvoyer$\ 
% {N}{A}{0}{1}{D=r(n)}{B}{1}{0}{q1}{r1}{alpha1=q1}{beta1=1}$\ 
%       {q2}{r2}{alpha2}{beta2}....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}|
%    \begin{macrocode}
\def\xint_bezalg_end0\XINT_bezalg_a #1#2#3#4#5#6#7#8\Z
{%
    \expandafter\xint_bezalg_end_
    \romannumeral0%
    \XINT_rord_main {}#8{{#1}{#3}}%
    \xint_relax
      \xint_bye\xint_bye\xint_bye\xint_bye
      \xint_bye\xint_bye\xint_bye\xint_bye
    \xint_relax
}%
%    \end{macrocode}
% \lverb|&
% {N}{D}{A}{B}{q1}{r1}{alpha1=q1}{beta1=1}{q2}{r2}{alpha2}{beta2}$\ 
%      ....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}$\ 
% On veut renvoyer$\ 
% {N}{A}{0}{1}{D=r(n)}{B}{1}{0}{q1}{r1}{alpha1=q1}{beta1=1}$\ 
%        {q2}{r2}{alpha2}{beta2}....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}|
%    \begin{macrocode}
\edef\xint_bezalg_end_ #1#2#3#4%
{%
    \space {#1}{#3}{0}{1}{#2}{#4}{1}{0}%
}%
%    \end{macrocode}
% \subsection{\csh{xintGCDof}}
% \lverb|New with 1.09a. I also tried an optimization (not working two by two)
% which I thought was clever but
% it seemed to be less efficient ...|
%    \begin{macrocode}
\def\xintGCDof      {\romannumeral0\xintgcdof }%
\def\xintgcdof    #1{\expandafter\XINT_gcdof_a\romannumeral`&&@#1\relax }%
\def\XINT_gcdof_a #1{\expandafter\XINT_gcdof_b\romannumeral`&&@#1\Z }%
\def\XINT_gcdof_b #1\Z #2{\expandafter\XINT_gcdof_c\romannumeral`&&@#2\Z {#1}\Z}%
\def\XINT_gcdof_c #1{\xint_gob_til_relax #1\XINT_gcdof_e\relax\XINT_gcdof_d #1}%
\def\XINT_gcdof_d #1\Z {\expandafter\XINT_gcdof_b\romannumeral0\xintgcd {#1}}%
\def\XINT_gcdof_e #1\Z #2\Z { #2}%
%    \end{macrocode}
% \subsection{\csh{xintLCMof}}
% \lverb|New with 1.09a|
%    \begin{macrocode}
\def\xintLCMof      {\romannumeral0\xintlcmof }%
\def\xintlcmof    #1{\expandafter\XINT_lcmof_a\romannumeral`&&@#1\relax }%
\def\XINT_lcmof_a #1{\expandafter\XINT_lcmof_b\romannumeral`&&@#1\Z }%
\def\XINT_lcmof_b #1\Z #2{\expandafter\XINT_lcmof_c\romannumeral`&&@#2\Z {#1}\Z}%
\def\XINT_lcmof_c #1{\xint_gob_til_relax #1\XINT_lcmof_e\relax\XINT_lcmof_d #1}%
\def\XINT_lcmof_d #1\Z {\expandafter\XINT_lcmof_b\romannumeral0\xintlcm {#1}}%
\def\XINT_lcmof_e #1\Z #2\Z { #2}%
%    \end{macrocode}
% \subsection{\csh{xintTypesetEuclideAlgorithm}}
% \lverb|&
% TYPESETTING
%
% Organisation:
%
% {N}{A}{D}{B}{q1}{r1}{q2}{r2}{q3}{r3}....{qN}{rN=0}$\ 
% \U1 = N = nombre d'tapes, \U3 = PGCD, \U2 = A, \U4=B
% q1 = \U5, q2 = \U7 --> qn = \U<2n+3>, rn = \U<2n+4>
% bn = rn. B = r0. A=r(-1)
%
% r(n-2) = q(n)r(n-1)+r(n) (n e tape)
%
% \U{2n} = \U{2n+3} \times \U{2n+2} + \U{2n+4}, n e tape.
% (avec n entre 1 et N)
%
% 1.09h uses \xintloop, and \par rather than \endgraf; and \par rather than
% \hfill\break|
%    \begin{macrocode}
\def\xintTypesetEuclideAlgorithm {%
    \unless\ifdefined\xintAssignArray
       \errmessage
        {xintgcd: package xinttools is required for \string\xintTypesetEuclideAlgorithm}%
       \expandafter\xint_gobble_iii
    \fi
    \XINT_TypesetEuclideAlgorithm
}%
\def\XINT_TypesetEuclideAlgorithm #1#2%
{% l'algo remplace #1 et #2 par |#1| et |#2|
  \par
  \begingroup
    \xintAssignArray\xintEuclideAlgorithm {#1}{#2}\to\U
    \edef\A{\U2}\edef\B{\U4}\edef\N{\U1}%
    \setbox 0 \vbox{\halign {$##$\cr \A\cr \B \cr}}%
    \count 255 1
    \xintloop
      \indent\hbox to \wd 0 {\hfil$\U{\numexpr 2*\count255\relax}$}%
      ${} =  \U{\numexpr 2*\count255 + 3\relax}
      \times \U{\numexpr 2*\count255 + 2\relax}
          +  \U{\numexpr 2*\count255 + 4\relax}$%
    \ifnum \count255 < \N
      \par
      \advance \count255 1
    \repeat
  \endgroup
}%
%    \end{macrocode}
% \subsection{\csh{xintTypesetBezoutAlgorithm}}
% \lverb|&
% Pour Bezout on a:
% {N}{A}{0}{1}{D=r(n)}{B}{1}{0}{q1}{r1}{alpha1=q1}{beta1=1}$\ 
%             {q2}{r2}{alpha2}{beta2}....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}%
% Donc 4N+8 termes:
% U1 = N, U2= A, U5=D, U6=B, q1 = U9, qn = U{4n+5}, n au moins 1$\ 
% rn = U{4n+6}, n au moins -1$\ 
% alpha(n) = U{4n+7}, n au moins -1$\ 
% beta(n)  = U{4n+8}, n au moins -1
%
% 1.09h uses \xintloop, and \par rather than \endgraf; and no more \parindent0pt
% |
%    \begin{macrocode}
\def\xintTypesetBezoutAlgorithm {%
    \unless\ifdefined\xintAssignArray
       \errmessage
        {xintgcd: package xinttools is required for \string\xintTypesetBezoutAlgorithm}%
       \expandafter\xint_gobble_iii
    \fi
    \XINT_TypesetBezoutAlgorithm
}%
\def\XINT_TypesetBezoutAlgorithm #1#2%
{%
  \par
  \begingroup
    \xintAssignArray\xintBezoutAlgorithm {#1}{#2}\to\BEZ
    \edef\A{\BEZ2}\edef\B{\BEZ6}\edef\N{\BEZ1}% A = |#1|, B = |#2|
    \setbox 0 \vbox{\halign {$##$\cr \A\cr \B \cr}}%
    \count255 1
    \xintloop
      \indent\hbox to \wd 0 {\hfil$\BEZ{4*\count255 - 2}$}%
      ${} =  \BEZ{4*\count255 + 5}
      \times \BEZ{4*\count255 + 2}
          +  \BEZ{4*\count255 + 6}$\hfill\break
      \hbox to \wd 0 {\hfil$\BEZ{4*\count255 +7}$}%
      ${} = \BEZ{4*\count255 + 5}
      \times \BEZ{4*\count255 + 3}
          +  \BEZ{4*\count255 - 1}$\hfill\break
      \hbox to \wd 0 {\hfil$\BEZ{4*\count255 +8}$}%
      ${} =  \BEZ{4*\count255 + 5}
      \times \BEZ{4*\count255 + 4}
          +  \BEZ{4*\count255 }$
      \par
    \ifnum \count255 < \N
    \advance \count255 1
  \repeat
    \edef\U{\BEZ{4*\N + 4}}%
    \edef\V{\BEZ{4*\N + 3}}%
    \edef\D{\BEZ5}%
    \ifodd\N
       $\U\times\A  - \V\times \B = -\D$%
    \else
       $\U\times\A - \V\times\B = \D$%
    \fi
    \par
  \endgroup
}%
\XINT_restorecatcodes_endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xintgcd>\relax
%\def<*xintfrac>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xintgcd>
%<*xintfrac>
%
% \StoreCodelineNo {xintgcd}
%
% \section{Package \xintfracnameimp implementation}
% \label{sec:fracimp}
%
% \localtableofcontents
%
% The commenting is currently (\xintdocdate) very sparse.
%
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
%
% The code for reload detection was initially copied from \textsc{Heiko
% Oberdiek}'s packages, then modified.
%
% The method for catcodes was also initially directly inspired by these
% packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xintfrac.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xint.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintfrac}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintfrac.sty
      \ifx\w\relax % but xint.sty not yet loaded.
         \def\z{\endgroup\input xint.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xint.sty not yet loaded.
            \def\z{\endgroup\RequirePackage{xint}}%
          \fi
      \else
        \aftergroup\endinput % xintfrac already loaded.
      \fi
    \fi
  \fi
\z%
\XINTsetupcatcodes% defined in xintkernel.sty
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\XINT_providespackage
\ProvidesPackage{xintfrac}%
  [2015/11/18 v1.2d Expandable operations on fractions (jfB)]%
%    \end{macrocode}
% \subsection{\csh{XINT_cntSgnFork}}
% \lverb|1.09i. Used internally, #1 must expand to \m@ne, \z@, or \@ne or
% equivalent. Does not insert a space token to stop a romannumeral0 expansion.|
%    \begin{macrocode}
\def\XINT_cntSgnFork #1%
{%
    \ifcase #1\expandafter\xint_secondofthree
            \or\expandafter\xint_thirdofthree
          \else\expandafter\xint_firstofthree
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintLen}}
%    \begin{macrocode}
\def\xintLen {\romannumeral0\xintlen }%
\def\xintlen #1%
{%
    \expandafter\XINT_flen\romannumeral0\XINT_infrac {#1}%
}%
\def\XINT_flen #1#2#3%
{%
    \expandafter\space
    \the\numexpr -1+\XINT_Abs {#1}+\XINT_Len {#2}+\XINT_Len {#3}\relax
}%
%    \end{macrocode}
% \subsection{\csh{XINT_lenrord_loop}}
%    \begin{macrocode}
\def\XINT_lenrord_loop #1#2#3#4#5#6#7#8#9%
{%  faire \romannumeral`&&@\XINT_lenrord_loop 0{}#1\Z\W\W\W\W\W\W\W\Z
    \xint_gob_til_W #9\XINT_lenrord_W\W
    \expandafter\XINT_lenrord_loop\expandafter
    {\the\numexpr #1+7}{#9#8#7#6#5#4#3#2}%
}%
\def\XINT_lenrord_W\W\expandafter\XINT_lenrord_loop\expandafter #1#2#3\Z
{%
    \expandafter\XINT_lenrord_X\expandafter {#1}#2\Z
}%
\def\XINT_lenrord_X #1#2\Z
{%
    \XINT_lenrord_Y #2\R\R\R\R\R\R\T {#1}%
}%
\def\XINT_lenrord_Y #1#2#3#4#5#6#7#8\T
{%
    \xint_gob_til_W
            #7\XINT_lenrord_Z \xint_c_viii
            #6\XINT_lenrord_Z \xint_c_vii
            #5\XINT_lenrord_Z \xint_c_vi
            #4\XINT_lenrord_Z \xint_c_v
            #3\XINT_lenrord_Z \xint_c_iv
            #2\XINT_lenrord_Z \xint_c_iii
            \W\XINT_lenrord_Z \xint_c_ii   \Z
}%
\def\XINT_lenrord_Z #1#2\Z #3% retourne: {longueur}renverse\Z
{%
    \expandafter{\the\numexpr #3-#1\relax}%
}%
%    \end{macrocode}
% \subsection{\csh{XINT_outfrac}}
% \lverb|&
% 1.06a version now outputs 0/1[0] and not 0[0] in case of zero. More generally
% all macros have been checked in xintfrac, xintseries, xintcfrac, to make sure
% the output format for fractions was always A/B[n]. (except \xintIrr,
% \xintJrr, \xintRawWithZeros)
%
% The problem with statements like those in the previous paragraph is that it is
% hard to maintain consistencies across relases. 
%
% Months later (2014/10/22): perhaps I should document what this macro does
% before I forget?  from {e}{N}{D} it outputs N/D[e], checking in passing if
% D=0 or if N=0. It also makes sure D is not < 0. I am not sure but I don't
% think there is any place in the code which could call \XINT_outfrac with a D
% < 0, but I should check.|
%    \begin{macrocode}
\def\XINT_outfrac #1#2#3%
{%
    \ifcase\XINT_cntSgn #3\Z
        \expandafter \XINT_outfrac_divisionbyzero
    \or
        \expandafter \XINT_outfrac_P
    \else
        \expandafter \XINT_outfrac_N
    \fi
    {#2}{#3}[#1]%
}%
\def\XINT_outfrac_divisionbyzero #1#2{\xintError:DivisionByZero\space #1/0}%
\edef\XINT_outfrac_P #1#2%
{%
    \noexpand\if0\noexpand\XINT_Sgn #1\noexpand\Z
        \noexpand\expandafter\noexpand\XINT_outfrac_Zero
    \noexpand\fi
    \space #1/#2%
}%
\def\XINT_outfrac_Zero #1[#2]{ 0/1[0]}%
\def\XINT_outfrac_N #1#2%
{%
    \expandafter\XINT_outfrac_N_a\expandafter
    {\romannumeral0\XINT_opp #2}{\romannumeral0\XINT_opp #1}%
}%
\def\XINT_outfrac_N_a #1#2%
{%
    \expandafter\XINT_outfrac_P\expandafter {#2}{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{XINT_inFrac}}
% \lverb|Extended in 1.07 to accept scientific notation on input. With lowercase
% e only. The \xintexpr parser does accept uppercase E also. Ah, by the way,
% perhaps I should at least say what this macro does? (belated addition
% 2014/10/22...), before I forget! It prepares the fraction in the internal
% format {exponent}{Numerator}{Denominator} where Denominator is at least 1.
%
% 2015/10/09: this venerable macro from the early days (1.03, 2013/04/14) has
% gotten a lifting for release 1.2. There were two kinds of issues:
%
% 1) use of \W, \Z, \T delimiters was very poor choice as this could clash with
% user input,
%
% 2) the new \XINT_frac_gen handles macros (possibly empty) in the input as
% general as \A.\Be\C/\D.\Ee\F. The earlier version would not have expanded
% the \B for example (only \A, \D, \C, \F).
%
% I wanted to make stricter the restricted A/B[N] case, doing no expansion of
% B, but this clashed with some established uses in the documentation like
% 1/\xintiiSqr{...}[0] for example. Thus I maintained it despite overhead of
% having to go over A one more time. Careful also here about potential brace
% removals if one does stuff like #1/#2#3[#4] regarding the #3. And while I
% was at it I added \numexpr parsing of the N, which earlier was restricted to
% be only explicit digits, and I even allowed [] with an empty N.
%
% This little event makes me think I should read again other remaining
% portions my early code, as I was still learning TeX coding at that time.|
%    \begin{macrocode}
\def\XINT_inFrac {\romannumeral0\XINT_infrac }%
\def\XINT_infrac #1%
{%
    \expandafter\XINT_infrac_fork\romannumeral`&&@#1/\XINT_W[\XINT_W\XINT_T
}%
\def\XINT_infrac_fork #1[#2%
{%
    \xint_UDXINTWfork
      #2\XINT_frac_gen
      \XINT_W\XINT_infrac_res_a % strict A[N] or A/B[N] input
    \krof
    #1[#2%
}%
\def\XINT_infrac_res_a #1%
{%
    \xint_gob_til_zero #1\XINT_infrac_res_zero 0\XINT_infrac_res_b #1%
}%
\def\XINT_infrac_res_zero 0\XINT_infrac_res_b #1\XINT_T {{0}{0}{1}}%
\def\XINT_infrac_res_b #1/#2%
{%
    \xint_UDXINTWfork
     #2\XINT_infrac_res_ca
     \XINT_W\XINT_infrac_res_cb
    \krof
    #1/#2%
}%
\def\XINT_infrac_res_ca #1[#2]/\XINT_W[\XINT_W\XINT_T     
   {\expandafter{\the\numexpr 0#2}{#1}{1}}%
\def\XINT_infrac_res_cb #1/#2[%
   {\expandafter\XINT_infrac_res_cc\romannumeral`&&@#2~#1[}%
\def\XINT_infrac_res_cc #1~#2[#3]/\XINT_W[\XINT_W\XINT_T 
   {\expandafter{\the\numexpr 0#3}{#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{XINT_frac_gen}}
% \lverb|Extended in 1.07 to recognize and accept scientific notation both at
% the numerator and (possible) denominator. Only a lowercase e will do here, but
% uppercase E is possible within an \xintexpr..\relax 
%
% Completely rewritten for 1.2 2015/10/10. It now is able to handles inputs
% such as \A.\Be\C/\D.\Ee\F where each of \A, \B, \D, and \E may need
% \fexpan sion and \C and \F will end up in \numexpr.|
%    \begin{macrocode}
\def\XINT_frac_gen #1/#2%
{%
    \xint_UDXINTWfork
      #2\XINT_frac_gen_A
      \XINT_W\XINT_frac_gen_B
    \krof
    #1/#2%
}%
\def\XINT_frac_gen_A #1/\XINT_W [\XINT_W {\XINT_frac_gen_C 0~1!#1ee.\XINT_W }%
\def\XINT_frac_gen_B #1/#2/\XINT_W[%\XINT_W
{%
    \expandafter\XINT_frac_gen_Ba
    \romannumeral`&&@#2ee.\XINT_W\XINT_Z #1ee.%\XINT_W
}%
\def\XINT_frac_gen_Ba #1.#2%
{%
    \xint_UDXINTWfork
      #2\XINT_frac_gen_Bb
      \XINT_W\XINT_frac_gen_Bc
    \krof
    #1.#2%
}%
\def\XINT_frac_gen_Bb #1e#2e#3\XINT_Z 
                {\expandafter\XINT_frac_gen_C\the\numexpr 0#2~#1!}%
\def\XINT_frac_gen_Bc #1.#2e%
{%
    \expandafter\XINT_frac_gen_Bd\romannumeral`&&@#2.#1e%
}%
\def\XINT_frac_gen_Bd #1.#2e#3e#4\XINT_Z
{%
    \expandafter\XINT_frac_gen_C\the\numexpr 0#3-\romannumeral0\expandafter
    \XINT_length_loop 
        0.#1\xint_relax\xint_relax\xint_relax\xint_relax
            \xint_relax\xint_relax\xint_relax\xint_relax\xint_bye~#2#1!%
}%
\def\XINT_frac_gen_C #1!#2.#3%
{%
    \xint_UDXINTWfork
      #3\XINT_frac_gen_Ca
      \XINT_W\XINT_frac_gen_Cb
    \krof
    #1!#2.#3%
}%
\def\XINT_frac_gen_Ca #1~#2!#3e#4e#5\XINT_T
{%
    \expandafter\XINT_frac_gen_F\the\numexpr #4-#1\expandafter
    ~\romannumeral0\XINT_num_loop
     #2\xint_relax\xint_relax\xint_relax\xint_relax
      \xint_relax\xint_relax\xint_relax\xint_relax\Z~#3~%
}%
\def\XINT_frac_gen_Cb #1.#2e%
{%
    \expandafter\XINT_frac_gen_Cc\romannumeral`&&@#2.#1e%
}%
\def\XINT_frac_gen_Cc #1.#2~#3!#4e#5e#6\XINT_T
{%
    \expandafter\XINT_frac_gen_F\the\numexpr #5-#2-%
    \romannumeral0\XINT_length_loop
      0.#1\xint_relax\xint_relax\xint_relax\xint_relax
      \xint_relax\xint_relax\xint_relax\xint_relax\xint_bye\expandafter
    ~\romannumeral0\XINT_num_loop
     #3\xint_relax\xint_relax\xint_relax\xint_relax
      \xint_relax\xint_relax\xint_relax\xint_relax\Z
    ~#4#1~%
}%
\def\XINT_frac_gen_F #1~#2%
{%
    \xint_UDzerominusfork
      #2-\XINT_frac_gen_Gdivbyzero
      0#2{\XINT_frac_gen_G  -{}}%
       0-{\XINT_frac_gen_G {}#2}%
    \krof  #1~%
}%
\def\XINT_frac_gen_Gdivbyzero #1~~#2~%
{%
   \expandafter\XINT_frac_gen_Gdivbyzero_a
   \romannumeral0\XINT_num_loop
     #2\xint_relax\xint_relax\xint_relax\xint_relax
      \xint_relax\xint_relax\xint_relax\xint_relax\Z~#1~%
}%
\def\XINT_frac_gen_Gdivbyzero_a #1~#2~%
{%
    \xintError:DivisionByZero {#2}{#1}{0}% 
}%
\def\XINT_frac_gen_G #1#2#3~#4~#5~%
{%
    \expandafter\XINT_frac_gen_Ga
    \romannumeral0\XINT_num_loop 
      #1#5\xint_relax\xint_relax\xint_relax\xint_relax
      \xint_relax\xint_relax\xint_relax\xint_relax\Z~#3~{#2#4}%
}%
\def\XINT_frac_gen_Ga #1#2~#3~%
{%
    \xint_gob_til_zero #1\XINT_frac_gen_zero 0%
    {#3}{#1#2}%
}%
\def\XINT_frac_gen_zero 0#1#2#3{{0}{0}{1}}%
%    \end{macrocode}
% \subsection{\csh{XINT_factortens}, \csh{XINT_cuz_cnt}}
%    \begin{macrocode}
\def\XINT_factortens #1%
{%
    \expandafter\XINT_cuz_cnt_loop\expandafter
    {\expandafter}\romannumeral0\XINT_rord_main {}#1%
      \xint_relax
        \xint_bye\xint_bye\xint_bye\xint_bye
        \xint_bye\xint_bye\xint_bye\xint_bye
      \xint_relax
    \R\R\R\R\R\R\R\R\Z
}%
\def\XINT_cuz_cnt #1%
{%
    \XINT_cuz_cnt_loop {}#1\R\R\R\R\R\R\R\R\Z
}%
\def\XINT_cuz_cnt_loop #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_R #9\XINT_cuz_cnt_toofara \R
    \expandafter\XINT_cuz_cnt_checka\expandafter
    {\the\numexpr #1+8\relax}{#2#3#4#5#6#7#8#9}%
}%
\def\XINT_cuz_cnt_toofara\R
    \expandafter\XINT_cuz_cnt_checka\expandafter #1#2%
{%
    \XINT_cuz_cnt_toofarb {#1}#2%
}%
\def\XINT_cuz_cnt_toofarb #1#2\Z {\XINT_cuz_cnt_toofarc #2\Z {#1}}%
\def\XINT_cuz_cnt_toofarc #1#2#3#4#5#6#7#8%
{%
    \xint_gob_til_R #2\XINT_cuz_cnt_toofard 7%
            #3\XINT_cuz_cnt_toofard 6%
            #4\XINT_cuz_cnt_toofard 5%
            #5\XINT_cuz_cnt_toofard 4%
            #6\XINT_cuz_cnt_toofard 3%
            #7\XINT_cuz_cnt_toofard 2%
            #8\XINT_cuz_cnt_toofard 1%
            \Z #1#2#3#4#5#6#7#8%
}%
\def\XINT_cuz_cnt_toofard #1#2\Z #3\R #4\Z #5%
{%
    \expandafter\XINT_cuz_cnt_toofare
    \the\numexpr #3\relax \R\R\R\R\R\R\R\R\Z
    {\the\numexpr #5-#1\relax}\R\Z
}%
\def\XINT_cuz_cnt_toofare #1#2#3#4#5#6#7#8%
{%
    \xint_gob_til_R #2\XINT_cuz_cnt_stopc 1%
            #3\XINT_cuz_cnt_stopc 2%
            #4\XINT_cuz_cnt_stopc 3%
            #5\XINT_cuz_cnt_stopc 4%
            #6\XINT_cuz_cnt_stopc 5%
            #7\XINT_cuz_cnt_stopc 6%
            #8\XINT_cuz_cnt_stopc 7%
            \Z #1#2#3#4#5#6#7#8%
}%
\def\XINT_cuz_cnt_checka #1#2%
{%
    \expandafter\XINT_cuz_cnt_checkb\the\numexpr #2\relax \Z {#1}%
}%
\def\XINT_cuz_cnt_checkb #1%
{%
    \xint_gob_til_zero #1\expandafter\XINT_cuz_cnt_loop\xint_gob_til_Z
    0\XINT_cuz_cnt_stopa #1%
}%
\def\XINT_cuz_cnt_stopa #1\Z
{%
    \XINT_cuz_cnt_stopb #1\R\R\R\R\R\R\R\R\Z %
}%
\def\XINT_cuz_cnt_stopb #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_R #2\XINT_cuz_cnt_stopc 1%
            #3\XINT_cuz_cnt_stopc 2%
            #4\XINT_cuz_cnt_stopc 3%
            #5\XINT_cuz_cnt_stopc 4%
            #6\XINT_cuz_cnt_stopc 5%
            #7\XINT_cuz_cnt_stopc 6%
            #8\XINT_cuz_cnt_stopc 7%
            #9\XINT_cuz_cnt_stopc 8%
            \Z #1#2#3#4#5#6#7#8#9%
}%
\def\XINT_cuz_cnt_stopc #1#2\Z #3\R #4\Z #5%
{%
    \expandafter\XINT_cuz_cnt_stopd\expandafter
    {\the\numexpr #5-#1}#3%
}%
\def\XINT_cuz_cnt_stopd #1#2\R #3\Z
{%
    \expandafter\space\expandafter
     {\romannumeral0\XINT_rord_main {}#2%
      \xint_relax
        \xint_bye\xint_bye\xint_bye\xint_bye
        \xint_bye\xint_bye\xint_bye\xint_bye
      \xint_relax }{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{XINT_addm_A}}
% \lverb|This is a routine from xintcore 1.0x, which is needed by \xintFloat,
% \XINTinFloat and \xintRound, for the time being. I should moved it here, now
% that xintcore has been entirely rewritten with release 1.2.|
%    \begin{macrocode}
\def\XINT_addm_A #1#2#3#4#5#6%
{%
    \xint_gob_til_W #3\xint_addm_az\W
    \XINT_addm_AB #1{#3#4#5#6}{#2}%
}%
\def\xint_addm_az\W\XINT_addm_AB #1#2%
{%
    \XINT_addm_AC_checkcarry #1%
}%
\def\XINT_addm_AB #1#2#3#4\W\X\Y\Z #5#6#7#8%
{%
    \XINT_addm_ABE #1#2{#8#7#6#5}{#3}#4\W\X\Y\Z
}%
\def\XINT_addm_ABE #1#2#3#4#5#6%
{%
    \expandafter\XINT_addm_ABEA\the\numexpr #1+10#5#4#3#2+#6.%
}%
\def\XINT_addm_ABEA #1#2#3.#4%
{%
    \XINT_addm_A  #2{#3#4}%
}%
\def\XINT_addm_AC_checkcarry #1%
{%
    \xint_gob_til_zero #1\xint_addm_AC_nocarry 0\XINT_addm_C
}%
\def\xint_addm_AC_nocarry 0\XINT_addm_C #1#2\W\X\Y\Z
{%
    \expandafter
    \xint_cleanupzeros_andstop
    \romannumeral0%
    \XINT_rord_main {}#2%
      \xint_relax
        \xint_bye\xint_bye\xint_bye\xint_bye
        \xint_bye\xint_bye\xint_bye\xint_bye
      \xint_relax
    #1%
}%
\def\XINT_addm_C #1#2#3#4#5%
{%
    \xint_gob_til_W
    #5\xint_addm_cw
    #4\xint_addm_cx
    #3\xint_addm_cy
    #2\xint_addm_cz
    \W\XINT_addm_CD {#5#4#3#2}{#1}%
}%
\def\XINT_addm_CD #1%
{%
    \expandafter\XINT_addm_CC\the\numexpr 1+10#1.%
}%
\def\XINT_addm_CC #1#2#3.#4%
{%
    \XINT_addm_AC_checkcarry  #2{#3#4}%
}%
\def\xint_addm_cw
    #1\xint_addm_cx
    #2\xint_addm_cy
    #3\xint_addm_cz
    \W\XINT_addm_CD
{%
    \expandafter\XINT_addm_CDw\the\numexpr 1+#1#2#3.%
}%
\def\XINT_addm_CDw #1.#2#3\X\Y\Z
{%
    \XINT_addm_end #1#3%
}%
\def\xint_addm_cx
    #1\xint_addm_cy
    #2\xint_addm_cz
    \W\XINT_addm_CD
{%
    \expandafter\XINT_addm_CDx\the\numexpr 1+#1#2.%
}%
\def\XINT_addm_CDx #1.#2#3\Y\Z
{%
    \XINT_addm_end #1#3%
}%
\def\xint_addm_cy
    #1\xint_addm_cz
    \W\XINT_addm_CD
{%
    \expandafter\XINT_addm_CDy\the\numexpr 1+#1.%
}%
\def\XINT_addm_CDy  #1.#2#3\Z
{%
    \XINT_addm_end #1#3%
}%
\def\xint_addm_cz\W\XINT_addm_CD #1#2#3{\XINT_addm_end #1#3}%
\edef\XINT_addm_end #1#2#3#4#5%
    {\noexpand\expandafter\space\noexpand\the\numexpr #1#2#3#4#5\relax}%
%    \end{macrocode}
% \subsection{\csh{xintRaw}}
% \lverb|&
% 1.07: this macro simply prints in a user readable form the fraction after its
% initial scanning. Useful when put inside braces in an \xintexpr, when the
% input is not yet in the A/B[n] form.|
%    \begin{macrocode}
\def\xintRaw {\romannumeral0\xintraw }%
\def\xintraw
{%
    \expandafter\XINT_raw\romannumeral0\XINT_infrac
}%
\def\XINT_raw #1#2#3{ #2/#3[#1]}%
%    \end{macrocode}
% \subsection{\csh{xintPRaw}}
% \lverb|1.09b|
%    \begin{macrocode}
\def\xintPRaw {\romannumeral0\xintpraw }%
\def\xintpraw
{%
    \expandafter\XINT_praw\romannumeral0\XINT_infrac
}%
\def\XINT_praw #1%
{%
    \ifnum #1=\xint_c_ \expandafter\XINT_praw_a\fi \XINT_praw_A {#1}%
}%
\def\XINT_praw_A #1#2#3%
{%
    \if\XINT_isOne{#3}1\expandafter\xint_firstoftwo
                  \else\expandafter\xint_secondoftwo
    \fi { #2[#1]}{ #2/#3[#1]}%
}%
\def\XINT_praw_a\XINT_praw_A #1#2#3%
{%
    \if\XINT_isOne{#3}1\expandafter\xint_firstoftwo
                  \else\expandafter\xint_secondoftwo
    \fi { #2}{ #2/#3}%
}%
%    \end{macrocode}
% \subsection{\csh{xintRawWithZeros}}
% \lverb|&
% This was called \xintRaw in versions earlier than 1.07|
%    \begin{macrocode}
\def\xintRawWithZeros {\romannumeral0\xintrawwithzeros }%
\def\xintrawwithzeros
{%
    \expandafter\XINT_rawz\romannumeral0\XINT_infrac
}%
\def\XINT_rawz #1%
{%
    \ifcase\XINT_cntSgn #1\Z
      \expandafter\XINT_rawz_Ba
    \or
      \expandafter\XINT_rawz_A
    \else
      \expandafter\XINT_rawz_Ba
    \fi
    {#1}%
}%
\def\XINT_rawz_A  #1#2#3{\xint_dsh {#2}{-#1}/#3}%
\def\XINT_rawz_Ba #1#2#3{\expandafter\XINT_rawz_Bb
                        \expandafter{\romannumeral0\xint_dsh {#3}{#1}}{#2}}%
\def\XINT_rawz_Bb #1#2{ #2/#1}%
%    \end{macrocode}
% \subsection{\csh{xintFloor}, \csh{xintiFloor}}
% \lverb|1.09a, 1.1 for \xintiFloor/\xintFloor. Not efficient if big negative
% decimal exponent. Also sub-efficient if big positive decimal exponent.|
%    \begin{macrocode}
\def\xintFloor {\romannumeral0\xintfloor }%
\def\xintfloor #1% devrais-je faire \xintREZ?
    {\expandafter\XINT_ifloor \romannumeral0\xintrawwithzeros {#1}./1[0]}%
\def\xintiFloor {\romannumeral0\xintifloor }%
\def\xintifloor #1%
    {\expandafter\XINT_ifloor \romannumeral0\xintrawwithzeros {#1}.}%
\def\XINT_ifloor #1/#2.{\xintiiquo {#1}{#2}}%
%    \end{macrocode}
% \subsection{\csh{xintCeil}, \csh{xintiCeil}}
% \lverb|1.09a|
%    \begin{macrocode}
\def\xintCeil {\romannumeral0\xintceil }%
\def\xintceil #1{\xintiiopp {\xintFloor {\xintOpp{#1}}}}%
\def\xintiCeil {\romannumeral0\xinticeil }%
\def\xinticeil #1{\xintiiopp {\xintiFloor {\xintOpp{#1}}}}%
%    \end{macrocode}
% \subsection{\csh{xintNumerator}}
%    \begin{macrocode}
\def\xintNumerator {\romannumeral0\xintnumerator }%
\def\xintnumerator
{%
    \expandafter\XINT_numer\romannumeral0\XINT_infrac
}%
\def\XINT_numer #1%
{%
    \ifcase\XINT_cntSgn #1\Z
      \expandafter\XINT_numer_B
    \or
      \expandafter\XINT_numer_A
    \else
      \expandafter\XINT_numer_B
    \fi
    {#1}%
}%
\def\XINT_numer_A #1#2#3{\xint_dsh {#2}{-#1}}%
\def\XINT_numer_B #1#2#3{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintDenominator}}
%    \begin{macrocode}
\def\xintDenominator {\romannumeral0\xintdenominator }%
\def\xintdenominator
{%
    \expandafter\XINT_denom\romannumeral0\XINT_infrac
}%
\def\XINT_denom #1%
{%
    \ifcase\XINT_cntSgn #1\Z
      \expandafter\XINT_denom_B
    \or
      \expandafter\XINT_denom_A
    \else
      \expandafter\XINT_denom_B
    \fi
    {#1}%
}%
\def\XINT_denom_A #1#2#3{ #3}%
\def\XINT_denom_B #1#2#3{\xint_dsh {#3}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintFrac}}
%    \begin{macrocode}
\def\xintFrac {\romannumeral0\xintfrac }%
\def\xintfrac #1%
{%
    \expandafter\XINT_fracfrac_A\romannumeral0\XINT_infrac {#1}%
}%
\def\XINT_fracfrac_A #1{\XINT_fracfrac_B #1\Z }%
\catcode`^=7
\def\XINT_fracfrac_B #1#2\Z
{%
    \xint_gob_til_zero #1\XINT_fracfrac_C 0\XINT_fracfrac_D {10^{#1#2}}%
}%
\def\XINT_fracfrac_C 0\XINT_fracfrac_D #1#2#3%
{%
    \if1\XINT_isOne {#3}%
        \xint_afterfi {\expandafter\xint_firstoftwo_thenstop\xint_gobble_ii }%
    \fi
    \space
    \frac {#2}{#3}%
}%
\def\XINT_fracfrac_D #1#2#3%
{%
    \if1\XINT_isOne {#3}\XINT_fracfrac_E\fi
    \space
    \frac {#2}{#3}#1%
}%
\def\XINT_fracfrac_E \fi\space\frac #1#2{\fi \space #1\cdot }%
%    \end{macrocode}
% \subsection{\csh{xintSignedFrac}}
%    \begin{macrocode}
\def\xintSignedFrac {\romannumeral0\xintsignedfrac }%
\def\xintsignedfrac #1%
{%
    \expandafter\XINT_sgnfrac_a\romannumeral0\XINT_infrac {#1}%
}%
\def\XINT_sgnfrac_a #1#2%
{%
    \XINT_sgnfrac_b #2\Z {#1}%
}%
\def\XINT_sgnfrac_b #1%
{%
    \xint_UDsignfork
      #1\XINT_sgnfrac_N
       -{\XINT_sgnfrac_P #1}%
    \krof
}%
\def\XINT_sgnfrac_P #1\Z #2%
{%
    \XINT_fracfrac_A {#2}{#1}%
}%
\def\XINT_sgnfrac_N
{%
    \expandafter\xint_minus_thenstop\romannumeral0\XINT_sgnfrac_P
}%
%    \end{macrocode}
% \subsection{\csh{xintFwOver}}
%    \begin{macrocode}
\def\xintFwOver {\romannumeral0\xintfwover }%
\def\xintfwover #1%
{%
    \expandafter\XINT_fwover_A\romannumeral0\XINT_infrac {#1}%
}%
\def\XINT_fwover_A #1{\XINT_fwover_B #1\Z }%
\def\XINT_fwover_B #1#2\Z
{%
    \xint_gob_til_zero #1\XINT_fwover_C 0\XINT_fwover_D {10^{#1#2}}%
}%
\catcode`^=11
\def\XINT_fwover_C #1#2#3#4#5%
{%
    \if0\XINT_isOne {#5}\xint_afterfi { {#4\over #5}}%
                   \else\xint_afterfi { #4}%
    \fi
}%
\def\XINT_fwover_D #1#2#3%
{%
    \if0\XINT_isOne {#3}\xint_afterfi { {#2\over #3}}%
                   \else\xint_afterfi { #2\cdot }%
    \fi
    #1%
}%
%    \end{macrocode}
% \subsection{\csh{xintSignedFwOver}}
%    \begin{macrocode}
\def\xintSignedFwOver {\romannumeral0\xintsignedfwover }%
\def\xintsignedfwover #1%
{%
    \expandafter\XINT_sgnfwover_a\romannumeral0\XINT_infrac {#1}%
}%
\def\XINT_sgnfwover_a #1#2%
{%
    \XINT_sgnfwover_b #2\Z {#1}%
}%
\def\XINT_sgnfwover_b #1%
{%
    \xint_UDsignfork
      #1\XINT_sgnfwover_N
       -{\XINT_sgnfwover_P #1}%
    \krof
}%
\def\XINT_sgnfwover_P #1\Z #2%
{%
    \XINT_fwover_A {#2}{#1}%
}%
\def\XINT_sgnfwover_N
{%
    \expandafter\xint_minus_thenstop\romannumeral0\XINT_sgnfwover_P
}%
%    \end{macrocode}
% \subsection{\csh{xintREZ}}
%    \begin{macrocode}
\def\xintREZ {\romannumeral0\xintrez }%
\def\xintrez
{%
    \expandafter\XINT_rez_A\romannumeral0\XINT_infrac
}%
\def\XINT_rez_A #1#2%
{%
    \XINT_rez_AB #2\Z {#1}%
}%
\def\XINT_rez_AB #1%
{%
    \xint_UDzerominusfork
      #1-\XINT_rez_zero
      0#1\XINT_rez_neg
       0-{\XINT_rez_B #1}%
    \krof
}%
\def\XINT_rez_zero #1\Z #2#3{ 0/1[0]}%
\def\XINT_rez_neg {\expandafter\xint_minus_thenstop\romannumeral0\XINT_rez_B }%
\def\XINT_rez_B #1\Z
{%
    \expandafter\XINT_rez_C\romannumeral0\XINT_factortens {#1}%
}%
\def\XINT_rez_C #1#2#3#4%
{%
    \expandafter\XINT_rez_D\romannumeral0\XINT_factortens {#4}{#3}{#2}{#1}%
}%
\def\XINT_rez_D #1#2#3#4#5%
{%
    \expandafter\XINT_rez_E\expandafter
    {\the\numexpr #3+#4-#2}{#1}{#5}%
}%
\def\XINT_rez_E #1#2#3{ #3/#2[#1]}%
%    \end{macrocode}
% \subsection{\csh{xintE}, \csh{xintFloatE}, \csh{XINTinFloatE}}
% \lverb|1.07: The fraction is the first argument contrarily to \xintTrunc and
% \xintRound.
%
% \xintfE (1.07) and \xintiE (1.09i) are for \xintexpr and cousins. It is quite
% annoying that \numexpr does not know how to deal correctly with a minus sign -
% as prefix: \numexpr -(1)\relax is illegal! (one can do \numexpr 0-(1)\relax).
%
% the 1.07 \xintE puts directly its second argument in a \numexpr. The \xintfE
% first uses \xintNum on it, this is necessary for use in \xintexpr. (but
% one cannot use directly infix notation in the second argument of \xintfE)
%
% 1.09i also adds \xintFloatE and modifies \XINTinFloatfE, although currently
% the latter is only used from \xintfloatexpr hence always with \XINTdigits, it
% comes equipped with its first argument within brackets as the other
% \XINTinFloat... macros.
%
% 1.09m ceases here and elsewhere, also in \xintcfracname, to use \Z as
% delimiter in the code for the optional argument, as this is unsafe (it
% makes impossible to the user to employ \Z as argument to the macro).
% Replaced by \xint_relax. 1.09e had already done that in \xintSeq, but
% this should have been systematic. 
%
% 1.1 modifies and moves \xintiiE to xint.sty, and cleans up some unneeded
% stuff, now that expressions implement scientific notation directly at the
% number parsing level.|
%    \begin{macrocode}
\def\xintE {\romannumeral0\xinte }%
\def\xinte #1%
{%
    \expandafter\XINT_e \romannumeral0\XINT_infrac {#1}%
}%
\def\XINT_e #1#2#3#4%
{%
    \expandafter\XINT_e_end\expandafter{\the\numexpr #1+#4}{#2}{#3}%
}%
\def\XINT_e_end #1#2#3{ #2/#3[#1]}%
\def\xintFloatE   {\romannumeral0\xintfloate }%
\def\xintfloate #1{\XINT_floate_chkopt #1\xint_relax }%
\def\XINT_floate_chkopt #1%
{%
    \ifx [#1\expandafter\XINT_floate_opt
       \else\expandafter\XINT_floate_noopt
    \fi  #1%
}%
\def\XINT_floate_noopt #1\xint_relax
{%
    \expandafter\XINT_floate_a\expandafter\XINTdigits
                \romannumeral0\XINT_infrac {#1}%
}%
\def\XINT_floate_opt [\xint_relax #1]#2%
{%
    \expandafter\XINT_floate_a\expandafter
    {\the\numexpr #1\expandafter}\romannumeral0\XINT_infrac {#2}%
}%
\def\XINT_floate_a #1#2#3#4#5%
{%
    \expandafter\expandafter\expandafter\XINT_float_a
    \expandafter\xint_exchangetwo_keepbraces\expandafter
            {\the\numexpr #2+#5}{#1}{#3}{#4}\XINT_float_Q
}%
\def\XINTinFloatE {\romannumeral0\XINTinfloate }%
\def\XINTinfloate {\expandafter\XINT_infloate\romannumeral0\XINTinfloat [\XINTdigits]}%
\def\XINT_infloate #1[#2]#3%
   {\expandafter\XINT_infloate_end\expandafter {\the\numexpr #3+#2}{#1}}%
\def\XINT_infloate_end #1#2{ #2[#1]}%
%    \end{macrocode}
% \subsection{\csh{xintIrr}}
% \lverb|&
% 1.04 fixes a buggy \xintIrr {0}.
% 1.05 modifies the initial parsing and post-processing to use \xintrawwithzeros
% and to
% more quickly deal with an input denominator equal to 1. 1.08 version does
% not remove a /1 denominator.|
%    \begin{macrocode}
\def\xintIrr {\romannumeral0\xintirr }%
\def\xintirr #1%
{%
    \expandafter\XINT_irr_start\romannumeral0\xintrawwithzeros {#1}\Z
}%
\def\XINT_irr_start #1#2/#3\Z
{%
    \if0\XINT_isOne {#3}%
      \xint_afterfi
          {\xint_UDsignfork
               #1\XINT_irr_negative
                -{\XINT_irr_nonneg #1}%
           \krof}%
    \else
      \xint_afterfi{\XINT_irr_denomisone #1}%
    \fi
    #2\Z {#3}%
}%
\def\XINT_irr_denomisone #1\Z #2{ #1/1}% changed in 1.08
\def\XINT_irr_negative   #1\Z #2{\XINT_irr_D #1\Z #2\Z \xint_minus_thenstop}%
\def\XINT_irr_nonneg     #1\Z #2{\XINT_irr_D #1\Z #2\Z \space}%
\def\XINT_irr_D #1#2\Z #3#4\Z
{%
    \xint_UDzerosfork
       #3#1\XINT_irr_indeterminate
       #30\XINT_irr_divisionbyzero
       #10\XINT_irr_zero
        00\XINT_irr_loop_a
    \krof
    {#3#4}{#1#2}{#3#4}{#1#2}%
}%
\def\XINT_irr_indeterminate #1#2#3#4#5{\xintError:NaN\space 0/0}%
\def\XINT_irr_divisionbyzero #1#2#3#4#5{\xintError:DivisionByZero #5#2/0}%
\def\XINT_irr_zero #1#2#3#4#5{ 0/1}% changed in 1.08
\def\XINT_irr_loop_a #1#2%
{%
    \expandafter\XINT_irr_loop_d
    \romannumeral0\XINT_div_prepare {#1}{#2}{#1}%
}%
\def\XINT_irr_loop_d #1#2%
{%
    \XINT_irr_loop_e #2\Z
}%
\def\XINT_irr_loop_e #1#2\Z
{%
    \xint_gob_til_zero #1\xint_irr_loop_exit0\XINT_irr_loop_a {#1#2}%
}%
\def\xint_irr_loop_exit0\XINT_irr_loop_a #1#2#3#4%
{%
    \expandafter\XINT_irr_loop_exitb\expandafter
    {\romannumeral0\xintiiquo {#3}{#2}}%
    {\romannumeral0\xintiiquo {#4}{#2}}%
}%
\def\XINT_irr_loop_exitb #1#2%
{%
   \expandafter\XINT_irr_finish\expandafter {#2}{#1}%
}%
\def\XINT_irr_finish #1#2#3{#3#1/#2}% changed in 1.08
%    \end{macrocode}
% \subsection{\csh{xintifInt}}
% \lverb|1.09e. xintfrac.sty only. Fixed in 1.1 to not use \xintIrr anymore
% as it was really stupid overhead.|
%    \begin{macrocode}
\def\xintifInt   {\romannumeral0\xintifint }%
\def\xintifint #1{\expandafter\XINT_ifint\romannumeral0\xintrawwithzeros {#1}.}%
\def\XINT_ifint #1/#2.%
{%
    \if 0\xintiiRem {#1}{#2}%
     \expandafter\xint_firstoftwo_thenstop
    \else
     \expandafter\xint_secondoftwo_thenstop
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintJrr}}
% \lverb|&
% Modified similarly as \xintIrr in release 1.05. 1.08 version does
% not remove a /1 denominator.|
%    \begin{macrocode}
\def\xintJrr {\romannumeral0\xintjrr }%
\def\xintjrr #1%
{%
    \expandafter\XINT_jrr_start\romannumeral0\xintrawwithzeros {#1}\Z
}%
\def\XINT_jrr_start #1#2/#3\Z
{%
    \if0\XINT_isOne {#3}\xint_afterfi
          {\xint_UDsignfork
               #1\XINT_jrr_negative
                -{\XINT_jrr_nonneg #1}%
           \krof}%
    \else
      \xint_afterfi{\XINT_jrr_denomisone #1}%
    \fi
    #2\Z {#3}%
}%
\def\XINT_jrr_denomisone #1\Z #2{ #1/1}% changed in 1.08
\def\XINT_jrr_negative   #1\Z #2{\XINT_jrr_D #1\Z #2\Z \xint_minus_thenstop }%
\def\XINT_jrr_nonneg     #1\Z #2{\XINT_jrr_D #1\Z #2\Z \space}%
\def\XINT_jrr_D #1#2\Z #3#4\Z
{%
    \xint_UDzerosfork
       #3#1\XINT_jrr_indeterminate
       #30\XINT_jrr_divisionbyzero
       #10\XINT_jrr_zero
        00\XINT_jrr_loop_a
    \krof
    {#3#4}{#1#2}1001%
}%
\def\XINT_jrr_indeterminate #1#2#3#4#5#6#7{\xintError:NaN\space 0/0}%
\def\XINT_jrr_divisionbyzero #1#2#3#4#5#6#7{\xintError:DivisionByZero #7#2/0}%
\def\XINT_jrr_zero #1#2#3#4#5#6#7{ 0/1}% changed in 1.08
\def\XINT_jrr_loop_a #1#2%
{%
    \expandafter\XINT_jrr_loop_b
    \romannumeral0\XINT_div_prepare {#1}{#2}{#1}%
}%
\def\XINT_jrr_loop_b #1#2#3#4#5#6#7%
{%
    \expandafter \XINT_jrr_loop_c \expandafter
        {\romannumeral0\xintiiadd{\XINT_mul_fork #4\Z #1\Z}{#6}}%
        {\romannumeral0\xintiiadd{\XINT_mul_fork #5\Z #1\Z}{#7}}%
    {#2}{#3}{#4}{#5}%
}%
\def\XINT_jrr_loop_c #1#2%
{%
    \expandafter \XINT_jrr_loop_d \expandafter{#2}{#1}%
}%
\def\XINT_jrr_loop_d #1#2#3#4%
{%
    \XINT_jrr_loop_e #3\Z {#4}{#2}{#1}%
}%
\def\XINT_jrr_loop_e #1#2\Z
{%
    \xint_gob_til_zero #1\xint_jrr_loop_exit0\XINT_jrr_loop_a {#1#2}%
}%
\def\xint_jrr_loop_exit0\XINT_jrr_loop_a #1#2#3#4#5#6%
{%
    \XINT_irr_finish {#3}{#4}%
}%
%    \end{macrocode}
% \subsection{\csh{xintTFrac}}
% \lverb|1.09i, for frac in \xintexpr. And \xintFrac is already assigned. T for
% truncation. However, potentially not very efficient with numbers in scientific
% notations, with big exponents. Will have to think it again some day. I
% hesitated how to call the macro. Same convention as in maple, but some people
% reserve fractional part to x - floor(x). Also, not clear if I had to make it
% negative (or zero) if x < 0, or rather always positive. There should be in
% fact such a thing for each rounding function, trunc, round, floor, ceil. |
%    \begin{macrocode}
\def\xintTFrac {\romannumeral0\xinttfrac }%
\def\xinttfrac #1{\expandafter\XINT_tfrac_fork\romannumeral0\xintrawwithzeros {#1}\Z }%
\def\XINT_tfrac_fork #1%
{%
    \xint_UDzerominusfork
        #1-\XINT_tfrac_zero
        0#1{\xintiiopp\XINT_tfrac_P }%
         0-{\XINT_tfrac_P #1}%
    \krof
}%
\def\XINT_tfrac_zero #1\Z { 0/1[0]}%
\def\XINT_tfrac_P #1/#2\Z {\expandafter\XINT_rez_AB
                           \romannumeral0\xintiirem{#1}{#2}\Z {0}{#2}}%
%    \end{macrocode}
% \subsection{\csh{XINTinFloatFracdigits}}
% \lverb|1.09i, for frac in \xintfloatexpr. This version computes
% exactly from the input the fractional part and then only converts it
% into a float with the asked-for number of digits. I will have to think
% it again some day, certainly.
%
% 1.1 removes optional argument for which there was anyhow no interface, for
% technical reasons having to do with \xintNewExpr.
%
% 1.1a renames the macro as \XINTinFloatFracdigits (from \XINTinFloatFrac) to
% be synchronous with the \XINTinFloatSqrt and \XINTinFloat habits related to
% \xintNewExpr problems.
%
% Note to myself: I still have to rethink the whole thing about what is the best
% to do, the initial way of going through \xinttfrac was just a first
% implementation.|
%    \begin{macrocode}
\def\XINTinFloatFracdigits {\romannumeral0\XINTinfloatfracdigits }%
\def\XINTinfloatfracdigits #1%
{%
    \expandafter\XINT_infloatfracdg_a\expandafter {\romannumeral0\xinttfrac{#1}}%
}%
\def\XINT_infloatfracdg_a {\XINTinfloat [\XINTdigits]}%
%    \end{macrocode}
% \subsection{\csh{xintTrunc}, \csh{xintiTrunc}}
% \lverb|&
% Modified in 1.06 to give the first argument to a \numexpr.
%
% 1.09f fixes the overhead added in 1.09a to some inner routines when \xintiquo
% was redefined to use \xintnum. Now uses \xintiiquo, rather.
%
% 1.09j: minor improvements, \XINT_trunc_E was very strange and defined two
% never occuring branches; also, optimizes the call to the division routine, and
% the zero loops.
%
% 1.1 adds \xintTTrunc as a shortcut to what \xintiTrunc 0 does, and maps \xintNum to it.|
%    \begin{macrocode}
\def\xintTrunc  {\romannumeral0\xinttrunc }%
\def\xintiTrunc {\romannumeral0\xintitrunc }%
\def\xinttrunc #1%
{%
    \expandafter\XINT_trunc\expandafter {\the\numexpr #1}%
}%
\def\XINT_trunc #1#2%
{%
    \expandafter\XINT_trunc_G
    \romannumeral0\expandafter\XINT_trunc_A
    \romannumeral0\XINT_infrac {#2}{#1}{#1}%
}%
\def\xintitrunc #1%
{%
    \expandafter\XINT_itrunc\expandafter {\the\numexpr #1}%
}%
\def\XINT_itrunc #1#2%
{%
    \expandafter\XINT_itrunc_G
    \romannumeral0\expandafter\XINT_trunc_A
    \romannumeral0\XINT_infrac {#2}{#1}{#1}%
}%
\def\XINT_trunc_A #1#2#3#4%
{%
    \expandafter\XINT_trunc_checkifzero
    \expandafter{\the\numexpr #1+#4}#2\Z {#3}%
}%
\def\XINT_trunc_checkifzero #1#2#3\Z
{%
    \xint_gob_til_zero #2\XINT_trunc_iszero0\XINT_trunc_B {#1}{#2#3}%
}%
\def\XINT_trunc_iszero0\XINT_trunc_B #1#2#3{ 0\Z 0}%
\def\XINT_trunc_B #1%
{%
    \ifcase\XINT_cntSgn #1\Z
      \expandafter\XINT_trunc_D
    \or
      \expandafter\XINT_trunc_D
    \else
      \expandafter\XINT_trunc_C
    \fi
    {#1}%
}%
\def\XINT_trunc_C #1#2#3%
{%
    \expandafter\XINT_trunc_CE\expandafter
    {\romannumeral0\XINT_dsx_zeroloop {-#1}{}\Z {#3}}{#2}%
}%
\def\XINT_trunc_CE #1#2{\XINT_trunc_E #2.{#1}}%
\def\XINT_trunc_D #1#2%
{%
    \expandafter\XINT_trunc_E
    \romannumeral0\XINT_dsx_zeroloop {#1}{}\Z {#2}.%
}%
\def\XINT_trunc_E #1%
{%
    \xint_UDsignfork
       #1\XINT_trunc_Fneg
        -{\XINT_trunc_Fpos #1}%
    \krof
}%
\def\XINT_trunc_Fneg #1.#2{\expandafter\xint_firstoftwo_thenstop
           \romannumeral0\XINT_div_prepare {#2}{#1}\Z \xint_minus_thenstop}%
\def\XINT_trunc_Fpos #1.#2{\expandafter\xint_firstoftwo_thenstop
           \romannumeral0\XINT_div_prepare {#2}{#1}\Z \space }%
\def\XINT_itrunc_G #1#2\Z #3#4%
{%
    \xint_gob_til_zero #1\XINT_trunc_zero 0#3#1#2%
}%
\def\XINT_trunc_zero 0#1#20{ 0}%
\def\XINT_trunc_G #1\Z #2#3%
{%
    \xint_gob_til_zero #2\XINT_trunc_zero 0%
    \expandafter\XINT_trunc_H\expandafter
    {\the\numexpr\romannumeral0\xintlength {#1}-#3}{#3}{#1}#2%
}%
\def\XINT_trunc_H #1#2%
{%
    \ifnum #1 > \xint_c_
        \xint_afterfi {\XINT_trunc_Ha {#2}}%
    \else
        \xint_afterfi {\XINT_trunc_Hb {-#1}}% -0,--1,--2, ....
    \fi
}%
\def\XINT_trunc_Ha
{%
  \expandafter\XINT_trunc_Haa\romannumeral0\xintdecsplit
}%
\def\XINT_trunc_Haa #1#2#3%
{%
    #3#1.#2%
}%
\def\XINT_trunc_Hb #1#2#3%
{%
    \expandafter #3\expandafter0\expandafter.%
    \romannumeral0\XINT_dsx_zeroloop {#1}{}\Z {}#2% #1=-0 autoris\'e !
}%
%    \end{macrocode}
% \subsection{\csh{xintTTrunc}}
% \lverb|1.1, a tiny bit more efficient than doing \xintiTrunc0. I map \xintNum
% to it, and I use it in \xintexpr for various things. Faster I guess than the \xintiFloor.|
%    \begin{macrocode}
\def\xintTTrunc {\romannumeral0\xintttrunc }%
\def\xintttrunc #1%
{%
    \expandafter\XINT_itrunc_G
    \romannumeral0\expandafter\XINT_ttrunc_A
    \romannumeral0\XINT_infrac {#1}0% this last 0 to let \XINT_itrunc_G be happy
}%
\def\XINT_ttrunc_A #1#2#3{\XINT_trunc_checkifzero {#1}#2\Z {#3}}%
%    \end{macrocode}
% \subsection{\csh{xintNum}}
% \lverb|This extension of the xint original xintNum is added in 1.05, as a
% synonym to \xintIrr, but raising an error when the input does not evaluate to
% an integer. Usable with not too much overhead on integer input as \xintIrr
% checks quickly for a denominator equal to 1 (which will be put there by the
% \XINT_infrac called by \xintrawwithzeros). This way, macros such as \xintQuo
% can be modified with minimal overhead to accept fractional input as long as
% it evaluates to an integer.
%
% 22 june 2014 (dev 1.1) I just don't understand what was the point of going through
% \xintIrr if to raise an arror afterwards...  and raising errors is silly, so
% let's do it sanely at last. In between I added \xintiFloor, thus, let's just
% let it to it.
%
% 24 october 2014 (final 1.1) (I left it taking dust since
% June...), I did \xintTTrunc, and will thus map \xintNum to it|
%    \begin{macrocode}
\let\xintNum \xintTTrunc
\let\xintnum \xintttrunc
%    \end{macrocode}
% \subsection{\csh{xintRound}, \csh{xintiRound}}
% \lverb|Modified in 1.06 to give the first argument to a \numexpr.|
%    \begin{macrocode}
\def\xintRound {\romannumeral0\xintround }%
\def\xintiRound {\romannumeral0\xintiround }%
\def\xintround #1%
{%
    \expandafter\XINT_round\expandafter {\the\numexpr #1}%
}%
\def\XINT_round
{%
    \expandafter\XINT_trunc_G\romannumeral0\XINT_round_A
}%
\def\xintiround #1%
{%
    \expandafter\XINT_iround\expandafter {\the\numexpr #1}%
}%
\def\XINT_iround
{%
    \expandafter\XINT_itrunc_G\romannumeral0\XINT_round_A
}%
\def\XINT_round_A #1#2%
{%
    \expandafter\XINT_round_B
    \romannumeral0\expandafter\XINT_trunc_A
    \romannumeral0\XINT_infrac {#2}{#1+\xint_c_i}{#1}%
}%
\def\XINT_round_B #1\Z
{%
    \expandafter\XINT_round_C
    \romannumeral0\XINT_rord_main {}#1%
      \xint_relax
        \xint_bye\xint_bye\xint_bye\xint_bye
        \xint_bye\xint_bye\xint_bye\xint_bye
      \xint_relax
    \Z
}%
\def\XINT_round_C #1%
{%
    \ifnum #1<\xint_c_v
        \expandafter\XINT_round_Daa
    \else
        \expandafter\XINT_round_Dba
    \fi
}%
\def\XINT_round_Daa #1%
{%
    \xint_gob_til_Z #1\XINT_round_Daz\Z \XINT_round_Da #1%
}%
\def\XINT_round_Daz\Z \XINT_round_Da \Z { 0\Z }%
\def\XINT_round_Da #1\Z
{%
    \XINT_rord_main {}#1%
      \xint_relax
        \xint_bye\xint_bye\xint_bye\xint_bye
        \xint_bye\xint_bye\xint_bye\xint_bye
      \xint_relax  \Z
}%
\def\XINT_round_Dba #1%
{%
    \xint_gob_til_Z #1\XINT_round_Dbz\Z \XINT_round_Db #1%
}%
\def\XINT_round_Dbz\Z \XINT_round_Db \Z { 1\Z }%
\def\XINT_round_Db #1\Z
{%
    \XINT_addm_A 0{}1000\W\X\Y\Z #1000\W\X\Y\Z \Z
}%
%    \end{macrocode}
% \subsection{\csh{xintXTrunc}}
% \lverb@1.09j [2014/01/06] This is completely expandable but not f-expandable.
% Designed be used inside an \edef or a \write, if one is interested in getting
% tens of thousands of digits from the decimal expansion of some fraction... it
% is not worth using it rather than \xintTrunc if for less than *hundreds* of
% digits. For efficiency it clones part of the preparatory division macros, as
% the same denominator will be used again and again. The D parameter which says
% how many digits to keep after decimal mark must be at least 1 (and it is
% forcefully set to such a value if found negative or zero, to avoid an eternal
% loop).
%
% For reasons of efficiency I try to use the shortest possible denominator, so
% if the fraction is A/B[N], I want to use B. For N at least zero, just
% immediately replace A by A.10^N. The first division then may be a little
% longish but the next ones will be fast (if B is not too big). For N<0, this is
% a bit more complicated. I thought somewhat about this, and I would need a
% rather complicated approach going through a long division algorithm, forcing
% me to essentially clone the actual division with some differences; a side
% thing is that as this would use blocks of four digits I would have a hard time
% allowing a non-multiple of four number of post decimal mark digits.
%
% Thus, for N<0, another method is followed. First the euclidean division
% A/B=Q+R/B is done. The number of digits of Q is M. If |N|\leq D, we launch
% inside a \csname the routine for obtaining D-|N| next digits (this may impact
% TeX's memory if D is very big), call them T. We then need to position the
% decimal mark D slots from the right of QT, which has length M+D-|N|, hence |N|
% slots from the right of Q. We thus avoid having to work will the T, as D may
% be very very big (\xintXTrunc's only goal is to make it possible to learn by
% hearts decimal expansions with thousands of digits). We can use the
% \xintDecSplit for that on Q . Computing the length M of Q was a more or less
% unavoidable step. If |N|>D, the \csname step is skipped we need to remove the
% D-|N| last digits from Q, etc.. we compare D-|N| with the length M of Q etc...
% (well in this last, very uncommon, branch, I stopped trying to optimize things
% and I even do an \xintnum to ensure a 0 if something comes out empty from
% \xintDecSplit).
%
% [2015/10/04] Although the explanations above are extremely clear, there are
% just too complicated for me to be now able to understand them fully. I
% miraculously managed to do the minimal changes (all happens between
% \XINT_xtrunc_Q and \XINT_xtrunc_Pa) in order for \xintXTrunc to use the 1.2
% division routine. Seems to work. But some thought should be given to how to
% adapt \xintXTrunc for it to better use the abilities and characteristics of
% the new division routines in xincore.@
%    \begin{macrocode}
\def\xintXTrunc #1#2%
{%
    \expandafter\XINT_xtrunc_a\expandafter
    {\the\numexpr #1\expandafter}\romannumeral0\xintraw {#2}%
}%
\def\XINT_xtrunc_a #1%
{%
    \expandafter\XINT_xtrunc_b\expandafter
    {\the\numexpr\ifnum#1<\xint_c_i \xint_c_i-\fi #1}%
}%
\def\XINT_xtrunc_b #1%
{%
    \expandafter\XINT_xtrunc_c\expandafter
    {\the\numexpr (#1+\xint_c_ii^v)/\xint_c_ii^vi-\xint_c_i}{#1}%
}%
\def\XINT_xtrunc_c #1#2%
{%
    \expandafter\XINT_xtrunc_d\expandafter
    {\the\numexpr #2-\xint_c_ii^vi*#1}{#1}{#2}%
}%
\def\XINT_xtrunc_d #1#2#3#4/#5[#6]%
{%
    \XINT_xtrunc_e #4.{#6}{#5}{#3}{#2}{#1}%
}%
%    \end{macrocode}
% \lverb+#1=numerator.#2=N,#3=B,#4=D,#5=Blocs,#6=extra+
%    \begin{macrocode}
\def\XINT_xtrunc_e #1%
{%
    \xint_UDzerominusfork
        #1-\XINT_xtrunc_zero
        0#1\XINT_xtrunc_N
        0-{\XINT_xtrunc_P #1}%
    \krof
}%
\def\XINT_xtrunc_zero .#1#2#3#4#5%
{%
    0.\romannumeral0\expandafter\XINT_dsx_zeroloop\expandafter
                                  {\the\numexpr #5}{}\Z {}%
    \xintiloop [#4+-1]
    \ifnum \xintiloopindex>\xint_c_
    0000000000000000000000000000000000000000000000000000000000000000%
    \repeat
}%
\def\XINT_xtrunc_N {-\XINT_xtrunc_P }%
\def\XINT_xtrunc_P #1.#2%
{%
    \ifnum #2<\xint_c_
        \expandafter\XINT_xtrunc_negN_Q
    \else
        \expandafter\XINT_xtrunc_Q
    \fi  {#2}{#1}.%
}%
\def\XINT_xtrunc_negN_Q #1#2.#3#4#5#6%
{%
    \expandafter\XINT_xtrunc_negN_R
    \romannumeral0\XINT_div_prepare {#3}{#2}{#3}{#1}{#4}%
}%
%    \end{macrocode}
% \lverb+#1=Q, #2=R, #3=B, #4=N<0, #5=D+
%    \begin{macrocode}
\def\XINT_xtrunc_negN_R #1#2#3#4#5%
{%
    \expandafter\XINT_xtrunc_negN_S\expandafter
    {\the\numexpr -#4}{#5}{#2}{#3}{#1}%
}%
\def\XINT_xtrunc_negN_S #1#2%
{%
    \expandafter\XINT_xtrunc_negN_T\expandafter
    {\the\numexpr #2-#1}{#1}{#2}%
}%
\def\XINT_xtrunc_negN_T #1%
{%
    \ifnum \xint_c_<#1
      \expandafter\XINT_xtrunc_negNA
    \else
      \expandafter\XINT_xtrunc_negNW
    \fi {#1}%
}%
%    \end{macrocode}
% \lverb+#1=D-|N|>0, #2=|N|, #3=D, #4=R, #5=B, #6=Q+
%    \begin{macrocode}
\def\XINT_xtrunc_unlock #10.{ }%
\def\XINT_xtrunc_negNA #1#2#3#4#5#6%
{%
   \expandafter\XINT_xtrunc_negNB\expandafter
   {\romannumeral0\expandafter\expandafter\expandafter
    \XINT_xtrunc_unlock\expandafter\string
    \csname\XINT_xtrunc_b {#1}#4/#5[0]\expandafter\endcsname
    \expandafter}\expandafter
    {\the\numexpr\xintLength{#6}-#2}{#6}%
}%
\def\XINT_xtrunc_negNB #1#2#3{\XINT_xtrunc_negNC {#2}{#3}#1}%
\def\XINT_xtrunc_negNC #1%
{%
    \ifnum \xint_c_ < #1
      \expandafter\XINT_xtrunc_negNDa
    \else
      \expandafter\XINT_xtrunc_negNE
    \fi {#1}%
}%
\def\XINT_xtrunc_negNDa #1#2%
{%
    \expandafter\XINT_xtrunc_negNDb%
    \romannumeral0\XINT_split_fromleft_loop {#1}{}#2\W\W\W\W\W\W\W\W\Z
}%
\def\XINT_xtrunc_negNDb #1#2{#1.#2}%
\def\XINT_xtrunc_negNE #1#2%
{%
    0.\romannumeral0\XINT_dsx_zeroloop {-#1}{}\Z {}#2%
}%
%    \end{macrocode}
% \lverb+#1=D-|N|<=0, #2=|N|, #3=D, #4=R, #5=B, #6=Q+
%    \begin{macrocode}
\def\XINT_xtrunc_negNW #1#2#3#4#5#6%
{%
    \expandafter\XINT_xtrunc_negNX\expandafter
    {\romannumeral0\xintnum{\xintDecSplitL {-#1}{#6}}}{#3}%
}%
\def\XINT_xtrunc_negNX #1#2%
{%
    \expandafter\XINT_xtrunc_negNC\expandafter
    {\the\numexpr\xintLength {#1}-#2}{#1}%
}%
%%%%%%%%%%%%
\def\XINT_xtrunc_BisOne #1#2#3#4#5#6#7%
{%
    #5.\romannumeral0\expandafter\XINT_dsx_zeroloop\expandafter
                                  {\the\numexpr #7}{}\Z {}%
    \xintiloop [#6+-1]
    \ifnum \xintiloopindex>\xint_c_
    0000000000000000000000000000000000000000000000000000000000000000%
    \repeat
}%
\def\XINT_xtrunc_BisTwo #1#2#3#4#5#6#7%
{%
    \xintHalf {#5}.\ifodd\xintiiLDg{#5} 5\else 0\fi
    \romannumeral0\expandafter\XINT_dsx_zeroloop\expandafter
                                  {\the\numexpr #7-\xint_c_i}{}\Z {}%
    \xintiloop [#6+-1]
    \ifnum \xintiloopindex>\xint_c_
    0000000000000000000000000000000000000000000000000000000000000000%
    \repeat
}%
%%%%%%%%%%%%
\def\XINT_xtrunc_Q #1%
{%
    \expandafter\XINT_xtrunc_prepare
    \romannumeral0\XINT_dsx_zeroloop {#1}{}\Z
}%
\def\XINT_xtrunc_prepare #1.#2#3%
{%
    \expandafter\XINT_xtrunc_Pa\expandafter
    {\romannumeral0%
    \XINT_xtrunc_prepare_a #2\R\R\R\R\R\R\R\R {10}0000001\W !{#2}}{#1}%
}%
%%%%%%%%%%%%
\def\XINT_xtrunc_prepare_a #1#2#3#4#5#6#7#8#9%
{%
    \xint_gob_til_R #9\XINT_xtrunc_prepare_small\R
    \XINT_xtrunc_prepare_b #9%
}%
\def\XINT_xtrunc_prepare_small\R #1!#2%
{%
    \ifcase #2
    \or\xint_afterfi{ \XINT_div_BisOne}%
    \or\xint_afterfi{ \XINT_div_BisTwo}%
    \else\expandafter\XINT_xtrunc_small_aa
    \fi {#2}%
}%
\def\XINT_xtrunc_small_aa #1%
{%
    \expandafter\space\expandafter\XINT_xtrunc_small_a
    \the\numexpr #1/\xint_c_ii\expandafter
    .\the\numexpr \xint_c_x^viii+#1!%
}%
%%%%%%%%%%%%
\def\XINT_xtrunc_small_a #1.#2!#3%
{%
    \expandafter\XINT_div_small_b\the\numexpr #1\expandafter
    .\the\numexpr #2\expandafter!%
    \romannumeral0\XINT_div_small_ba #3\R\R\R\R\R\R\R\R{10}0000001\W
       #3\XINT_sepbyviii_Z_end 2345678\relax
}%
%%%%%%%%%%%%
\def\XINT_xtrunc_prepare_b
   {\expandafter\XINT_xtrunc_prepare_c\romannumeral0\XINT_zeroes_forviii }%
\def\XINT_xtrunc_prepare_c #1!%
{%
     \XINT_xtrunc_prepare_d  #1.00000000!{#1}%
}%
\def\XINT_xtrunc_prepare_d #1#2#3#4#5#6#7#8#9%
{%
    \expandafter\XINT_xtrunc_prepare_e\xint_gob_til_dot #1#2#3#4#5#6#7#8#9!%
}%
\def\XINT_xtrunc_prepare_e #1!#2!#3#4%
{%
    \XINT_xtrunc_prepare_f #4#3\X {#1}{#3}%
}%
\def\XINT_xtrunc_prepare_f #1#2#3#4#5#6#7#8#9\X
{%
    \expandafter\space\expandafter\XINT_div_prepare_g
     \the\numexpr  #1#2#3#4#5#6#7#8+\xint_c_i\expandafter
    .\the\numexpr (#1#2#3#4#5#6#7#8+\xint_c_i)/\xint_c_ii\expandafter
    .\the\numexpr #1#2#3#4#5#6#7#8\expandafter
    .\romannumeral0\XINT_sepandrev_andcount
    #1#2#3#4#5#6#7#8#9\XINT_rsepbyviii_end_A 2345678%
                      \XINT_rsepbyviii_end_B 2345678%
    \relax\xint_c_ii\xint_c_iii
        \R.\xint_c_vi\R.\xint_c_v\R.\xint_c_iv\R.\xint_c_iii
        \R.\xint_c_ii\R.\xint_c_i\R.\xint_c_\W
    \X
}%
%%%%%%%%%%%%
\def\XINT_xtrunc_Pa #1#2%
{%
    \expandafter\XINT_xtrunc_Pb\romannumeral0#1{#2}{#1}%
}%
\def\XINT_xtrunc_Pb #1#2#3#4{#1.\XINT_xtrunc_A {#4}{#2}{#3}}%
\def\XINT_xtrunc_A #1%
{%
    \unless\ifnum #1>\xint_c_ \XINT_xtrunc_transition\fi
    \expandafter\XINT_xtrunc_B\expandafter{\the\numexpr #1-\xint_c_i}%
}%
\def\XINT_xtrunc_B #1#2#3%
{%
    \expandafter\XINT_xtrunc_D\romannumeral0#3%
    {#20000000000000000000000000000000000000000000000000000000000000000}%
    {#1}{#3}%
}%
\def\XINT_xtrunc_D #1#2#3%
{%
    \romannumeral0\expandafter\XINT_dsx_zeroloop\expandafter
                  {\the\numexpr \xint_c_ii^vi-\xintLength{#1}}{}\Z {}#1%
    \XINT_xtrunc_A {#3}{#2}%
}%
\def\XINT_xtrunc_transition\fi
    \expandafter\XINT_xtrunc_B\expandafter #1#2#3#4%
{%
    \fi
    \ifnum #4=\xint_c_ \XINT_xtrunc_abort\fi
    \expandafter\XINT_xtrunc_x\expandafter
    {\romannumeral0\XINT_dsx_zeroloop {#4}{}\Z {#2}}{#3}{#4}%
}%
\def\XINT_xtrunc_x #1#2%
{%
    \expandafter\XINT_xtrunc_y\romannumeral0#2{#1}%
}%
\def\XINT_xtrunc_y #1#2#3%
{%
    \romannumeral0\expandafter\XINT_dsx_zeroloop\expandafter
                  {\the\numexpr #3-\xintLength{#1}}{}\Z {}#1%
}%
\def\XINT_xtrunc_abort\fi\expandafter\XINT_xtrunc_x\expandafter #1#2#3{\fi}%
%    \end{macrocode}
% \subsection{\csh{xintDigits}}
% \lverb|The mathchardef used to be called \XINT_digits, but for reasons originating in
% \xintNewExpr (and now obsolete), release 1.09a uses \XINTdigits without underscore.|
%    \begin{macrocode}
\mathchardef\XINTdigits 16
\def\xintDigits #1#2%
   {\afterassignment \xint_gobble_i \mathchardef\XINTdigits=}%
\def\xinttheDigits {\number\XINTdigits }%
%    \end{macrocode}
% \subsection{\csh{xintFloat}}
% \lverb|1.07. Completely re-written in 1.08a, with spectacular speed
% gains. The earlier version was seriously silly when dealing with
% inputs having a big power of ten. Again some modifications in 1.08b
% for a better treatment of cases with long explicit numerators or
% denominators.|
%    \begin{macrocode}
\def\xintFloat   {\romannumeral0\xintfloat }%
\def\xintfloat #1{\XINT_float_chkopt #1\xint_relax }%
\def\XINT_float_chkopt #1%
{%
    \ifx [#1\expandafter\XINT_float_opt
       \else\expandafter\XINT_float_noopt
    \fi  #1%
}%
\def\XINT_float_noopt #1\xint_relax
{%
    \expandafter\XINT_float_a\expandafter\XINTdigits
    \romannumeral0\XINT_infrac {#1}\XINT_float_Q
}%
\def\XINT_float_opt [\xint_relax #1]#2%
{%
    \expandafter\XINT_float_a\expandafter
    {\the\numexpr #1\expandafter}%
    \romannumeral0\XINT_infrac {#2}\XINT_float_Q
}%
\def\XINT_float_a #1#2#3% #1=P, #2=n, #3=A, #4=B
{%
    \XINT_float_fork #3\Z {#1}{#2}% #1 = precision, #2=n
}%
\def\XINT_float_fork #1%
{%
    \xint_UDzerominusfork
     #1-\XINT_float_zero
     0#1\XINT_float_J
      0-{\XINT_float_K #1}%
    \krof
}%
\def\XINT_float_zero #1\Z #2#3#4#5{ 0.e0}%
\def\XINT_float_J {\expandafter\xint_minus_thenstop\romannumeral0\XINT_float_K }%
\def\XINT_float_K #1\Z #2% #1=A, #2=P, #3=n, #4=B
{%
    \expandafter\XINT_float_L\expandafter
    {\the\numexpr\xintLength{#1}\expandafter}\expandafter
    {\the\numexpr #2+\xint_c_ii}{#1}{#2}%
}%
\def\XINT_float_L #1#2%
{%
    \ifnum #1>#2
      \expandafter\XINT_float_Ma
    \else
      \expandafter\XINT_float_Mc
    \fi {#1}{#2}%
}%
\def\XINT_float_Ma #1#2#3%
{%
    \expandafter\XINT_float_Mb\expandafter
    {\the\numexpr #1-#2\expandafter\expandafter\expandafter}%
    \expandafter\expandafter\expandafter
    {\expandafter\xint_firstoftwo
     \romannumeral0\XINT_split_fromleft_loop {#2}{}#3\W\W\W\W\W\W\W\W\Z
     }{#2}%
}%
\def\XINT_float_Mb #1#2#3#4#5#6% #2=A', #3=P+2, #4=P, #5=n, #6=B
{%
   \expandafter\XINT_float_N\expandafter
   {\the\numexpr\xintLength{#6}\expandafter}\expandafter
   {\the\numexpr #3\expandafter}\expandafter
   {\the\numexpr #1+#5}%
   {#6}{#3}{#2}{#4}%
}% long de B, P+2, n', B, |A'|=P+2, A', P
\def\XINT_float_Mc #1#2#3#4#5#6%
{%
   \expandafter\XINT_float_N\expandafter
   {\romannumeral0\xintlength{#6}}{#2}{#5}{#6}{#1}{#3}{#4}%
}% long de B, P+2, n, B, |A|, A, P
\def\XINT_float_N #1#2%
{%
    \ifnum #1>#2
      \expandafter\XINT_float_O
    \else
      \expandafter\XINT_float_P
    \fi {#1}{#2}%
}%
\def\XINT_float_O #1#2#3#4%
{%
    \expandafter\XINT_float_P\expandafter
    {\the\numexpr #2\expandafter}\expandafter
    {\the\numexpr #2\expandafter}\expandafter
    {\the\numexpr #3-#1+#2\expandafter\expandafter\expandafter}%
    \expandafter\expandafter\expandafter
    {\expandafter\xint_firstoftwo
     \romannumeral0\XINT_split_fromleft_loop {#2}{}#4\W\W\W\W\W\W\W\W\Z
     }%
}% |B|,P+2,n,B,|A|,A,P
\def\XINT_float_P #1#2#3#4#5#6#7#8%
{%
    \expandafter #8\expandafter {\the\numexpr #1-#5+#2-\xint_c_i}%
    {#6}{#4}{#7}{#3}%
}% |B|-|A|+P+1,A,B,P,n
\def\XINT_float_Q #1%
{%
    \ifnum #1<\xint_c_
      \expandafter\XINT_float_Ri
    \else
      \expandafter\XINT_float_Rii
    \fi {#1}%
}%
\def\XINT_float_Ri #1#2#3%
{%
    \expandafter\XINT_float_Sa
    \romannumeral0\xintiiquo {#2}%
         {\XINT_dsx_addzerosnofuss {-#1}{#3}}\Z {#1}%
}%
\def\XINT_float_Rii #1#2#3%
{%
    \expandafter\XINT_float_Sa
    \romannumeral0\xintiiquo
         {\XINT_dsx_addzerosnofuss {#1}{#2}}{#3}\Z {#1}%
}%
\def\XINT_float_Sa #1%
{%
    \if #19%
        \xint_afterfi {\XINT_float_Sb\XINT_float_Wb }%
    \else
        \xint_afterfi {\XINT_float_Sb\XINT_float_Wa }%
    \fi #1%
}%
\def\XINT_float_Sb #1#2\Z #3#4%
{%
    \expandafter\XINT_float_T\expandafter
    {\the\numexpr #4+\xint_c_i\expandafter}%
    \romannumeral`&&@\XINT_lenrord_loop 0{}#2\Z\W\W\W\W\W\W\W\Z #1{#3}{#4}%
}%
\def\XINT_float_T #1#2#3%
{%
    \ifnum #2>#1
      \xint_afterfi{\XINT_float_U\XINT_float_Xb}%
    \else
      \xint_afterfi{\XINT_float_U\XINT_float_Xa #3}%
    \fi
}%
\def\XINT_float_U #1#2%
{%
    \ifnum #2<\xint_c_v
      \expandafter\XINT_float_Va
    \else
      \expandafter\XINT_float_Vb
    \fi #1%
}%
\def\XINT_float_Va #1#2\Z #3%
{%
    \expandafter#1%
    \romannumeral0\expandafter\XINT_float_Wa
    \romannumeral0\XINT_rord_main {}#2%
      \xint_relax
        \xint_bye\xint_bye\xint_bye\xint_bye
        \xint_bye\xint_bye\xint_bye\xint_bye
      \xint_relax \Z
}%
\def\XINT_float_Vb #1#2\Z #3%
{%
    \expandafter #1%
    \romannumeral0\expandafter #3%
    \romannumeral0\XINT_addm_A 0{}1000\W\X\Y\Z #2000\W\X\Y\Z \Z
}%
\def\XINT_float_Wa #1{ #1.}%
\def\XINT_float_Wb #1#2%
    {\if #11\xint_afterfi{ 10.}\else\xint_afterfi{ #1.#2}\fi }%
\def\XINT_float_Xa #1\Z #2#3#4%
{%
    \expandafter\XINT_float_Y\expandafter
    {\the\numexpr #3+#4-#2}{#1}%
}%
\def\XINT_float_Xb #1\Z #2#3#4%
{%
    \expandafter\XINT_float_Y\expandafter
    {\the\numexpr #3+#4+\xint_c_i-#2}{#1}%
}%
\def\XINT_float_Y #1#2{ #2e#1}%
%    \end{macrocode}
% \subsection{\csh{xintPFloat}}
% \lverb|1.1|
%    \begin{macrocode}
\def\xintPFloat   {\romannumeral0\xintpfloat }%
\def\xintpfloat #1{\XINT_pfloat_chkopt #1\xint_relax }%
\def\XINT_pfloat_chkopt #1%
{%
    \ifx [#1\expandafter\XINT_pfloat_opt
       \else\expandafter\XINT_pfloat_noopt
    \fi  #1%
}%
\def\XINT_pfloat_noopt #1\xint_relax
{%
    \expandafter\XINT_pfloat_a\expandafter\XINTdigits
    \romannumeral0\XINTinfloat [\XINTdigits]{#1}%
}%
\def\XINT_pfloat_opt [\xint_relax #1]%#2%
{%
    \expandafter\XINT_pfloat_a\expandafter {\the\numexpr #1\expandafter}%
    \romannumeral0\XINTinfloat [\numexpr #1\relax]%{#2}%
}%
\def\XINT_pfloat_a #1#2%
{%
    \xint_UDzerominusfork
                           #2-\XINT_pfloat_zero
                           0#2\XINT_pfloat_neg
                            0-{\XINT_pfloat_pos #2}%
    \krof {#1}%
}%
\def\XINT_pfloat_zero #1[#2]{ 0}%
\def\XINT_pfloat_neg
   {\expandafter\xint_minus_thenstop\romannumeral0\XINT_pfloat_pos {}}%
\def\XINT_pfloat_pos #1#2#3[#4]%
{%
    \ifnum#4>0 \xint_dothis\XINT_pfloat_no\fi
    \ifnum#4>\numexpr-#2\relax \xint_dothis\XINT_pfloat_b\fi
    \ifnum#4>\numexpr-#2-\xint_c_v\relax \xint_dothis\XINT_pfloat_B\fi
    \xint_orthat\XINT_pfloat_no {#2}{#4}{#1#3}%
}%
\def\XINT_pfloat_no #1#2%
{%
 \expandafter\XINT_pfloat_no_b\expandafter{\the\numexpr #2+#1-\xint_c_i\relax}%
}%
\def\XINT_pfloat_no_b #1#2{\XINT_pfloat_no_c #2e#1}%
\def\XINT_pfloat_no_c #1{ #1.}%
\def\XINT_pfloat_b #1#2#3%
   {\expandafter\XINT_pfloat_c
    \romannumeral0\expandafter\XINT_split_fromleft_loop
    \expandafter {\the\numexpr #1+#2-\xint_c_i}#3\W\W\W\W\W\W\W\W\Z }%
\def\XINT_pfloat_c #1#2{ #1.#2}% #2 peut \^etre vide
\def\XINT_pfloat_B #1#2#3%
   {\expandafter\XINT_pfloat_C
    \romannumeral0\XINT_dsx_zeroloop {\numexpr -#1-#2}{}\Z {}#3}%
\def\XINT_pfloat_C { 0.}%
%    \end{macrocode}
% \subsection{\csh{XINTinFloat}}
% \lverb|1.07. Completely rewritten in 1.08a for immensely greater efficiency
% when the power of ten is big: previous version had some very serious
% bottlenecks arising from the creation of long strings of zeros, which made
% things such as 2^999999 completely impossible, but now even 2^999999999 with
% 24 significant digits is no problem! Again (slightly) improved in 1.08b.
%
% I decide in 1.09a not to use anymore \romannumeral`-0 mais \romannumeral0 also
% in the float routines, for consistency of style.
%
% Here again some inner macros used the \xintiquo with extra \xintnum overhead
% in 1.09a, 1.09f fixed that to use \xintiiquo for example.
%
% 1.09i added a stupid bug to \XINT_infloat_zero when it changed 0[0] to a silly
% 0/1[0], breaking in particular \xintFloatAdd when one of the argument is zero
%          :(((
%
% 1.09j fixes this. Besides, for notational coherence \XINT_inFloat and
% \XINT_infloat have been renamed respectively \XINTinFloat and \XINTinfloat in
% release 1.09j.|
%    \begin{macrocode}
\def\XINTinFloat {\romannumeral0\XINTinfloat }%
\def\XINTinfloat [#1]#2%
{%
    \expandafter\XINT_infloat_a\expandafter
    {\the\numexpr #1\expandafter}%
    \romannumeral0\XINT_infrac {#2}\XINT_infloat_Q
}%
\def\XINT_infloat_a #1#2#3% #1=P, #2=n, #3=A, #4=B
{%
    \XINT_infloat_fork #3\Z {#1}{#2}% #1 = precision, #2=n
}%
\def\XINT_infloat_fork #1%
{%
    \xint_UDzerominusfork
     #1-\XINT_infloat_zero
     0#1\XINT_infloat_J
      0-{\XINT_float_K #1}%
    \krof
}%
\def\XINT_infloat_zero #1\Z #2#3#4#5{ 0[0]}%
%    \end{macrocode}
% \lverb|the 0[0] was stupidly changed to 0/1[0] in 1.09i, with the result
% that the Float addition would crash when an operand was zero.|
%    \begin{macrocode}
\def\XINT_infloat_J {\expandafter-\romannumeral0\XINT_float_K }%
\def\XINT_infloat_Q #1%
{%
    \ifnum #1<\xint_c_
      \expandafter\XINT_infloat_Ri
    \else
      \expandafter\XINT_infloat_Rii
    \fi {#1}%
}%
\def\XINT_infloat_Ri #1#2#3%
{%
    \expandafter\XINT_infloat_S\expandafter
    {\romannumeral0\xintiiquo {#2}%
         {\XINT_dsx_addzerosnofuss {-#1}{#3}}}{#1}%
}%
\def\XINT_infloat_Rii #1#2#3%
{%
    \expandafter\XINT_infloat_S\expandafter
    {\romannumeral0\xintiiquo
         {\XINT_dsx_addzerosnofuss {#1}{#2}}{#3}}{#1}%
}%
\def\XINT_infloat_S #1#2#3%
{%
    \expandafter\XINT_infloat_T\expandafter
    {\the\numexpr #3+\xint_c_i\expandafter}%
    \romannumeral`&&@\XINT_lenrord_loop 0{}#1\Z\W\W\W\W\W\W\W\Z
    {#2}%
}%
\def\XINT_infloat_T #1#2#3%
{%
    \ifnum #2>#1
      \xint_afterfi{\XINT_infloat_U\XINT_infloat_Wb}%
    \else
      \xint_afterfi{\XINT_infloat_U\XINT_infloat_Wa #3}%
    \fi
}%
\def\XINT_infloat_U #1#2%
{%
    \ifnum #2<\xint_c_v
      \expandafter\XINT_infloat_Va
    \else
      \expandafter\XINT_infloat_Vb
    \fi #1%
}%
\def\XINT_infloat_Va #1#2\Z
{%
    \expandafter#1%
    \romannumeral0\XINT_rord_main {}#2%
      \xint_relax
        \xint_bye\xint_bye\xint_bye\xint_bye
        \xint_bye\xint_bye\xint_bye\xint_bye
      \xint_relax \Z
}%
\def\XINT_infloat_Vb #1#2\Z
{%
    \expandafter #1%
    \romannumeral0\XINT_addm_A 0{}1000\W\X\Y\Z #2000\W\X\Y\Z \Z
}%
\def\XINT_infloat_Wa #1\Z #2#3%
{%
    \expandafter\XINT_infloat_X\expandafter
    {\the\numexpr #3+\xint_c_i-#2}{#1}%
}%
\def\XINT_infloat_Wb #1\Z #2#3%
{%
    \expandafter\XINT_infloat_X\expandafter
    {\the\numexpr #3+\xint_c_ii-#2}{#1}%
}%
\def\XINT_infloat_X #1#2{ #2[#1]}%
%    \end{macrocode}
% \subsection{\csh{xintAdd}}
% \lverb|modified in v1.1. Et aussi 25 juin pour intercepter summand nul.|
%    \begin{macrocode}
\def\xintAdd {\romannumeral0\xintadd }%
\def\xintadd #1{\expandafter\xint_fadd\romannumeral0\xintraw {#1}}%
\def\xint_fadd #1{\xint_gob_til_zero #1\XINT_fadd_Azero 0\XINT_fadd_a #1}%
\def\XINT_fadd_Azero #1]{\xintraw }%
\def\XINT_fadd_a #1/#2[#3]#4%
   {\expandafter\XINT_fadd_b\romannumeral0\xintraw {#4}{#3}{#1}{#2}}%
\def\XINT_fadd_b #1{\xint_gob_til_zero #1\XINT_fadd_Bzero 0\XINT_fadd_c #1}%
\def\XINT_fadd_Bzero #1]#2#3#4{ #3/#4[#2]}%
\def\XINT_fadd_c #1/#2[#3]#4%
{%
    \expandafter\XINT_fadd_Aa\expandafter{\the\numexpr #4-#3}{#3}{#4}{#1}{#2}%
}%
\def\XINT_fadd_Aa #1%
{%
    \ifcase\XINT_cntSgn #1\Z
       \expandafter\XINT_fadd_B
    \or
       \expandafter \XINT_fadd_Ba
    \else
       \expandafter \XINT_fadd_Bb
    \fi {#1}%
}%
\def\XINT_fadd_B   #1#2#3#4#5#6#7{\XINT_fadd_C {#4}{#5}{#7}{#6}[#3]}%
\def\XINT_fadd_Ba  #1#2#3#4#5#6#7%
{%
    \expandafter\XINT_fadd_C\expandafter
        {\romannumeral0\XINT_dsx_zeroloop {#1}{}\Z {#6}}%
    {#7}{#5}{#4}[#2]%
}%
\def\XINT_fadd_Bb #1#2#3#4#5#6#7%
{%
    \expandafter\XINT_fadd_C\expandafter
        {\romannumeral0\XINT_dsx_zeroloop {-#1}{}\Z {#4}}%
    {#5}{#7}{#6}[#3]%
}%
\def\XINT_fadd_C #1#2#3%
{%
   \ifcase\romannumeral0\xintiicmp {#2}{#3} %<- intentional space here.
      \expandafter\XINT_fadd_eq
   \or\expandafter\XINT_fadd_D
   \else\expandafter\XINT_fadd_Da
   \fi {#2}{#3}{#1}%
}%
\def\XINT_fadd_eq #1#2#3#4%#5%
{%
   \expandafter\XINT_fadd_G
   \romannumeral0\xintiiadd {#3}{#4}/#1%[#5]%
}%
\def\XINT_fadd_D #1#2%
{%
   \expandafter\XINT_fadd_E\romannumeral0\XINT_div_prepare {#2}{#1}{#1}{#2}%
}%
\def\XINT_fadd_E #1#2%
{%
   \if0\XINT_Sgn #2\Z
        \expandafter\XINT_fadd_F
   \else\expandafter\XINT_fadd_K
   \fi {#1}%
}%
\def\XINT_fadd_F #1#2#3#4#5%#6%
{%
   \expandafter\XINT_fadd_G
   \romannumeral0\xintiiadd {\xintiiMul {#5}{#1}}{#4}/#2%[#6]%
}%
\def\XINT_fadd_Da #1#2%
{%
   \expandafter\XINT_fadd_Ea\romannumeral0\XINT_div_prepare {#1}{#2}{#1}{#2}%
}%
\def\XINT_fadd_Ea #1#2%
{%
   \if0\XINT_Sgn #2\Z
        \expandafter\XINT_fadd_Fa
   \else\expandafter\XINT_fadd_K
   \fi {#1}%
}%
\def\XINT_fadd_Fa #1#2#3#4#5%#6%
{%
   \expandafter\XINT_fadd_G
   \romannumeral0\xintiiadd {\xintiiMul {#4}{#1}}{#5}/#3%[#6]%
}%
\def\XINT_fadd_G #1{\if0#1\XINT_fadd_iszero\fi\space #1}%
\def\XINT_fadd_K #1#2#3#4#5%
{%
    \expandafter\XINT_fadd_L
    \romannumeral0\xintiiadd {\xintiiMul {#2}{#5}}{\xintiiMul {#3}{#4}}.%
    {{#2}{#3}}%
}%
\def\XINT_fadd_L #1{\if0#1\XINT_fadd_iszero\fi \XINT_fadd_M #1}%
\def\XINT_fadd_M #1.#2{\expandafter\XINT_fadd_N \expandafter
                       {\romannumeral0\xintiimul #2}{#1}}%
\def\XINT_fadd_N #1#2{ #2/#1}%
\edef\XINT_fadd_iszero\fi #1[#2]{\noexpand\fi\space 0/1[0]}% ou [#2] originel?
%    \end{macrocode}
% \subsection{\csh{xintSub}}
% \lverb|refait dans 1.1 pour vrifier si summands nuls.|
%    \begin{macrocode}
\def\xintSub   {\romannumeral0\xintsub }%
\def\xintsub #1{\expandafter\xint_fsub\romannumeral0\xintraw {#1}}%
\def\xint_fsub #1{\xint_gob_til_zero #1\XINT_fsub_Azero 0\XINT_fsub_a #1}%
\def\XINT_fsub_Azero #1]{\xintopp }%
\def\XINT_fsub_a #1/#2[#3]#4%
   {\expandafter\XINT_fsub_b\romannumeral0\xintraw {#4}{#3}{#1}{#2}}%
\def\XINT_fsub_b #1{\xint_UDzerominusfork
                      #1-\XINT_fadd_Bzero
                       0#1\XINT_fadd_c
                       0-{\XINT_fadd_c -#1}%
                     \krof }%
%    \end{macrocode}
% \subsection{\csh{xintSum}}
%    \begin{macrocode}
\def\xintSum {\romannumeral0\xintsum }%
\def\xintsum #1{\xintsumexpr #1\relax }%
\def\xintSumExpr {\romannumeral0\xintsumexpr }%
\def\xintsumexpr {\expandafter\XINT_fsumexpr\romannumeral`&&@}%
\def\XINT_fsumexpr {\XINT_fsum_loop_a {0/1[0]}}%
\def\XINT_fsum_loop_a #1#2%
{%
    \expandafter\XINT_fsum_loop_b \romannumeral`&&@#2\Z {#1}%
}%
\def\XINT_fsum_loop_b #1%
{%
    \xint_gob_til_relax #1\XINT_fsum_finished\relax
    \XINT_fsum_loop_c #1%
}%
\def\XINT_fsum_loop_c #1\Z #2%
{%
    \expandafter\XINT_fsum_loop_a\expandafter{\romannumeral0\xintadd {#2}{#1}}%
}%
\def\XINT_fsum_finished #1\Z #2{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintMul}}
% \lverb|modif 1.1 25-juin-14 pour vrifier plus tt si nul|
%    \begin{macrocode}
\def\xintMul {\romannumeral0\xintmul }%
\def\xintmul #1{\expandafter\xint_fmul\romannumeral0\xintraw {#1}.}%
\def\xint_fmul #1{\xint_gob_til_zero #1\XINT_fmul_zero 0\XINT_fmul_a #1}%
\def\XINT_fmul_a #1[#2].#3%
   {\expandafter\XINT_fmul_b\romannumeral0\xintraw {#3}#1[#2.]}%
\def\XINT_fmul_b #1{\xint_gob_til_zero #1\XINT_fmul_zero 0\XINT_fmul_c #1}%
\def\XINT_fmul_c #1/#2[#3]#4/#5[#6.]%
{%
    \expandafter\XINT_fmul_d
    \expandafter{\the\numexpr #3+#6\expandafter}%
    \expandafter{\romannumeral0\xintiimul {#5}{#2}}%
    {\romannumeral0\xintiimul {#4}{#1}}%
}%
\def\XINT_fmul_d #1#2#3%
{%
    \expandafter \XINT_fmul_e \expandafter{#3}{#1}{#2}%
}%
\def\XINT_fmul_e #1#2{\XINT_outfrac {#2}{#1}}%
\def\XINT_fmul_zero #1.#2{ 0/1[0]}%
%    \end{macrocode}
% \subsection{\csh{xintSqr}}
% \lverb|1.1 modifs comme xintMul|
%    \begin{macrocode}
\def\xintSqr {\romannumeral0\xintsqr }%
\def\xintsqr #1{\expandafter\xint_fsqr\romannumeral0\xintraw {#1}}%
\def\xint_fsqr #1{\xint_gob_til_zero #1\XINT_fsqr_zero 0\XINT_fsqr_a #1}%
\def\xint_fsqr_a #1/#2[#3]%
{%
    \expandafter\XINT_fsqr_b
    \expandafter{\the\numexpr #3+#3\expandafter}%
    \expandafter{\romannumeral0\xintiisqr {#2}}%
    {\romannumeral0\xintiisqr {#1}}%
}%
\def\XINT_fsqr_b #1#2#3{\expandafter \XINT_fmul_e \expandafter{#3}{#1}{#2}}%
\def\XINT_fsqr_zero #1]{ 0/1[0]}%
%    \end{macrocode}
% \subsection{\csh{xintPow}}
% \lverb|&
% Modified in 1.06 to give the exponent to a \numexpr.
%
% With 1.07 and for use within the \xintexpr parser, we must allow
% fractions (which are integers in disguise) as input to the exponent, so we
% must have a variant which uses \xintNum and not only \numexpr
% for normalizing the input. Hence the \xintfPow here.
%
% 1.08b: well actually I
% think that with xintfrac.sty loaded the exponent should always be allowed to
% be a fraction giving an integer. So I do as for \xintFac, and remove here the
% duplicated. Then \xintexpr can use the \xintPow as defined here.|
%    \begin{macrocode}
\def\xintPow {\romannumeral0\xintpow }%
\def\xintpow #1%
{%
    \expandafter\xint_fpow\expandafter {\romannumeral0\XINT_infrac {#1}}%
}%
\def\xint_fpow #1#2%
{%
    \expandafter\XINT_fpow_fork\the\numexpr \xintNum{#2}\relax\Z #1%
}%
\def\XINT_fpow_fork #1#2\Z
{%
    \xint_UDzerominusfork
      #1-\XINT_fpow_zero
      0#1\XINT_fpow_neg
       0-{\XINT_fpow_pos #1}%
    \krof
    {#2}%
}%
\def\XINT_fpow_zero #1#2#3#4{ 1/1[0]}%
\def\XINT_fpow_pos #1#2#3#4#5%
{%
    \expandafter\XINT_fpow_pos_A\expandafter
    {\the\numexpr #1#2*#3\expandafter}\expandafter
    {\romannumeral0\xintiipow {#5}{#1#2}}%
    {\romannumeral0\xintiipow {#4}{#1#2}}%
}%
\def\XINT_fpow_neg #1#2#3#4%
{%
    \expandafter\XINT_fpow_pos_A\expandafter
    {\the\numexpr -#1*#2\expandafter}\expandafter
    {\romannumeral0\xintiipow {#3}{#1}}%
    {\romannumeral0\xintiipow {#4}{#1}}%
}%
\def\XINT_fpow_pos_A #1#2#3%
{%
    \expandafter\XINT_fpow_pos_B\expandafter {#3}{#1}{#2}%
}%
\def\XINT_fpow_pos_B #1#2{\XINT_outfrac {#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintFac}}
% \lverb|1.07: to be used by the \xintexpr scanner which needs to be able to
% apply \xintFac
% to a fraction which is an integer in disguise; so we use \xintNum and not only
% \numexpr. Je modifie cela dans 1.08b, au lieu d'avoir un \xintfFac
% spcialement pour \xintexpr, tout simplement j'tends \xintFac comme les
% autres macros, pour qu'elle utilise \xintNum. |
%    \begin{macrocode}
\def\xintFac {\romannumeral0\xintfac }%
\def\xintfac #1%
{%
    \expandafter\XINT_fac_fork\expandafter{\the\numexpr \xintNum{#1}}%
}%
%    \end{macrocode}
% \subsection{\csh{xintPrd}}
%    \begin{macrocode}
\def\xintPrd {\romannumeral0\xintprd }%
\def\xintprd #1{\xintprdexpr #1\relax }%
\def\xintPrdExpr {\romannumeral0\xintprdexpr }%
\def\xintprdexpr {\expandafter\XINT_fprdexpr \romannumeral`&&@}%
\def\XINT_fprdexpr {\XINT_fprod_loop_a {1/1[0]}}%
\def\XINT_fprod_loop_a #1#2%
{%
    \expandafter\XINT_fprod_loop_b \romannumeral`&&@#2\Z {#1}%
}%
\def\XINT_fprod_loop_b #1%
{%
    \xint_gob_til_relax #1\XINT_fprod_finished\relax
    \XINT_fprod_loop_c #1%
}%
\def\XINT_fprod_loop_c #1\Z #2%
{%
  \expandafter\XINT_fprod_loop_a\expandafter{\romannumeral0\xintmul {#1}{#2}}%
}%
\def\XINT_fprod_finished #1\Z #2{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintDiv}}
%    \begin{macrocode}
\def\xintDiv {\romannumeral0\xintdiv }%
\def\xintdiv #1%
{%
    \expandafter\xint_fdiv\expandafter {\romannumeral0\XINT_infrac {#1}}%
}%
\def\xint_fdiv #1#2%
   {\expandafter\XINT_fdiv_A\romannumeral0\XINT_infrac {#2}#1}%
\def\XINT_fdiv_A #1#2#3#4#5#6%
{%
    \expandafter\XINT_fdiv_B
    \expandafter{\the\numexpr #4-#1\expandafter}%
    \expandafter{\romannumeral0\xintiimul {#2}{#6}}%
    {\romannumeral0\xintiimul {#3}{#5}}%
}%
\def\XINT_fdiv_B #1#2#3%
{%
    \expandafter\XINT_fdiv_C
    \expandafter{#3}{#1}{#2}%
}%
\def\XINT_fdiv_C #1#2{\XINT_outfrac {#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintDivFloor}}
% \lverb|1.1|
%    \begin{macrocode}
\def\xintDivFloor     {\romannumeral0\xintdivfloor }%
\def\xintdivfloor #1#2{\xintfloor{\xintDiv {#1}{#2}}}%
%    \end{macrocode}
% \subsection{\csh{xintDivTrunc}}
% \lverb|1.1. \xintttrunc rather than \xintitrunc0 in 1.1a|
%    \begin{macrocode}
\def\xintDivTrunc     {\romannumeral0\xintdivtrunc }%
\def\xintdivtrunc #1#2{\xintttrunc {\xintDiv {#1}{#2}}}%
%    \end{macrocode}
% \subsection{\csh{xintDivRound}}
% \lverb|1.1|
%    \begin{macrocode}
\def\xintDivRound     {\romannumeral0\xintdivround }%
\def\xintdivround #1#2{\xintiround 0{\xintDiv {#1}{#2}}}%
%    \end{macrocode}
% \subsection{\csh{xintMod}}
% \lverb|1.1. \xintMod {q1}{q2} computes q2*t(q1/q2) with t(q1/q2) equal to
% the truncated division of two arbitrary fractions q1 and q2. We put some
% efforts into minimizing the amount of computations.|
%    \begin{macrocode}
\def\xintMod {\romannumeral0\xintmod }%
\def\xintmod #1{\expandafter\XINT_mod_a\romannumeral0\xintraw{#1}.}%
\def\XINT_mod_a #1#2.#3%
   {\expandafter\XINT_mod_b\expandafter #1\romannumeral0\xintraw{#3}#2.}%
\def\XINT_mod_b #1#2% #1 de A, #2 de B.
{%
    \if0#2\xint_dothis\XINT_mod_divbyzero\fi
    \if0#1\xint_dothis\XINT_mod_aiszero\fi
    \if-#2\xint_dothis{\XINT_mod_bneg #1}\fi
          \xint_orthat{\XINT_mod_bpos #1#2}%
}%
\def\XINT_mod_bpos #1%
{%
    \xint_UDsignfork
            #1{\xintiiopp\XINT_mod_pos {}}%
             -{\XINT_mod_pos #1}%
    \krof
}%
\def\XINT_mod_bneg #1%
{%
    \xint_UDsignfork
            #1{\xintiiopp\XINT_mod_pos {}}%
             -{\XINT_mod_pos #1}%
    \krof
}%
\def\XINT_mod_divbyzero #1.{\xintError:DivisionByZero\space 0/1[0]}%
\def\XINT_mod_aiszero #1.{ 0/1[0]}%
\def\XINT_mod_pos #1#2/#3[#4]#5/#6[#7].%
{%
    \expandafter\XINT_mod_pos_a
    \the\numexpr\ifnum#7>#4 #4\else #7\fi\expandafter.\expandafter
    {\romannumeral0\xintiimul {#6}{#3}}%       n fois u
    {\xintiiE{\xintiiMul {#1#5}{#3}}{#7-#4}}%  m fois u
    {\xintiiE{\xintiiMul {#2}{#6}}{#4-#7}}%    t fois n
}%
\def\XINT_mod_pos_a #1.#2#3#4{\xintiirem {#3}{#4}/#2[#1]}%
%    \end{macrocode}
% \subsection{\csh{XINTinFloatMod}}
% \lverb|Pour emploi dans xintexpr 1.1|
%    \begin{macrocode}
\def\XINTinFloatMod {\romannumeral0\XINTinfloatmod [\XINTdigits]}%
\def\XINTinfloatmod [#1]#2#3{\expandafter\XINT_infloatmod\expandafter
                           {\romannumeral0\XINTinfloat[#1]{#2}}%
                           {\romannumeral0\XINTinfloat[#1]{#3}}{#1}}%
\def\XINT_infloatmod #1#2{\expandafter\XINT_infloatmod_a\expandafter {#2}{#1}}%
\def\XINT_infloatmod_a #1#2#3{\XINTinfloat [#3]{\xintMod {#2}{#1}}}%
%    \end{macrocode}
% \subsection{\csh{xintIsOne}}
% \lverb|&
% New with 1.09a. Could be more efficient. For fractions with big powers of
% tens, it is better to use \xintCmp{f}{1}. Restyled in 1.09i.|
%    \begin{macrocode}
\def\xintIsOne   {\romannumeral0\xintisone }%
\def\xintisone #1{\expandafter\XINT_fracisone
                  \romannumeral0\xintrawwithzeros{#1}\Z }%
\def\XINT_fracisone #1/#2\Z
    {\if0\XINT_Cmp {#1}{#2}\xint_afterfi{ 1}\else\xint_afterfi{ 0}\fi}%
%    \end{macrocode}
% \subsection{\csh{xintGeq}}
% \lverb|&
% Rewritten completely in 1.08a to be less dumb when comparing fractions having
% big powers of tens.|
%    \begin{macrocode}
\def\xintGeq {\romannumeral0\xintgeq }%
\def\xintgeq #1%
{%
    \expandafter\xint_fgeq\expandafter {\romannumeral0\xintabs {#1}}%
}%
\def\xint_fgeq #1#2%
{%
    \expandafter\XINT_fgeq_A \romannumeral0\xintabs {#2}#1%
}%
\def\XINT_fgeq_A #1%
{%
    \xint_gob_til_zero #1\XINT_fgeq_Zii 0%
    \XINT_fgeq_B #1%
}%
\def\XINT_fgeq_Zii 0\XINT_fgeq_B #1[#2]#3[#4]{ 1}%
\def\XINT_fgeq_B #1/#2[#3]#4#5/#6[#7]%
{%
    \xint_gob_til_zero #4\XINT_fgeq_Zi 0%
    \expandafter\XINT_fgeq_C\expandafter
    {\the\numexpr #7-#3\expandafter}\expandafter
    {\romannumeral0\xintiimul {#4#5}{#2}}%
    {\romannumeral0\xintiimul {#6}{#1}}%
}%
\def\XINT_fgeq_Zi 0#1#2#3#4#5#6#7{ 0}%
\def\XINT_fgeq_C #1#2#3%
{%
    \expandafter\XINT_fgeq_D\expandafter
    {#3}{#1}{#2}%
}%
\def\XINT_fgeq_D #1#2#3%
{%
    \expandafter\XINT_cntSgnFork\romannumeral`&&@\expandafter\XINT_cntSgn
     \the\numexpr #2+\xintLength{#3}-\xintLength{#1}\relax\Z
    { 0}{\XINT_fgeq_E #2\Z {#3}{#1}}{ 1}%
}%
\def\XINT_fgeq_E #1%
{%
    \xint_UDsignfork
        #1\XINT_fgeq_Fd
         -{\XINT_fgeq_Fn #1}%
    \krof
}%
\def\XINT_fgeq_Fd #1\Z #2#3%
{%
    \expandafter\XINT_fgeq_Fe\expandafter
    {\romannumeral0\XINT_dsx_addzerosnofuss {#1}{#3}}{#2}%
}%
\def\XINT_fgeq_Fe #1#2{\XINT_geq_pre {#2}{#1}}%
\def\XINT_fgeq_Fn #1\Z #2#3%
{%
    \expandafter\XINT_geq_pre\expandafter
    {\romannumeral0\XINT_dsx_addzerosnofuss {#1}{#2}}{#3}%
}%
%    \end{macrocode}
% \subsection{\csh{xintMax}}
% \lverb|&
% Rewritten completely in 1.08a.|
%    \begin{macrocode}
\def\xintMax {\romannumeral0\xintmax }%
\def\xintmax #1%
{%
    \expandafter\xint_fmax\expandafter {\romannumeral0\xintraw {#1}}%
}%
\def\xint_fmax #1#2%
{%
    \expandafter\XINT_fmax_A\romannumeral0\xintraw {#2}#1%
}%
\def\XINT_fmax_A #1#2/#3[#4]#5#6/#7[#8]%
{%
    \xint_UDsignsfork
      #1#5\XINT_fmax_minusminus
       -#5\XINT_fmax_firstneg
       #1-\XINT_fmax_secondneg
        --\XINT_fmax_nonneg_a
    \krof
    #1#5{#2/#3[#4]}{#6/#7[#8]}%
}%
\def\XINT_fmax_minusminus --%
   {\expandafter\xint_minus_thenstop\romannumeral0\XINT_fmin_nonneg_b }%
\def\XINT_fmax_firstneg #1-#2#3{ #1#2}%
\def\XINT_fmax_secondneg -#1#2#3{ #1#3}%
\def\XINT_fmax_nonneg_a #1#2#3#4%
{%
    \XINT_fmax_nonneg_b {#1#3}{#2#4}%
}%
\def\XINT_fmax_nonneg_b #1#2%
{%
    \if0\romannumeral0\XINT_fgeq_A #1#2%
          \xint_afterfi{ #1}%
    \else \xint_afterfi{ #2}%
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintMaxof}}
%    \begin{macrocode}
\def\xintMaxof      {\romannumeral0\xintmaxof }%
\def\xintmaxof    #1{\expandafter\XINT_maxof_a\romannumeral`&&@#1\relax }%
\def\XINT_maxof_a #1{\expandafter\XINT_maxof_b\romannumeral0\xintraw{#1}\Z }%
\def\XINT_maxof_b #1\Z #2%
           {\expandafter\XINT_maxof_c\romannumeral`&&@#2\Z {#1}\Z}%
\def\XINT_maxof_c #1%
           {\xint_gob_til_relax #1\XINT_maxof_e\relax\XINT_maxof_d #1}%
\def\XINT_maxof_d #1\Z
           {\expandafter\XINT_maxof_b\romannumeral0\xintmax {#1}}%
\def\XINT_maxof_e #1\Z #2\Z { #2}%
%    \end{macrocode}
% \subsection{\csh{xintMin}}
% \lverb|&
% Rewritten completely in 1.08a.|
%    \begin{macrocode}
\def\xintMin {\romannumeral0\xintmin }%
\def\xintmin #1%
{%
    \expandafter\xint_fmin\expandafter {\romannumeral0\xintraw {#1}}%
}%
\def\xint_fmin #1#2%
{%
    \expandafter\XINT_fmin_A\romannumeral0\xintraw {#2}#1%
}%
\def\XINT_fmin_A #1#2/#3[#4]#5#6/#7[#8]%
{%
    \xint_UDsignsfork
      #1#5\XINT_fmin_minusminus
       -#5\XINT_fmin_firstneg
       #1-\XINT_fmin_secondneg
        --\XINT_fmin_nonneg_a
    \krof
    #1#5{#2/#3[#4]}{#6/#7[#8]}%
}%
\def\XINT_fmin_minusminus --%
   {\expandafter\xint_minus_thenstop\romannumeral0\XINT_fmax_nonneg_b }%
\def\XINT_fmin_firstneg #1-#2#3{ -#3}%
\def\XINT_fmin_secondneg -#1#2#3{ -#2}%
\def\XINT_fmin_nonneg_a #1#2#3#4%
{%
    \XINT_fmin_nonneg_b {#1#3}{#2#4}%
}%
\def\XINT_fmin_nonneg_b #1#2%
{%
    \if0\romannumeral0\XINT_fgeq_A #1#2%
          \xint_afterfi{ #2}%
    \else \xint_afterfi{ #1}%
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintMinof}}
%    \begin{macrocode}
\def\xintMinof      {\romannumeral0\xintminof }%
\def\xintminof    #1{\expandafter\XINT_minof_a\romannumeral`&&@#1\relax }%
\def\XINT_minof_a #1{\expandafter\XINT_minof_b\romannumeral0\xintraw{#1}\Z }%
\def\XINT_minof_b #1\Z #2%
           {\expandafter\XINT_minof_c\romannumeral`&&@#2\Z {#1}\Z}%
\def\XINT_minof_c #1%
           {\xint_gob_til_relax #1\XINT_minof_e\relax\XINT_minof_d #1}%
\def\XINT_minof_d #1\Z
           {\expandafter\XINT_minof_b\romannumeral0\xintmin {#1}}%
\def\XINT_minof_e #1\Z #2\Z { #2}%
%    \end{macrocode}
% \subsection{\csh{xintCmp}}
% \lverb|Rewritten completely in 1.08a to be less dumb when comparing
% fractions having big powers of tens.|
%    \begin{macrocode}
%\def\xintCmp {\romannumeral0\xintcmp }%
\def\xintcmp #1%
{%
    \expandafter\xint_fcmp\expandafter {\romannumeral0\xintraw {#1}}%
}%
\def\xint_fcmp #1#2%
{%
    \expandafter\XINT_fcmp_A\romannumeral0\xintraw {#2}#1%
}%
\def\XINT_fcmp_A #1#2/#3[#4]#5#6/#7[#8]%
{%
    \xint_UDsignsfork
      #1#5\XINT_fcmp_minusminus
       -#5\XINT_fcmp_firstneg
       #1-\XINT_fcmp_secondneg
        --\XINT_fcmp_nonneg_a
    \krof
    #1#5{#2/#3[#4]}{#6/#7[#8]}%
}%
\def\XINT_fcmp_minusminus --#1#2{\XINT_fcmp_B #2#1}%
\def\XINT_fcmp_firstneg #1-#2#3{ -1}%
\def\XINT_fcmp_secondneg -#1#2#3{ 1}%
\def\XINT_fcmp_nonneg_a #1#2%
{%
    \xint_UDzerosfork
      #1#2\XINT_fcmp_zerozero
       0#2\XINT_fcmp_firstzero
       #10\XINT_fcmp_secondzero
        00\XINT_fcmp_pos
    \krof
    #1#2%
}%
\def\XINT_fcmp_zerozero   #1#2#3#4{ 0}%  1.08b had some [ and ] here!!!
\def\XINT_fcmp_firstzero  #1#2#3#4{ -1}% incredibly I never saw that until
\def\XINT_fcmp_secondzero #1#2#3#4{ 1}%  preparing 1.09a.
\def\XINT_fcmp_pos #1#2#3#4%
{%
    \XINT_fcmp_B #1#3#2#4%
}%
\def\XINT_fcmp_B #1/#2[#3]#4/#5[#6]%
{%
    \expandafter\XINT_fcmp_C\expandafter
    {\the\numexpr #6-#3\expandafter}\expandafter
    {\romannumeral0\xintiimul {#4}{#2}}%
    {\romannumeral0\xintiimul {#5}{#1}}%
}%
\def\XINT_fcmp_C #1#2#3%
{%
    \expandafter\XINT_fcmp_D\expandafter
    {#3}{#1}{#2}%
}%
\def\XINT_fcmp_D #1#2#3%
{%
    \expandafter\XINT_cntSgnFork\romannumeral`&&@\expandafter\XINT_cntSgn
    \the\numexpr #2+\xintLength{#3}-\xintLength{#1}\relax\Z
    { -1}{\XINT_fcmp_E #2\Z {#3}{#1}}{ 1}%
}%
\def\XINT_fcmp_E #1%
{%
    \xint_UDsignfork
        #1\XINT_fcmp_Fd
         -{\XINT_fcmp_Fn #1}%
    \krof
}%
\def\XINT_fcmp_Fd #1\Z #2#3%
{%
    \expandafter\XINT_fcmp_Fe\expandafter
    {\romannumeral0\XINT_dsx_addzerosnofuss {#1}{#3}}{#2}%
}%
\def\XINT_fcmp_Fe #1#2{\xintiicmp {#2}{#1}}%
\def\XINT_fcmp_Fn #1\Z #2#3%
{%
    \expandafter\xintiicmp\expandafter
    {\romannumeral0\XINT_dsx_addzerosnofuss {#1}{#2}}{#3}%
}%
%    \end{macrocode}
% \subsection{\csh{xintAbs}}
%    \begin{macrocode}
\def\xintAbs   {\romannumeral0\xintabs }%
\def\xintabs #1{\expandafter\XINT_abs\romannumeral0\xintraw {#1}}%
%    \end{macrocode}
% \subsection{\csh{xintOpp}}
%    \begin{macrocode}
\def\xintOpp   {\romannumeral0\xintopp }%
\def\xintopp #1{\expandafter\XINT_opp\romannumeral0\xintraw {#1}}%
%    \end{macrocode}
% \subsection{\csh{xintSgn}}
%    \begin{macrocode}
\def\xintSgn   {\romannumeral0\xintsgn }%
\def\xintsgn #1{\expandafter\XINT_sgn\romannumeral0\xintraw {#1}\Z }%
%    \end{macrocode}
% \subsection{Floating point macros}
% \begin{framed}
%   1.2 release has not touched the floating point routines apart from adding
%   the new \csh{xintFloatFac}. The others should be revised for some
%   optimizations related to the underlying model of the new core routines.
%   This is particularly the case for \csh{xintFloatPow} and
%   \csh{xintFloatPower} which should keep intermediate results in a suitable
%   format, like \csh{xintiiPow} does.
%
%   The switch to 1.2 was smooth (apart from the writing up of the new
%   \csh{xintFloatFac}), as I didn't have to change a single line of code
%   anywhere here !
% \end{framed}
% 
% \subsection{\csh{xintFloatAdd}, \csh{XINTinFloatAdd}}
% \lverb|1.07; 1.09ka improves a bit the efficieny of the coding of
% \XINT_FL_Add_d.|
%    \begin{macrocode}
\def\xintFloatAdd      {\romannumeral0\xintfloatadd }%
\def\xintfloatadd    #1{\XINT_fladd_chkopt \xintfloat #1\xint_relax }%
\def\XINTinFloatAdd    {\romannumeral0\XINTinfloatadd }%
\def\XINTinfloatadd  #1{\XINT_fladd_chkopt \XINTinfloat #1\xint_relax }%
\def\XINT_fladd_chkopt #1#2%
{%
    \ifx [#2\expandafter\XINT_fladd_opt
       \else\expandafter\XINT_fladd_noopt
    \fi  #1#2%
}%
\def\XINT_fladd_noopt #1#2\xint_relax #3%
{%
    #1[\XINTdigits]{\XINT_FL_Add {\XINTdigits+\xint_c_ii}{#2}{#3}}%
}%
\def\XINT_fladd_opt #1[\xint_relax #2]#3#4%
{%
    #1[#2]{\XINT_FL_Add {#2+\xint_c_ii}{#3}{#4}}%
}%
\def\XINT_FL_Add #1#2%
{%
    \expandafter\XINT_FL_Add_a\expandafter{\the\numexpr #1\expandafter}%
    \expandafter{\romannumeral0\XINTinfloat [#1]{#2}}%
}%
\def\XINT_FL_Add_a #1#2#3%
{%
    \expandafter\XINT_FL_Add_b\romannumeral0\XINTinfloat [#1]{#3}#2{#1}%
}%
\def\XINT_FL_Add_b #1%
{%
    \xint_gob_til_zero #1\XINT_FL_Add_zero 0\XINT_FL_Add_c #1%
}%
\def\XINT_FL_Add_c #1[#2]#3%
{%
    \xint_gob_til_zero #3\XINT_FL_Add_zerobis 0\XINT_FL_Add_d #1[#2]#3%
}%
\def\XINT_FL_Add_d #1[#2]#3[#4]#5%
{%
    \ifnum \numexpr #2-#4-#5>\xint_c_i
       \expandafter \xint_secondofthree_thenstop
    \else
       \ifnum \numexpr #4-#2-#5>\xint_c_i
              \expandafter\expandafter\expandafter\xint_thirdofthree_thenstop
       \fi
    \fi
    \xintadd {#1[#2]}{#3[#4]}%
}%
\def\XINT_FL_Add_zero 0\XINT_FL_Add_c 0[0]#1[#2]#3{#1[#2]}%
\def\XINT_FL_Add_zerobis 0\XINT_FL_Add_d #1[#2]0[0]#3{#1[#2]}%
%    \end{macrocode}
% \subsection{\csh{xintFloatSub}, \csh{XINTinFloatSub}}
% \lverb|1.07|
%    \begin{macrocode}
\def\xintFloatSub {\romannumeral0\xintfloatsub }%
\def\xintfloatsub    #1{\XINT_flsub_chkopt \xintfloat #1\xint_relax }%
\def\XINTinFloatSub {\romannumeral0\XINTinfloatsub }%
\def\XINTinfloatsub #1{\XINT_flsub_chkopt \XINTinfloat #1\xint_relax }%
\def\XINT_flsub_chkopt #1#2%
{%
    \ifx [#2\expandafter\XINT_flsub_opt
       \else\expandafter\XINT_flsub_noopt
    \fi  #1#2%
}%
\def\XINT_flsub_noopt #1#2\xint_relax #3%
{%
    #1[\XINTdigits]{\XINT_FL_Add {\XINTdigits+\xint_c_ii}{#2}{\xintOpp{#3}}}%
}%
\def\XINT_flsub_opt #1[\xint_relax #2]#3#4%
{%
    #1[#2]{\XINT_FL_Add {#2+\xint_c_ii}{#3}{\xintOpp{#4}}}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFloatMul}, \csh{XINTinFloatMul}}
% \begin{framed}
%   It is a long-standing issue here that I must at some point revise the code
%   and avoid compute with 2P digits the exact intermediate result.
% \end{framed}
% \lverb|1.07|
%    \begin{macrocode}
\def\xintFloatMul    {\romannumeral0\xintfloatmul}%
\def\xintfloatmul    #1{\XINT_flmul_chkopt \xintfloat #1\xint_relax }%
\def\XINTinFloatMul {\romannumeral0\XINTinfloatmul }%
\def\XINTinfloatmul #1{\XINT_flmul_chkopt \XINTinfloat #1\xint_relax }%
\def\XINT_flmul_chkopt #1#2%
{%
    \ifx [#2\expandafter\XINT_flmul_opt
       \else\expandafter\XINT_flmul_noopt
    \fi  #1#2%
}%
\def\XINT_flmul_noopt #1#2\xint_relax #3%
{%
    #1[\XINTdigits]{\XINT_FL_Mul {\XINTdigits+\xint_c_ii}{#2}{#3}}%
}%
\def\XINT_flmul_opt #1[\xint_relax #2]#3#4%
{%
    #1[#2]{\XINT_FL_Mul {#2+\xint_c_ii}{#3}{#4}}%
}%
\def\XINT_FL_Mul #1#2%
{%
    \expandafter\XINT_FL_Mul_a\expandafter{\the\numexpr #1\expandafter}%
    \expandafter{\romannumeral0\XINTinfloat [#1]{#2}}%
}%
\def\XINT_FL_Mul_a #1#2#3%
{%
    \expandafter\XINT_FL_Mul_b\romannumeral0\XINTinfloat [#1]{#3}#2%
}%
\def\XINT_FL_Mul_b #1[#2]#3[#4]{\xintE{\xintiiMul {#1}{#3}}{#2+#4}}%
%    \end{macrocode}
% \subsection{\csh{xintFloatDiv}, \csh{XINTinFloatDiv}}
% \lverb|1.07|
%    \begin{macrocode}
\def\xintFloatDiv    {\romannumeral0\xintfloatdiv}%
\def\xintfloatdiv    #1{\XINT_fldiv_chkopt \xintfloat #1\xint_relax }%
\def\XINTinFloatDiv  {\romannumeral0\XINTinfloatdiv }%
\def\XINTinfloatdiv  #1{\XINT_fldiv_chkopt \XINTinfloat #1\xint_relax }%
\def\XINT_fldiv_chkopt #1#2%
{%
    \ifx [#2\expandafter\XINT_fldiv_opt
       \else\expandafter\XINT_fldiv_noopt
    \fi  #1#2%
}%
\def\XINT_fldiv_noopt #1#2\xint_relax #3%
{%
    #1[\XINTdigits]{\XINT_FL_Div {\XINTdigits+\xint_c_ii}{#2}{#3}}%
}%
\def\XINT_fldiv_opt #1[\xint_relax #2]#3#4%
{%
    #1[#2]{\XINT_FL_Div {#2+\xint_c_ii}{#3}{#4}}%
}%
\def\XINT_FL_Div #1#2%
{%
    \expandafter\XINT_FL_Div_a\expandafter{\the\numexpr #1\expandafter}%
    \expandafter{\romannumeral0\XINTinfloat [#1]{#2}}%
}%
\def\XINT_FL_Div_a #1#2#3%
{%
    \expandafter\XINT_FL_Div_b\romannumeral0\XINTinfloat [#1]{#3}#2%
}%
\def\XINT_FL_Div_b #1[#2]#3[#4]{\xintE{#3/#1}{#4-#2}}%
%    \end{macrocode}
% \subsection{\csh{xintFloatPow}, \csh{XINTinFloatPow}}
% \begin{framed}
%   This definitely should be revised to better take into account the new
%   multiplication to maintain through intermediate states a suitable internal
%   format, optimized for calls to \csh{XINT_mul_loop}.
% \end{framed}
% \lverb|1.07. Release 1.09j has re-organized the core loop, and
% \XINT_flpow_prd sub-routine has been removed.|
%    \begin{macrocode}
\def\xintFloatPow {\romannumeral0\xintfloatpow}%
\def\xintfloatpow #1{\XINT_flpow_chkopt \xintfloat #1\xint_relax }%
\def\XINTinFloatPow {\romannumeral0\XINTinfloatpow }%
\def\XINTinfloatpow #1{\XINT_flpow_chkopt \XINTinfloat #1\xint_relax }%
\def\XINT_flpow_chkopt #1#2%
{%
    \ifx [#2\expandafter\XINT_flpow_opt
       \else\expandafter\XINT_flpow_noopt
    \fi
     #1#2%
}%
\def\XINT_flpow_noopt  #1#2\xint_relax #3%
{%
   \expandafter\XINT_flpow_checkB_start\expandafter
                {\the\numexpr #3\expandafter}\expandafter
                {\the\numexpr \XINTdigits}{#2}{#1[\XINTdigits]}%
}%
\def\XINT_flpow_opt #1[\xint_relax #2]#3#4%
{%
   \expandafter\XINT_flpow_checkB_start\expandafter
               {\the\numexpr #4\expandafter}\expandafter
               {\the\numexpr #2}{#3}{#1[#2]}%
}%
\def\XINT_flpow_checkB_start #1{\XINT_flpow_checkB_a #1\Z }%
\def\XINT_flpow_checkB_a #1%
{%
    \xint_UDzerominusfork
      #1-\XINT_flpow_BisZero
      0#1{\XINT_flpow_checkB_b 1}%
       0-{\XINT_flpow_checkB_b 0#1}%
    \krof
}%
\def\XINT_flpow_BisZero \Z #1#2#3{#3{1/1[0]}}%
\def\XINT_flpow_checkB_b #1#2\Z #3%
{%
    \expandafter\XINT_flpow_checkB_c \expandafter
    {\romannumeral0\xintlength{#2}}{#3}{#2}#1%
}%
\def\XINT_flpow_checkB_c #1#2%
{%
    \expandafter\XINT_flpow_checkB_d \expandafter
    {\the\numexpr \expandafter\xintLength\expandafter
                  {\the\numexpr #1*20/\xint_c_iii }+#1+#2+\xint_c_i }%
}%
\def\XINT_flpow_checkB_d #1#2#3#4%
{%
    \expandafter \XINT_flpow_a
    \romannumeral0\XINTinfloat [#1]{#4}{#1}{#2}#3%
}%
\def\XINT_flpow_a #1%
{%
    \xint_UDzerominusfork
      #1-\XINT_flpow_zero
      0#1{\XINT_flpow_b 1}%
       0-{\XINT_flpow_b 0#1}%
    \krof
}%
\def\XINT_flpow_b #1#2[#3]#4#5%
{%
    \XINT_flpow_loopI {#5}{#2[#3]}{\romannumeral0\XINTinfloatmul [#4]}%
    {#1*\ifodd #5 1\else 0\fi}%
}%
\def\XINT_flpow_zero [#1]#2#3#4#5%
%    \end{macrocode}
% \lverb|xint is not equipped to signal infinity, the 2^31 will provoke
% deliberately a number too big and arithmetic overflow in \XINT_float_Xb|
%    \begin{macrocode}
{%
    \if #41\xint_afterfi {\xintError:DivisionByZero #5{1[2147483648]}}%
    \else \xint_afterfi {#5{0[0]}}\fi
}%
\def\XINT_flpow_loopI #1%
{%
    \ifnum #1=\xint_c_i\XINT_flpow_ItoIII\fi
    \ifodd #1
       \expandafter\XINT_flpow_loopI_odd
    \else
       \expandafter\XINT_flpow_loopI_even
    \fi
    {#1}%
}%
\def\XINT_flpow_ItoIII\fi #1\fi #2#3#4#5%
{%
    \fi\expandafter\XINT_flpow_III\the\numexpr #5\relax #3%
}%
\def\XINT_flpow_loopI_even #1#2#3%
{%
    \expandafter\XINT_flpow_loopI\expandafter
    {\the\numexpr #1/\xint_c_ii\expandafter}\expandafter
    {#3{#2}{#2}}{#3}%
}%
\def\XINT_flpow_loopI_odd #1#2#3%
{%
    \expandafter\XINT_flpow_loopII\expandafter
    {\the\numexpr #1/\xint_c_ii-\xint_c_i\expandafter}\expandafter
    {#3{#2}{#2}}{#3}{#2}%
}%
\def\XINT_flpow_loopII #1%
{%
    \ifnum #1 = \xint_c_i\XINT_flpow_IItoIII\fi
    \ifodd #1
       \expandafter\XINT_flpow_loopII_odd
    \else
       \expandafter\XINT_flpow_loopII_even
    \fi
    {#1}%
}%
\def\XINT_flpow_loopII_even #1#2#3%
{%
    \expandafter\XINT_flpow_loopII\expandafter
    {\the\numexpr #1/\xint_c_ii\expandafter}\expandafter
    {#3{#2}{#2}}{#3}%
}%
\def\XINT_flpow_loopII_odd #1#2#3#4%
{%
    \expandafter\XINT_flpow_loopII_odda\expandafter
    {#3{#2}{#4}}{#1}{#2}{#3}%
}%
\def\XINT_flpow_loopII_odda #1#2#3#4%
{%
    \expandafter\XINT_flpow_loopII\expandafter
    {\the\numexpr #2/\xint_c_ii-\xint_c_i\expandafter}\expandafter
    {#4{#3}{#3}}{#4}{#1}%
}%
\def\XINT_flpow_IItoIII\fi #1\fi #2#3#4#5#6%
{%
    \fi\expandafter\XINT_flpow_III\the\numexpr #6\expandafter\relax
    #4{#3}{#5}%
}%
\def\XINT_flpow_III #1#2[#3]#4%
{%
    \expandafter\XINT_flpow_IIIend\expandafter
    {\the\numexpr\if #41-\fi#3\expandafter}%
    \xint_UDzerofork
        #4{{#2}}%
         0{{1/#2}}%
    \krof #1%
}%
\def\XINT_flpow_IIIend #1#2#3#4%
{%
    \xint_UDzerofork
    #3{#4{#2[#1]}}%
     0{#4{-#2[#1]}}%
    \krof
}%
%    \end{macrocode}
% \subsection{\csh{xintFloatPower}, \csh{XINTinFloatPower}}
% \lverb|1.07. The core loop has been re-organized in 1.09j for some slight
% efficiency gain. |
%    \begin{macrocode}
\def\xintFloatPower {\romannumeral0\xintfloatpower}%
\def\xintfloatpower #1{\XINT_flpower_chkopt \xintfloat #1\xint_relax }%
\def\XINTinFloatPower {\romannumeral0\XINTinfloatpower}%
\def\XINTinfloatpower #1{\XINT_flpower_chkopt \XINTinfloat #1\xint_relax }%
\def\XINT_flpower_chkopt #1#2%
{%
    \ifx [#2\expandafter\XINT_flpower_opt
       \else\expandafter\XINT_flpower_noopt
    \fi
     #1#2%
}%
\def\XINT_flpower_noopt  #1#2\xint_relax #3%
{%
   \expandafter\XINT_flpower_checkB_start\expandafter
                {\the\numexpr \XINTdigits\expandafter}\expandafter
                {\romannumeral0\xintnum{#3}}{#2}{#1[\XINTdigits]}%
}%
\def\XINT_flpower_opt #1[\xint_relax #2]#3#4%
{%
   \expandafter\XINT_flpower_checkB_start\expandafter
               {\the\numexpr #2\expandafter}\expandafter
               {\romannumeral0\xintnum{#4}}{#3}{#1[#2]}%
}%
\def\XINT_flpower_checkB_start #1#2{\XINT_flpower_checkB_a #2\Z {#1}}%
\def\XINT_flpower_checkB_a #1%
{%
    \xint_UDzerominusfork
      #1-\XINT_flpower_BisZero
      0#1{\XINT_flpower_checkB_b 1}%
       0-{\XINT_flpower_checkB_b 0#1}%
    \krof
}%
\def\XINT_flpower_BisZero \Z #1#2#3{#3{1/1[0]}}%
\def\XINT_flpower_checkB_b #1#2\Z #3%
{%
    \expandafter\XINT_flpower_checkB_c \expandafter
    {\romannumeral0\xintlength{#2}}{#3}{#2}#1%
}%
\def\XINT_flpower_checkB_c #1#2%
{%
    \expandafter\XINT_flpower_checkB_d \expandafter
    {\the\numexpr \expandafter\xintLength\expandafter
                  {\the\numexpr #1*20/\xint_c_iii }+#1+#2+\xint_c_i }%
}%
\def\XINT_flpower_checkB_d #1#2#3#4%
{%
    \expandafter \XINT_flpower_a
    \romannumeral0\XINTinfloat [#1]{#4}{#1}{#2}#3%
}%
\def\XINT_flpower_a #1%
{%
    \xint_UDzerominusfork
      #1-\XINT_flpow_zero
      0#1{\XINT_flpower_b 1}%
       0-{\XINT_flpower_b 0#1}%
    \krof
}%
\def\XINT_flpower_b #1#2[#3]#4#5%
{%
    \XINT_flpower_loopI {#5}{#2[#3]}{\romannumeral0\XINTinfloatmul [#4]}%
    {#1*\xintiiOdd {#5}}%
}%
\def\XINT_flpower_loopI #1%
{%
    \if1\XINT_isOne {#1}\XINT_flpower_ItoIII\fi
    \if1\xintiiOdd{#1}%
       \expandafter\expandafter\expandafter\XINT_flpower_loopI_odd
    \else
       \expandafter\expandafter\expandafter\XINT_flpower_loopI_even
    \fi
    \expandafter {\romannumeral0\xinthalf{#1}}%
}%
\def\XINT_flpower_ItoIII\fi #1\fi\expandafter #2#3#4#5%
{%
    \fi\expandafter\XINT_flpow_III \the\numexpr #5\relax #3%
}%
\def\XINT_flpower_loopI_even #1#2#3%
{%
    \expandafter\XINT_flpower_toI\expandafter {#3{#2}{#2}}{#1}{#3}%
}%
\def\XINT_flpower_loopI_odd #1#2#3%
{%
    \expandafter\XINT_flpower_toII\expandafter {#3{#2}{#2}}{#1}{#3}{#2}%
}%
\def\XINT_flpower_toI  #1#2{\XINT_flpower_loopI  {#2}{#1}}%
\def\XINT_flpower_toII #1#2{\XINT_flpower_loopII {#2}{#1}}%
\def\XINT_flpower_loopII #1%
{%
    \if1\XINT_isOne {#1}\XINT_flpower_IItoIII\fi
    \if1\xintiiOdd{#1}%
       \expandafter\expandafter\expandafter\XINT_flpower_loopII_odd
    \else
       \expandafter\expandafter\expandafter\XINT_flpower_loopII_even
    \fi
    \expandafter {\romannumeral0\xinthalf{#1}}%
}%
\def\XINT_flpower_loopII_even #1#2#3%
{%
    \expandafter\XINT_flpower_toII\expandafter
    {#3{#2}{#2}}{#1}{#3}%
}%
\def\XINT_flpower_loopII_odd #1#2#3#4%
{%
    \expandafter\XINT_flpower_loopII_odda\expandafter
    {#3{#2}{#4}}{#2}{#3}{#1}%
}%
\def\XINT_flpower_loopII_odda #1#2#3#4%
{%
    \expandafter\XINT_flpower_toII\expandafter
    {#3{#2}{#2}}{#4}{#3}{#1}%
}%
\def\XINT_flpower_IItoIII\fi #1\fi\expandafter #2#3#4#5#6%
{%
    \fi\expandafter\XINT_flpow_III\the\numexpr #6\expandafter\relax
    #4{#3}{#5}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFloatFac}, \csh{XINTFloatFac}}
% \lverb|1.2. Je dois documenter le raisonnement sur la prcision  imposer
% pour les calculs par blocs de huit faits en sous-main. Par ailleurs j'ai t
% amen  une routine smallmul spciale.
%
% Comment 2015/11/13: at least I do have a file which privately document my
% choice of precision (I could reduce by one unit here). I hesitated with doing
% a divide and conquer approach, but last time I thought about it I did not see
% an obvious advantage in this context. But I should implement and compare.|
%    \begin{macrocode}
\def\xintFloatFac     {\romannumeral0\xintfloatfac}%
\def\xintfloatfac   #1{\XINT_flfac_chkopt \xintfloat #1\xint_relax }%
\def\XINTinFloatFac   {\romannumeral0\XINTinfloatfac }%
\def\XINTinfloatfac #1{\XINT_flfac_chkopt \XINTinfloat #1\xint_relax }%
\def\XINT_flfac_chkopt #1#2%
{%
    \ifx [#2\expandafter\XINT_flfac_opt
       \else\expandafter\XINT_flfac_noopt
    \fi
     #1#2%
}%
\def\XINT_flfac_noopt  #1#2\xint_relax
{%
   \expandafter\XINT_FL_fac_start\expandafter
   {\the\numexpr #2}{\XINTdigits}{#1[\XINTdigits]}%
}%
\def\XINT_flfac_opt #1[\xint_relax #2]#3%
{%
   \expandafter\XINT_FL_fac_start\expandafter
   {\the\numexpr #3\expandafter}\expandafter{\the\numexpr#2}{#1[#2]}%
}%
\def\XINT_FL_fac_start #1%
{%
    \ifcase\XINT_cntSgn #1\Z
       \expandafter\XINT_FL_fac_iszero
    \or
       \expandafter\XINT_FL_fac_increaseP
    \else
       \expandafter\XINT_FL_fac_isneg
    \fi {#1}%
}%
\def\XINT_FL_fac_iszero #1#2#3{#3{1/1[0]}}%
\def\XINT_FL_fac_isneg  #1#2#3%
    {\expandafter\xintError:FactorialOfNegativeNumber #3{1/1[0]}}%
\def\XINT_FL_fac_increaseP #1#2%
{%
    \expandafter\XINT_FL_fac_fork
    \the\numexpr \xint_c_viii*%
    ((\xint_c_v+#2+\XINT_FL_fac_extradigits #187654321\Z)/\xint_c_viii).%
    #1.%
}%
\def\XINT_FL_fac_extradigits #1#2#3#4#5#6#7#8{\XINT_FL_fac_extra_a }%
\def\XINT_FL_fac_extra_a     #1#2\Z {#1}%
\def\XINT_FL_fac_fork #1.#2.#3%
{%
    \ifnum #2>99999999 \xint_dothis{\XINT_FL_fac_toobig  }\fi
    \ifnum #2>9999 \xint_dothis{\XINT_FL_fac_vbigloop_a }\fi
    \ifnum #2>465  \xint_dothis{\XINT_FL_fac_bigloop_a }\fi
    \ifnum #2>101  \xint_dothis{\XINT_FL_fac_medloop_a }\fi
                   \xint_orthat{\XINT_FL_fac_smallloop_a }%
    #2.#1.{\XINT_FL_fac_out}{#3}%
}%
\def\XINT_FL_fac_toobig #1.#2.#3#4%
    {\expandafter\xintError:FactorialOfTooBigNumber #4{1/1[0]}}%
\def\XINT_FL_fac_out #1\Z![#2]#3{#3{\romannumeral0\XINT_mul_out 
                                 #1\Z!1\R!1\R!1\R!1\R!1\R!1\R!1\R!1\R!\W [#2]}}%
\def\XINT_FL_fac_vbigloop_a #1.#2.%
{%
    \XINT_FL_fac_bigloop_a 9999.#2.%
    {\expandafter\XINT_FL_fac_vbigloop_loop\the\numexpr 100010000\expandafter.%
     \the\numexpr \xint_c_x^viii+#1.}%
}%
\def\XINT_FL_fac_vbigloop_loop #1.#2.%
{%
    \ifnum #1>#2 \expandafter\XINT_FL_fac_loop_exit\fi
    \expandafter\XINT_FL_fac_vbigloop_loop
    \the\numexpr #1+\xint_c_i\expandafter.%
    \the\numexpr #2\expandafter.\the\numexpr\XINT_FL_fac_mul #1!%
}%
\def\XINT_FL_fac_bigloop_a #1.%
{%
    \expandafter\XINT_FL_fac_bigloop_b \the\numexpr 
    #1+\xint_c_i-\xint_c_ii*((#1-464)/\xint_c_ii).#1.%
}%
\def\XINT_FL_fac_bigloop_b #1.#2.#3.%
{%
    \expandafter\XINT_FL_fac_medloop_a
        \the\numexpr #1-\xint_c_i.#3.{\XINT_FL_fac_bigloop_loop #1.#2.}%
}%
\def\XINT_FL_fac_bigloop_loop #1.#2.%
{%
    \ifnum #1>#2 \expandafter\XINT_FL_fac_loop_exit\fi
    \expandafter\XINT_FL_fac_bigloop_loop
    \the\numexpr #1+\xint_c_ii\expandafter.%
    \the\numexpr #2\expandafter.\the\numexpr\XINT_FL_fac_bigloop_mul #1!%
}%
\def\XINT_FL_fac_bigloop_mul #1!%
{%
    \expandafter\XINT_FL_fac_mul
        \the\numexpr \xint_c_x^viii+#1*(#1+\xint_c_i)!%
}%
\def\XINT_FL_fac_medloop_a #1.%
{%
    \expandafter\XINT_FL_fac_medloop_b
        \the\numexpr #1+\xint_c_i-\xint_c_iii*((#1-100)/\xint_c_iii).#1.%
}%
\def\XINT_FL_fac_medloop_b #1.#2.#3.%
{%
    \expandafter\XINT_FL_fac_smallloop_a
        \the\numexpr #1-\xint_c_i.#3.{\XINT_FL_fac_medloop_loop #1.#2.}%
}%
\def\XINT_FL_fac_medloop_loop #1.#2.%
{%
    \ifnum #1>#2 \expandafter\XINT_FL_fac_loop_exit\fi
    \expandafter\XINT_FL_fac_medloop_loop
    \the\numexpr #1+\xint_c_iii\expandafter.%
    \the\numexpr #2\expandafter.\the\numexpr\XINT_FL_fac_medloop_mul #1!%
}%
\def\XINT_FL_fac_medloop_mul #1!%
{%
    \expandafter\XINT_FL_fac_mul
    \the\numexpr 
        \xint_c_x^viii+#1*(#1+\xint_c_i)*(#1+\xint_c_ii)!%
}%
\def\XINT_FL_fac_smallloop_a #1.%
{%
    \csname 
       XINT_FL_fac_smallloop_\the\numexpr #1-\xint_c_iv*(#1/\xint_c_iv)\relax
    \endcsname #1.%
}%
\expandafter\def\csname XINT_FL_fac_smallloop_1\endcsname #1.#2.%
{%
    \XINT_FL_fac_addzeros #2.100000001!.{2.#1.}{#2}%
}%
\expandafter\def\csname XINT_FL_fac_smallloop_-2\endcsname #1.#2.%
{%
    \XINT_FL_fac_addzeros #2.100000002!.{3.#1.}{#2}%
}%
\expandafter\def\csname XINT_FL_fac_smallloop_-1\endcsname #1.#2.%
{%
    \XINT_FL_fac_addzeros #2.100000006!.{4.#1.}{#2}%
}%
\expandafter\def\csname XINT_FL_fac_smallloop_0\endcsname #1.#2.%
{%
    \XINT_FL_fac_addzeros #2.100000024!.{5.#1.}{#2}%
}%
\def\XINT_FL_fac_addzeros #1.%
{%
    \ifnum #1=\xint_c_viii \expandafter\XINT_FL_fac_addzeros_exit\fi
    \expandafter\XINT_FL_fac_addzeros\the\numexpr #1-\xint_c_viii.100000000!%
}%
\def\XINT_FL_fac_addzeros_exit #1.#2.#3#4%
   {\XINT_FL_fac_smallloop_loop #3#21\Z![-#4]}%
\def\XINT_FL_fac_smallloop_loop #1.#2.%
{%
    \ifnum #1>#2 \expandafter\XINT_FL_fac_loop_exit\fi
    \expandafter\XINT_FL_fac_smallloop_loop
    \the\numexpr #1+\xint_c_iv\expandafter.%
    \the\numexpr #2\expandafter.\romannumeral0\XINT_FL_fac_smallloop_mul #1!%
}%
\def\XINT_FL_fac_smallloop_mul #1!%
{%
    \expandafter\XINT_FL_fac_mul
    \the\numexpr 
        \xint_c_x^viii+#1*(#1+\xint_c_i)*(#1+\xint_c_ii)*(#1+\xint_c_iii)!%
}%[[
\def\XINT_FL_fac_loop_exit #1!#2]#3{#3#2]}%
\def\XINT_FL_fac_mul 1#1!%
   {\expandafter\XINT_FL_fac_mul_a\the\numexpr\XINT_FL_fac_smallmul 10!{#1}}%
\def\XINT_FL_fac_mul_a #1-#2%
{%
    \if#21\xint_afterfi{\expandafter\space\xint_gob_til_exclam}\else
    \expandafter\space\fi #11\Z!%
}%
\def\XINT_FL_fac_minimulwc_a #1#2#3#4#5!#6#7#8#9%
{%
    \XINT_FL_fac_minimulwc_b {#1#2#3#4}{#5}{#6#7#8#9}%
}%
\def\XINT_FL_fac_minimulwc_b #1#2#3#4!#5%
{%
    \expandafter\XINT_FL_fac_minimulwc_c
    \the\numexpr \xint_c_x^ix+#5+#2*#4.{{#1}{#2}{#3}{#4}}%
}%
\def\XINT_FL_fac_minimulwc_c 1#1#2#3#4#5#6.#7%
{%
    \expandafter\XINT_FL_fac_minimulwc_d {#1#2#3#4#5}#7{#6}%
}%
\def\XINT_FL_fac_minimulwc_d #1#2#3#4#5%
{%
    \expandafter\XINT_FL_fac_minimulwc_e
    \the\numexpr \xint_c_x^ix+#1+#2*#5+#3*#4.{#2}{#4}%
}%
\def\XINT_FL_fac_minimulwc_e 1#1#2#3#4#5#6.#7#8#9%
{%
    1#6#9\expandafter!%
    \the\numexpr\expandafter\XINT_FL_fac_smallmul
    \the\numexpr \xint_c_x^viii+#1#2#3#4#5+#7*#8!%
}%
\def\XINT_FL_fac_smallmul 1#1!#21#3!%
{%
    \xint_gob_til_Z #3\XINT_FL_fac_smallmul_end\Z
    \XINT_FL_fac_minimulwc_a #2!#3!{#1}{#2}%
}%
\def\XINT_FL_fac_smallmul_end\Z\XINT_FL_fac_minimulwc_a #1!\Z!#2#3[#4]%
{%
   \ifnum #2=\xint_c_ 
       \expandafter\xint_firstoftwo\else
       \expandafter\xint_secondoftwo
   \fi
   {-2\relax[#4]}%
   {1#2\expandafter!\expandafter-\expandafter1\expandafter
                  [\the\numexpr #4+\xint_c_viii]}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFloatSqrt}, \csh{XINTinFloatSqrt}}
% \lverb|1.08. Note 2015/11/16: I absolutely must document what's happening
% here, I have a file with comments from June 2013 which however is not
% completely explicit (as I did the rounding integer square root \xintiiSqrtR
% more than one year later, I am not
% 100$char37 $space sure the one here does correct rounding, and I don't
% have time to check now.)|
%    \begin{macrocode}
\def\xintFloatSqrt     {\romannumeral0\xintfloatsqrt }%
\def\xintfloatsqrt   #1{\XINT_flsqrt_chkopt \xintfloat #1\xint_relax }%
\def\XINTinFloatSqrt   {\romannumeral0\XINTinfloatsqrt }%
\def\XINTinfloatsqrt #1{\XINT_flsqrt_chkopt \XINTinfloat #1\xint_relax }%
\def\XINT_flsqrt_chkopt #1#2%
{%
    \ifx [#2\expandafter\XINT_flsqrt_opt
       \else\expandafter\XINT_flsqrt_noopt
    \fi  #1#2%
}%
\def\XINT_flsqrt_noopt #1#2\xint_relax
{%
    #1[\XINTdigits]{\XINT_FL_sqrt \XINTdigits {#2}}%
}%
\def\XINT_flsqrt_opt #1[\xint_relax #2]#3%
{%
    #1[#2]{\XINT_FL_sqrt {#2}{#3}}%
}%
\def\XINT_FL_sqrt #1%
{%
    \ifnum\numexpr #1<\xint_c_xviii
        \xint_afterfi {\XINT_FL_sqrt_a\xint_c_xviii}%
    \else
        \xint_afterfi {\XINT_FL_sqrt_a {#1+\xint_c_i}}%
    \fi
}%
\def\XINT_FL_sqrt_a #1#2%
{%
    \expandafter\XINT_FL_sqrt_checkifzeroorneg
    \romannumeral0\XINTinfloat [#1]{#2}%
}%
\def\XINT_FL_sqrt_checkifzeroorneg #1%
{%
    \xint_UDzerominusfork
     #1-\XINT_FL_sqrt_iszero
     0#1\XINT_FL_sqrt_isneg
      0-{\XINT_FL_sqrt_b #1}%
    \krof
}%
\def\XINT_FL_sqrt_iszero #1[#2]{0[0]}%
\def\XINT_FL_sqrt_isneg  #1[#2]{\xintError:RootOfNegative 0[0]}%
\def\XINT_FL_sqrt_b #1[#2]%
{%
    \ifodd #2
        \xint_afterfi{\XINT_FL_sqrt_c 01}%
    \else
        \xint_afterfi{\XINT_FL_sqrt_c {}0}%
    \fi
    {#1}{#2}%
}%
\def\XINT_FL_sqrt_c #1#2#3#4%
{%
    \expandafter\XINT_flsqrt\expandafter {\the\numexpr #4-#2}{#3#1}%
}%
\def\XINT_flsqrt #1#2%
{%
    \expandafter\XINT_sqrt_a
    \expandafter{\romannumeral0\xintlength {#2}}\XINT_flsqrt_big_d {#2}{#1}%
}%
\def\XINT_flsqrt_big_d #1#2%
{%
   \ifodd #2
     \expandafter\expandafter\expandafter\XINT_flsqrt_big_eB
   \else
     \expandafter\expandafter\expandafter\XINT_flsqrt_big_eA
   \fi
   \expandafter {\the\numexpr (#2-\xint_c_i)/\xint_c_ii }{#1}%
}%
\def\XINT_flsqrt_big_eA  #1#2#3%
{%
    \XINT_flsqrt_big_eA_a #3\Z {#2}{#1}{#3}%
}%
\def\XINT_flsqrt_big_eA_a #1#2#3#4#5#6#7#8#9\Z
{%
    \XINT_flsqrt_big_eA_b {#1#2#3#4#5#6#7#8}%
}%
\def\XINT_flsqrt_big_eA_b #1#2%
{%
    \expandafter\XINT_flsqrt_big_f
    \romannumeral0\XINT_flsqrt_small_e {#2001}{#1}%
}%
\def\XINT_flsqrt_big_eB #1#2#3%
{%
    \XINT_flsqrt_big_eB_a #3\Z {#2}{#1}{#3}%
}%
\def\XINT_flsqrt_big_eB_a #1#2#3#4#5#6#7#8#9%
{%
    \XINT_flsqrt_big_eB_b {#1#2#3#4#5#6#7#8#9}%
}%
\def\XINT_flsqrt_big_eB_b #1#2\Z #3%
{%
    \expandafter\XINT_flsqrt_big_f
    \romannumeral0\XINT_flsqrt_small_e {#30001}{#1}%
}%
\def\XINT_flsqrt_small_e #1#2%
{%
   \expandafter\XINT_flsqrt_small_f\expandafter
   {\the\numexpr #1*#1-#2-\xint_c_i}{#1}%
}%
\def\XINT_flsqrt_small_f #1#2%
{%
   \expandafter\XINT_flsqrt_small_g\expandafter
   {\the\numexpr (#1+#2)/(2*#2)-\xint_c_i }{#1}{#2}%
}%
\def\XINT_flsqrt_small_g #1%
{%
    \ifnum #1>\xint_c_
       \expandafter\XINT_flsqrt_small_h
    \else
       \expandafter\XINT_flsqrt_small_end
    \fi
    {#1}%
}%
\def\XINT_flsqrt_small_h #1#2#3%
{%
    \expandafter\XINT_flsqrt_small_f\expandafter
    {\the\numexpr #2-\xint_c_ii*#1*#3+#1*#1\expandafter}\expandafter
    {\the\numexpr #3-#1}%
}%
\def\XINT_flsqrt_small_end #1#2#3%
{%
    \expandafter\space\expandafter
    {\the\numexpr \xint_c_i+#3*\xint_c_x^iv-
                      (#2*\xint_c_x^iv+#3)/(\xint_c_ii*#3)}%
}%
\def\XINT_flsqrt_big_f #1%
{%
    \expandafter\XINT_flsqrt_big_fa\expandafter
    {\romannumeral0\xintiisqr {#1}}{#1}%
}%
\def\XINT_flsqrt_big_fa #1#2#3#4%
{%
    \expandafter\XINT_flsqrt_big_fb\expandafter
    {\romannumeral0\XINT_dsx_addzerosnofuss
                     {\numexpr #3-\xint_c_viii\relax}{#2}}%
    {\romannumeral0\xintiisub
      {\XINT_dsx_addzerosnofuss
           {\numexpr \xint_c_ii*(#3-\xint_c_viii)\relax}{#1}}{#4}}%
    {#3}%
}%
\def\XINT_flsqrt_big_fb #1#2%
{%
    \expandafter\XINT_flsqrt_big_g\expandafter {#2}{#1}%
}%
\def\XINT_flsqrt_big_g #1#2%
{%
    \expandafter\XINT_flsqrt_big_j
    \romannumeral0\xintiidivision
    {#1}{\romannumeral0\XINT_dbl_pos #2\Z}{#2}%
}%
\def\XINT_flsqrt_big_j #1%
{%
    \if0\XINT_Sgn #1\Z
        \expandafter \XINT_flsqrt_big_end_a
    \else \expandafter \XINT_flsqrt_big_k
    \fi {#1}%
}%
\def\XINT_flsqrt_big_k #1#2#3%
{%
    \expandafter\XINT_flsqrt_big_l\expandafter
    {\romannumeral0\xintiisub {#3}{#1}}%
    {\romannumeral0\xintiiadd {#2}{\romannumeral0\XINT_sqr #1\Z}}%
}%
\def\XINT_flsqrt_big_l #1#2%
{%
   \expandafter\XINT_flsqrt_big_g\expandafter
   {#2}{#1}%
}%
\def\XINT_flsqrt_big_end_a #1#2#3#4#5%
{%
   \expandafter\XINT_flsqrt_big_end_b\expandafter
   {\the\numexpr -#4+#5/\xint_c_ii\expandafter}\expandafter
   {\romannumeral0\xintiisub
    {\XINT_dsx_addzerosnofuss {#4}{#3}}%
    {\xintHalf{\xintiiQuo{\XINT_dsx_addzerosnofuss {#4}{#2}}{#3}}}}%
}%
\def\XINT_flsqrt_big_end_b #1#2{#2[#1]}%
\XINT_restorecatcodes_endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xintfrac>\relax
%\def<*xintseries>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xintfrac>
%<*xintseries>
%
% \StoreCodelineNo {xintfrac}
%
% \section{Package \xintseriesnameimp implementation}
% \label{sec:seriesimp}
%
% \localtableofcontents
%
% The commenting is currently (\xintdocdate) very sparse.
%
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
%
% The code for reload detection was initially copied from \textsc{Heiko
% Oberdiek}'s packages, then modified.
%
% The method for catcodes was also initially directly inspired by these
% packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xintseries.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xintfrac.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintseries}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintseries.sty
      \ifx\w\relax % but xintfrac.sty not yet loaded.
         \def\z{\endgroup\input xintfrac.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xintfrac.sty not yet loaded.
            \def\z{\endgroup\RequirePackage{xintfrac}}%
          \fi
      \else
        \aftergroup\endinput % xintseries already loaded.
      \fi
    \fi
  \fi
\z%
\XINTsetupcatcodes% defined in xintkernel.sty
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\XINT_providespackage
\ProvidesPackage{xintseries}%
  [2015/11/18 v1.2d Expandable partial sums with xint package (jfB)]%
%    \end{macrocode}
% \subsection{\csh{xintSeries}}
% \lverb|&
% Modified in 1.06 to give the indices first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.
% 1.08a adds the forgotten optimization following that previous change.|
%    \begin{macrocode}
\def\xintSeries {\romannumeral0\xintseries }%
\def\xintseries #1#2%
{%
    \expandafter\XINT_series\expandafter
    {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #2}%
}%
\def\XINT_series #1#2#3%
{%
   \ifnum #2<#1
      \xint_afterfi { 0/1[0]}%
   \else
      \xint_afterfi {\XINT_series_loop {#1}{0}{#2}{#3}}%
   \fi
}%
\def\XINT_series_loop #1#2#3#4%
{%
    \ifnum #3>#1 \else \XINT_series_exit \fi
    \expandafter\XINT_series_loop\expandafter
    {\the\numexpr #1+1\expandafter }\expandafter
    {\romannumeral0\xintadd {#2}{#4{#1}}}%
    {#3}{#4}%
}%
\def\XINT_series_exit \fi #1#2#3#4#5#6#7#8%
{%
    \fi\xint_gobble_ii #6%
}%
%    \end{macrocode}
% \subsection{\csh{xintiSeries}}
% \lverb|&
% Modified in 1.06 to give the indices first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.
% 1.08a adds the forgotten optimization following that previous change.|
%    \begin{macrocode}
\def\xintiSeries {\romannumeral0\xintiseries }%
\def\xintiseries #1#2%
{%
    \expandafter\XINT_iseries\expandafter
    {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #2}%
}%
\def\XINT_iseries #1#2#3%
{%
   \ifnum #2<#1
      \xint_afterfi { 0}%
   \else
      \xint_afterfi {\XINT_iseries_loop {#1}{0}{#2}{#3}}%
   \fi
}%
\def\XINT_iseries_loop #1#2#3#4%
{%
    \ifnum #3>#1 \else \XINT_iseries_exit \fi
    \expandafter\XINT_iseries_loop\expandafter
    {\the\numexpr #1+1\expandafter }\expandafter
    {\romannumeral0\xintiiadd {#2}{#4{#1}}}%
    {#3}{#4}%
}%
\def\XINT_iseries_exit \fi #1#2#3#4#5#6#7#8%
{%
    \fi\xint_gobble_ii #6%
}%
%    \end{macrocode}
% \subsection{\csh{xintPowerSeries}}
% \lverb|&
% The 1.03 version was very lame and created a build-up of denominators.
% (this was at a time \xintAdd always multiplied denominators, by the way)
% The Horner scheme for polynomial evaluation is used in 1.04, this
% cures the denominator problem and drastically improves the efficiency
% of the macro.
% Modified in 1.06 to give the indices first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.
% 1.08a adds the forgotten optimization following that previous change.|
%    \begin{macrocode}
\def\xintPowerSeries {\romannumeral0\xintpowerseries }%
\def\xintpowerseries #1#2%
{%
    \expandafter\XINT_powseries\expandafter
    {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #2}%
}%
\def\XINT_powseries #1#2#3#4%
{%
   \ifnum #2<#1
      \xint_afterfi { 0/1[0]}%
   \else
      \xint_afterfi
      {\XINT_powseries_loop_i {#3{#2}}{#1}{#2}{#3}{#4}}%
   \fi
}%
\def\XINT_powseries_loop_i #1#2#3#4#5%
{%
    \ifnum #3>#2 \else\XINT_powseries_exit_i\fi
    \expandafter\XINT_powseries_loop_ii\expandafter
    {\the\numexpr #3-1\expandafter}\expandafter
    {\romannumeral0\xintmul {#1}{#5}}{#2}{#4}{#5}%
}%
\def\XINT_powseries_loop_ii #1#2#3#4%
{%
   \expandafter\XINT_powseries_loop_i\expandafter
   {\romannumeral0\xintadd {#4{#1}}{#2}}{#3}{#1}{#4}%
}%
\def\XINT_powseries_exit_i\fi #1#2#3#4#5#6#7#8#9%
{%
    \fi \XINT_powseries_exit_ii  #6{#7}%
}%
\def\XINT_powseries_exit_ii #1#2#3#4#5#6%
{%
    \xintmul{\xintPow {#5}{#6}}{#4}%
}%
%    \end{macrocode}
% \subsection{\csh{xintPowerSeriesX}}
% \lverb|&
% Same as \xintPowerSeries except for the initial expansion of the x parameter.
% Modified in 1.06 to give the indices first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.
% 1.08a adds the forgotten optimization following that previous change.|
%    \begin{macrocode}
\def\xintPowerSeriesX {\romannumeral0\xintpowerseriesx }%
\def\xintpowerseriesx #1#2%
{%
    \expandafter\XINT_powseriesx\expandafter
    {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #2}%
}%
\def\XINT_powseriesx #1#2#3#4%
{%
   \ifnum #2<#1
      \xint_afterfi { 0/1[0]}%
   \else
      \xint_afterfi
      {\expandafter\XINT_powseriesx_pre\expandafter
                  {\romannumeral`&&@#4}{#1}{#2}{#3}%
      }%
   \fi
}%
\def\XINT_powseriesx_pre #1#2#3#4%
{%
    \XINT_powseries_loop_i {#4{#3}}{#2}{#3}{#4}{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintRationalSeries}}
% \lverb|&
% This computes F(a)+...+F(b) on the basis of the value of F(a) and the
% ratios F(n)/F(n-1). As in \xintPowerSeries we use an iterative scheme which
% has the great advantage to avoid denominator build-up. This makes exact
% computations possible with exponential type series, which would be completely
% inaccessible to \xintSeries.
% #1=a, #2=b, #3=F(a), #4=ratio function
% Modified in 1.06 to give the indices first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.
% 1.08a adds the forgotten optimization following that previous change.|
%    \begin{macrocode}
\def\xintRationalSeries {\romannumeral0\xintratseries }%
\def\xintratseries #1#2%
{%
    \expandafter\XINT_ratseries\expandafter
    {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #2}%
}%
\def\XINT_ratseries #1#2#3#4%
{%
   \ifnum #2<#1
      \xint_afterfi { 0/1[0]}%
   \else
      \xint_afterfi
      {\XINT_ratseries_loop {#2}{1}{#1}{#4}{#3}}%
   \fi
}%
\def\XINT_ratseries_loop #1#2#3#4%
{%
    \ifnum #1>#3 \else\XINT_ratseries_exit_i\fi
    \expandafter\XINT_ratseries_loop\expandafter
    {\the\numexpr #1-1\expandafter}\expandafter
    {\romannumeral0\xintadd {1}{\xintMul {#2}{#4{#1}}}}{#3}{#4}%
}%
\def\XINT_ratseries_exit_i\fi #1#2#3#4#5#6#7#8%
{%
    \fi \XINT_ratseries_exit_ii  #6%
}%
\def\XINT_ratseries_exit_ii #1#2#3#4#5%
{%
    \XINT_ratseries_exit_iii #5%
}%
\def\XINT_ratseries_exit_iii #1#2#3#4%
{%
    \xintmul{#2}{#4}%
}%
%    \end{macrocode}
% \subsection{\csh{xintRationalSeriesX}}
% \lverb|&
% a,b,initial,ratiofunction,x$\ 
% This computes F(a,x)+...+F(b,x) on the basis of the value of F(a,x) and the
% ratios F(n,x)/F(n-1,x). The argument x is first expanded and it is the value
% resulting from this which is used then throughout. The initial term F(a,x)
% must be defined as one-parameter macro which will be given x.
% Modified in 1.06 to give the indices first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.
% 1.08a adds the forgotten optimization following that previous change.|
%    \begin{macrocode}
\def\xintRationalSeriesX {\romannumeral0\xintratseriesx }%
\def\xintratseriesx #1#2%
{%
    \expandafter\XINT_ratseriesx\expandafter
    {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #2}%
}%
\def\XINT_ratseriesx #1#2#3#4#5%
{%
   \ifnum #2<#1
      \xint_afterfi { 0/1[0]}%
   \else
      \xint_afterfi
      {\expandafter\XINT_ratseriesx_pre\expandafter
                   {\romannumeral`&&@#5}{#2}{#1}{#4}{#3}%
      }%
   \fi
}%
\def\XINT_ratseriesx_pre #1#2#3#4#5%
{%
    \XINT_ratseries_loop {#2}{1}{#3}{#4{#1}}{#5{#1}}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFxPtPowerSeries}}
% \lverb|&
% I am not two happy with this piece of code. Will make it more economical
% another day.
% Modified in 1.06 to give the indices first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.
% 1.08a: forgot last time some optimization from the change to \numexpr.|
%    \begin{macrocode}
\def\xintFxPtPowerSeries {\romannumeral0\xintfxptpowerseries }%
\def\xintfxptpowerseries #1#2%
{%
    \expandafter\XINT_fppowseries\expandafter
    {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #2}%
}%
\def\XINT_fppowseries #1#2#3#4#5%
{%
   \ifnum #2<#1
      \xint_afterfi { 0}%
   \else
      \xint_afterfi
        {\expandafter\XINT_fppowseries_loop_pre\expandafter
           {\romannumeral0\xinttrunc {#5}{\xintPow {#4}{#1}}}%
          {#1}{#4}{#2}{#3}{#5}%
        }%
   \fi
}%
\def\XINT_fppowseries_loop_pre #1#2#3#4#5#6%
{%
    \ifnum #4>#2 \else\XINT_fppowseries_dont_i \fi
    \expandafter\XINT_fppowseries_loop_i\expandafter
    {\the\numexpr #2+\xint_c_i\expandafter}\expandafter
    {\romannumeral0\xintitrunc {#6}{\xintMul {#5{#2}}{#1}}}%
    {#1}{#3}{#4}{#5}{#6}%
}%
\def\XINT_fppowseries_dont_i \fi\expandafter\XINT_fppowseries_loop_i
    {\fi \expandafter\XINT_fppowseries_dont_ii }%
\def\XINT_fppowseries_dont_ii #1#2#3#4#5#6#7{\xinttrunc {#7}{#2[-#7]}}%
\def\XINT_fppowseries_loop_i #1#2#3#4#5#6#7%
{%
    \ifnum #5>#1 \else \XINT_fppowseries_exit_i \fi
    \expandafter\XINT_fppowseries_loop_ii\expandafter
    {\romannumeral0\xinttrunc {#7}{\xintMul {#3}{#4}}}%
    {#1}{#4}{#2}{#5}{#6}{#7}%
}%
\def\XINT_fppowseries_loop_ii #1#2#3#4#5#6#7%
{%
    \expandafter\XINT_fppowseries_loop_i\expandafter
    {\the\numexpr #2+\xint_c_i\expandafter}\expandafter
    {\romannumeral0\xintiiadd {#4}{\xintiTrunc {#7}{\xintMul {#6{#2}}{#1}}}}%
    {#1}{#3}{#5}{#6}{#7}%
}%
\def\XINT_fppowseries_exit_i\fi\expandafter\XINT_fppowseries_loop_ii
    {\fi \expandafter\XINT_fppowseries_exit_ii }%
\def\XINT_fppowseries_exit_ii #1#2#3#4#5#6#7%
{%
    \xinttrunc {#7}
    {\xintiiadd {#4}{\xintiTrunc {#7}{\xintMul {#6{#2}}{#1}}}[-#7]}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFxPtPowerSeriesX}}
% \lverb|&
% a,b,coeff,x,D$\ 
% Modified in 1.06 to give the indices first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.
% 1.08a adds the forgotten optimization following that previous change.|
%    \begin{macrocode}
\def\xintFxPtPowerSeriesX {\romannumeral0\xintfxptpowerseriesx }%
\def\xintfxptpowerseriesx #1#2%
{%
    \expandafter\XINT_fppowseriesx\expandafter
    {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #2}%
}%
\def\XINT_fppowseriesx #1#2#3#4#5%
{%
   \ifnum #2<#1
      \xint_afterfi { 0}%
   \else
      \xint_afterfi
        {\expandafter \XINT_fppowseriesx_pre \expandafter
         {\romannumeral`&&@#4}{#1}{#2}{#3}{#5}%
        }%
   \fi
}%
\def\XINT_fppowseriesx_pre #1#2#3#4#5%
{%
    \expandafter\XINT_fppowseries_loop_pre\expandafter
       {\romannumeral0\xinttrunc {#5}{\xintPow {#1}{#2}}}%
       {#2}{#1}{#3}{#4}{#5}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFloatPowerSeries}}
% \lverb|1.08a. I still have to re-visit \xintFxPtPowerSeries; temporarily I
% just adapted the code to the case of floats.|
%    \begin{macrocode}
\def\xintFloatPowerSeries {\romannumeral0\xintfloatpowerseries }%
\def\xintfloatpowerseries #1{\XINT_flpowseries_chkopt #1\xint_relax }%
\def\XINT_flpowseries_chkopt #1%
{%
    \ifx [#1\expandafter\XINT_flpowseries_opt
       \else\expandafter\XINT_flpowseries_noopt
    \fi
    #1%
}%
\def\XINT_flpowseries_noopt  #1\xint_relax #2%
{%
    \expandafter\XINT_flpowseries\expandafter
    {\the\numexpr #1\expandafter}\expandafter
    {\the\numexpr #2}\XINTdigits
}%
\def\XINT_flpowseries_opt [\xint_relax #1]#2#3%
{%
    \expandafter\XINT_flpowseries\expandafter
    {\the\numexpr #2\expandafter}\expandafter
    {\the\numexpr #3\expandafter}{\the\numexpr #1}%
}%
\def\XINT_flpowseries #1#2#3#4#5%
{%
   \ifnum #2<#1
      \xint_afterfi { 0.e0}%
   \else
      \xint_afterfi
        {\expandafter\XINT_flpowseries_loop_pre\expandafter
           {\romannumeral0\XINTinfloatpow [#3]{#5}{#1}}%
          {#1}{#5}{#2}{#4}{#3}%
        }%
   \fi
}%
\def\XINT_flpowseries_loop_pre #1#2#3#4#5#6%
{%
    \ifnum #4>#2 \else\XINT_flpowseries_dont_i \fi
    \expandafter\XINT_flpowseries_loop_i\expandafter
    {\the\numexpr #2+\xint_c_i\expandafter}\expandafter
    {\romannumeral0\XINTinfloatmul [#6]{#5{#2}}{#1}}%
    {#1}{#3}{#4}{#5}{#6}%
}%
\def\XINT_flpowseries_dont_i \fi\expandafter\XINT_flpowseries_loop_i
    {\fi \expandafter\XINT_flpowseries_dont_ii }%
\def\XINT_flpowseries_dont_ii #1#2#3#4#5#6#7{\xintfloat [#7]{#2}}%
\def\XINT_flpowseries_loop_i #1#2#3#4#5#6#7%
{%
    \ifnum #5>#1 \else \XINT_flpowseries_exit_i \fi
    \expandafter\XINT_flpowseries_loop_ii\expandafter
    {\romannumeral0\XINTinfloatmul [#7]{#3}{#4}}%
    {#1}{#4}{#2}{#5}{#6}{#7}%
}%
\def\XINT_flpowseries_loop_ii #1#2#3#4#5#6#7%
{%
    \expandafter\XINT_flpowseries_loop_i\expandafter
    {\the\numexpr #2+\xint_c_i\expandafter}\expandafter
    {\romannumeral0\XINTinfloatadd [#7]{#4}%
                        {\XINTinfloatmul [#7]{#6{#2}}{#1}}}%
    {#1}{#3}{#5}{#6}{#7}%
}%
\def\XINT_flpowseries_exit_i\fi\expandafter\XINT_flpowseries_loop_ii
    {\fi \expandafter\XINT_flpowseries_exit_ii }%
\def\XINT_flpowseries_exit_ii #1#2#3#4#5#6#7%
{%
    \xintfloatadd [#7]{#4}{\XINTinfloatmul [#7]{#6{#2}}{#1}}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFloatPowerSeriesX}}
% \lverb|1.08a|
%    \begin{macrocode}
\def\xintFloatPowerSeriesX {\romannumeral0\xintfloatpowerseriesx }%
\def\xintfloatpowerseriesx #1{\XINT_flpowseriesx_chkopt #1\xint_relax }%
\def\XINT_flpowseriesx_chkopt #1%
{%
    \ifx [#1\expandafter\XINT_flpowseriesx_opt
       \else\expandafter\XINT_flpowseriesx_noopt
    \fi
    #1%
}%
\def\XINT_flpowseriesx_noopt  #1\xint_relax #2%
{%
    \expandafter\XINT_flpowseriesx\expandafter
    {\the\numexpr #1\expandafter}\expandafter
    {\the\numexpr #2}\XINTdigits
}%
\def\XINT_flpowseriesx_opt [\xint_relax #1]#2#3%
{%
    \expandafter\XINT_flpowseriesx\expandafter
    {\the\numexpr #2\expandafter}\expandafter
    {\the\numexpr #3\expandafter}{\the\numexpr #1}%
}%
\def\XINT_flpowseriesx #1#2#3#4#5%
{%
   \ifnum #2<#1
      \xint_afterfi { 0.e0}%
   \else
      \xint_afterfi
        {\expandafter \XINT_flpowseriesx_pre \expandafter
         {\romannumeral`&&@#5}{#1}{#2}{#4}{#3}%
        }%
   \fi
}%
\def\XINT_flpowseriesx_pre #1#2#3#4#5%
{%
    \expandafter\XINT_flpowseries_loop_pre\expandafter
       {\romannumeral0\XINTinfloatpow [#5]{#1}{#2}}%
       {#2}{#1}{#3}{#4}{#5}%
}%
\XINT_restorecatcodes_endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xintseries>\relax
%\def<*xintcfrac>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xintseries>
%<*xintcfrac>
%
% \StoreCodelineNo {xintseries}
%
% \section{Package \xintcfracnameimp implementation}
% \label{sec:cfracimp}
%
% \localtableofcontents
%
% The commenting is currently (\xintdocdate) very sparse. Release |1.09m|
% (|2014/02/26|) has modified a few things: |\xintFtoCs| and
% |\xintCntoCs| insert spaces after the commas, |\xintCstoF| and
% |\xintCstoCv| authorize spaces in the input also before the commas,
% |\xintCntoCs| does not brace the produced coefficients, new macros
% |\xintFtoC|, |\xintCtoF|, |\xintCtoCv|, |\xintFGtoC|, and
% |\xintGGCFrac|.
%
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
%
% The code for reload detection was initially copied from \textsc{Heiko
% Oberdiek}'s packages, then modified.
%
% The method for catcodes was also initially directly inspired by these
% packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xintcfrac.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xintfrac.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintcfrac}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintcfrac.sty
      \ifx\w\relax % but xintfrac.sty not yet loaded.
         \def\z{\endgroup\input xintfrac.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xintfrac.sty not yet loaded.
            \def\z{\endgroup\RequirePackage{xintfrac}}%
          \fi
      \else
        \aftergroup\endinput % xintcfrac already loaded.
      \fi
    \fi
  \fi
\z%
\XINTsetupcatcodes% defined in xintkernel.sty
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\XINT_providespackage
\ProvidesPackage{xintcfrac}%
  [2015/11/18 v1.2d Expandable continued fractions with xint package (jfB)]%
%    \end{macrocode}
% \subsection{\csh{xintCFrac}}
%    \begin{macrocode}
\def\xintCFrac {\romannumeral0\xintcfrac }%
\def\xintcfrac #1%
{%
    \XINT_cfrac_opt_a #1\xint_relax
}%
\def\XINT_cfrac_opt_a #1%
{%
    \ifx[#1\XINT_cfrac_opt_b\fi \XINT_cfrac_noopt #1%
}%
\def\XINT_cfrac_noopt #1\xint_relax
{%
    \expandafter\XINT_cfrac_A\romannumeral0\xintrawwithzeros {#1}\Z
    \relax\relax
}%
\def\XINT_cfrac_opt_b\fi\XINT_cfrac_noopt [\xint_relax #1]%
{%
    \fi\csname XINT_cfrac_opt#1\endcsname
}%
\def\XINT_cfrac_optl #1%
{%
    \expandafter\XINT_cfrac_A\romannumeral0\xintrawwithzeros {#1}\Z
    \relax\hfill
}%
\def\XINT_cfrac_optc #1%
{%
    \expandafter\XINT_cfrac_A\romannumeral0\xintrawwithzeros {#1}\Z
    \relax\relax
}%
\def\XINT_cfrac_optr #1%
{%
    \expandafter\XINT_cfrac_A\romannumeral0\xintrawwithzeros {#1}\Z
    \hfill\relax
}%
\def\XINT_cfrac_A #1/#2\Z
{%
    \expandafter\XINT_cfrac_B\romannumeral0\xintiidivision {#1}{#2}{#2}%
}%
\def\XINT_cfrac_B #1#2%
{%
    \XINT_cfrac_C #2\Z {#1}%
}%
\def\XINT_cfrac_C #1%
{%
    \xint_gob_til_zero #1\XINT_cfrac_integer 0\XINT_cfrac_D #1%
}%
\def\XINT_cfrac_integer 0\XINT_cfrac_D 0#1\Z #2#3#4#5{ #2}%
\def\XINT_cfrac_D #1\Z #2#3{\XINT_cfrac_loop_a {#1}{#3}{#1}{{#2}}}%
\def\XINT_cfrac_loop_a
{%
    \expandafter\XINT_cfrac_loop_d\romannumeral0\XINT_div_prepare
}%
\def\XINT_cfrac_loop_d #1#2%
{%
    \XINT_cfrac_loop_e #2.{#1}%
}%
\def\XINT_cfrac_loop_e #1%
{%
    \xint_gob_til_zero #1\xint_cfrac_loop_exit0\XINT_cfrac_loop_f #1%
}%
\def\XINT_cfrac_loop_f #1.#2#3#4%
{%
    \XINT_cfrac_loop_a {#1}{#3}{#1}{{#2}#4}%
}%
\def\xint_cfrac_loop_exit0\XINT_cfrac_loop_f #1.#2#3#4#5#6%
   {\XINT_cfrac_T #5#6{#2}#4\Z }%
\def\XINT_cfrac_T #1#2#3#4%
{%
  \xint_gob_til_Z #4\XINT_cfrac_end\Z\XINT_cfrac_T #1#2{#4+\cfrac{#11#2}{#3}}%
}%
\def\XINT_cfrac_end\Z\XINT_cfrac_T #1#2#3%
{%
    \XINT_cfrac_end_b #3%
}%
\def\XINT_cfrac_end_b \Z+\cfrac#1#2{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintGCFrac}}
%    \begin{macrocode}
\def\xintGCFrac {\romannumeral0\xintgcfrac }%
\def\xintgcfrac #1{\XINT_gcfrac_opt_a #1\xint_relax }%
\def\XINT_gcfrac_opt_a #1%
{%
    \ifx[#1\XINT_gcfrac_opt_b\fi \XINT_gcfrac_noopt #1%
}%
\def\XINT_gcfrac_noopt #1\xint_relax
{%
    \XINT_gcfrac #1+\xint_relax/\relax\relax
}%
\def\XINT_gcfrac_opt_b\fi\XINT_gcfrac_noopt [\xint_relax #1]%
{%
    \fi\csname XINT_gcfrac_opt#1\endcsname
}%
\def\XINT_gcfrac_optl #1%
{%
    \XINT_gcfrac #1+\xint_relax/\relax\hfill
}%
\def\XINT_gcfrac_optc #1%
{%
    \XINT_gcfrac #1+\xint_relax/\relax\relax
}%
\def\XINT_gcfrac_optr #1%
{%
    \XINT_gcfrac #1+\xint_relax/\hfill\relax
}%
\def\XINT_gcfrac
{%
    \expandafter\XINT_gcfrac_enter\romannumeral`&&@%
}%
\def\XINT_gcfrac_enter {\XINT_gcfrac_loop {}}%
\def\XINT_gcfrac_loop #1#2+#3/%
{%
    \xint_gob_til_xint_relax #3\XINT_gcfrac_endloop\xint_relax
    \XINT_gcfrac_loop {{#3}{#2}#1}%
}%
\def\XINT_gcfrac_endloop\xint_relax\XINT_gcfrac_loop #1#2#3%
{%
    \XINT_gcfrac_T #2#3#1\xint_relax\xint_relax
}%
\def\XINT_gcfrac_T #1#2#3#4{\XINT_gcfrac_U #1#2{\xintFrac{#4}}}%
\def\XINT_gcfrac_U #1#2#3#4#5%
{%
    \xint_gob_til_xint_relax #5\XINT_gcfrac_end\xint_relax\XINT_gcfrac_U
              #1#2{\xintFrac{#5}%
               \ifcase\xintSgn{#4}
               +\or+\else-\fi
               \cfrac{#1\xintFrac{\xintAbs{#4}}#2}{#3}}%
}%
\def\XINT_gcfrac_end\xint_relax\XINT_gcfrac_U #1#2#3%
{%
    \XINT_gcfrac_end_b #3%
}%
\def\XINT_gcfrac_end_b #1\cfrac#2#3{ #3}%
%    \end{macrocode}
% \subsection{\csh{xintGGCFrac}}
% \lverb|New with 1.09m|
%    \begin{macrocode}
\def\xintGGCFrac {\romannumeral0\xintggcfrac }%
\def\xintggcfrac #1{\XINT_ggcfrac_opt_a #1\xint_relax }%
\def\XINT_ggcfrac_opt_a #1%
{%
    \ifx[#1\XINT_ggcfrac_opt_b\fi \XINT_ggcfrac_noopt #1%
}%
\def\XINT_ggcfrac_noopt #1\xint_relax
{%
    \XINT_ggcfrac #1+\xint_relax/\relax\relax
}%
\def\XINT_ggcfrac_opt_b\fi\XINT_ggcfrac_noopt [\xint_relax #1]%
{%
    \fi\csname XINT_ggcfrac_opt#1\endcsname
}%
\def\XINT_ggcfrac_optl #1%
{%
    \XINT_ggcfrac #1+\xint_relax/\relax\hfill
}%
\def\XINT_ggcfrac_optc #1%
{%
    \XINT_ggcfrac #1+\xint_relax/\relax\relax
}%
\def\XINT_ggcfrac_optr #1%
{%
    \XINT_ggcfrac #1+\xint_relax/\hfill\relax
}%
\def\XINT_ggcfrac
{%
    \expandafter\XINT_ggcfrac_enter\romannumeral`&&@%
}%
\def\XINT_ggcfrac_enter {\XINT_ggcfrac_loop {}}%
\def\XINT_ggcfrac_loop #1#2+#3/%
{%
    \xint_gob_til_xint_relax #3\XINT_ggcfrac_endloop\xint_relax
    \XINT_ggcfrac_loop {{#3}{#2}#1}%
}%
\def\XINT_ggcfrac_endloop\xint_relax\XINT_ggcfrac_loop #1#2#3%
{%
    \XINT_ggcfrac_T #2#3#1\xint_relax\xint_relax
}%
\def\XINT_ggcfrac_T #1#2#3#4{\XINT_ggcfrac_U #1#2{#4}}%
\def\XINT_ggcfrac_U #1#2#3#4#5%
{%
    \xint_gob_til_xint_relax #5\XINT_ggcfrac_end\xint_relax\XINT_ggcfrac_U
              #1#2{#5+\cfrac{#1#4#2}{#3}}%
}%
\def\XINT_ggcfrac_end\xint_relax\XINT_ggcfrac_U #1#2#3%
{%
    \XINT_ggcfrac_end_b #3%
}%
\def\XINT_ggcfrac_end_b #1\cfrac#2#3{ #3}%
%    \end{macrocode}
% \subsection{\csh{xintGCtoGCx}}
%    \begin{macrocode}
\def\xintGCtoGCx {\romannumeral0\xintgctogcx }%
\def\xintgctogcx #1#2#3%
{%
    \expandafter\XINT_gctgcx_start\expandafter {\romannumeral`&&@#3}{#1}{#2}%
}%
\def\XINT_gctgcx_start #1#2#3{\XINT_gctgcx_loop_a {}{#2}{#3}#1+\xint_relax/}%
\def\XINT_gctgcx_loop_a #1#2#3#4+#5/%
{%
    \xint_gob_til_xint_relax #5\XINT_gctgcx_end\xint_relax
    \XINT_gctgcx_loop_b {#1{#4}}{#2{#5}#3}{#2}{#3}%
}%
\def\XINT_gctgcx_loop_b #1#2%
{%
    \XINT_gctgcx_loop_a {#1#2}%
}%
\def\XINT_gctgcx_end\xint_relax\XINT_gctgcx_loop_b #1#2#3#4{ #1}%
%    \end{macrocode}
% \subsection{\csh{xintFtoCs}}
% \lverb|Modified in 1.09m: a space is added after the inserted commas.|
%    \begin{macrocode}
\def\xintFtoCs {\romannumeral0\xintftocs }%
\def\xintftocs #1%
{%
    \expandafter\XINT_ftc_A\romannumeral0\xintrawwithzeros {#1}\Z
}%
\def\XINT_ftc_A #1/#2\Z
{%
    \expandafter\XINT_ftc_B\romannumeral0\xintiidivision {#1}{#2}{#2}%
}%
\def\XINT_ftc_B #1#2%
{%
    \XINT_ftc_C #2.{#1}%
}%
\def\XINT_ftc_C #1%
{%
    \xint_gob_til_zero #1\XINT_ftc_integer 0\XINT_ftc_D #1%
}%
\def\XINT_ftc_integer 0\XINT_ftc_D 0#1.#2#3{ #2}%
\def\XINT_ftc_D #1.#2#3{\XINT_ftc_loop_a {#1}{#3}{#1}{#2, }}% 1.09m adds a space
\def\XINT_ftc_loop_a
{%
    \expandafter\XINT_ftc_loop_d\romannumeral0\XINT_div_prepare
}%
\def\XINT_ftc_loop_d #1#2%
{%
    \XINT_ftc_loop_e #2.{#1}%
}%
\def\XINT_ftc_loop_e #1%
{%
    \xint_gob_til_zero #1\xint_ftc_loop_exit0\XINT_ftc_loop_f #1%
}%
\def\XINT_ftc_loop_f #1.#2#3#4%
{%
    \XINT_ftc_loop_a {#1}{#3}{#1}{#4#2, }% 1.09m has an added space here
}%
\def\xint_ftc_loop_exit0\XINT_ftc_loop_f #1.#2#3#4{ #4#2}%
%    \end{macrocode}
% \subsection{\csh{xintFtoCx}}
%    \begin{macrocode}
\def\xintFtoCx {\romannumeral0\xintftocx }%
\def\xintftocx #1#2%
{%
    \expandafter\XINT_ftcx_A\romannumeral0\xintrawwithzeros {#2}\Z {#1}%
}%
\def\XINT_ftcx_A #1/#2\Z
{%
    \expandafter\XINT_ftcx_B\romannumeral0\xintiidivision {#1}{#2}{#2}%
}%
\def\XINT_ftcx_B #1#2%
{%
    \XINT_ftcx_C #2.{#1}%
}%
\def\XINT_ftcx_C #1%
{%
    \xint_gob_til_zero #1\XINT_ftcx_integer 0\XINT_ftcx_D #1%
}%
\def\XINT_ftcx_integer 0\XINT_ftcx_D 0#1.#2#3#4{ #2}%
\def\XINT_ftcx_D #1.#2#3#4{\XINT_ftcx_loop_a {#1}{#3}{#1}{{#2}#4}{#4}}%
\def\XINT_ftcx_loop_a
{%
    \expandafter\XINT_ftcx_loop_d\romannumeral0\XINT_div_prepare
}%
\def\XINT_ftcx_loop_d #1#2%
{%
    \XINT_ftcx_loop_e #2.{#1}%
}%
\def\XINT_ftcx_loop_e #1%
{%
    \xint_gob_til_zero #1\xint_ftcx_loop_exit0\XINT_ftcx_loop_f #1%
}%
\def\XINT_ftcx_loop_f #1.#2#3#4#5%
{%
    \XINT_ftcx_loop_a {#1}{#3}{#1}{#4{#2}#5}{#5}%
}%
\def\xint_ftcx_loop_exit0\XINT_ftcx_loop_f #1.#2#3#4#5{ #4{#2}}%
%    \end{macrocode}
% \subsection{\csh{xintFtoC}}
% \lverb|New in 1.09m: this is the same as \xintFtoCx with empty separator. I
% had temporarily during preparation of 1.09m removed braces from \xintFtoCx,
% but I recalled later why that was useful (see doc), thus let's just here do
% \xintFtoCx {}|
%    \begin{macrocode}
\def\xintFtoC {\romannumeral0\xintftoc }%
\def\xintftoc {\xintftocx {}}%
%    \end{macrocode}
% \subsection{\csh{xintFtoGC}}
%    \begin{macrocode}
\def\xintFtoGC {\romannumeral0\xintftogc }%
\def\xintftogc {\xintftocx {+1/}}%
%    \end{macrocode}
% \subsection{\csh{xintFGtoC}}
% \lverb|New with 1.09m of 2014/02/26. Computes the common initial coefficients
% for the two fractions f and g, and outputs them as a sequence of braced
% items.|
%    \begin{macrocode}
\def\xintFGtoC {\romannumeral0\xintfgtoc}%
\def\xintfgtoc#1%
{%
    \expandafter\XINT_fgtc_a\romannumeral0\xintrawwithzeros {#1}\Z
}%
\def\XINT_fgtc_a #1/#2\Z #3%
{%
    \expandafter\XINT_fgtc_b\romannumeral0\xintrawwithzeros {#3}\Z #1/#2\Z { }%
}%
\def\XINT_fgtc_b #1/#2\Z
{%
    \expandafter\XINT_fgtc_c\romannumeral0\xintiidivision {#1}{#2}{#2}%
}%
\def\XINT_fgtc_c #1#2#3#4/#5\Z
{%
    \expandafter\XINT_fgtc_d\romannumeral0\xintiidivision
                                         {#4}{#5}{#5}{#1}{#2}{#3}%
}%
\def\XINT_fgtc_d #1#2#3#4%#5#6#7%
{%
    \xintifEq {#1}{#4}{\XINT_fgtc_da {#1}{#2}{#3}{#4}}%
                      {\xint_thirdofthree}%
}%
\def\XINT_fgtc_da #1#2#3#4#5#6#7%
{%
     \XINT_fgtc_e {#2}{#5}{#3}{#6}{#7{#1}}%
}%
\def\XINT_fgtc_e #1%
{%
    \xintifZero {#1}{\expandafter\xint_firstofone\xint_gobble_iii}%
                    {\XINT_fgtc_f {#1}}%
}%
\def\XINT_fgtc_f #1#2%
{%
   \xintifZero {#2}{\xint_thirdofthree}{\XINT_fgtc_g {#1}{#2}}%
}%
\def\XINT_fgtc_g #1#2#3%
{%
    \expandafter\XINT_fgtc_h\romannumeral0\XINT_div_prepare {#1}{#3}{#1}{#2}%
}%
\def\XINT_fgtc_h #1#2#3#4#5%
{%
    \expandafter\XINT_fgtc_d\romannumeral0\XINT_div_prepare
                       {#4}{#5}{#4}{#1}{#2}{#3}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFtoCC}}
%    \begin{macrocode}
\def\xintFtoCC {\romannumeral0\xintftocc }%
\def\xintftocc #1%
{%
    \expandafter\XINT_ftcc_A\expandafter {\romannumeral0\xintrawwithzeros {#1}}%
}%
\def\XINT_ftcc_A #1%
{%
    \expandafter\XINT_ftcc_B
    \romannumeral0\xintrawwithzeros {\xintAdd {1/2[0]}{#1[0]}}\Z {#1[0]}%
}%
\def\XINT_ftcc_B #1/#2\Z
{%
    \expandafter\XINT_ftcc_C\expandafter {\romannumeral0\xintiiquo {#1}{#2}}%
}%
\def\XINT_ftcc_C #1#2%
{%
    \expandafter\XINT_ftcc_D\romannumeral0\xintsub {#2}{#1}\Z {#1}%
}%
\def\XINT_ftcc_D #1%
{%
    \xint_UDzerominusfork
      #1-\XINT_ftcc_integer
      0#1\XINT_ftcc_En
       0-{\XINT_ftcc_Ep #1}%
    \krof
}%
\def\XINT_ftcc_Ep #1\Z #2%
{%
    \expandafter\XINT_ftcc_loop_a\expandafter
    {\romannumeral0\xintdiv {1[0]}{#1}}{#2+1/}%
}%
\def\XINT_ftcc_En #1\Z #2%
{%
    \expandafter\XINT_ftcc_loop_a\expandafter
    {\romannumeral0\xintdiv {1[0]}{#1}}{#2+-1/}%
}%
\def\XINT_ftcc_integer #1\Z #2{ #2}%
\def\XINT_ftcc_loop_a #1%
{%
    \expandafter\XINT_ftcc_loop_b
    \romannumeral0\xintrawwithzeros {\xintAdd {1/2[0]}{#1}}\Z {#1}%
}%
\def\XINT_ftcc_loop_b #1/#2\Z
{%
    \expandafter\XINT_ftcc_loop_c\expandafter
    {\romannumeral0\xintiiquo {#1}{#2}}%
}%
\def\XINT_ftcc_loop_c #1#2%
{%
    \expandafter\XINT_ftcc_loop_d
    \romannumeral0\xintsub {#2}{#1[0]}\Z {#1}%
}%
\def\XINT_ftcc_loop_d #1%
{%
    \xint_UDzerominusfork
      #1-\XINT_ftcc_end
      0#1\XINT_ftcc_loop_N
       0-{\XINT_ftcc_loop_P #1}%
    \krof
}%
\def\XINT_ftcc_end #1\Z #2#3{ #3#2}%
\def\XINT_ftcc_loop_P #1\Z #2#3%
{%
    \expandafter\XINT_ftcc_loop_a\expandafter
    {\romannumeral0\xintdiv {1[0]}{#1}}{#3#2+1/}%
}%
\def\XINT_ftcc_loop_N #1\Z #2#3%
{%
    \expandafter\XINT_ftcc_loop_a\expandafter
    {\romannumeral0\xintdiv {1[0]}{#1}}{#3#2+-1/}%
}%
%    \end{macrocode}
% \subsection{\csh{xintCtoF}, \csh{xintCstoF}}
% \lverb|1.09m uses \xintCSVtoList on the argument of \xintCstoF to allow
% spaces also before the commas. And the original \xintCstoF code became the
% one of the new \xintCtoF dealing with a braced rather than comma separated
% list.|
%    \begin{macrocode}
\def\xintCstoF {\romannumeral0\xintcstof }%
\def\xintcstof #1%
{%
    \expandafter\XINT_ctf_prep \romannumeral0\xintcsvtolist{#1}\xint_relax
}%
\def\xintCtoF {\romannumeral0\xintctof }%
\def\xintctof #1%
{%
    \expandafter\XINT_ctf_prep \romannumeral`&&@#1\xint_relax
}%
\def\XINT_ctf_prep
{%
    \XINT_ctf_loop_a 1001%
}%
\def\XINT_ctf_loop_a #1#2#3#4#5%
{%
    \xint_gob_til_xint_relax #5\XINT_ctf_end\xint_relax
    \expandafter\XINT_ctf_loop_b
    \romannumeral0\xintrawwithzeros {#5}.{#1}{#2}{#3}{#4}%
}%
\def\XINT_ctf_loop_b #1/#2.#3#4#5#6%
{%
    \expandafter\XINT_ctf_loop_c\expandafter
    {\romannumeral0\XINT_mul_fork #2\Z #4\Z }%
    {\romannumeral0\XINT_mul_fork #2\Z #3\Z }%
    {\romannumeral0\xintiiadd {\XINT_mul_fork #2\Z #6\Z}{\XINT_mul_fork #1\Z #4\Z}}%
    {\romannumeral0\xintiiadd {\XINT_mul_fork #2\Z #5\Z}{\XINT_mul_fork #1\Z #3\Z}}%
}%
\def\XINT_ctf_loop_c #1#2%
{%
    \expandafter\XINT_ctf_loop_d\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_ctf_loop_d #1#2%
{%
    \expandafter\XINT_ctf_loop_e\expandafter {\expandafter{#2}#1}%
}%
\def\XINT_ctf_loop_e #1#2%
{%
    \expandafter\XINT_ctf_loop_a\expandafter{#2}#1%
}%
\def\XINT_ctf_end #1.#2#3#4#5{\xintrawwithzeros {#2/#3}}% 1.09b removes [0]
%    \end{macrocode}
% \subsection{\csh{xintiCstoF}}
%    \begin{macrocode}
\def\xintiCstoF {\romannumeral0\xinticstof }%
\def\xinticstof #1%
{%
    \expandafter\XINT_icstf_prep \romannumeral`&&@#1,\xint_relax,%
}%
\def\XINT_icstf_prep
{%
    \XINT_icstf_loop_a 1001%
}%
\def\XINT_icstf_loop_a #1#2#3#4#5,%
{%
    \xint_gob_til_xint_relax #5\XINT_icstf_end\xint_relax
    \expandafter
    \XINT_icstf_loop_b \romannumeral`&&@#5.{#1}{#2}{#3}{#4}%
}%
\def\XINT_icstf_loop_b #1.#2#3#4#5%
{%
    \expandafter\XINT_icstf_loop_c\expandafter
    {\romannumeral0\xintiiadd {#5}{\XINT_mul_fork #1\Z #3\Z}}%
    {\romannumeral0\xintiiadd {#4}{\XINT_mul_fork #1\Z #2\Z}}%
    {#2}{#3}%
}%
\def\XINT_icstf_loop_c #1#2%
{%
    \expandafter\XINT_icstf_loop_a\expandafter {#2}{#1}%
}%
\def\XINT_icstf_end#1.#2#3#4#5{\xintrawwithzeros {#2/#3}}% 1.09b removes [0]
%    \end{macrocode}
% \subsection{\csh{xintGCtoF}}
%    \begin{macrocode}
\def\xintGCtoF {\romannumeral0\xintgctof }%
\def\xintgctof #1%
{%
    \expandafter\XINT_gctf_prep \romannumeral`&&@#1+\xint_relax/%
}%
\def\XINT_gctf_prep
{%
    \XINT_gctf_loop_a 1001%
}%
\def\XINT_gctf_loop_a #1#2#3#4#5+%
{%
    \expandafter\XINT_gctf_loop_b
    \romannumeral0\xintrawwithzeros {#5}.{#1}{#2}{#3}{#4}%
}%
\def\XINT_gctf_loop_b #1/#2.#3#4#5#6%
{%
    \expandafter\XINT_gctf_loop_c\expandafter
    {\romannumeral0\XINT_mul_fork #2\Z #4\Z }%
    {\romannumeral0\XINT_mul_fork #2\Z #3\Z }%
    {\romannumeral0\xintiiadd {\XINT_mul_fork #2\Z #6\Z}{\XINT_mul_fork #1\Z #4\Z}}%
    {\romannumeral0\xintiiadd {\XINT_mul_fork #2\Z #5\Z}{\XINT_mul_fork #1\Z #3\Z}}%
}%
\def\XINT_gctf_loop_c #1#2%
{%
    \expandafter\XINT_gctf_loop_d\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_gctf_loop_d #1#2%
{%
    \expandafter\XINT_gctf_loop_e\expandafter {\expandafter{#2}#1}%
}%
\def\XINT_gctf_loop_e #1#2%
{%
    \expandafter\XINT_gctf_loop_f\expandafter {\expandafter{#2}#1}%
}%
\def\XINT_gctf_loop_f #1#2/%
{%
    \xint_gob_til_xint_relax #2\XINT_gctf_end\xint_relax
    \expandafter\XINT_gctf_loop_g
    \romannumeral0\xintrawwithzeros {#2}.#1%
}%
\def\XINT_gctf_loop_g #1/#2.#3#4#5#6%
{%
    \expandafter\XINT_gctf_loop_h\expandafter
    {\romannumeral0\XINT_mul_fork #1\Z #6\Z }%
    {\romannumeral0\XINT_mul_fork #1\Z #5\Z }%
    {\romannumeral0\XINT_mul_fork #2\Z #4\Z }%
    {\romannumeral0\XINT_mul_fork #2\Z #3\Z }%
}%
\def\XINT_gctf_loop_h #1#2%
{%
    \expandafter\XINT_gctf_loop_i\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_gctf_loop_i #1#2%
{%
    \expandafter\XINT_gctf_loop_j\expandafter {\expandafter{#2}#1}%
}%
\def\XINT_gctf_loop_j #1#2%
{%
    \expandafter\XINT_gctf_loop_a\expandafter {#2}#1%
}%
\def\XINT_gctf_end #1.#2#3#4#5{\xintrawwithzeros {#2/#3}}% 1.09b removes [0]
%    \end{macrocode}
% \subsection{\csh{xintiGCtoF}}
%    \begin{macrocode}
\def\xintiGCtoF {\romannumeral0\xintigctof }%
\def\xintigctof #1%
{%
    \expandafter\XINT_igctf_prep \romannumeral`&&@#1+\xint_relax/%
}%
\def\XINT_igctf_prep
{%
    \XINT_igctf_loop_a 1001%
}%
\def\XINT_igctf_loop_a #1#2#3#4#5+%
{%
    \expandafter\XINT_igctf_loop_b
    \romannumeral`&&@#5.{#1}{#2}{#3}{#4}%
}%
\def\XINT_igctf_loop_b #1.#2#3#4#5%
{%
    \expandafter\XINT_igctf_loop_c\expandafter
    {\romannumeral0\xintiiadd {#5}{\XINT_mul_fork #1\Z #3\Z}}%
    {\romannumeral0\xintiiadd {#4}{\XINT_mul_fork #1\Z #2\Z}}%
    {#2}{#3}%
}%
\def\XINT_igctf_loop_c #1#2%
{%
    \expandafter\XINT_igctf_loop_f\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_igctf_loop_f #1#2#3#4/%
{%
    \xint_gob_til_xint_relax #4\XINT_igctf_end\xint_relax
    \expandafter\XINT_igctf_loop_g
    \romannumeral`&&@#4.{#2}{#3}#1%
}%
\def\XINT_igctf_loop_g #1.#2#3%
{%
    \expandafter\XINT_igctf_loop_h\expandafter
    {\romannumeral0\XINT_mul_fork #1\Z #3\Z }%
    {\romannumeral0\XINT_mul_fork #1\Z #2\Z }%
}%
\def\XINT_igctf_loop_h #1#2%
{%
    \expandafter\XINT_igctf_loop_i\expandafter {#2}{#1}%
}%
\def\XINT_igctf_loop_i #1#2#3#4%
{%
    \XINT_igctf_loop_a {#3}{#4}{#1}{#2}%
}%
\def\XINT_igctf_end #1.#2#3#4#5{\xintrawwithzeros {#4/#5}}% 1.09b removes [0]
%    \end{macrocode}
% \subsection{\csh{xintCtoCv}, \csh{xintCstoCv}}
% \lverb|1.09m uses \xintCSVtoList on the argument of \xintCstoCv to allow
% spaces also before the commas. The original \xintCstoCv code became the
% one of the new \xintCtoF dealing with a braced rather than comma separated
% list.|
%    \begin{macrocode}
\def\xintCstoCv {\romannumeral0\xintcstocv }%
\def\xintcstocv #1%
{%
    \expandafter\XINT_ctcv_prep\romannumeral0\xintcsvtolist{#1}\xint_relax
}%
\def\xintCtoCv {\romannumeral0\xintctocv }%
\def\xintctocv #1%
{%
    \expandafter\XINT_ctcv_prep\romannumeral`&&@#1\xint_relax
}%
\def\XINT_ctcv_prep
{%
    \XINT_ctcv_loop_a {}1001%
}%
\def\XINT_ctcv_loop_a #1#2#3#4#5#6%
{%
    \xint_gob_til_xint_relax #6\XINT_ctcv_end\xint_relax
    \expandafter\XINT_ctcv_loop_b
    \romannumeral0\xintrawwithzeros {#6}.{#2}{#3}{#4}{#5}{#1}%
}%
\def\XINT_ctcv_loop_b #1/#2.#3#4#5#6%
{%
    \expandafter\XINT_ctcv_loop_c\expandafter
    {\romannumeral0\XINT_mul_fork #2\Z #4\Z }%
    {\romannumeral0\XINT_mul_fork #2\Z #3\Z }%
    {\romannumeral0\xintiiadd {\XINT_mul_fork #2\Z #6\Z}{\XINT_mul_fork #1\Z #4\Z}}%
    {\romannumeral0\xintiiadd {\XINT_mul_fork #2\Z #5\Z}{\XINT_mul_fork #1\Z #3\Z}}%
}%
\def\XINT_ctcv_loop_c #1#2%
{%
    \expandafter\XINT_ctcv_loop_d\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_ctcv_loop_d #1#2%
{%
    \expandafter\XINT_ctcv_loop_e\expandafter {\expandafter{#2}#1}%
}%
\def\XINT_ctcv_loop_e #1#2%
{%
    \expandafter\XINT_ctcv_loop_f\expandafter{#2}#1%
}%
\def\XINT_ctcv_loop_f #1#2#3#4#5%
{%
    \expandafter\XINT_ctcv_loop_g\expandafter
    {\romannumeral0\xintrawwithzeros {#1/#2}}{#5}{#1}{#2}{#3}{#4}%
}%
\def\XINT_ctcv_loop_g #1#2{\XINT_ctcv_loop_a {#2{#1}}}% 1.09b removes [0]
\def\XINT_ctcv_end #1.#2#3#4#5#6{ #6}%
%    \end{macrocode}
% \subsection{\csh{xintiCstoCv}}
%    \begin{macrocode}
\def\xintiCstoCv {\romannumeral0\xinticstocv }%
\def\xinticstocv #1%
{%
    \expandafter\XINT_icstcv_prep \romannumeral`&&@#1,\xint_relax,%
}%
\def\XINT_icstcv_prep
{%
    \XINT_icstcv_loop_a {}1001%
}%
\def\XINT_icstcv_loop_a #1#2#3#4#5#6,%
{%
    \xint_gob_til_xint_relax #6\XINT_icstcv_end\xint_relax
    \expandafter
    \XINT_icstcv_loop_b \romannumeral`&&@#6.{#2}{#3}{#4}{#5}{#1}%
}%
\def\XINT_icstcv_loop_b #1.#2#3#4#5%
{%
    \expandafter\XINT_icstcv_loop_c\expandafter
    {\romannumeral0\xintiiadd {#5}{\XINT_mul_fork #1\Z #3\Z}}%
    {\romannumeral0\xintiiadd {#4}{\XINT_mul_fork #1\Z #2\Z}}%
    {{#2}{#3}}%
}%
\def\XINT_icstcv_loop_c #1#2%
{%
    \expandafter\XINT_icstcv_loop_d\expandafter {#2}{#1}%
}%
\def\XINT_icstcv_loop_d #1#2%
{%
    \expandafter\XINT_icstcv_loop_e\expandafter
    {\romannumeral0\xintrawwithzeros {#1/#2}}{{#1}{#2}}%
}%
\def\XINT_icstcv_loop_e #1#2#3#4{\XINT_icstcv_loop_a {#4{#1}}#2#3}%
\def\XINT_icstcv_end #1.#2#3#4#5#6{ #6}%  1.09b removes [0]
%    \end{macrocode}
% \subsection{\csh{xintGCtoCv}}
%    \begin{macrocode}
\def\xintGCtoCv {\romannumeral0\xintgctocv }%
\def\xintgctocv #1%
{%
    \expandafter\XINT_gctcv_prep \romannumeral`&&@#1+\xint_relax/%
}%
\def\XINT_gctcv_prep
{%
    \XINT_gctcv_loop_a {}1001%
}%
\def\XINT_gctcv_loop_a #1#2#3#4#5#6+%
{%
    \expandafter\XINT_gctcv_loop_b
    \romannumeral0\xintrawwithzeros {#6}.{#2}{#3}{#4}{#5}{#1}%
}%
\def\XINT_gctcv_loop_b #1/#2.#3#4#5#6%
{%
    \expandafter\XINT_gctcv_loop_c\expandafter
    {\romannumeral0\XINT_mul_fork #2\Z #4\Z }%
    {\romannumeral0\XINT_mul_fork #2\Z #3\Z }%
    {\romannumeral0\xintiiadd {\XINT_mul_fork #2\Z #6\Z}{\XINT_mul_fork #1\Z #4\Z}}%
    {\romannumeral0\xintiiadd {\XINT_mul_fork #2\Z #5\Z}{\XINT_mul_fork #1\Z #3\Z}}%
}%
\def\XINT_gctcv_loop_c #1#2%
{%
    \expandafter\XINT_gctcv_loop_d\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_gctcv_loop_d #1#2%
{%
    \expandafter\XINT_gctcv_loop_e\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_gctcv_loop_e #1#2%
{%
    \expandafter\XINT_gctcv_loop_f\expandafter {#2}#1%
}%
\def\XINT_gctcv_loop_f #1#2%
{%
    \expandafter\XINT_gctcv_loop_g\expandafter
    {\romannumeral0\xintrawwithzeros {#1/#2}}{{#1}{#2}}%
}%
\def\XINT_gctcv_loop_g #1#2#3#4%
{%
    \XINT_gctcv_loop_h {#4{#1}}{#2#3}% 1.09b removes [0]
}%
\def\XINT_gctcv_loop_h #1#2#3/%
{%
    \xint_gob_til_xint_relax #3\XINT_gctcv_end\xint_relax
    \expandafter\XINT_gctcv_loop_i
    \romannumeral0\xintrawwithzeros {#3}.#2{#1}%
}%
\def\XINT_gctcv_loop_i #1/#2.#3#4#5#6%
{%
    \expandafter\XINT_gctcv_loop_j\expandafter
    {\romannumeral0\XINT_mul_fork #1\Z #6\Z }%
    {\romannumeral0\XINT_mul_fork #1\Z #5\Z }%
    {\romannumeral0\XINT_mul_fork #2\Z #4\Z }%
    {\romannumeral0\XINT_mul_fork #2\Z #3\Z }%
}%
\def\XINT_gctcv_loop_j #1#2%
{%
    \expandafter\XINT_gctcv_loop_k\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_gctcv_loop_k #1#2%
{%
    \expandafter\XINT_gctcv_loop_l\expandafter {\expandafter{#2}#1}%
}%
\def\XINT_gctcv_loop_l #1#2%
{%
    \expandafter\XINT_gctcv_loop_m\expandafter {\expandafter{#2}#1}%
}%
\def\XINT_gctcv_loop_m #1#2{\XINT_gctcv_loop_a {#2}#1}%
\def\XINT_gctcv_end #1.#2#3#4#5#6{ #6}%
%    \end{macrocode}
% \subsection{\csh{xintiGCtoCv}}
%    \begin{macrocode}
\def\xintiGCtoCv {\romannumeral0\xintigctocv }%
\def\xintigctocv #1%
{%
    \expandafter\XINT_igctcv_prep \romannumeral`&&@#1+\xint_relax/%
}%
\def\XINT_igctcv_prep
{%
    \XINT_igctcv_loop_a {}1001%
}%
\def\XINT_igctcv_loop_a #1#2#3#4#5#6+%
{%
    \expandafter\XINT_igctcv_loop_b
    \romannumeral`&&@#6.{#2}{#3}{#4}{#5}{#1}%
}%
\def\XINT_igctcv_loop_b #1.#2#3#4#5%
{%
    \expandafter\XINT_igctcv_loop_c\expandafter
    {\romannumeral0\xintiiadd {#5}{\XINT_mul_fork #1\Z #3\Z}}%
    {\romannumeral0\xintiiadd {#4}{\XINT_mul_fork #1\Z #2\Z}}%
    {{#2}{#3}}%
}%
\def\XINT_igctcv_loop_c #1#2%
{%
    \expandafter\XINT_igctcv_loop_f\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_igctcv_loop_f #1#2#3#4/%
{%
    \xint_gob_til_xint_relax #4\XINT_igctcv_end_a\xint_relax
    \expandafter\XINT_igctcv_loop_g
    \romannumeral`&&@#4.#1#2{#3}%
}%
\def\XINT_igctcv_loop_g #1.#2#3#4#5%
{%
    \expandafter\XINT_igctcv_loop_h\expandafter
    {\romannumeral0\XINT_mul_fork #1\Z #5\Z }%
    {\romannumeral0\XINT_mul_fork #1\Z #4\Z }%
    {{#2}{#3}}%
}%
\def\XINT_igctcv_loop_h #1#2%
{%
    \expandafter\XINT_igctcv_loop_i\expandafter {\expandafter{#2}{#1}}%
}%
\def\XINT_igctcv_loop_i #1#2{\XINT_igctcv_loop_k #2{#2#1}}%
\def\XINT_igctcv_loop_k #1#2%
{%
    \expandafter\XINT_igctcv_loop_l\expandafter
    {\romannumeral0\xintrawwithzeros {#1/#2}}%
}%
\def\XINT_igctcv_loop_l #1#2#3{\XINT_igctcv_loop_a {#3{#1}}#2}%1.09i removes [0]
\def\XINT_igctcv_end_a #1.#2#3#4#5%
{%
    \expandafter\XINT_igctcv_end_b\expandafter
    {\romannumeral0\xintrawwithzeros {#2/#3}}%
}%
\def\XINT_igctcv_end_b #1#2{ #2{#1}}% 1.09b removes [0]
%    \end{macrocode}
% \subsection{\csh{xintFtoCv}}
% \lverb|Still uses \xinticstocv \xintFtoCs rather than \xintctocv \xintFtoC.|
%    \begin{macrocode}
\def\xintFtoCv {\romannumeral0\xintftocv }%
\def\xintftocv #1%
{%
    \xinticstocv {\xintFtoCs {#1}}%
}%
%    \end{macrocode}
% \subsection{\csh{xintFtoCCv}}
%    \begin{macrocode}
\def\xintFtoCCv {\romannumeral0\xintftoccv }%
\def\xintftoccv #1%
{%
    \xintigctocv {\xintFtoCC {#1}}%
}%
%    \end{macrocode}
% \subsection{\csh{xintCntoF}}
% \lverb|&
% Modified in 1.06 to give the N first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.|
%    \begin{macrocode}
\def\xintCntoF {\romannumeral0\xintcntof }%
\def\xintcntof #1%
{%
    \expandafter\XINT_cntf\expandafter {\the\numexpr #1}%
}%
\def\XINT_cntf #1#2%
{%
   \ifnum #1>\xint_c_
      \xint_afterfi {\expandafter\XINT_cntf_loop\expandafter
                     {\the\numexpr #1-1\expandafter}\expandafter
                     {\romannumeral`&&@#2{#1}}{#2}}%
   \else
      \xint_afterfi
         {\ifnum #1=\xint_c_
              \xint_afterfi {\expandafter\space \romannumeral`&&@#2{0}}%
          \else \xint_afterfi { }% 1.09m now returns nothing.
          \fi}%
   \fi
}%
\def\XINT_cntf_loop #1#2#3%
{%
    \ifnum #1>\xint_c_ \else \XINT_cntf_exit \fi
    \expandafter\XINT_cntf_loop\expandafter
    {\the\numexpr #1-1\expandafter }\expandafter
    {\romannumeral0\xintadd {\xintDiv {1[0]}{#2}}{#3{#1}}}%
    {#3}%
}%
\def\XINT_cntf_exit \fi
    \expandafter\XINT_cntf_loop\expandafter
    #1\expandafter #2#3%
{%
    \fi\xint_gobble_ii #2%
}%
%    \end{macrocode}
% \subsection{\csh{xintGCntoF}}
% \lverb|Modified in 1.06 to give the N argument first to a \numexpr rather
% than expanding twice. I just use \the\numexpr and maintain the previous code
% after that.|
%    \begin{macrocode}
\def\xintGCntoF {\romannumeral0\xintgcntof }%
\def\xintgcntof #1%
{%
    \expandafter\XINT_gcntf\expandafter {\the\numexpr #1}%
}%
\def\XINT_gcntf #1#2#3%
{%
   \ifnum #1>\xint_c_
      \xint_afterfi {\expandafter\XINT_gcntf_loop\expandafter
                     {\the\numexpr #1-1\expandafter}\expandafter
                     {\romannumeral`&&@#2{#1}}{#2}{#3}}%
   \else
      \xint_afterfi
         {\ifnum #1=\xint_c_
              \xint_afterfi {\expandafter\space\romannumeral`&&@#2{0}}%
          \else \xint_afterfi { }% 1.09m now returns nothing rather than 0/1[0]
          \fi}%
   \fi
}%
\def\XINT_gcntf_loop #1#2#3#4%
{%
    \ifnum #1>\xint_c_ \else \XINT_gcntf_exit \fi
    \expandafter\XINT_gcntf_loop\expandafter
    {\the\numexpr #1-1\expandafter }\expandafter
    {\romannumeral0\xintadd {\xintDiv {#4{#1}}{#2}}{#3{#1}}}%
    {#3}{#4}%
}%
\def\XINT_gcntf_exit \fi
    \expandafter\XINT_gcntf_loop\expandafter
    #1\expandafter #2#3#4%
{%
    \fi\xint_gobble_ii #2%
}%
%    \end{macrocode}
% \subsection{\csh{xintCntoCs}}
% \lverb|Modified in 1.09m: added spaces after the commas in the produced list.
% Moreover the coefficients are not braced anymore. A slight induced limitation
% is that the macro argument should not contain some explicit comma (cf.
% \XINT_cntcs_exit_b), hence \xintCntoCs {\macro,} with \def\macro,#1{<stuff>}
% would crash. Not a very serious limitation, I believe. |
%    \begin{macrocode}
\def\xintCntoCs {\romannumeral0\xintcntocs }%
\def\xintcntocs #1%
{%
    \expandafter\XINT_cntcs\expandafter {\the\numexpr #1}%
}%
\def\XINT_cntcs #1#2%
{%
   \ifnum #1<0
      \xint_afterfi { }% 1.09i: a 0/1[0] was here, now the macro returns nothing
   \else
      \xint_afterfi {\expandafter\XINT_cntcs_loop\expandafter
                     {\the\numexpr #1-\xint_c_i\expandafter}\expandafter
                     {\romannumeral`&&@#2{#1}}{#2}}% produced coeff not braced
   \fi
}%
\def\XINT_cntcs_loop #1#2#3%
{%
    \ifnum #1>-\xint_c_i \else \XINT_cntcs_exit \fi
    \expandafter\XINT_cntcs_loop\expandafter
    {\the\numexpr #1-\xint_c_i\expandafter}\expandafter
    {\romannumeral`&&@#3{#1}, #2}{#3}% space added, 1.09m
}%
\def\XINT_cntcs_exit \fi
    \expandafter\XINT_cntcs_loop\expandafter
    #1\expandafter #2#3%
{%
    \fi\XINT_cntcs_exit_b #2%
}%
\def\XINT_cntcs_exit_b #1,{}% romannumeral stopping space already there
%    \end{macrocode}
% \subsection{\csh{xintCntoGC}}
% \lverb|&
% Modified in 1.06 to give the N first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.
%
% 1.09m maintains the braces, as the coeff are allowed to be fraction and the
% slash can not be naked in the GC format, contrarily to what happens in
% \xintCntoCs. Also the separators given to \xintGCtoGCx may then fetch the
% coefficients as argument, as they are braced.|
%    \begin{macrocode}
\def\xintCntoGC {\romannumeral0\xintcntogc }%
\def\xintcntogc #1%
{%
    \expandafter\XINT_cntgc\expandafter {\the\numexpr #1}%
}%
\def\XINT_cntgc #1#2%
{%
   \ifnum #1<0
      \xint_afterfi { }% 1.09i there was as strange 0/1[0] here, removed
   \else
      \xint_afterfi {\expandafter\XINT_cntgc_loop\expandafter
                     {\the\numexpr #1-\xint_c_i\expandafter}\expandafter
                     {\expandafter{\romannumeral`&&@#2{#1}}}{#2}}%
   \fi
}%
\def\XINT_cntgc_loop #1#2#3%
{%
    \ifnum #1>-\xint_c_i \else \XINT_cntgc_exit \fi
    \expandafter\XINT_cntgc_loop\expandafter
    {\the\numexpr #1-\xint_c_i\expandafter }\expandafter
    {\expandafter{\romannumeral`&&@#3{#1}}+1/#2}{#3}%
}%
\def\XINT_cntgc_exit \fi
    \expandafter\XINT_cntgc_loop\expandafter
    #1\expandafter #2#3%
{%
    \fi\XINT_cntgc_exit_b #2%
}%
\def\XINT_cntgc_exit_b #1+1/{ }%
%    \end{macrocode}
% \subsection{\csh{xintGCntoGC}}
% \lverb|&
% Modified in 1.06 to give the N first to a \numexpr rather than expanding
% twice. I just use \the\numexpr and maintain the previous code after that.|
%    \begin{macrocode}
\def\xintGCntoGC {\romannumeral0\xintgcntogc }%
\def\xintgcntogc #1%
{%
    \expandafter\XINT_gcntgc\expandafter {\the\numexpr #1}%
}%
\def\XINT_gcntgc #1#2#3%
{%
   \ifnum #1<0
      \xint_afterfi { }% 1.09i now returns nothing
   \else
      \xint_afterfi {\expandafter\XINT_gcntgc_loop\expandafter
                     {\the\numexpr #1-\xint_c_i\expandafter}\expandafter
                     {\expandafter{\romannumeral`&&@#2{#1}}}{#2}{#3}}%
   \fi
}%
\def\XINT_gcntgc_loop #1#2#3#4%
{%
    \ifnum #1>-\xint_c_i \else \XINT_gcntgc_exit \fi
    \expandafter\XINT_gcntgc_loop_b\expandafter
    {\expandafter{\romannumeral`&&@#4{#1}}/#2}{#3{#1}}{#1}{#3}{#4}%
}%
\def\XINT_gcntgc_loop_b #1#2#3%
{%
    \expandafter\XINT_gcntgc_loop\expandafter
    {\the\numexpr #3-\xint_c_i \expandafter}\expandafter
    {\expandafter{\romannumeral`&&@#2}+#1}%
}%
\def\XINT_gcntgc_exit \fi
    \expandafter\XINT_gcntgc_loop_b\expandafter #1#2#3#4#5%
{%
    \fi\XINT_gcntgc_exit_b #1%
}%
\def\XINT_gcntgc_exit_b #1/{ }%
%    \end{macrocode}
% \subsection{\csh{xintCstoGC}}
%    \begin{macrocode}
\def\xintCstoGC {\romannumeral0\xintcstogc }%
\def\xintcstogc #1%
{%
    \expandafter\XINT_cstc_prep \romannumeral`&&@#1,\xint_relax,%
}%
\def\XINT_cstc_prep #1,{\XINT_cstc_loop_a {{#1}}}%
\def\XINT_cstc_loop_a #1#2,%
{%
    \xint_gob_til_xint_relax #2\XINT_cstc_end\xint_relax
    \XINT_cstc_loop_b {#1}{#2}%
}%
\def\XINT_cstc_loop_b #1#2{\XINT_cstc_loop_a {#1+1/{#2}}}%
\def\XINT_cstc_end\xint_relax\XINT_cstc_loop_b #1#2{ #1}%
%    \end{macrocode}
% \subsection{\csh{xintGCtoGC}}
%    \begin{macrocode}
\def\xintGCtoGC {\romannumeral0\xintgctogc }%
\def\xintgctogc #1%
{%
    \expandafter\XINT_gctgc_start \romannumeral`&&@#1+\xint_relax/%
}%
\def\XINT_gctgc_start {\XINT_gctgc_loop_a {}}%
\def\XINT_gctgc_loop_a #1#2+#3/%
{%
    \xint_gob_til_xint_relax #3\XINT_gctgc_end\xint_relax
    \expandafter\XINT_gctgc_loop_b\expandafter
    {\romannumeral`&&@#2}{#3}{#1}%
}%
\def\XINT_gctgc_loop_b #1#2%
{%
    \expandafter\XINT_gctgc_loop_c\expandafter
    {\romannumeral`&&@#2}{#1}%
}%
\def\XINT_gctgc_loop_c #1#2#3%
{%
    \XINT_gctgc_loop_a {#3{#2}+{#1}/}%
}%
\def\XINT_gctgc_end\xint_relax\expandafter\XINT_gctgc_loop_b
{%
    \expandafter\XINT_gctgc_end_b
}%
\def\XINT_gctgc_end_b #1#2#3{ #3{#1}}%
\XINT_restorecatcodes_endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xintcfrac>\relax
%\def<*xintexpr>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xintcfrac>
%<*xintexpr>
%
% \StoreCodelineNo {xintcfrac}
%
% \section{Package \xintexprnameimp implementation}
% \label{sec:exprimp}
%
% \etocstandarddisplaystyle
% \etocstandardlines
% \etocsetnexttocdepth {subsection}
%
% \localtableofcontents
% \etocsettocstyle{}{}
%
% \etocmarkbothnouc {Package \xintexprnameimp implementation}
%
% The first version was released in June 2013. I was greatly helped in this task
% of writing an expandable parser of infix operations by the comments provided
% in |l3fp-parse.dtx| (in its version as available in April-May 2013). One will
% recognize in particular the idea of the `until' macros; I have not looked into
% the actual |l3fp| code beyond the very useful comments provided in its
% documentation.
%
% A main worry was that my data has no a priori bound on its size; to keep the
% code reasonably efficient, I experimented with a technique of storing and
% retrieving data expandably as \emph{names} of control sequences. Intermediate
% computation results are stored as control sequences |\.=a/b[n]|.
%
% Release |1.2| |[2015/10/10]| has the following changes:
% \begin{description}
% \item[not anymore limited to 5000
%   digits:] |1.2| replaces chains of |\romannumeral-`0| used earlier to
%   gather digits by |\csname| governed expansions. The use of
%   |\csname.=A/B[N]\endcsname| storage has been part of the design from the
%   start, hence it was very natural and not too hard to gather the number
%   directly inside |\csname|. With the chains of |\romannumeral-`0| gone,
%   there is no more a limit at about 5000 (with the standard settings of the
%   maximal expansion depth at 10000) on the maximal number of digits for each
%   gathered number.
% \item[faster gathering of digits:] the previous item and some other changes
%   have accelerated the building up of numbers.
% \item[optional accelerated parsing:] the new functions |qint|, |qfrac|,
%   |qfloat| allow to skip entirely the digit by digit parsing and hand over
%   directly responsability to \csa{xintiNum}, \csa{xintRaw}, or
%   \csa{xintFloat} respectively.
% \item[float factorial:] the factorial operator |!| maps to the new macro
%   \csa{xintFloatFac} inside \csa{xintfloatexpr}.
% \item[isolated dot now illegal:] the decimal mark must have digits either
%   before or after it, an isolated |.| is now illegal input.
% \item[more recognized tokens:] |\ht|, |\dp|, |\wd|, |\fontcharht|,
%   |\fontcharwd|, |\fontchardp| and |\fontcharic| are recognized and prefixed
%   with |\number| automatically.
% \end{description}
%
% Release |1.1| |[2014/10/28]| has made many extensions, some bug fixes, and
% some breaking changes:
% \begin{description}
% \item[bug fixes]  \begin{itemize}
%   \item |\xintiiexpr| did not strip leading zeroes,
%   \item |\xinttheexpr \xintiexpr 1.23\relax\relax| should have produced |1|,
%     but it produced |1.23|
%   \item the catcode of |;| was not set at package launching time.
%   \end{itemize}
% \item[breaking changes] \begin{itemize}
%   \item in |\xintiiexpr|, |/| does \emph{rounded} division, rather than the
%     Euclidean division (for positive arguments, this is truncated division).
%     The new |//| operator does truncated division,
%   \item the |:| operator for three-way branching is gone, replaced with |??|,
%   \item |1e(3+5)| is now illegal. The number parser identifies |e| and |E|
%     in the same way it does for the decimal mark, earlier versions treated
%     |e| as |E| rather as postfix operators,
%   \item the |add| and |mul| have a new syntax, old syntax is with |`+`| and
%     |`*`| (quotes mandatory), |sum| and |prd| are gone,
%   \item no more special treatment for encountered brace pairs |{..}| by the
%     number scanner, |a/b[N]| notation can be used without use of braces (the
%     |N| will end up as is in a |\numexpr|, it is not parsed by the
%     |\xintexpr|-ession scanner).
%   \item although |&| and \verb+|+ are still available as Boolean
%     operators the use of |&&| and \verb+||+ is strongly recommended.
%     The single letter operators might be assigned some other meaning
%     in later releases (bitwise operations, perhaps). Do not use them.
%   \item place holders for |\xintNewExpr| could be denoted |#1|, |#2|,
%     ... or also, for special purposes |$1|,
%     |$2|, ... Only the first form is now accepted and the special cases
%     previously treated via the second form are now managed via a
%     |protect(...)| function.
% \end{itemize}
% \item[novelties] They are quite a few. \begin{itemize}
%    \item |\xintiexpr|, |\xinttheiexpr| admit an optional argument within brackets
%     |[d]|, they round the computation result (or results, if comma separated)
%     to |d| digits after decimal mark, (the whole computation is done exactly,
%     as in |xintexpr|),
%
%    \item |\xintfloatexpr|, |\xintthefloatexpr| similarly admit an optional
%     argument which serves to keep only |d| digits of precision, getting rid
%     of cumulated uncertainties in the last digits (the whole computation is
%     done according to the precision set via |\xintDigits|),
%
%    \item |\xinttheexpr| and |\xintthefloatexpr| ''pretty-print'' if possible,
%     the former removing unit denominator or |[0]| brackets, the latter
%     avoiding scientific notation if decimal notation is practical,
%
%    \item the |//| does truncated division and |/:| is the associated modulo,
%
%    \item multi-character operators |&&|, \verb+||+, |==|, |<=|, |>=|, |!=|,
%     |**|,
%
%    \item multi-letter infix binary words |'and'|, |'or'|, |'xor'|, |'mod'|
%     (quotes mandatory),
%
%    \item functions |even|, |odd|, 
%
%    \item |\xintdefvar A3:=3.1415;| for variable definitions (non expandable,
%     naturally), usable in subsequent expressions; variable names may contain
%     letters, digits, underscores. They should not start with a digit, the
%     |@| is reserved, and single lowercase and uppercase Latin letters are
%     predefined to work as dummy variables (see next),
%
%    \item generation of comma separated lists |a..b|, |a..[d]..b|,
%
%    \item Python syntax-like list extractors |[list][n:]|, |[list][:n]|,
%     |[list][a:b]| allowing negative indices, but no optional step argument,
%     and |[list][n]| (|n=0| for the number of items in the list),
%
%    \item functions |first|, |last|, |reversed|,
%
%    \item itemwise operations on comma separated lists |a*[list]|, etc.., possible
%     on both sides |a*[list]^b|, an obeying the same precedence rules as with
%     numbers,
%
%    \item |add| and |mul| must use a dummy variable: |add(x(x+1)(x-1), x=-10..10)|,
%
%    \item variable substitutions with |subs|: |subs(subs(add(x^2+y^2,x=1..y),y=t),t=20)|,
%
%    \item sequence generation using |seq| with a dummy variable: |seq(x^3, x=-10..10)|,
%
%    \item simple recursive lists with |rseq|, with |@| given the last value,
%      |rseq(1;2@+1,i=1..10)|,
%
%    \item higher recursion with |rrseq|, |@1|, |@2|, |@3|, |@4|, and |@@(n)|
%      for earlier values, up to |n=K| where |K| is the number of terms of the
%      initial stretch |rrseq(0,1;@1+@2,i=2..100)|,
%
%    \item iteration with |iter| which is like |rrseq| but outputs only the
%      last |K| terms, where |K| was the number of initial terms,
%
%    \item inside |seq|, |rseq|, |rrseq|, |iter|, possibility to use |omit|,
%      |abort| and |break| to control termination,
%
%    \item |n++| potentially infinite index generation for |seq|, |rseq|,
%      |rrseq|, and |iter|, it is advised to use |abort| or |break(..)| at
%      some point,
%
%    \item the |add|, |mul|, |seq|, ... are nestable,
%
%    \item |\xintthecoords| converts a comma separated list of an even number
%      of items to the format as expected by the |TikZ| |coordinates| syntax,
%
%    \item completely rewritten |\xintNewExpr|, |protect| function to handle
%      external macros. However not all constructs are compatible with
%      |\xintNewExpr|.
%
% \end{itemize}
% \end{description}
%
% Comments dating back to earlier releases:
% 
% Roughly speaking, the parser mechanism is as follows: at any given time the
% last found ``operator'' has its associated |until| macro awaiting some news
% from the token flow; first |getnext| expands forward in the hope to construct
% some number, which may come from a parenthesized sub-expression, from some
% braced material, or from a digit by digit scan. After this number has been
% formed the next operator is looked for by the |getop| macro. Once |getop| has
% finished its job, |until| is presented with three tokens: the first one is the
% precedence level of the new found operator (which may be an end of expression
% marker), the second is the operator character token (earlier versions had here
% already some macro name, but in order to keep as much common code to expr and
% floatexpr common as possible, this was modified) of the new found operator, and
% the third one is the newly found number (which was encountered just before the
% new operator).
%
% The |until| macro of the earlier operator examines the precedence level of the
% new found one, and either executes the earlier operator (in the case of a
% binary operation, with the found number and a previously stored one) or it
% delays execution, giving the hand to the |until| macro of the operator having
% been found of higher precedence.
%
% A minus sign acting as prefix gets converted into a (unary) operator
% inheriting the precedence level of the previous operator.
%
% Once the end of the expression is found (it has to be marked by a |\relax|)
% the final result is output as four tokens (five tokens since |1.09j|) the
% first one a catcode 11 exclamation mark, the second one an error generating
% macro, the third one is a protection mechanism, the fourth one a printing
% macro and the fifth is |\.=a/b[n]|. The prefix |\xintthe| makes the output
% printable by killing the first three tokens.
%
% \begin{description}
% \item[{|1.08b [2013/06/14]|}] corrected a problem originating in the attempt
% to attribute a special rle to braces: expansion could be stopped by space
% tokens, as various macros tried to expand without grabbing what came next.
% They now have a doubled |\romannumeral-`0|.
%
% \item[{|1.09a| |[2013/09/24]|}] has a better mechanism regarding |\xintthe|,
% more commenting and better organization of the code, and most importantly it
% implements functions, comparison operators, logic operators, conditionals. The
% code was reorganized and expansion proceeds a bit differently in order to have
% the |_getnext| and |_getop| codes entirely shared by |\xintexpr| and
% |\xintfloatexpr|. |\xintNewExpr| was rewritten in order to work with the
% standard macro parameter character |#|, to be catcode protected and to also
% allow comma separated expressions.
%
% \item[{|1.09c| |[2013/10/09]|}] added the |bool| and |togl| operators,
% |\xintboolexpr|, and |\xintNewNumExpr|, |\xintNewBoolExpr|. The code for
% |\xintNewExpr| is shared with |float|, |num|, and |bool|-expressions. Also the
% precedence level of the postfix operators |!|, |?| and |:| has been made lower
% than the one of functions. 
%
% \item[{|1.09i| |[2013/12/18]|}] unpacks count and dimen registers and control
% squences, with tacit multiplication. It has also made small improvements.
% (speed gains in macro expansions in quite a few places.)
%
% Also, |1.09i| implements |\xintiiexpr|, |\xinttheiiexpr|. New function |frac|.
% And encapsulation in |\csname..\endcsname| is done with |.=| as first tokens,
% so unpacking with |\string| can be done in a completely escape char agnostic
% way.
%
% \item[{|1.09j| |[2014/01/09]|}] extends the tacit multiplication to the case of
% a sub |\xintexpr|-essions. Also, it now |\xint_protect|s the result of the
% |\xintexpr| full expansions, thus, an |\xintexpr| without |\xintthe| prefix
% can be used not only as the first item within an ``|\fdef|'' as previously but
% also now anywhere within an |\edef|. Five tokens are used to pack the
% computation result rather than the possibly hundreds or thousands of digits of
% an |\xintthe| unlocked result. I deliberately omit a second |\xint_protect|
% which, however would be necessary if some macro |\.=digits/digits[digits]| had
% acquired some expandable meaning elsewhere. But this seems not that probable,
% and adding the protection would mean impacting everything only to allow some
% crazy user which has loaded something else than xint to do an |\edef|... the
% |\xintexpr| computations are otherwise in no way affected if such control
% sequences have a meaning.
%
% \item[{|1.09k| |[2014/01/21]|}] does tacit multiplication also for an opening
% parenthesis encountered during the scanning of a number, or at a time when the
% parser expects an infix operator.
%
% And it adds to the syntax recognition of hexadecimal numbers starting with a
% |"|, and having possibly a fractional part (except in |\xintiiexpr|,
% naturally).
%
% \item[{|1.09kb| |[2014/02/13]|}] fixes the bug introduced in |\xintNewExpr|
% in |1.09i| of December 2013: an |\endlinechar -1| was removed, but without
% it there is a spurious trailing space token in the outputs of the created
% macros, and nesting is then impossible.
%
% \end{description}
%
% This is release \expandafter|\xintbndlversion| of
% \expandafter|\expandafter[\xintbndldate]|.
%
% \subsection{Catcodes, \protect\eTeX{} and reload detection}
%
% The code for reload detection was initially copied from \textsc{Heiko
% Oberdiek}'s packages, then modified.
%
% The method for catcodes was also initially directly inspired by these
% packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \def\z {\endgroup}%
  \expandafter\let\expandafter\x\csname ver@xintexpr.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xintfrac.sty\endcsname
  \expandafter\let\expandafter\t\csname ver@xinttools.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintexpr}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintexpr.sty
      \ifx\w\relax % but xintfrac.sty not yet loaded.
         \expandafter\def\expandafter\z\expandafter
                    {\z\input xintfrac.sty\relax}%
      \fi
      \ifx\t\relax % but xinttools.sty not yet loaded.
         \expandafter\def\expandafter\z\expandafter
                    {\z\input xinttools.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xintfrac.sty not yet loaded.
            \expandafter\def\expandafter\z\expandafter
                           {\z\RequirePackage{xintfrac}}%
          \fi
          \ifx\t\relax % xinttools.sty not yet loaded.
            \expandafter\def\expandafter\z\expandafter
                           {\z\RequirePackage{xinttools}}%
          \fi
      \else
        \aftergroup\endinput % xintexpr already loaded.
      \fi
    \fi
  \fi
\z%
\XINTsetupcatcodes%
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\XINT_providespackage
\ProvidesPackage{xintexpr}%
  [2015/11/18 v1.2d Expandable expression parser (jfB)]%
\catcode`! 11
%    \end{macrocode}
% \subsection{Locking and unlocking}
% \lverb|Some renaming and modifications here with release 1.2 to switch from
% using chains of \romannumeral-`0 in order to gather numbers, possibly
% hexadecimals, to using a \csname governed expansion. In this way no more
% limit at 5000 digits, and besides this is a logical move because the
% \xintexpr parser is already based on \csname...\endcsname storage of numbers
% as one token.
%
% The limitation at 5000 digits didn't worry me too much because it was not
% very realistic to launch computations with thousands of digits... such
% computations are still slow with 1.2 but less so now. Chains or
% \romannumeral are still used for the gathering of function names and other
% stuff which I have half-forgotten because the parser does many things.
%
% In the earlier versions we used the lockscan macro after a chain of
% \romannumeral-`0 had ended gathering digits; this uses has been replaced by
% direct processing inside a \csname...\endcsname and the macro is kept only
% for matters of dummy variables.
%
% Currently, the parsing of hexadecimal numbers needs two nested
% \csname...\endcsname, first to gather the letters (possibly with a hexadecimal
% fractional part), and in a second stage to apply \xintHexToDec to do the
% actual conversion. This should be faster than updating on the fly the number
% (which would be hard for the fraction part...). The macro \xintHexToDec
% could probably be made faster by using techniques similar as the ones v1.2
% uses in xintcore.sty.|
%    \begin{macrocode}
\def\xint_gob_til_! #1!{}% catcode 11 ! default in xintexpr.sty code.
\edef\XINT_expr_lockscan#1!% not used for decimal numbers in xintexpr 1.2
    {\noexpand\expandafter\space\noexpand\csname .=#1\endcsname }%
\edef\XINT_expr_lockit   
     #1{\noexpand\expandafter\space\noexpand\csname .=#1\endcsname }%
\def\XINT_expr_unlock_hex_in #1%  expanded inside \csname..\endcsname
   {\expandafter\XINT_expr_inhex\romannumeral`&&@\XINT_expr_unlock#1;}%
\def\XINT_expr_inhex #1.#2#3;%    expanded inside \csname..\endcsname
{%
    \if#2>\xintHexToDec{#1}%
    \else
      \xintiiMul{\xintiiPow{625}{\xintLength{#3}}}{\xintHexToDec{#1#3}}%
      [\the\numexpr-4*\xintLength{#3}]%
    \fi
}%
%%%%%%%%%%%%
\def\XINT_expr_unlock  {\expandafter\XINT_expr_unlock_a\string }%
\def\XINT_expr_unlock_a #1.={}%
\def\XINT_expr_unexpectedtoken {\xintError:ignored }%
\let\XINT_expr_done\space
%    \end{macrocode}
% \subsection{\csh{XINT_expr_wrap}, \csh{XINT_iiexpr_wrap}}
%    \begin{macrocode}
\def\XINT_expr_wrap   { !\XINT_expr_usethe\XINT_protectii\XINT_expr_print }%
\def\XINT_iiexpr_wrap { !\XINT_expr_usethe\XINT_protectii\XINT_iiexpr_print }%
%    \end{macrocode}
% \subsection{\csh{XINT_protectii}, \csh{XINT_expr_usethe}}
%    \begin{macrocode}
\def\XINT_protectii #1{\noexpand\XINT_protectii\noexpand #1\noexpand }%
\protected\def\XINT_expr_usethe\XINT_protectii {\xintError:missing_xintthe!}%
%    \end{macrocode}
% \subsection{\csh{XINT_expr_print}, \csh{XINT_iiexpr_print}, \csh{XINT_boolexpr_print}}
% \lverb|See also the \XINT_flexpr_print which is special, below.|
%    \begin{macrocode}
\def\XINT_expr_print     #1{\xintSPRaw::csv  {\XINT_expr_unlock #1}}%
\def\XINT_iiexpr_print   #1{\xintCSV::csv    {\XINT_expr_unlock #1}}%
\def\XINT_boolexpr_print #1{\xintIsTrue::csv {\XINT_expr_unlock #1}}%
%    \end{macrocode}
% \subsection{\csh{xintexpr}, \csh{xintiexpr}, \csh{xintfloatexpr},
% \csh{xintiiexpr}, \csh{xinttheexpr}, etc\dots}
%    \begin{macrocode}
\def\xintexpr       {\romannumeral0\xinteval      }%
\def\xintiexpr      {\romannumeral0\xintieval     }%
\def\xintfloatexpr  {\romannumeral0\xintfloateval }%
\def\xintiiexpr     {\romannumeral0\xintiieval    }%
\def\xinttheexpr    
   {\romannumeral`&&@\expandafter\XINT_expr_print\romannumeral0\xintbareeval  }%
\def\xinttheiexpr     {\romannumeral`&&@\xintthe\xintiexpr }%
\def\xintthefloatexpr {\romannumeral`&&@\xintthe\xintfloatexpr }%
\def\xinttheiiexpr 
   {\romannumeral`&&@\expandafter\XINT_iiexpr_print\romannumeral0\xintbareiieval }%
%    \end{macrocode}
% \subsection{\csh{xintthe}}
%    \begin{macrocode}
\def\xintthe #1{\romannumeral`&&@\expandafter\xint_gobble_iii\romannumeral`&&@#1}%
%    \end{macrocode}
% \subsection{\csh{xintthecoords}}
% \lverb|1.1 Wraps up an even number of comma separated items into pairs of
% TikZ coordinates; for use in the following way: 
%
% coordinates {\xintthecoords\xintfloatexpr ... \relax}
%
% The crazyness with the \csname and unlock is due to TikZ somewhat STRANGE
% control of the TOTAL number of expansions which should not exceed the very low
% value of 100 !! As we implemented \XINT_thecoords_b in an "inline" style for
% efficiency, we need to hide its expansions.
%
% Not to be used as \xintthecoords\xintthefloatexpr, only as
% \xintthecoords\xintfloatexpr (or \xintiexpr etc...). Perhaps \xintthecoords
% could make an extra check, but one should not accustom users to too loose
% requirements!|
%    \begin{macrocode}
\def\xintthecoords  #1{\romannumeral`&&@\expandafter\expandafter\expandafter
                     \XINT_thecoords_a
                     \expandafter\xint_gobble_iii\romannumeral0#1}%
\def\XINT_thecoords_a #1#2% #1=print macro, indispensible for scientific notation
   {\expandafter\XINT_expr_unlock\csname.=\expandafter\XINT_thecoords_b
                         \romannumeral`&&@#1#2,!,!,^\endcsname }%
\def\XINT_thecoords_b #1#2,#3#4,%
   {\xint_gob_til_! #3\XINT_thecoords_c ! (#1#2, #3#4)\XINT_thecoords_b }%
\def\XINT_thecoords_c #1^{}%
%    \end{macrocode}
% \subsection{\csh{xintbareeval}, \csh{xintbarefloateval}, \csh{xintbareiieval}}
%    \begin{macrocode}
\def\xintbareeval      
   {\expandafter\XINT_expr_until_end_a\romannumeral`&&@\XINT_expr_getnext }%
\def\xintbarefloateval 
   {\expandafter\XINT_flexpr_until_end_a\romannumeral`&&@\XINT_expr_getnext }%
\def\xintbareiieval    
   {\expandafter\XINT_iiexpr_until_end_a\romannumeral`&&@\XINT_expr_getnext }%
%    \end{macrocode}
% \subsection{\csh{xintthebareeval}, \csh{xintthebarefloateval}, \csh{xintthebareiieval}}
%    \begin{macrocode}
\def\xintthebareeval      {\expandafter\XINT_expr_unlock\romannumeral0\xintbareeval}%
\def\xintthebarefloateval {\expandafter\XINT_expr_unlock\romannumeral0\xintbarefloateval}%
\def\xintthebareiieval    {\expandafter\XINT_expr_unlock\romannumeral0\xintbareiieval}%
%    \end{macrocode}
% \subsection{\csh{xinteval}, \csh{xintiieval}}
%    \begin{macrocode}
\def\xinteval   {\expandafter\XINT_expr_wrap\romannumeral0\xintbareeval }%
\def\xintiieval {\expandafter\XINT_iiexpr_wrap\romannumeral0\xintbareiieval }%
%    \end{macrocode}
% \subsection{\csh{xintieval}, \csh{XINT_iexpr_wrap}}
% \lverb|Optional argument since 1.1.|
%    \begin{macrocode}
\def\xintieval #1%
   {\ifx [#1\expandafter\XINT_iexpr_withopt\else\expandafter\XINT_iexpr_noopt \fi #1}%
\def\XINT_iexpr_noopt 
   {\expandafter\XINT_iexpr_wrap \expandafter 0\romannumeral0\xintbareeval }%
\def\XINT_iexpr_withopt [#1]%
{%
    \expandafter\XINT_iexpr_wrap\expandafter
    {\the\numexpr \xint_zapspaces #1 \xint_gobble_i\expandafter}%
    \romannumeral0\xintbareeval 
}%
\def\XINT_iexpr_wrap #1#2%
{%
    \expandafter\XINT_expr_wrap
    \csname .=\xintRound::csv {#1}{\XINT_expr_unlock #2}\endcsname 
}%
%    \end{macrocode}
% \subsection{\csh{xintfloateval}, \csh{XINT_flexpr_wrap}, \csh{XINT_flexpr_print}}
% \lverb|Optional argument since 1.1|
%    \begin{macrocode}
\def\xintfloateval #1%
{%
    \ifx [#1\expandafter\XINT_flexpr_withopt_a\else\expandafter\XINT_flexpr_noopt
    \fi #1%
}%
\def\XINT_flexpr_noopt
{%
   \expandafter\XINT_flexpr_withopt_b\expandafter\xinttheDigits
   \romannumeral0\xintbarefloateval 
}%
\def\XINT_flexpr_withopt_a [#1]%
{%
   \expandafter\XINT_flexpr_withopt_b\expandafter
    {\the\numexpr\xint_zapspaces #1 \xint_gobble_i\expandafter}%
    \romannumeral0\xintbarefloateval 
}%
\def\XINT_flexpr_withopt_b #1#2%
{%
    \expandafter\XINT_flexpr_wrap\csname .;#1.=% ; and not : as before b'cause NewExpr
    \XINTinFloat::csv {#1}{\XINT_expr_unlock #2}\endcsname 
}%
\def\XINT_flexpr_wrap { !\XINT_expr_usethe\XINT_protectii\XINT_flexpr_print }%
\def\XINT_flexpr_print #1%
{%
    \expandafter\xintPFloat::csv
    \romannumeral`&&@\expandafter\XINT_expr_unlock_sp\string #1!%
}%
\catcode`: 12
    \def\XINT_expr_unlock_sp #1.;#2.=#3!{{#2}{#3}}%
\catcode`: 11
%    \end{macrocode}
% \subsection{\csh{xintboolexpr}, \csh{xinttheboolexpr}}
%    \begin{macrocode}
\def\xintboolexpr      {\romannumeral0\expandafter\expandafter\expandafter
    \XINT_boolexpr_done \expandafter\xint_gobble_iv\romannumeral0\xinteval }%
\def\xinttheboolexpr   {\romannumeral`&&@\expandafter\expandafter\expandafter
    \XINT_boolexpr_print\expandafter\xint_gobble_iv\romannumeral0\xinteval }%
\def\XINT_boolexpr_done { !\XINT_expr_usethe\XINT_protectii\XINT_boolexpr_print }%
%    \end{macrocode}
% \subsection{\csh{xintifboolexpr}, \csh{xintifboolfloatexpr}, \csh{xintifbooliiexpr}}
% \lverb|Do not work with comma separated expressions.|
%    \begin{macrocode}
\def\xintifboolexpr      #1{\romannumeral0\xintifnotzero {\xinttheexpr #1\relax}}%
\def\xintifboolfloatexpr #1{\romannumeral0\xintifnotzero {\xintthefloatexpr #1\relax}}%
\def\xintifbooliiexpr    #1{\romannumeral0\xintifnotzero {\xinttheiiexpr #1\relax}}%
%    \end{macrocode}
% \subsection{Macros handling csv lists on output (for \csh{XINT_expr_print} et
% al. routines)}
% \localtableofcontents
% \lverb|Changed completely for 1.1, which adds the optional arguments to
% \xintiexpr and \xintfloatexpr.|
% \subsubsection{\csh{XINT_::_end}}
% \lverb|Le mcanisme est le suivant, #2 est dans des accolades et commence par
% ,<sp>. Donc le gobble se dbarrasse du, et le <sp> aprs brace stripping
% arrte un \romannumeral0 ou \romannumeral-`0|
%    \begin{macrocode}
\def\XINT_::_end #1,#2{\xint_gobble_i #2}%
%    \end{macrocode}
% \subsubsection{\csh{xintCSV::csv}}
% \lverb|pour \xinttheiiexpr. 1.1a adds the \romannumeral-`0 for each item,
% which have no use for \xintiiexpr etc..., but are necessary for \xintNewExpr
% to be able to handle comma separated inputs. I am not sure but I think I had
% them just prior to releasing 1.1 but removed them foolishsly.|
%    \begin{macrocode}
\def\xintCSV::csv #1{\expandafter\XINT_csv::_a\romannumeral`&&@#1,^,}%
\def\XINT_csv::_a {\XINT_csv::_b {}}%
\def\XINT_csv::_b #1#2,{\expandafter\XINT_csv::_c \romannumeral`&&@#2,{#1}}%
\def\XINT_csv::_c #1{\if ^#1\expandafter\XINT_::_end\fi\XINT_csv::_d #1}%
\def\XINT_csv::_d #1,#2{\XINT_csv::_b {#2, #1}}% possibly, item #1 is empty.
%    \end{macrocode}
% \subsubsection{\csh{xintSPRaw}, \csh{xintSPRaw::csv}}
% \lverb|Pour \xinttheexpr.
% J'avais voulu optimiser en testant si prsence ou non de [N],
% cependant reduce() produit rsultat sans, et du coup, le /1 peut ne pas
% tre retir. Bon je rajoute un [0] dans reduce. 14/10/25 au moment de
% boucler.
%
% Same added \romannumeral-`0 in 1.1a for \xintNewExpr purposes.|
%    \begin{macrocode}
\def\xintSPRaw    {\romannumeral0\xintspraw }%
\def\xintspraw  #1{\expandafter\XINT_spraw\romannumeral`&&@#1[\W]}%
\def\XINT_spraw #1[#2#3]{\xint_gob_til_W #2\XINT_spraw_a\W\XINT_spraw_p #1[#2#3]}%
\def\XINT_spraw_a\W\XINT_spraw_p #1[\W]{ #1}%
\def\XINT_spraw_p #1[\W]{\xintpraw {#1}}%
\def\xintSPRaw::csv #1{\romannumeral0\expandafter\XINT_spraw::_a\romannumeral`&&@#1,^,}%
\def\XINT_spraw::_a {\XINT_spraw::_b {}}%
\def\XINT_spraw::_b #1#2,{\expandafter\XINT_spraw::_c \romannumeral`&&@#2,{#1}}%
\def\XINT_spraw::_c #1{\if ,#1\xint_dothis\XINT_spraw::_e\fi
                       \if ^#1\xint_dothis\XINT_::_end\fi
                       \xint_orthat\XINT_spraw::_d #1}%
\def\XINT_spraw::_d #1,{\expandafter\XINT_spraw::_e\romannumeral0\XINT_spraw #1[\W],}%
\def\XINT_spraw::_e #1,#2{\XINT_spraw::_b {#2, #1}}%
%    \end{macrocode}
% \subsubsection{\csh{xintIsTrue::csv}}
%    \begin{macrocode}
\def\xintIsTrue::csv #1{\romannumeral0\expandafter\XINT_istrue::_a\romannumeral`&&@#1,^,}%
\def\XINT_istrue::_a {\XINT_istrue::_b {}}%
\def\XINT_istrue::_b #1#2,{\expandafter\XINT_istrue::_c \romannumeral`&&@#2,{#1}}%
\def\XINT_istrue::_c #1{\if ,#1\xint_dothis\XINT_istrue::_e\fi
                        \if ^#1\xint_dothis\XINT_::_end\fi
                        \xint_orthat\XINT_istrue::_d #1}%
\def\XINT_istrue::_d #1,{\expandafter\XINT_istrue::_e\romannumeral0\xintisnotzero {#1},}%
\def\XINT_istrue::_e #1,#2{\XINT_istrue::_b {#2, #1}}%
%    \end{macrocode}
% \subsubsection{\csh{xintRound::csv}}
% \lverb|Pour \xintiexpr avec argument optionnel (finalement, malgr un
% certain overhead lors de l'excution, pour conomiser du code je ne
% distingue plus les deux cas). Reason for annoying expansion bridge is
% related to \xintNewExpr. Attention utilise \XINT_:::_end.|
%    \begin{macrocode}
\def\XINT_:::_end #1,#2#3{\xint_gobble_i #3}%
\def\xintRound::csv #1#2{\romannumeral0\expandafter\XINT_round::_b\expandafter
    {\the\numexpr#1\expandafter}\expandafter{\expandafter}\romannumeral`&&@#2,^,}%
\def\XINT_round::_b #1#2#3,{\expandafter\XINT_round::_c \romannumeral`&&@#3,{#1}{#2}}%
\def\XINT_round::_c #1{\if ,#1\xint_dothis\XINT_round::_e\fi
                       \if ^#1\xint_dothis\XINT_:::_end\fi
                       \xint_orthat\XINT_round::_d #1}%
\def\XINT_round::_d #1,#2{%
      \expandafter\XINT_round::_e\romannumeral0\ifnum#2>\xint_c_
      \expandafter\xintround\else\expandafter\xintiround\fi {#2}{#1},{#2}}%
\def\XINT_round::_e #1,#2#3{\XINT_round::_b {#2}{#3, #1}}%
%    \end{macrocode}
% \subsubsection{\csh{XINTinFloat::csv}}
% \lverb|Pour \xintfloatexpr. Attention, prpare sous la forme digits[N] pour
% traitement par les macros. Pas utilis en sortie. Utilise \XINT_:::_end.
%
% 1.1a: I believe this is not needed for \xintNewExpr, as it is removed by
% re-defined \XINT_flexpr_wrap code, hence no need to add the extra
% \romannumeral-`0. Sub-expressions in \xintNewExpr are not supported.
%
% I didn't start and don't want now to think about it at all.
%|
%    \begin{macrocode}
\def\XINTinFloat::csv #1#2{\romannumeral0\expandafter\XINT_infloat::_b\expandafter
   {\the\numexpr #1\expandafter}\expandafter{\expandafter}\romannumeral`&&@#2,^,}%
\def\XINT_infloat::_b #1#2#3,{\XINT_infloat::_c #3,{#1}{#2}}%
\def\XINT_infloat::_c #1{\if ,#1\xint_dothis\XINT_infloat::_e\fi
                       \if ^#1\xint_dothis\XINT_:::_end\fi
                       \xint_orthat\XINT_infloat::_d #1}%
\def\XINT_infloat::_d #1,#2%
        {\expandafter\XINT_infloat::_e\romannumeral0\XINTinfloat [#2]{#1},{#2}}%
\def\XINT_infloat::_e #1,#2#3{\XINT_infloat::_b {#2}{#3, #1}}%
%    \end{macrocode}
% \subsubsection{\csh{xintPFloat::csv}}
% \lverb|Expansion  cause de \xintNewExpr. Attention  l'ordre, pas le mme que pour
% \XINTinFloat::csv. Donc c'est cette routine qui imprime. Utilise \XINT_:::_end|
%    \begin{macrocode}
\def\xintPFloat::csv #1#2{\romannumeral0\expandafter\XINT_pfloat::_b\expandafter
   {\the\numexpr #1\expandafter}\expandafter{\expandafter}\romannumeral`&&@#2,^,}%
\def\XINT_pfloat::_b #1#2#3,{\expandafter\XINT_pfloat::_c \romannumeral`&&@#3,{#1}{#2}}%
\def\XINT_pfloat::_c #1{\if ,#1\xint_dothis\XINT_pfloat::_e\fi
                       \if ^#1\xint_dothis\XINT_:::_end\fi
                       \xint_orthat\XINT_pfloat::_d #1}%
\def\XINT_pfloat::_d #1,#2%
 {\expandafter\XINT_pfloat::_e\romannumeral0\XINT_pfloat_opt [\xint_relax #2]{#1},{#2}}%
\def\XINT_pfloat::_e #1,#2#3{\XINT_pfloat::_b {#2}{#3, #1}}%
%    \end{macrocode}
% \subsection{\csh{XINT_expr_getnext}: fetching some number then an operator}
% \lverb|Big change in 1.1, no attempt to detect braced stuff anymore as the
% [N] notation is implemented otherwise. Now, braces should not be used at
% all; one level removed, then \romannumeral-`0 expansion.|
%    \begin{macrocode}
\def\XINT_expr_getnext #1%
{%
    \expandafter\XINT_expr_getnext_a\romannumeral`&&@#1%
}%
\def\XINT_expr_getnext_a #1%
{% screens out sub-expressions and \count or \dimen registers/variables
    \xint_gob_til_! #1\XINT_expr_subexpr !% recall this ! has catcode 11
    \ifcat\relax#1% \count or \numexpr etc... token or count, dimen, skip cs
       \expandafter\XINT_expr_countetc
    \else
       \expandafter\expandafter\expandafter\XINT_expr_getnextfork\expandafter\string
    \fi
    #1%
}%
\def\XINT_expr_subexpr !#1\fi !{\expandafter\XINT_expr_getop\xint_gobble_iii }%
%    \end{macrocode}
% \lverb|1.2 adds \ht, \dp, \wd and the eTeX font things.|
%    \begin{macrocode}
\def\XINT_expr_countetc #1%
{%
    \ifx\count#1\else\ifx\dimen#1\else\ifx\numexpr#1\else\ifx\dimexpr#1\else
    \ifx\skip#1\else\ifx\glueexpr#1\else\ifx\fontdimen#1\else\ifx\ht#1\else
    \ifx\dp#1\else\ifx\wd#1\else\ifx\fontcharht#1\else\ifx\fontcharwd#1\else
    \ifx\fontchardp#1\else\ifx\fontcharic#1\else
      \XINT_expr_unpackvar
    \fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
    \expandafter\XINT_expr_getnext\number #1%
}%
\def\XINT_expr_unpackvar\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
    \expandafter\XINT_expr_getnext\number #1%
    {\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
     \expandafter\XINT_expr_getop\csname .=\number#1\endcsname }%
\begingroup
\lccode`*=`#
\lowercase{\endgroup
\def\XINT_expr_getnextfork #1{%
    \if#1*\xint_dothis {\XINT_expr_scan_macropar *}\fi
    \if#1[\xint_dothis {\xint_c_xviii ({}}\fi
    \if#1+\xint_dothis \XINT_expr_getnext \fi
    \if#1.\xint_dothis {\XINT_expr_startdec}\fi
    \if#1-\xint_dothis -\fi
    \if#1(\xint_dothis {\xint_c_xviii ({}}\fi
    \xint_orthat {\XINT_expr_scan_nbr_or_func #1}%
}}%
\def\XINT_expr_scan_macropar #1#2{\expandafter\XINT_expr_getop\csname .=#1#2\endcsname }%
%    \end{macrocode}
% \subsection{The  integer or decimal number or hexa-decimal number or
% function name or variable name or special hacky things big parser}
% \localtableofcontents
% \lverb@1.2 release has replaced chains of \romannumeral-`0 by \csname
% governed expansion. Thus there is no more the limit at about 5000 digits for
% parsed numbers.
% 
% In order to avoid having to lock and unlock in succession to handle the
% scientific part and adjust the exponent according to the number of digits of
% the decimal part, the parsing of this decimal part counts on the fly the
% number of digits it encounters.
%
% There is some slight annoyance with \xintiiexpr which should never be given
% a [n] inside its \csname.=<digits>\endcsname storage of numbers (because its
% arithmetic uses the ii macros which know nothing about the [N] notation).
% Hence if the parser has only seen digits when hitting something else than
% the dot or e (or E), it will not insert a [0]. Thus we very slightly
% compromise the efficiency of \xintexpr and \xintfloatexpr in order to be
% able to share the same code with \xintiiexpr.
%
% Indeed, the parser at this location is completely common to all, it does not
% know if it is working inside \xintexpr or \xintiiexpr. On the other hand if
% a dot or a e (or E) is met, then the (common) parser has no scrupules ending
% this number with a [n], this will provoke an error later if that was within
% an \xintiiexpr, as soon as an arithmetic macro is used.
%
% As the gathered numbers have no spaces, no pluses, no minuses, the only
% remaining issue is with leading zeroes, which are discarded on the fly. The
% hexadecimal numbers leading zeroes are stripped in a second stage by the
% \xintHexToDec macro.
%
% With v1.2, \xinttheexpr . \relax does not work anymore (it did in earlier
% releases). There must be digits either before or after the decimal mark. Thus
% both \xinttheexpr 1.\relax and \xinttheexpr .1\relax are legal.
%
% The ` syntax is here used for special constructs like `+`(..), `*`(..) where
% + or * will be treated as functions. Current implementation pick only one
% token (could have been braced stuff), thus here it will be + or *, and via
% \XINT_expr_op_` this into becomes a suitable
% \XINT_{expr|iiexpr|flexpr}_func_+ (or *). Documentation of 1.1 said to use
% `+`(...), but `+(...) is also valid. The opening parenthesis must be there,
% it is not allowed to come from expansion.@
%    \begin{macrocode}
\catcode96 11 % `
\def\XINT_expr_scan_nbr_or_func #1% this #1 has necessarily here catcode 12
{%
    \if "#1\xint_dothis \XINT_expr_scanhex_I\fi
    \if `#1\xint_dothis {\XINT_expr_onlitteral_`}\fi
    \ifnum \xint_c_ix<1#1 \xint_dothis \XINT_expr_startint\fi
    \xint_orthat \XINT_expr_scanfunc #1%
}%
\def\XINT_expr_onlitteral_` #1#2#3({\xint_c_xviii `{#2}}%
\catcode96 12 % `
\def\XINT_expr_startint #1%
{%
    \if #10\expandafter\XINT_expr_gobz_a\else\XINT_expr_scanint_a\fi #1%
}%
\def\XINT_expr_scanint_a #1#2%
    {\expandafter\XINT_expr_getop\csname.=#1%
     \expandafter\XINT_expr_scanint_b\romannumeral`&&@#2}%
\def\XINT_expr_gobz_a #1%
    {\expandafter\XINT_expr_getop\csname.=%
     \expandafter\XINT_expr_gobz_scanint_b\romannumeral`&&@#1}%
\def\XINT_expr_startdec #1%
    {\expandafter\XINT_expr_getop\csname.=%
     \expandafter\XINT_expr_scandec_a\romannumeral`&&@#1}%
%    \end{macrocode}
% \subsubsection{Integral part (skipping zeroes)}
% \lverb|1.2 has modified the code to give highest priority to digits, the
% accelerating impact is non-negligeable. I don't think the doubled \string is
% a serious penalty.|
%    \begin{macrocode}
\def\XINT_expr_scanint_b #1%
{%
    \ifcat \relax #1\expandafter\XINT_expr_scanint_endbycs\expandafter #1\fi
    \ifnum\xint_c_ix<1\string#1 \else\expandafter\XINT_expr_scanint_c\fi
    \string#1\XINT_expr_scanint_d
}%
\def\XINT_expr_scanint_d #1%
{%
    \expandafter\XINT_expr_scanint_b\romannumeral`&&@#1%
}%
\def\XINT_expr_scanint_endbycs#1#2\XINT_expr_scanint_d{\endcsname #1}%
%    \end{macrocode}
% \lverb|With 1.2d the tacit multiplication in front of a variable name or
% function name is now done with a higher precedence, intermediate between the
% common one of * and / and the one of ^. Thus x/2y is like x/(2y), but x^2y
% is like x^2*y and 2y! is not (2y)! but 2*y!.
%
% Finally, 1.2d has moved away from the _scan macros all the business of the
% tacit multiplication in one unique place via \XINT_expr_getop. For this, the
% ending token is not first given to \string as was done earlier before
% handing over back control to \XINT_expr_getop. Earlier we had to identify
% the catcode 11 ! signaling a sub-expression here. With no \string applied
% we can do it in \XINT_expr_getop. As a corollary of this displacement,
% parsing of big numbers should be a tiny bit faster now.|
%    \begin{macrocode}
\def\XINT_expr_scanint_c\string #1\XINT_expr_scanint_d
{%
    \if    e#1\xint_dothis{[\the\numexpr0\XINT_expr_scanexp_a +}\fi
    \if    E#1\xint_dothis{[\the\numexpr0\XINT_expr_scanexp_a +}\fi
    \if    .#1\xint_dothis{\XINT_expr_startdec_a .}\fi
    \xint_orthat {\endcsname #1}%
}%
\def\XINT_expr_startdec_a .#1%
{%
    \expandafter\XINT_expr_scandec_a\romannumeral`&&@#1%
}%
\def\XINT_expr_scandec_a #1%
{%
    \if .#1\xint_dothis{\endcsname..}\fi
    \xint_orthat {\XINT_expr_scandec_b 0.#1}%
}%
\def\XINT_expr_gobz_scanint_b #1%
{%
    \ifcat \relax #1\expandafter\XINT_expr_gobz_scanint_endbycs\expandafter #1\fi
    \ifnum\xint_c_x<1\string#1 \else\expandafter\XINT_expr_gobz_scanint_c\fi
    \string#1\XINT_expr_scanint_d
}%
\def\XINT_expr_gobz_scanint_endbycs#1#2\XINT_expr_scanint_d{0\endcsname #1}%
\def\XINT_expr_gobz_scanint_c\string #1\XINT_expr_scanint_d
{%
    \if    e#1\xint_dothis{0[\the\numexpr0\XINT_expr_scanexp_a +}\fi
    \if    E#1\xint_dothis{0[\the\numexpr0\XINT_expr_scanexp_a +}\fi
    \if    .#1\xint_dothis{\XINT_expr_gobz_startdec_a .}\fi
    \if    0#1\xint_dothis\XINT_expr_gobz_scanint_d\fi
    \xint_orthat {0\endcsname #1}%
}%
\def\XINT_expr_gobz_scanint_d #1%
{%
    \expandafter\XINT_expr_gobz_scanint_b\romannumeral`&&@#1%
}%
\def\XINT_expr_gobz_startdec_a .#1%
{%
    \expandafter\XINT_expr_gobz_scandec_a\romannumeral`&&@#1%
}%
\def\XINT_expr_gobz_scandec_a #1%
{%
    \if .#1\xint_dothis{0\endcsname..}\fi
    \xint_orthat {\XINT_expr_gobz_scandec_b 0.#1}%
}%
%    \end{macrocode}
% \subsubsection{Fractional part}
% \lverb|Annoying duplication of code to allow 0. as input.
%
% 1.2a corrects a very bad bug in 1.2 \XINT_expr_gobz_scandec_b which should
% have stripped leading zeroes in the fractional part but didn't; as a result
% \xinttheexpr 0.01\relax returned 0 =:-((( Thanks to Kroum Tzanev who
% reported the issue. Does it improve things if I say the bug was introduced
% in 1.2, it wasn't present before ?|
%    \begin{macrocode}
\def\XINT_expr_scandec_b #1.#2%
{%
    \ifcat \relax #2\expandafter\XINT_expr_scandec_endbycs\expandafter#2\fi
    \ifnum\xint_c_ix<1\string#2 \else\expandafter\XINT_expr_scandec_c\fi
    \string#2\expandafter\XINT_expr_scandec_d\the\numexpr #1-\xint_c_i.%
}%
\def\XINT_expr_scandec_endbycs #1#2\XINT_expr_scandec_d
    \the\numexpr#3-\xint_c_i.{[#3]\endcsname #1}%
\def\XINT_expr_scandec_d #1.#2%
{%
    \expandafter\XINT_expr_scandec_b
    \the\numexpr #1\expandafter.\romannumeral`&&@#2%
}%
\def\XINT_expr_scandec_c\string #1#2\the\numexpr#3-\xint_c_i.%
{%
    \if    e#1\xint_dothis{[\the\numexpr#3\XINT_expr_scanexp_a +}\fi
    \if    E#1\xint_dothis{[\the\numexpr#3\XINT_expr_scanexp_a +}\fi
    \xint_orthat {[#3]\endcsname #1}%
}%
%    \end{macrocode}
% \lverb|For bugfix release 1.2a, I only need code that works, I will think
% another day about making it perhaps more elegant/efficient.|
%    \begin{macrocode}
\def\XINT_expr_gobz_scandec_b #1.#2%
{%
    \ifcat \relax #2\expandafter\XINT_expr_gobz_scandec_endbycs\expandafter#2\fi
    \ifnum\xint_c_ix<1\string#2 \else\expandafter\XINT_expr_gobz_scandec_c\fi
    \if0#2\expandafter\xint_firstoftwo\else\expandafter\xint_secondoftwo\fi
    {\expandafter\XINT_expr_gobz_scandec_b}%
    {\string#2\expandafter\XINT_expr_scandec_d}\the\numexpr#1-\xint_c_i.%
}%
%    \end{macrocode}
% \lverb|Even if number is zero leave a trace in [..] of its formation ? for
% code tracing purposes ? Finally no. But in case of exponential part, yes as
% I don't want to write extra code just to handle that case.|
%    \begin{macrocode}
\def\XINT_expr_gobz_scandec_endbycs #1#2\xint_c_i.{0[0]\endcsname #1}%
\def\XINT_expr_gobz_scandec_c\if0#1#2\fi #3\xint_c_i.%
{%
    \if    e#1\xint_dothis{0[\the\numexpr0\XINT_expr_scanexp_a +}\fi
    \if    E#1\xint_dothis{0[\the\numexpr0\XINT_expr_scanexp_a +}\fi
    \xint_orthat {0[0]\endcsname #1}%
}%
%    \end{macrocode}
% \subsubsection{Scientific notation}
% \lverb|Some pluses and minuses are allowed at the start of the scientific
% part, however not later, and no parenthesis.|
%    \begin{macrocode}
\def\XINT_expr_scanexp_a #1#2%
{%
    #1\expandafter\XINT_expr_scanexp_b\romannumeral`&&@#2%
}%
\def\XINT_expr_scanexp_b #1%
{%
    \ifcat \relax #1\expandafter\XINT_expr_scanexp_endbycs\expandafter #1\fi
    \ifnum\xint_c_ix<1\string#1 \else\expandafter\XINT_expr_scanexp_c\fi
    \string#1\XINT_expr_scanexp_d
}%
\def\XINT_expr_scanexpr_endbycs#1#2\XINT_expr_scanexp_d {]\endcsname #1}%
\def\XINT_expr_scanexp_d #1%
{%
    \expandafter\XINT_expr_scanexp_bb\romannumeral`&&@#1%
}%
\def\XINT_expr_scanexp_c\string #1\XINT_expr_scanexp_d
{%
    \if    +#1\xint_dothis {\XINT_expr_scanexp_a +}\fi
    \if    -#1\xint_dothis {\XINT_expr_scanexp_a -}\fi
    \xint_orthat {]\endcsname #1}%
}%
\def\XINT_expr_scanexp_bb #1%
{%
    \ifcat \relax #1\expandafter\XINT_expr_scanexp_endbycs_b\expandafter #1\fi
    \ifnum\xint_c_ix<1\string#1 \else\expandafter\XINT_expr_scanexp_cb\fi
    \string#1\XINT_expr_scanexp_db
}%
\def\XINT_expr_scanexp_endbycs_b#1#2\XINT_expr_scanexp_db {]\endcsname #1}%
\def\XINT_expr_scanexp_db #1%
{%
    \expandafter\XINT_expr_scanexp_bb\romannumeral`&&@#1%
}%
\def\XINT_expr_scanexp_cb\string #1\XINT_expr_scanexp_db {]\endcsname #1}%
%    \end{macrocode}
% \subsubsection{Hexadecimal numbers}
% \lverb|1.2d has moved most of the handling of tacit multiplication to
% \XINT_expr_getop, but we have to do some of it here, because we apply
% \string before calling \XINT_expr_scanhexI_aa. I do not insert the *
% in \XINT_expr_scanhexI_a, because it is its higher precedence variant which
% will is expected, to do the same as when a non-hexadecimal number prefixes a
% sub-expression. Tacit multiplication in front of variable or function names
% will not work (because of this \string).|
%    \begin{macrocode}
\def\XINT_expr_scanhex_I #1% #1="
{%
    \expandafter\XINT_expr_getop\csname.=\expandafter
    \XINT_expr_unlock_hex_in\csname.=\XINT_expr_scanhexI_a
}%
\def\XINT_expr_scanhexI_a #1%
{%
    \ifcat #1\relax\xint_dothis{.>\endcsname\endcsname #1}\fi
    \ifx   !#1\xint_dothis{.>\endcsname\endcsname !}\fi
    \xint_orthat {\expandafter\XINT_expr_scanhexI_aa\string #1}%
}%
\def\XINT_expr_scanhexI_aa #1%
{%
    \if\ifnum`#1>`/
       \ifnum`#1>`9
       \ifnum`#1>`@
       \ifnum`#1>`F
       0\else1\fi\else0\fi\else1\fi\else0\fi 1%
       \expandafter\XINT_expr_scanhexI_b
    \else
       \if .#1%
           \expandafter\xint_firstoftwo
       \else % gather what we got so far, leave catcode 12 #1 in stream
           \expandafter\xint_secondoftwo
       \fi
       {\expandafter\XINT_expr_scanhex_transition}%
       {\xint_afterfi {.>\endcsname\endcsname}}%
    \fi
    #1%
}%
\def\XINT_expr_scanhexI_b #1#2%
{%
    #1\expandafter\XINT_expr_scanhexI_a\romannumeral`&&@#2%
}%
\def\XINT_expr_scanhex_transition .#1%
{%
    \expandafter.\expandafter.\expandafter
    \XINT_expr_scanhexII_a\romannumeral`&&@#1%
}%
\def\XINT_expr_scanhexII_a #1%
{%
    \ifcat #1\relax\xint_dothis{\endcsname\endcsname#1}\fi
    \ifx   !#1\xint_dothis{\endcsname\endcsname !}\fi
    \xint_orthat {\expandafter\XINT_expr_scanhexII_aa\string #1}%
}%
\def\XINT_expr_scanhexII_aa #1%
{%
    \if\ifnum`#1>`/
       \ifnum`#1>`9
       \ifnum`#1>`@
       \ifnum`#1>`F
       0\else1\fi\else0\fi\else1\fi\else0\fi 1%
       \expandafter\XINT_expr_scanhexII_b
    \else
       \xint_afterfi {\endcsname\endcsname}%
    \fi
    #1%
}%
\def\XINT_expr_scanhexII_b #1#2%
{%
    #1\expandafter\XINT_expr_scanhexII_a\romannumeral`&&@#2%
}%
%    \end{macrocode}
% \subsubsection{Parsing names of functions and variables}
%    \begin{macrocode}
\def\XINT_expr_scanfunc
{%
    \expandafter\XINT_expr_func\romannumeral`&&@\XINT_expr_scanfunc_a
}%
\def\XINT_expr_scanfunc_a #1#2%
{%
    \expandafter #1\romannumeral`&&@\expandafter\XINT_expr_scanfunc_b\romannumeral`&&@#2%
}%
%    \end{macrocode}
% \lverb|This used to handle: 1) tacit multiplication by a variable in
% front a of sub-expression, 2) (indirectly) tacit multiplication in front of
% a \count etc..., 3) functions are recognized via an encountered opening
% parenthesis (but later this must be disambiguated from variables with tacit
% multiplication) 4) _ is allowed as part of variable or function names 5)
% also @ (used privately), 6) also digits, 7) letters or tokens of category code
% letters. 
%
% In case 1), v1.2d does not insert the * itself, it is left to
% \XINT_expr_getop to do it. The \ifx !#1 test is now dropped. The
% \ifcat\relax#1 test is only there to avoid an \escapechar giving a digit
% fooling up the \xint_c_ix<\string#1 test next. I almost suppressed it
% because it is a silly overhead for a silly liberty left to the user.
% Probably at some point in the future I will just say: don't use a digit as
% escapechar !|
%    \begin{macrocode}
\def\XINT_expr_scanfunc_b #1%
{%
  \ifcat \relax#1\xint_dothis{(_}\fi 
  \if (#1\xint_dothis{\xint_firstoftwo{(`}}\fi
  \if _#1\xint_dothis \XINT_expr_scanfunc_a \fi
  \if @#1\xint_dothis \XINT_expr_scanfunc_a \fi
  \ifnum \xint_c_ix<1\string#1 \xint_dothis \XINT_expr_scanfunc_a \fi
  \ifcat a#1\xint_dothis \XINT_expr_scanfunc_a \fi
  \xint_orthat {(_}%
    #1%
}%
%    \end{macrocode}
% \lverb@Comments written 2015/11/12: earlier there was an \ifcsname test for
% checking if we had a variable in front of a (, for tacit multiplication for
% example in x(y+z(x+w)) to work. But after I had implemented functions (that
% was yesterday...), I had the problem if was impossible to re-declare a
% variable name such as "f" as a function name. The problem is that here we
% can not test if the function is available because we don't know if we are in
% expr, iiexpr or floatexpr. The \xint_c_xviii causes all fetching operations
% to stop and control is handed over to the routines which will be expr,
% iiexpr ou floatexpr specific, i.e. the \XINT_{expr|iiexpr|flexpr}_op_{`|_}
% which are invoked by the until_<op>_b macros earlier in the stream.
% Functions may exist for one but not the two other parsers. Variables are
% declared via one parser and usable in the others, but naturally \xintiiexpr
% has its restrictions.
%
% Thinking about this again I decided to treat a priori cases such as x(...)
% as functions, after having assigned to each variable a low-weight macro
% which will convert this into _getop\.=<value of x>*(...). To activate that
% macro at the right time I could for this exploit the "onlitteral" intercept,
% which is parser independent (1.2c).
%
% This led to me necessarily to rewrite partially the seq, add, mul, subs,
% iter ... routines as now the variables fetch only one token. I think the
% thing is more efficient.
%
% 1.2c had \def\XINT_expr_func #1(#2{\xint_c_xviii #2{#1}}
% 
% In \XINT_expr_func the #2 is _ if #1 must be a variable name, or #2=` if #1
% must be either a function name or possibly a variable name which will then
% have to be followed by tacit multiplication before the opening parenthesis.
%
% The \xint_c_xviii is there because _op_` must know in which parser
% it works. Dispendious for _. Hence I modify for 1.2d. @
%    \begin{macrocode}
\def\XINT_expr_func #1(#2{\if _#2\xint_dothis\XINT_expr_op__\fi
                          \xint_orthat{\xint_c_xviii #2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{XINT_expr_getop}: finding the next operator or closing
% parenthesis or end of expression}
% \lverb|Release 1.1 implements multi-character operators.
%
% 1.2d adds tacit mutiplication also in front of variable or functions names
% starting with a letter, not only a @ or a _ as was already the case. This is
% for (x+y)z situations. It also applies higher precedence in cases like x/2y
% or x/2@, or x/2max(3,5), or x/2\xintexpr 3\relax.
%
% In fact, finally I decide that all sorts of tacit multiplication will always
% use the higher precedence.
%
% Indeed I hesitated somewhat: with the current code one does not know if
% \XINT_expr_getop as invoked after a closing parenthesis or because a number
% parsing ended, and I felt distinguishing the two was unneeded extra stuff.
% This means cases like (a+b)/(c+d)(e+f) will first multiply the last two
% parenthesized terms.
%
% The ! starting a sub-expression must be distinguished from the post-fix !
% for factorial, thus we must not do a too early \string. In versions < 1.2c,
% the catcode 11 ! had to be identified in all branches of the number or
% function scans. Here it is simply treated as a special case of a letter.|
%    \begin{macrocode}
\def\XINT_expr_getop #1#2% this #1 is the current locked computed value
{%
    \expandafter\XINT_expr_getop_a\expandafter #1\romannumeral`&&@#2%
}%
\catcode`* 11
\def\XINT_expr_getop_a #1#2%
{%
    \ifx   \relax #2\xint_dothis\xint_firstofthree\fi
    \ifcat \relax #2\xint_dothis\xint_secondofthree\fi
    \if    _#2\xint_dothis      \xint_secondofthree\fi
    \if    @#2\xint_dothis      \xint_secondofthree\fi
    \if    (#2\xint_dothis      \xint_secondofthree\fi
    \ifcat a#2\xint_dothis      \xint_secondofthree\fi
    \xint_orthat \xint_thirdofthree
    {\XINT_expr_foundend #1}%
    {\XINT_expr_precedence_*** *#1#2}% tacit multiplication with higher precedence
    {\expandafter\XINT_expr_getop_b \string#2#1}%
}%
\catcode`* 12
\def\XINT_expr_foundend {\xint_c_ \relax }% \relax is a place holder here.
%    \end{macrocode}
% \lverb|? is a very special operator with top precedence which will check if
% the next token is another ?, while avoiding removing a brace pair from token
% stream due to its syntax. Pre 1.1 releases used : rather than ??, but we
% need : for Python like slices of lists.|
%    \begin{macrocode}
\def\XINT_expr_getop_b #1%
{%
     \if '#1\xint_dothis{\XINT_expr_binopwrd }\fi
     \if ?#1\xint_dothis{\XINT_expr_precedence_? ?}\fi
     \xint_orthat       {\XINT_expr_scanop_a #1}%
}%
\def\XINT_expr_binopwrd #1#2'{\expandafter\XINT_expr_foundop_a
    \csname XINT_expr_itself_\xint_zapspaces #2 \xint_gobble_i\endcsname #1}%
\def\XINT_expr_scanop_a #1#2#3%
    {\expandafter\XINT_expr_scanop_b\expandafter #1\expandafter #2\romannumeral`&&@#3}%
\def\XINT_expr_scanop_b #1#2#3%
{%
  \ifcat#3\relax\xint_dothis{\XINT_expr_foundop_a #1#2#3}\fi
  \ifcsname XINT_expr_itself_#1#3\endcsname
  \xint_dothis
        {\expandafter\XINT_expr_scanop_c\csname XINT_expr_itself_#1#3\endcsname #2}\fi
  \xint_orthat {\XINT_expr_foundop_a #1#2#3}%
}%
\def\XINT_expr_scanop_c #1#2#3%
{%
  \expandafter\XINT_expr_scanop_d\expandafter #1\expandafter #2\romannumeral`&&@#3%
}%
\def\XINT_expr_scanop_d #1#2#3%
{%
  \ifcat#3\relax \xint_dothis{\XINT_expr_foundop #1#2#3}\fi
  \ifcsname XINT_expr_itself_#1#3\endcsname
  \xint_dothis
        {\expandafter\XINT_expr_scanop_c\csname XINT_expr_itself_#1#3\endcsname #2}\fi
  \xint_orthat {\csname XINT_expr_precedence_#1\endcsname #1#2#3}%
}%
\def\XINT_expr_foundop_a #1%
{%
    \ifcsname XINT_expr_precedence_#1\endcsname
        \csname XINT_expr_precedence_#1\expandafter\endcsname
        \expandafter #1%
    \else
        \xint_afterfi{\XINT_expr_unknown_operator {#1}\XINT_expr_getop}%
    \fi
}%
\def\XINT_expr_unknown_operator #1{\xintError:removed \xint_gobble_i {#1}}%
\def\XINT_expr_foundop #1{\csname XINT_expr_precedence_#1\endcsname #1}%
%    \end{macrocode}
% \subsection{Expansion spanning; opening and closing parentheses}
% \lverb|Version 1.1 had a hack inside the until macros for handling the omit
% and abort in iterations over dummy variables. This has been removed by
% 1.2c, see the subsection where omit and abort are discussed.|
%    \begin{macrocode}
\catcode`) 11
\def\XINT_tmpa #1#2#3#4% (avant #4#5)
{%
    \def#1##1%
    {%
        \xint_UDsignfork
                     ##1{\expandafter#1\romannumeral`&&@#3}%
                       -{#2##1}%
        \krof
    }%
    \def#2##1##2%
    {%
        \ifcase ##1\expandafter\XINT_expr_done
        \or\xint_afterfi{\XINT_expr_extra_)
                          \expandafter #1\romannumeral`&&@\XINT_expr_getop }%
        \else
        \xint_afterfi{\expandafter#1\romannumeral`&&@\csname XINT_#4_op_##2\endcsname }%
        \fi
    }%
}%
\def\XINT_expr_extra_) {\xintError:removed }%
\xintFor #1 in {expr,flexpr,iiexpr} \do {%
    \expandafter\XINT_tmpa
    \csname XINT_#1_until_end_a\expandafter\endcsname
    \csname XINT_#1_until_end_b\expandafter\endcsname
    \csname XINT_#1_op_-vi\endcsname
    {#1}%
}%
\def\XINT_tmpa #1#2#3#4#5#6%
{%
    \def #1##1{\expandafter #3\romannumeral`&&@\XINT_expr_getnext }%
    \def #2{\expandafter #3\romannumeral`&&@\XINT_expr_getnext }%
    \def #3##1{\xint_UDsignfork
                ##1{\expandafter #3\romannumeral`&&@#5}%
                  -{#4##1}%
               \krof }%
    \def #4##1##2{\ifcase ##1\expandafter\XINT_expr_missing_)
      \or   \csname XINT_#6_op_##2\expandafter\endcsname
      \else 
      \xint_afterfi{\expandafter #3\romannumeral`&&@\csname XINT_#6_op_##2\endcsname }%
      \fi
    }%
}%
\def\XINT_expr_missing_) {\xintError:inserted \xint_c_ \XINT_expr_done }%
%    \end{macrocode}
% \lverb|We should be using until_( notation to stay synchronous with until_+,
% until_* etc..., but I found that until_) said more.|
%    \begin{macrocode}
\catcode`) 12
\xintFor #1 in {expr,flexpr,iiexpr} \do {%
    \expandafter\XINT_tmpa
    \csname XINT_#1_op_(\expandafter\endcsname
    \csname XINT_#1_oparen\expandafter\endcsname
    \csname XINT_#1_until_)_a\expandafter\endcsname
    \csname XINT_#1_until_)_b\expandafter\endcsname
    \csname XINT_#1_op_-vi\endcsname
    {#1}%
}%
\expandafter\let\csname XINT_expr_precedence_)\endcsname\xint_c_i
%    \end{macrocode}
% \subsection{\textbar, \textbar\textbar, \&,
% \&\&, <, >, =, ==, <=, >=, !=, +, \textendash,
% \texorpdfstring{\protect\lowast}{*}, /, \textasciicircum,
% \texorpdfstring{\protect\lowast\protect\lowast}{**}, //, /:, .., ..[, ]..,
% ][, ][:, :],  and ++ operators}
% \localtableofcontents
% \subsubsection{Square brackets for lists, the
% !? for omit and abort, and the ++ postfix construct}
% \lverb|This is all very clever and only need setting some suitable precedence
% levels, if only I could understand what I did in 2014... just joking. Notice
% that op_) macros are defined here in the \xintFor loop.
% 
% There is some clever business going on here with the letter a for handling
% constructs such as [3..5]*2 (I think...).
%
% 1.2c has replaced 1.1's private dealings with "^C" (which was done before
% dummy variables got implemented) by use of "!?". See discussion of omit and abort.|
%    \begin{macrocode}
\expandafter\let\csname XINT_expr_precedence_]\endcsname\xint_c_i
\expandafter\let\csname XINT_expr_precedence_;\endcsname\xint_c_i
\let\XINT_expr_precedence_a \xint_c_xviii
\let\XINT_expr_precedence_!? \xint_c_ii
\expandafter\let\csname XINT_expr_precedence_++)\endcsname \xint_c_i
%    \end{macrocode}
% \lverb|Comments added 2015/11/13 Here we have in particular the mechanism
% for post action on lists via op_] The precedence_] is the one of a closing
% parenthesis. We need the closing parenthesis to do its job, hence we can not
% define a op_]+ operator for example, as we want to assign it the precedence
% of addition not the one of closing parenthesis. The trick I used in 1.1 was
% to let the op_] insert the letter a, this letter exceptionnally also being a
% legitimate operator, launch the _getop and let it find a a*, a+, a/, a-, a^,
% a** operator standing for ]*, ]+, ]/, ]^, ]** postfix item by item list
% operator. I thought I had in mind an example to show that having defined
% op_a and precedence_a for the letter a caused a reduction in syntax for this
% letter, but it seems I am lacking now an example.
% 
% 2015/11/18: for 1.2d I accelerate \XINT_expr_op_] to jump over the
% \XINT_expr_getop_a which now does tacit multiplications also in front of
% letters, for reasons of things like, (x+y)z, hence it must not see the "a".
% I could have used a catcode12 a possibly, but anyhow jumping straight to
% \XINT_expr_scanop_a skips a few expansion steps (up to the potential price
% of less conceptual programming if I change things in the future.)|
%    \begin{macrocode}
\catcode`. 11 \catcode`= 11 \catcode`+ 11
\xintFor #1 in {expr,flexpr,iiexpr} \do {%
    \expandafter\let\csname XINT_#1_op_)\endcsname \XINT_expr_getop
    \expandafter\let\csname XINT_#1_op_;\endcsname \space
    \expandafter\def\csname XINT_#1_op_]\endcsname ##1{\XINT_expr_scanop_a a##1}%
    \expandafter\let\csname XINT_#1_op_a\endcsname \XINT_expr_getop
%    \end{macrocode}
% \lverb|1.1 2014/10/29 did \expandafter\.=+\xintiCeil which transformed it into
% \romannumeral0\xinticeil, which seems a bit weird. This exploited the fact
% that dummy variables macros could back then pick braced material (which in the
% case at hand here ended being {\romannumeral0\xinticeil...} and were submitted
% to two expansions. The result of this was to provide a not value which got
% expanded only in the first loop of the :_A and following macros of seq,
% iter, rseq, etc...
%
% Anyhow with 1.2c I have changed the implementation of dummy variables which
% now need to fetch a single locked token, which they do not expand.
%
% The \xintiCeil appears a bit dispendious, but I need the starting value in a
% \numexpr compatible form in the iteration loops.|
%    \begin{macrocode}
    \expandafter\def\csname XINT_#1_op_++)\endcsname ##1##2\relax
  {\expandafter\XINT_expr_foundend \expandafter 
      {\expandafter\.=+\csname .=\xintiCeil{\XINT_expr_unlock ##1}\endcsname }}%
}%
\catcode`. 12 \catcode`= 12 \catcode`+ 12
%    \end{macrocode}
% \lverb|1.2d adds the *** for tying via tacit multiplication, for example
% x/2y. Actually I don't need the _itself mechanism for ***, only a precedence.|
%    \begin{macrocode}
\catcode`& 12
\xintFor* #1 in {{==}{<=}{>=}{!=}{&&}{||}{**}{//}{/:}{..}{..[}{].}{]..}%
                 {+[}{-[}{*[}{/[}{**[}{^[}{a+}{a-}{a*}{a/}{a**}{a^}%
                 {][}{][:}{:]}{!?}{++}{++)}}%{***}}
    \do {\expandafter\def\csname XINT_expr_itself_#1\endcsname {#1}}%
\catcode`& 7
\expandafter\let\csname XINT_expr_precedence_***\endcsname \xint_c_viii
%    \end{macrocode}
% \subsubsection{The \textbar, \&, xor, <, >, =, <=, >=, !=, //, /: and ..
% operators for expr and floatexpr}
%    \begin{macrocode}
\def\XINT_tmpc #1#2#3#4#5#6#7#8%
{%
  \def #1##1% \XINT_expr_op_<op> ou flexpr ou iiexpr
  {% keep value, get next number and operator, then do until
    \expandafter #2\expandafter ##1%
    \romannumeral`&&@\expandafter\XINT_expr_getnext }%
  \def #2##1##2% \XINT_expr_until_<op>_a ou flexpr ou iiexpr
  {\xint_UDsignfork ##2{\expandafter #2\expandafter ##1\romannumeral`&&@#4}%
    -{#3##1##2}%
    \krof }%
  \def #3##1##2##3##4% \XINT_expr_until_<op>_b ou flexpr ou iiexpr
  {% either execute next operation now, or first do next (possibly unary)
    \ifnum ##2>#5%
    \xint_afterfi {\expandafter #2\expandafter ##1\romannumeral`&&@%
      \csname XINT_#8_op_##3\endcsname {##4}}%
    \else \xint_afterfi {\expandafter ##2\expandafter ##3%
      \csname .=#6{\XINT_expr_unlock ##1}{\XINT_expr_unlock ##4}\endcsname }%
    \fi }%
  \let #7#5%
}%
\def\XINT_tmpb #1#2#3#4#5#6%
{%
  \expandafter\XINT_tmpc
  \csname XINT_#1_op_#3\expandafter\endcsname
  \csname XINT_#1_until_#3_a\expandafter\endcsname
  \csname XINT_#1_until_#3_b\expandafter\endcsname
  \csname XINT_#1_op_-#5\expandafter\endcsname
  \csname xint_c_#4\expandafter\endcsname
  \csname #2#6\expandafter\endcsname
  \csname XINT_expr_precedence_#3\endcsname {#1}%
}%
\catcode`& 12
\xintFor #1 in {expr, flexpr} \do {%
  \def\XINT_tmpa ##1{\XINT_tmpb {#1}{xint}##1}%
  \xintApplyInline {\XINT_tmpa }{%
    {|{iii}{vi}{OR}}%
    {&{iv}{vi}{AND}}%
    {{xor}{iii}{vi}{XOR}}%
    {<{v}{vi}{Lt}}%
    {>{v}{vi}{Gt}}%
    {={v}{vi}{Eq}}%
    {{<=}{v}{vi}{LtorEq}}%
    {{>=}{v}{vi}{GtorEq}}%
    {{!=}{v}{vi}{Neq}}%
    {{..}{iii}{vi}{Seq::csv}}%
    {{//}{vii}{vii}{DivTrunc}}%
    {{/:}{vii}{vii}{Mod}}%
  }%
}%
\catcode`& 7
%    \end{macrocode}
% \subsubsection{The +, \textendash, \texorpdfstring{\protect\lowast}{*}, /,
% \textasciicircum,  ..[, and ].. operators for expr and floatexpr}
% \lverb|1.2d needed some room between /, * and ^. Hence precedence for ^ is
% now at 9.|
%    \begin{macrocode}
\def\XINT_tmpa #1{\XINT_tmpb {expr}{xint}#1}%
\xintApplyInline {\XINT_tmpa }{%
  {+{vi}{vi}{Add}}%
  {-{vi}{vi}{Sub}}%
  {*{vii}{vii}{Mul}}%
  {/{vii}{vii}{Div}}%
  {^{ix}{ix}{Pow}}%
  {{..[}{iii}{vi}{SeqA::csv}}%
  {{]..}{iii}{vi}{SeqB::csv}}%
}%
\def\XINT_tmpa #1{\XINT_tmpb {flexpr}{XINTinFloat}#1}%
\xintApplyInline {\XINT_tmpa }{%
  {+{vi}{vi}{Add}}%
  {-{vi}{vi}{Sub}}%
  {*{vii}{vii}{Mul}}%
  {/{vii}{vii}{Div}}%
  {^{ix}{ix}{Power}}%
  {{..[}{iii}{vi}{SeqA::csv}}%
  {{]..}{iii}{vi}{SeqB::csv}}%
}%
%    \end{macrocode}
% \subsubsection{The previous operators for iiexpr}
%    \begin{macrocode}
\def\XINT_tmpa #1{\XINT_tmpb {iiexpr}{xint}#1}%
\catcode`& 12
\xintApplyInline {\XINT_tmpa }{%
    {|{iii}{vi}{OR}}%
    {&{iv}{vi}{AND}}%
    {{xor}{iii}{vi}{XOR}}%
    {<{v}{vi}{iiLt}}%
    {>{v}{vi}{iiGt}}%
    {={v}{vi}{iiEq}}%
    {{<=}{v}{vi}{iiLtorEq}}%
    {{>=}{v}{vi}{iiGtorEq}}%
    {{!=}{v}{vi}{iiNeq}}%
  {+{vi}{vi}{iiAdd}}%
  {-{vi}{vi}{iiSub}}%
  {*{vii}{vii}{iiMul}}%
  {/{vii}{vii}{iiDivRound}}% CHANGED IN 1.1! PREVIOUSLY DID EUCLIDEAN QUOTIENT
  {^{ix}{ix}{iiPow}}%
  {{..[}{iii}{vi}{iiSeqA::csv}}%
  {{]..}{iii}{vi}{iiSeqB::csv}}%
  {{..}{iii}{vi}{iiSeq::csv}}%
  {{//}{vii}{vii}{iiDivTrunc}}%
  {{/:}{vii}{vii}{iiMod}}%
}%
\catcode`& 7
%    \end{macrocode}
% \subsubsection{The ]+, ]\textendash, ]\texorpdfstring{\protect\lowast}{*}, ]/, ]\textasciicircum, +[, \textendash[, \texorpdfstring{\protect\lowast}{*}[, /[, and \textasciicircum[ list
% operators}
% \paragraph{\csh{XINT_expr_binop_inline_b}}\par
% \lverb|This handles acting on comma separated values (no need to bother
% about spaces in this context; expansion in a \csname...\endcsname.|
%    \begin{macrocode}
\def\XINT_expr_binop_inline_a
   {\expandafter\xint_gobble_i\romannumeral`&&@\XINT_expr_binop_inline_b }%
\def\XINT_expr_binop_inline_b #1#2,{\XINT_expr_binop_inline_c #2,{#1}}%
\def\XINT_expr_binop_inline_c #1{%
   \if ,#1\xint_dothis\XINT_expr_binop_inline_e\fi
   \if ^#1\xint_dothis\XINT_expr_binop_inline_end\fi
   \xint_orthat\XINT_expr_binop_inline_d #1}%
\def\XINT_expr_binop_inline_d #1,#2{,#2{#1}\XINT_expr_binop_inline_b {#2}}%
\def\XINT_expr_binop_inline_e #1,#2{,\XINT_expr_binop_inline_b {#2}}%
\def\XINT_expr_binop_inline_end #1,#2{}%
\def\XINT_tmpc #1#2#3#4#5#6#7#8%
{%
  \def #1##1% \XINT_expr_op_<op> ou flexpr ou iiexpr
  {% keep value, get next number and operator, then do until
    \expandafter #2\expandafter ##1%
    \romannumeral`&&@\expandafter\XINT_expr_getnext }%
  \def #2##1##2% \XINT_expr_until_<op>_a ou flexpr ou iiexpr
  {\xint_UDsignfork ##2{\expandafter #2\expandafter ##1\romannumeral`&&@#4}%
    -{#3##1##2}%
    \krof }%
  \def #3##1##2##3##4% \XINT_expr_until_<op>_b ou flexpr ou iiexpr
  {% either execute next operation now, or first do next (possibly unary)
    \ifnum ##2>#5%
    \xint_afterfi {\expandafter #2\expandafter ##1\romannumeral`&&@%
      \csname XINT_#8_op_##3\endcsname {##4}}%
    \else \xint_afterfi {\expandafter ##2\expandafter ##3%
      \csname .=\expandafter\XINT_expr_binop_inline_a\expandafter
      {\expandafter\expandafter\expandafter#6\expandafter
       \xint_exchangetwo_keepbraces\expandafter
      {\expandafter\XINT_expr_unlock\expandafter ##4\expandafter}\expandafter}%
         \romannumeral`&&@\XINT_expr_unlock ##1,^,\endcsname }%
    \fi }%
  \let #7#5%
}%
\def\XINT_tmpb #1#2#3#4%
{%
  \expandafter\XINT_tmpc
  \csname XINT_#1_op_#2\expandafter\endcsname
  \csname XINT_#1_until_#2_a\expandafter\endcsname
  \csname XINT_#1_until_#2_b\expandafter\endcsname
  \csname XINT_#1_op_-#3\expandafter\endcsname
  \csname xint_c_#3\expandafter\endcsname
  \csname #4\expandafter\endcsname
  \csname XINT_expr_precedence_#2\endcsname {#1}%
}%
%    \end{macrocode}
% \lverb|This is for [x..y]*z syntax etc.... Attention that with 1.2d,
% precedence level of ^ raised to ix to make room for ***.|
%    \begin{macrocode}
\xintApplyInline {\expandafter\XINT_tmpb \xint_firstofone}{%
  {{expr}{a+}{vi}{xintAdd}}%
  {{expr}{a-}{vi}{xintSub}}%
  {{expr}{a*}{vii}{xintMul}}%
  {{expr}{a/}{vii}{xintDiv}}%
  {{expr}{a^}{ix}{xintPow}}%
  {{iiexpr}{a+}{vi}{xintiiAdd}}%
  {{iiexpr}{a-}{vi}{xintiiSub}}%
  {{iiexpr}{a*}{vii}{xintiiMul}}%
  {{iiexpr}{a/}{vii}{xintiiDivRound}}%
  {{iiexpr}{a^}{ix}{xintiiPow}}%
  {{flexpr}{a+}{vi}{XINTinFloatAdd}}%
  {{flexpr}{a-}{vi}{XINTinFloatSub}}%
  {{flexpr}{a*}{vii}{XINTinFloatMul}}%
  {{flexpr}{a/}{vii}{XINTinFloatDiv}}%
  {{flexpr}{a^}{ix}{XINTinFloatPower}}%
}%
\def\XINT_tmpc #1#2#3#4#5#6#7%
{%
  \def #1##1{\expandafter#2\expandafter##1\romannumeral`&&@%
             \expandafter #3\romannumeral`&&@\XINT_expr_getnext }%
  \def #2##1##2##3##4%
  {% either execute next operation now, or first do next (possibly unary)
    \ifnum ##2>#4%
    \xint_afterfi {\expandafter #2\expandafter ##1\romannumeral`&&@%
      \csname XINT_#7_op_##3\endcsname {##4}}%
    \else \xint_afterfi {\expandafter ##2\expandafter ##3%
      \csname .=\expandafter\XINT_expr_binop_inline_a\expandafter
      {\expandafter#5\expandafter
      {\expandafter\XINT_expr_unlock\expandafter ##1\expandafter}\expandafter}%
         \romannumeral`&&@\XINT_expr_unlock ##4,^,\endcsname }%
    \fi }%
  \let #6#4%
}%
\def\XINT_tmpb #1#2#3#4%
{%
  \expandafter\XINT_tmpc
  \csname XINT_#1_op_#2\expandafter\endcsname
  \csname XINT_#1_until_#2\expandafter\endcsname
  \csname XINT_#1_until_)_a\expandafter\endcsname
  \csname xint_c_#3\expandafter\endcsname
  \csname #4\expandafter\endcsname
  \csname XINT_expr_precedence_#2\endcsname {#1}%
}%
%    \end{macrocode}
% \lverb|This is for z*[x..y] syntax etc...|
%    \begin{macrocode}
\xintApplyInline {\expandafter\XINT_tmpb\xint_firstofone }{%
  {{expr}{+[}{vi}{xintAdd}}%
  {{expr}{-[}{vi}{xintSub}}%
  {{expr}{*[}{vii}{xintMul}}%
  {{expr}{/[}{vii}{xintDiv}}%
  {{expr}{^[}{ix}{xintPow}}%
  {{iiexpr}{+[}{vi}{xintiiAdd}}%
  {{iiexpr}{-[}{vi}{xintiiSub}}%
  {{iiexpr}{*[}{vii}{xintiiMul}}%
  {{iiexpr}{/[}{vii}{xintiiDivRound}}%
  {{iiexpr}{^[}{ix}{xintiiPow}}%
  {{flexpr}{+[}{vi}{XINTinFloatAdd}}%
  {{flexpr}{-[}{vi}{XINTinFloatSub}}%
  {{flexpr}{*[}{vii}{XINTinFloatMul}}%
  {{flexpr}{/[}{vii}{XINTinFloatDiv}}%
  {{flexpr}{^[}{ix}{XINTinFloatPower}}%
}%
%    \end{macrocode}
% \subsubsection{The \textquotesingle and\textquotesingle, \textquotesingle
% or\textquotesingle, \textquotesingle xor\textquotesingle, and
% \textquotesingle mod\textquotesingle\ as infix operator words}
%    \begin{macrocode}
\xintFor #1 in {and,or,xor,mod} \do {%
   \expandafter\def\csname XINT_expr_itself_#1\endcsname {#1}}%
\expandafter\let\csname XINT_expr_precedence_and\expandafter\endcsname
                \csname XINT_expr_precedence_&\endcsname
\expandafter\let\csname XINT_expr_precedence_or\expandafter\endcsname
                \csname XINT_expr_precedence_|\endcsname
\expandafter\let\csname XINT_expr_precedence_mod\expandafter\endcsname
                \csname XINT_expr_precedence_/:\endcsname
\xintFor #1 in {expr, flexpr, iiexpr} \do {%
   \expandafter\let\csname XINT_#1_op_and\expandafter\endcsname
                   \csname XINT_#1_op_&\endcsname
   \expandafter\let\csname XINT_#1_op_or\expandafter\endcsname
                   \csname XINT_#1_op_|\endcsname
   \expandafter\let\csname XINT_#1_op_mod\expandafter\endcsname
                   \csname XINT_#1_op_/:\endcsname
}%
%    \end{macrocode}
% \subsubsection{The \textbar\textbar,
% \&\&, \texorpdfstring{\protect\lowast\protect\lowast,
% \protect\lowast\protect\lowast[, ]\protect\lowast\protect\lowast}{**, **[, ]**}{} operators as synonyms}
%    \begin{macrocode}
\expandafter\let\csname XINT_expr_precedence_==\expandafter\endcsname
                \csname XINT_expr_precedence_=\endcsname
\expandafter\let\csname XINT_expr_precedence_&\string&\expandafter\endcsname
                \csname XINT_expr_precedence_&\endcsname
\expandafter\let\csname XINT_expr_precedence_||\expandafter\endcsname
                \csname XINT_expr_precedence_|\endcsname
\expandafter\let\csname XINT_expr_precedence_**\expandafter\endcsname
                \csname XINT_expr_precedence_^\endcsname
\expandafter\let\csname XINT_expr_precedence_a**\expandafter\endcsname
                \csname XINT_expr_precedence_a^\endcsname
\expandafter\let\csname XINT_expr_precedence_**[\expandafter\endcsname
                \csname XINT_expr_precedence_^[\endcsname
\xintFor #1 in {expr, flexpr, iiexpr} \do {%
   \expandafter\let\csname XINT_#1_op_==\expandafter\endcsname
                   \csname XINT_#1_op_=\endcsname
   \expandafter\let\csname XINT_#1_op_&\string&\expandafter\endcsname
                   \csname XINT_#1_op_&\endcsname
   \expandafter\let\csname XINT_#1_op_||\expandafter\endcsname
                   \csname XINT_#1_op_|\endcsname
   \expandafter\let\csname XINT_#1_op_**\expandafter\endcsname
                   \csname XINT_#1_op_^\endcsname
   \expandafter\let\csname XINT_#1_op_a**\expandafter\endcsname
                   \csname XINT_#1_op_a^\endcsname
   \expandafter\let\csname XINT_#1_op_**[\expandafter\endcsname
                   \csname XINT_#1_op_^[\endcsname
}%
%    \end{macrocode}
% \subsubsection{List selectors: [list][N], [list][:b], [list][a:], [list][a:b]}
% \lverb|1.1 (27 octobre 2014) I implement Python syntax, see
% http://stackoverflow.com/a/13005464/4184837. I do not implement third
% argument giving the step. Also, Python [5:2] selector returns empty
% and not, as I could have been tempted to do, (list[5], list[4], list[3]).
% Anyway, it is simpler not to do that. For reversing I could allow
% [::-1] syntax but this would get confusing, better to do function "reversed".
%
% This gets the job done, but I would definitely need \xintTrim::csv, \xintKeep::csv,
% \xintNthElt::csv for better efficiency. Not for 1.1.
%
% The \xintListSel::csv was named \xintListSel:csv, but as it not only
% extracts one item but may produce csv, I renamed it.|
%    \begin{macrocode}
\def\XINT_tmpa #1#2#3#4#5#6%
{%
    \def #1##1% \XINT_expr_op_][
    {%
        \expandafter #2\expandafter ##1\romannumeral`&&@\XINT_expr_getnext
    }%
    \def #2##1##2% \XINT_expr_until_][_a
    {\xint_UDsignfork
        ##2{\expandafter #2\expandafter ##1\romannumeral`&&@#4}%
          -{#3##1##2}%
     \krof }%
    \def #3##1##2##3##4% \XINT_expr_until_][_b
    {%
      \ifnum ##2>\xint_c_ii
        \xint_afterfi {\expandafter #2\expandafter ##1\romannumeral`&&@%
                       \csname XINT_#6_op_##3\endcsname {##4}}%
      \else
        \xint_afterfi
        {\expandafter ##2\expandafter ##3\csname 
              .=\expandafter\xintListSel::csv \romannumeral`&&@\XINT_expr_unlock ##4;%
                \XINT_expr_unlock ##1;\endcsname % unlock added for \xintNewExpr
        }%
      \fi
    }%
    \let #5\xint_c_ii
}%
\xintFor #1 in {expr,flexpr,iiexpr} \do {%
\expandafter\XINT_tmpa
    \csname XINT_#1_op_][\expandafter\endcsname
    \csname XINT_#1_until_][_a\expandafter\endcsname
    \csname XINT_#1_until_][_b\expandafter\endcsname
    \csname XINT_#1_op_-vi\expandafter\endcsname
    \csname XINT_expr_precedence_][\endcsname {#1}%
}%
\def\XINT_tmpa #1#2#3#4#5#6%
{%
    \def #1##1% \XINT_expr_op_:
    {%
        \expandafter #2\expandafter ##1\romannumeral`&&@\XINT_expr_getnext
    }%
    \def #2##1##2% \XINT_expr_until_:_a
    {\xint_UDsignfork
        ##2{\expandafter #2\expandafter ##1\romannumeral`&&@#4}%
          -{#3##1##2}%
     \krof }%
    \def #3##1##2##3##4% \XINT_expr_until_:_b
    {%
      \ifnum ##2>\xint_c_iii
        \xint_afterfi {\expandafter #2\expandafter ##1\romannumeral`&&@%
                       \csname XINT_#6_op_##3\endcsname {##4}}%
      \else
        \xint_afterfi
        {\expandafter ##2\expandafter ##3\csname 
              .=:\xintiiifSgn{\XINT_expr_unlock ##1}NPP.%
                \xintiiifSgn{\XINT_expr_unlock ##4}NPP.%
                \xintNum{\XINT_expr_unlock ##1};\xintNum{\XINT_expr_unlock ##4}\endcsname 
        }%
      \fi
    }%
    \let #5\xint_c_iii
}%
\xintFor #1 in {expr,flexpr,iiexpr} \do {%
\expandafter\XINT_tmpa
    \csname XINT_#1_op_:\expandafter\endcsname
    \csname XINT_#1_until_:_a\expandafter\endcsname
    \csname XINT_#1_until_:_b\expandafter\endcsname
    \csname XINT_#1_op_-vi\expandafter\endcsname
    \csname XINT_expr_precedence_:\endcsname {#1}%
}%
\catcode`[ 11 \catcode`] 11
\let\XINT_expr_precedence_:] \xint_c_iii
\def\XINT_expr_op_:] #1{\expandafter\xint_c_i\expandafter )%
    \csname .=]\xintiiifSgn{\XINT_expr_unlock #1}npp\XINT_expr_unlock #1\endcsname }%
\let\XINT_flexpr_op_:] \XINT_expr_op_:]
\let\XINT_iiexpr_op_:] \XINT_expr_op_:]
\let\XINT_expr_precedence_][: \xint_c_iii
%    \end{macrocode}
% \lverb|At the end of the replacement text of \XINT_expr_op_][:, the : after
% index 0 must be catcode 12, else will be mistaken for the start of variable
% by expression parser (as <digits><variable> is allowed by the syntax and does
% tacit multiplication).|
%    \begin{macrocode}
\edef\XINT_expr_op_][: #1{\xint_c_ii \expandafter\noexpand
                          \csname XINT_expr_itself_][\endcsname #10\string :}%
%    \end{macrocode}
% \subsubsection{\csh{xintListSel::csv}}
% \lverb|Some complications here are due to \xintNewExpr matters.|
%    \begin{macrocode}
\let\XINT_flexpr_op_][: \XINT_expr_op_][:
\let\XINT_iiexpr_op_][: \XINT_expr_op_][:
\catcode`[ 12 \catcode`] 12
\def\xintListSel::csv #1{%
    \if ]\noexpand#1\xint_dothis{\expandafter\XINT_listsel:_s\romannumeral`&&@}\fi
    \if :\noexpand#1\xint_dothis{\XINT_listsel:_:}\fi
    \xint_orthat {\XINT_listsel:_nth #1}%
}%
\def\XINT_listsel:_s #1{\if p#1\expandafter\XINT_listsel:_trim\else
                               \expandafter\XINT_listsel:_keep\fi }%
\def\XINT_listsel:_: #1.#2.{\csname XINT_listsel:_#1#2\endcsname }%
\def\XINT_listsel:_trim #1;#2;%
   {\xintListWithSep,{\xintTrim {\xintNum{#1}}{\xintCSVtoListNonStripped{#2}}}}%
\def\XINT_listsel:_keep #1;#2;%
   {\xintListWithSep,{\xintKeep {\xintNum{#1}}{\xintCSVtoListNonStripped{#2}}}}%
\def\XINT_listsel:_nth#1;#2;%
   {\xintNthElt {\xintNum{#1}}{\xintCSVtoListNonStripped{#2}}}%
\def\XINT_listsel:_PP #1;#2;#3;%
   {\xintListWithSep,%
    {\xintTrim {\xintNum{#1}}{\xintKeep {\xintNum{#2}}{\xintCSVtoListNonStripped{#3}}}}%
   }%
\def\XINT_listsel:_NN #1;#2;#3;%
   {\xintListWithSep,%
    {\xintTrim {\xintNum{#2}}{\xintKeep {\xintNum{#1}}{\xintCSVtoListNonStripped{#3}}}}%
   }%
\def\XINT_listsel:_NP #1;#2;#3;%
   {\expandafter\XINT_listsel:_NP_a \the\numexpr #1+%
             \xintNthElt{0}{\xintCSVtoListNonStripped{#3}};#2;#3;}%
\def\XINT_listsel:_NP_a #1#2;{\if -#1\expandafter\XINT_listsel:_OP\fi
                              \XINT_listsel:_PP #1#2;}%
\def\XINT_listsel:_OP\XINT_listsel:_PP #1;{\XINT_listsel:_PP 0;}%
\def\XINT_listsel:_PN #1;#2;#3;%
   {\expandafter\XINT_listsel:_PN_a \the\numexpr #2+%
             \xintNthElt{0}{\xintCSVtoListNonStripped{#3}};#1;#3;}%
\def\XINT_listsel:_PN_a #1#2;#3;{\if -#1\expandafter\XINT_listsel:_PO\fi
                              \XINT_listsel:_PP #3;#1#2;}%
\def\XINT_listsel:_PO\XINT_listsel:_PP #1;#2;{\XINT_listsel:_PP #1;0;}%
%    \end{macrocode}
%\subsection{Macros for a..b list generation}
% \localtableofcontents
%\lverb|Attention, ne produit que des listes de petits entiers!|
%\subsubsection{\csh{xintSeq::csv}}
%\lverb|Commence par remplacer a par ceil(a) et b par floor(b) et renvoie
% ensuite les entiers entre les deux, possiblement en dcroissant, et
% extrmits comprises. Si a=b est non entier en obtient donc ceil(a) et
% floor(a). Ne renvoie jamais une liste vide.|
%    \begin{macrocode}
\def\xintSeq::csv {\romannumeral0\xintseq::csv }%
\def\xintseq::csv #1#2%
{%
    \expandafter\XINT_seq::csv\expandafter
       {\the\numexpr \xintiCeil{#1}\expandafter}\expandafter
       {\the\numexpr \xintiFloor{#2}}%
}%
\def\XINT_seq::csv #1#2%
{%
   \ifcase\ifnum #1=#2 0\else\ifnum #2>#1 1\else -1\fi\fi\space
      \expandafter\XINT_seq::csv_z
   \or
      \expandafter\XINT_seq::csv_p
   \else
      \expandafter\XINT_seq::csv_n
   \fi
   {#2}{#1}%
}%
\def\XINT_seq::csv_z #1#2{ #1/1[0]}%
\def\XINT_seq::csv_p #1#2%
{%
    \ifnum #1>#2
      \expandafter\expandafter\expandafter\XINT_seq::csv_p
    \else
      \expandafter\XINT_seq::csv_e
    \fi
    \expandafter{\the\numexpr #1-\xint_c_i}{#2},#1/1[0]%
}%
\def\XINT_seq::csv_n #1#2%
{%
    \ifnum #1<#2
      \expandafter\expandafter\expandafter\XINT_seq::csv_n
    \else
      \expandafter\XINT_seq::csv_e
    \fi
     \expandafter{\the\numexpr #1+\xint_c_i}{#2},#1/1[0]%
}%
\def\XINT_seq::csv_e #1,{ }%
%    \end{macrocode}
%\subsubsection{\csh{xintiiSeq::csv}}
%    \begin{macrocode}
\def\xintiiSeq::csv {\romannumeral0\xintiiseq::csv }%
\def\xintiiseq::csv #1#2%
{%
    \expandafter\XINT_iiseq::csv\expandafter
       {\the\numexpr #1\expandafter}\expandafter{\the\numexpr #2}%
}%
\def\XINT_iiseq::csv #1#2%
{%
   \ifcase\ifnum #1=#2 0\else\ifnum #2>#1 1\else -1\fi\fi\space
      \expandafter\XINT_iiseq::csv_z
   \or
      \expandafter\XINT_iiseq::csv_p
   \else
      \expandafter\XINT_iiseq::csv_n
   \fi
   {#2}{#1}%
}%
\def\XINT_iiseq::csv_z #1#2{ #1}%
\def\XINT_iiseq::csv_p #1#2%
{%
    \ifnum #1>#2
      \expandafter\expandafter\expandafter\XINT_iiseq::csv_p
    \else
      \expandafter\XINT_seq::csv_e
    \fi
    \expandafter{\the\numexpr #1-\xint_c_i}{#2},#1%
}%
\def\XINT_iiseq::csv_n #1#2%
{%
    \ifnum #1<#2
      \expandafter\expandafter\expandafter\XINT_iiseq::csv_n
    \else
      \expandafter\XINT_seq::csv_e
    \fi
     \expandafter{\the\numexpr #1+\xint_c_i}{#2},#1%
}%
\def\XINT_seq::csv_e #1,{ }%
%    \end{macrocode}
%\subsection{Macros for a..[d]..b list generation}
% \localtableofcontents 
%
% \lverb|Contrarily to a..b which is limited to small integers, this works
% with a, b, and d (big) fractions. It will produce a nil list, if a>b and
% d<0 or a<b and d>0.|
%
%\subsubsection{\csh{xintSeqA::csv}, \csh{xintiiSeqA::csv}, \csh{XINTinFloatSeqA::csv}}
%
% \lverb|2015/11/11 Naturally, I did not document anything in 2014, and today
% I was perplexed about what these macros do; and why something was wrong with
% \xintNewIIExpr and a..[b]..c things therein. In fact \xintiiSeqB:f:csv had a
% typo in its name, but this had escaped my 2014 tests; and if I had corrected
% it I would have seen another problem with a..[b]..C in \xintNewIIExpr, the
% \xintiiSeqB:f:csv macro calls \xintiiSeqA::csv with arguments which have no
% more a \XINT_expr_unlock. But \xintiiSeqA::csv tried to be clever and
% assumed the \XINT_expr_unlock were there. The other two expanded either in
% \xintraw or \XINTinfloat, hence no problem arose in
% \xintNewExpr/\xintNewFloatExpr. The fix has been to let \xintiiSeqA::csv act
% a bit more like the other two.|
%    \begin{macrocode}
\def\xintSeqA::csv #1%
   {\expandafter\XINT_seqa::csv\expandafter{\romannumeral0\xintraw {#1}}}%
\def\XINT_seqa::csv #1#2{\expandafter\XINT_seqa::csv_a \romannumeral0\xintraw {#2};#1;}%
\def\xintiiSeqA::csv #1{\expandafter\XINT_iiseqa::csv\expandafter{\romannumeral`&&@#1}}%
\def\XINT_iiseqa::csv #1#2{\expandafter\XINT_seqa::csv_a\romannumeral`&&@#2;#1;}%
\def\XINTinFloatSeqA::csv #1{\expandafter\XINT_flseqa::csv\expandafter
   {\romannumeral0\XINTinfloat [\XINTdigits]{#1}}}%
\def\XINT_flseqa::csv #1#2%
   {\expandafter\XINT_seqa::csv_a\romannumeral0\XINTinfloat [\XINTdigits]{#2};#1;}%
\def\XINT_seqa::csv_a #1{\xint_UDzerominusfork
                                   #1-{z}%
                                   0#1{n}%
                                   0-{p}%
                        \krof #1}%
%    \end{macrocode}
%\subsubsection{\csh{xintSeqB::csv}}
% \lverb|With one year late documentation, let's just say, the #1 is
% \XINT_expr_unlock\.=Ua;b; with U=z or n or p, a=step, b=start.|
%    \begin{macrocode}
\def\xintSeqB::csv #1#2%
   {\expandafter\XINT_seqb::csv \expandafter{\romannumeral0\xintraw{#2}}{#1}}%
\def\XINT_seqb::csv #1#2{\expandafter\XINT_seqb::csv_a\romannumeral`&&@#2#1!}%
\def\XINT_seqb::csv_a #1#2;#3;#4!{\expandafter\XINT_expr_seq_empty?
      \romannumeral0\csname XINT_seqb::csv_#1\endcsname {#3}{#4}{#2}}%
\def\XINT_seqb::csv_p #1#2#3%
{%
   \xintifCmp {#1}{#2}{,#1\expandafter\XINT_seqb::csv_p\expandafter}%
   {,#1\xint_gobble_iii}{\xint_gobble_iii}%
%    \end{macrocode}
% \lverb|\romannumeral0 stopped by \endcsname, XINT_expr_seq_empty? constructs
% "nil".|
%    \begin{macrocode}
   {\romannumeral0\xintadd {#3}{#1}}{#2}{#3}%
}%
\def\XINT_seqb::csv_n #1#2#3%
{%
    \xintifCmp {#1}{#2}{\xint_gobble_iii}{,#1\xint_gobble_iii}%
    {,#1\expandafter\XINT_seqb::csv_n\expandafter}%
    {\romannumeral0\xintadd {#3}{#1}}{#2}{#3}%
}%
\def\XINT_seqb::csv_z #1#2#3{,#1}%
%    \end{macrocode}
%\subsubsection{\csh{xintiiSeqB::csv}}
%    \begin{macrocode}
\def\xintiiSeqB::csv #1#2{\XINT_iiseqb::csv #1#2}%
\def\XINT_iiseqb::csv #1#2#3#4%
   {\expandafter\XINT_iiseqb::csv_a
    \romannumeral`&&@\expandafter \XINT_expr_unlock\expandafter#2%
    \romannumeral`&&@\XINT_expr_unlock #4!}%
\def\XINT_iiseqb::csv_a #1#2;#3;#4!{\expandafter\XINT_expr_seq_empty?
      \romannumeral`&&@\csname XINT_iiseqb::csv_#1\endcsname {#3}{#4}{#2}}%
\def\XINT_iiseqb::csv_p #1#2#3%
{%
  \xintSgnFork{\XINT_Cmp {#1}{#2}}{,#1\expandafter\XINT_iiseqb::csv_p\expandafter}%
  {,#1\xint_gobble_iii}{\xint_gobble_iii}%
  {\romannumeral0\xintiiadd {#3}{#1}}{#2}{#3}%
}%
\def\XINT_iiseqb::csv_n #1#2#3%
{%
  \xintSgnFork{\XINT_Cmp {#1}{#2}}{\xint_gobble_iii}{,#1\xint_gobble_iii}%
  {,#1\expandafter\XINT_iiseqb::csv_n\expandafter}%
  {\romannumeral0\xintiiadd {#3}{#1}}{#2}{#3}%
}%
\def\XINT_iiseqb::csv_z #1#2#3{,#1}%
%    \end{macrocode}
%\subsubsection{\csh{XINTinFloatSeqB::csv}}
%    \begin{macrocode}
\def\XINTinFloatSeqB::csv #1#2{\expandafter\XINT_flseqb::csv \expandafter
    {\romannumeral0\XINTinfloat [\XINTdigits]{#2}}{#1}}%
\def\XINT_flseqb::csv #1#2{\expandafter\XINT_flseqb::csv_a\romannumeral`&&@#2#1!}%
\def\XINT_flseqb::csv_a #1#2;#3;#4!{\expandafter\XINT_expr_seq_empty?
      \romannumeral`&&@\csname XINT_flseqb::csv_#1\endcsname {#3}{#4}{#2}}%
\def\XINT_flseqb::csv_p #1#2#3%
{%
  \xintifCmp {#1}{#2}{,#1\expandafter\XINT_flseqb::csv_p\expandafter}%
  {,#1\xint_gobble_iii}{\xint_gobble_iii}%
  {\romannumeral0\XINTinfloatadd {#3}{#1}}{#2}{#3}%
}%
\def\XINT_flseqb::csv_n #1#2#3%
{%
  \xintifCmp {#1}{#2}{\xint_gobble_iii}{,#1\xint_gobble_iii}%
  {,#1\expandafter\XINT_flseqb::csv_n\expandafter}%
  {\romannumeral0\XINTinfloatadd {#3}{#1}}{#2}{#3}%
}%
\def\XINT_flseqb::csv_z #1#2#3{,#1}%
%    \end{macrocode}
% \subsection{The comma as binary operator}
% \lverb|New with 1.09a. Suffices to set its precedence level to two.|
%    \begin{macrocode}
\def\XINT_tmpa #1#2#3#4#5#6%
{%
    \def #1##1% \XINT_expr_op_,
    {%
        \expandafter #2\expandafter ##1\romannumeral`&&@\XINT_expr_getnext
    }%
    \def #2##1##2% \XINT_expr_until_,_a
    {\xint_UDsignfork
        ##2{\expandafter #2\expandafter ##1\romannumeral`&&@#4}%
          -{#3##1##2}%
     \krof }%
    \def #3##1##2##3##4% \XINT_expr_until_,_b
    {%
      \ifnum ##2>\xint_c_ii
        \xint_afterfi {\expandafter #2\expandafter ##1\romannumeral`&&@%
                       \csname XINT_#6_op_##3\endcsname {##4}}%
      \else
        \xint_afterfi
        {\expandafter ##2\expandafter ##3%
         \csname .=\XINT_expr_unlock ##1,\XINT_expr_unlock ##4\endcsname }%
      \fi
    }%
    \let #5\xint_c_ii
}%
\xintFor #1 in {expr,flexpr,iiexpr} \do {%
\expandafter\XINT_tmpa
    \csname XINT_#1_op_,\expandafter\endcsname
    \csname XINT_#1_until_,_a\expandafter\endcsname
    \csname XINT_#1_until_,_b\expandafter\endcsname
    \csname XINT_#1_op_-vi\expandafter\endcsname
    \csname XINT_expr_precedence_,\endcsname {#1}%
}%
%    \end{macrocode}
% \subsection{The minus as prefix operator of variable precedence level}
% \lverb|Inherits the precedence level of the previous infix operator.|
%    \begin{macrocode}
\def\XINT_tmpa #1#2#3%
{%
    \expandafter\XINT_tmpb
    \csname XINT_#1_op_-#3\expandafter\endcsname
    \csname XINT_#1_until_-#3_a\expandafter\endcsname
    \csname XINT_#1_until_-#3_b\expandafter\endcsname
    \csname xint_c_#3\endcsname {#1}#2%
}%
\def\XINT_tmpb #1#2#3#4#5#6%
{%
    \def #1% \XINT_expr_op_-<level>
    {%  get next number+operator then switch to _until macro
        \expandafter #2\romannumeral`&&@\XINT_expr_getnext
    }%
    \def #2##1% \XINT_expr_until_-<l>_a
    {\xint_UDsignfork
        ##1{\expandafter #2\romannumeral`&&@#1}%
          -{#3##1}%
     \krof }%
    \def #3##1##2##3% \XINT_expr_until_-<l>_b
    {%  _until tests precedence level with next op, executes now or postpones
        \ifnum ##1>#4%
         \xint_afterfi {\expandafter #2\romannumeral`&&@%
                        \csname XINT_#5_op_##2\endcsname {##3}}%
        \else
         \xint_afterfi {\expandafter ##1\expandafter ##2%
                        \csname .=#6{\XINT_expr_unlock ##3}\endcsname }%
        \fi
    }%
}%
%    \end{macrocode}
% \lverb|1.2d needs precedence 8 for *** and 9 for ^. Earlier, precedence
% level for ^ was only 8 but nevertheless the code did also "ix" here, which I
% think was unneeded back then.|
%    \begin{macrocode}
\xintApplyInline{\XINT_tmpa {expr}\xintOpp}{{vi}{vii}{viii}{ix}}%
\xintApplyInline{\XINT_tmpa {flexpr}\xintOpp}{{vi}{vii}{viii}{ix}}%
\xintApplyInline{\XINT_tmpa {iiexpr}\xintiiOpp}{{vi}{vii}{viii}{ix}}%
%    \end{macrocode}
% \subsection{? as two-way and ?? as three-way conditionals with braced branches}
% \lverb|In 1.1, I overload ? with ??, as : will be used for list extraction,
% problem with (stuff)?{?(1)}{0} for example, one should put a space (stuff)?{
% ?(1)}{0} will work. Small idiosyncrasy. 
%
% syntax: ?{yes}{no} and ??{<0}{=0}{>0}.
%
% The difficulty is to recognize the second ? without removing braces as would
% be the case with standard parsing of operators. Hence the ? operator is
% intercepted in \XINT_expr_getop_b.|
%    \begin{macrocode}
\let\XINT_expr_precedence_? \xint_c_x
\def\XINT_expr_op_? #1#2{\if ?#2\expandafter \XINT_expr_op_??\fi
                         \XINT_expr_op_?a #1{#2}}% 
\def\XINT_expr_op_?a #1#2#3%
{%
    \xintiiifNotZero{\XINT_expr_unlock  #1}{\XINT_expr_getnext #2}{\XINT_expr_getnext #3}%
}%
\let\XINT_flexpr_op_?\XINT_expr_op_?
\let\XINT_iiexpr_op_?\XINT_expr_op_?
\def\XINT_expr_op_?? #1#2#3#4#5#6%
{%
     \xintiiifSgn {\XINT_expr_unlock  #2}{\XINT_expr_getnext #4}{\XINT_expr_getnext #5}%
                  {\XINT_expr_getnext #6}%
}%
%    \end{macrocode}
% \subsection{! as postfix factorial operator}
% \lverb|A float version \xintFloatFac was at last done 2015/10/06.|
%    \begin{macrocode}
\let\XINT_expr_precedence_! \xint_c_x
\def\XINT_expr_op_! #1{\expandafter\XINT_expr_getop
                                    \csname .=\xintFac{\XINT_expr_unlock #1}\endcsname }%
\def\XINT_flexpr_op_! #1{\expandafter\XINT_expr_getop
                                    \csname .=\XINTinFloatFac{\XINT_expr_unlock #1}\endcsname }%
\def\XINT_iiexpr_op_! #1{\expandafter\XINT_expr_getop
                                   \csname .=\xintiiFac{\XINT_expr_unlock #1}\endcsname }%
%    \end{macrocode}
% \subsection{The A/B[N] mechanism}
% \lverb|Releases earlier than 1.1 required the use of braces around A/B[N]
% input. The [N] is now implemented directly. *BUT* this uses a delimited macro!
% thus N is not allowed to be itself an expression (I could add it...).
% \xintE, \xintiiE, and \XINTinFloatE all put #2 in a \numexpr. But attention
% to the fact that \numexpr stops at spaces separating digits:
% \the\numexpr 3 + 7 9\relax gives 109\relax !! Hence we have to be
% careful.
%
% \numexpr will not handle catcode 11 digits, but adding a \detokenize will
% suddenly make illicit for N to rely on macro expansion.|
%    \begin{macrocode}
\catcode`[ 11
\catcode`* 11
\let\XINT_expr_precedence_[ \xint_c_vii
\def\XINT_expr_op_[ #1#2]{\expandafter\XINT_expr_getop
                \csname .=\xintE{\XINT_expr_unlock #1}%
                {\xint_zapspaces #2 \xint_gobble_i}\endcsname}%
\def\XINT_iiexpr_op_[ #1#2]{\expandafter\XINT_expr_getop
                \csname .=\xintiiE{\XINT_expr_unlock #1}%
                {\xint_zapspaces #2 \xint_gobble_i}\endcsname}%
\def\XINT_flexpr_op_[ #1#2]{\expandafter\XINT_expr_getop
                \csname .=\XINTinFloatE{\XINT_expr_unlock #1}%
                {\xint_zapspaces #2 \xint_gobble_i}\endcsname}%
\catcode`[ 12
\catcode`* 12
%    \end{macrocode}
% \subsection{\csh{XINT_expr_op__} for recognizing variables}
% \lverb|The 1.1 mechanism for \XINT_expr_var_<varname> has been modified in 1.2c.
% The <varname> associated macro is now only expanded once, not twice.
%
% We arrive here via \XINT_expr_func.|
%    \begin{macrocode}
\def\XINT_expr_op__  #1% op__ with two _'s
     {%
         \ifcsname XINT_expr_var_#1\endcsname
           \expandafter\xint_firstoftwo
         \else
           \expandafter\xint_secondoftwo
         \fi
         {\expandafter\expandafter\expandafter
          \XINT_expr_getop\csname XINT_expr_var_#1\endcsname}%
         {\XINT_expr_unknown_variable {#1}%
          \expandafter\XINT_expr_getop\csname .=0\endcsname}%
     }%
\def\XINT_expr_unknown_variable #1{\xintError:removed \xint_gobble_i {#1}}%
\let\XINT_flexpr_op__ \XINT_expr_op__
\let\XINT_iiexpr_op__ \XINT_expr_op__
%    \end{macrocode}
% \subsection{User defined variables: \csh{xintdefvar}, \csh{xintdefiivar}, \csh{xintdeffloatvar}}
% \lverb|1.1 An active : character will be a pain with our delimited macros and
% I almost decided not to use := but rather = as assignation operator, but this
% is the same problem inside expressions with the modulo operator /:, or with
% babel+frenchb with all high punctuation ?, !, :, ;.
%
% Variable names may contain letters, digits, underscores, and must not start
% with a digit. Names starting with @ or un underscore are reserved.
%
% Note (2015/11/11): although defined since october 2014 with 1.1, they were
% only very briefly mentioned in the user documentation, I should have
% expanded more. I am now adding functions to variables, and will rewrite
% entirely the documentation of xintexpr.sty.
%
% 1.2c adds the "onlitteral" macros as we changed our tricks to disambiguate
% variables from functions if followed by a parenthesis, in order to allow
% function names to have precedence on variable names.
%
% I don't issue warnings if a an attempt to define a variable name clashes
% with a pre-existing function name, as I would have to check expr, iiexpr and
% also floatexpr. And anyhow overloading a function name with a variable name
% is allowed, the only thing to know is that if an opening parenthesis follows
% it is the function meaning which prevails.
%
% 2015/11/13: I now first do an a priori complete expansion of #1, and then apply
% \detokenize to the result, and remove spaces. Should xintexpr log the values
% of the declared variables ? |
%    \begin{macrocode}
\catcode`: 12
\def\xintdefvar #1:=#2;{%
   \edef\XINT_expr_tmpa{#1}%
   \edef\XINT_expr_tmpa
       {\expandafter\xint_zapspaces\detokenize\expandafter{\XINT_expr_tmpa} \xint_gobble_i}%
   \edef\XINT_expr_tmpb {\romannumeral0\xintbareeval #2\relax }%
   \ifxintverbose\xintMessage {info}{xintexpr}
     {Variable \XINT_expr_tmpa\space defined with value 
               \expandafter\XINT_expr_unlock\XINT_expr_tmpb.}%
   \fi
   \expandafter\edef\csname XINT_expr_var_\XINT_expr_tmpa\endcsname 
              {\expandafter\noexpand\XINT_expr_tmpb}%
   \expandafter\edef\csname XINT_expr_onlitteral_\XINT_expr_tmpa\endcsname
              {\noexpand\XINT_expr_getop\expandafter\noexpand\XINT_expr_tmpb *(}%
}%
\def\xintdefiivar #1:=#2;{%
   \edef\XINT_expr_tmpa{#1}%
   \edef\XINT_expr_tmpa
       {\expandafter\xint_zapspaces\detokenize\expandafter{\XINT_expr_tmpa} \xint_gobble_i}%
   \edef\XINT_expr_tmpb {\romannumeral0\xintbareiieval #2\relax }%
   \ifxintverbose\xintMessage {info}{xintexpr}
     {Variable \XINT_expr_tmpa\space defined with value 
               \expandafter\XINT_expr_unlock\XINT_expr_tmpb.}%
   \fi
   \expandafter\edef\csname XINT_expr_var_\XINT_expr_tmpa\endcsname 
              {\expandafter\noexpand\XINT_expr_tmpb}%
   \expandafter\edef\csname XINT_expr_onlitteral_\XINT_expr_tmpa\endcsname
              {\noexpand\XINT_expr_getop\expandafter\noexpand\XINT_expr_tmpb *(}%
}%
\def\xintdeffloatvar #1:=#2;{%
   \edef\XINT_expr_tmpa{#1}%
   \edef\XINT_expr_tmpa
       {\expandafter\xint_zapspaces\detokenize\expandafter{\XINT_expr_tmpa}
         \xint_gobble_i}%
   \edef\XINT_expr_tmpb {\romannumeral0\xintbarefloateval #2\relax }%
   \ifxintverbose\xintMessage {info}{xintexpr}
     {Variable \XINT_expr_tmpa\space defined with value 
               \expandafter\XINT_expr_unlock\XINT_expr_tmpb.}%
   \fi
   \expandafter\edef\csname XINT_expr_var_\XINT_expr_tmpa\endcsname 
              {\expandafter\noexpand\XINT_expr_tmpb}%
   \expandafter\edef\csname XINT_expr_onlitteral_\XINT_expr_tmpa\endcsname
              {\noexpand\XINT_expr_getop\expandafter\noexpand\XINT_expr_tmpb *(}%
}%
\catcode`: 11
%    \end{macrocode}
% \subsection{All letters usable as dummy variables}
% \lverb|The nil variable was introduced in 1.1 but I don't think it is used
% anywhere (comment 2015/11/11; well it is, for example in the macros handling
% a..[d]..b, or for seq with dummy variable where omit has omitted everyting).
%
% 1.2c has changed the way variables are disambiguated from functions and for
% this it has added here the definitions of \XINT_expr_onlitteral_<name>.
%
% In 1.1 a letter variable say X was acting as a delimited macro looking for !X{stuff} and
% then would expand the stuff inside a \csname.=...\endcsname. I don't think I used the
% possibilities this opened and the 1.2c version has stuff _already_ encapsulated thus a
% single token. Only one expansion, not two is then needed in \XINT_expr_op__.
%
% I had to accordingly modify seq, add, mul and subs, but fortunately realized that the @,
% @1, etc... variables for rseq, rrseq and iter already had been defined in
% the way now also followed by the Latin letters as dummy variables.|
%    \begin{macrocode}
\def\XINT_tmpa #1%
{%
   \expandafter\def\csname XINT_expr_var_#1\endcsname ##1\relax !#1##2%
      {##2##1\relax !#1##2}%
   \expandafter\def\csname XINT_expr_onlitteral_#1\endcsname ##1\relax !#1##2%
      {\XINT_expr_getop ##2*(##1\relax !#1##2}%
}%
\xintApplyUnbraced \XINT_tmpa {abcdefghijklmnopqrstuvwxyz}%
\xintApplyUnbraced \XINT_tmpa {ABCDEFGHIJKLMNOPQRSTUVWXYZ}%
\edef\XINT_expr_var_nil  {\expandafter\noexpand\csname .= \endcsname}%
\edef\XINT_expr_onlitteral_nil 
      {\noexpand\XINT_expr_getop\expandafter\noexpand\csname .= \endcsname *(}%
%    \end{macrocode}
% \subsection{The omit and abort constructs}
% \lverb|& attention  ce & qui est de catcode 14 dans les \lverb
% June 24 and 25, 2014. 
%
% Added comments 2015/11/13: 
% 
% Et la documentation ? on n'y comprend plus rien. Trop
% rus.$newline
% \def\XINT_expr_var_omit  #1\relax !{1^C!{}{}{}\.=!\relax !}$newline
% \def\XINT_expr_var_abort #1\relax !{1^C!{}{}{}\.=^\relax !}$newline
% C'tait accompagn de \XINT_expr_precedence_^C=0 et d'un hack au sein mme
% des macros until de plus bas niveau.
%
% Le mcanisme sioux tait le suivant: ^C est dclar comme un oprateur de
% prcdence nulle. Lorsque le parseur trouve un "omit" dans un seq ou autre,
% il va insrer dans le stream \XINT_expr_getop suivi du texte de
% remplacement. Donc ici on avait un 1 comme place holder, puis l'oprateur
% ^C. Celui-ci tant de prcdence zro provoque la finalisation de tous les
% calculs antrieurs dans le sous-bareeval. Mais j'ai d hacker le until_end_b
% (et le until_)_b) qui confront  ^C, va se relancer  zro, le getnext va
% trouver le !{}{}{}\.=! et ensuite il y aura \relax, et le rsultat sera \.=!
% pour omit ou \.=^ pour abort. Les routines des boucles seq, iter, etc...
% peuvent alors reprer le ! ou ^ et agir en consquence (un long paragraphe
% pour ne dcrire que partiellement une ou deux lignes de codes...).
%
% Mais ^C a t fait alors que je n'avais pas encore les variables muettes. Je
% dois trouver autre chose, car seq(2^C, C=1..5) est alors impossible. De
% toute faon ce ^C tait  usage interne uniquement.
%
% Il me faut un symbole d'oprateur qui ne rentre pas en conflit. Bon je vais
% prendre !?. Ensuite au lieu de hacker until_end, il vaut mieux lui donner
% prcdence 2 (mais a ne pourra pas marcher  l'intrieur de parenthses il
% faut d'abord les fermer manuellement) et lui associer un simplement un op
% spcial. Je n'avais pas fait cela peut-tre pour viter d'avoir  dfinir
% plusieurs macros. Le #1 dans la dfinition de \XINT_expr_op_!? est le
% rsultat de l'valuation force prcdente.
%
% Attention que les premier ! doiventt tre de catcode 12 sinon ils
% signalent une sous-expression qui dclenche une multiplication tacite.
%
% 2015/11/13|
%    \begin{macrocode}
\edef\XINT_expr_var_omit  #1\relax !{1\string !?!\relax !}%
\edef\XINT_expr_var_abort #1\relax !{1\string !?^\relax !}%
\def\XINT_expr_op_!? #1#2\relax {\expandafter\XINT_expr_foundend\csname .=#2\endcsname}%
\let\XINT_iiexpr_op_!? \XINT_expr_op_!?
\let\XINT_flexpr_op_!? \XINT_expr_op_!?
%    \end{macrocode}
% \subsection{The special variables @, @1, @2, @3, @4, @@, @@(1), \dots, @@@,
% @@@(1), \dots for recursion} 
% \lverb|October 2014: I had completely forgotten what the @@@ etc... stuff
% were supposed to do: this is for nesting recursions! (I was mad back in
% June). @@(N) gives the Nth back, @@@(N) gives the Nth back of the higher
% recursion!
%
% 1.2c adds the needed "onlitteral" now that tacit multiplication between a
% variable and a ( has a new mechanism.|
%    \begin{macrocode}
\catcode`? 3
\def\XINT_expr_var_@ #1~#2{#2#1~#2}%
\expandafter\let\csname XINT_expr_var_@1\endcsname \XINT_expr_var_@
\expandafter\def\csname XINT_expr_var_@2\endcsname #1~#2#3{#3#1~#2#3}%
\expandafter\def\csname XINT_expr_var_@3\endcsname #1~#2#3#4{#4#1~#2#3#4}%
\expandafter\def\csname XINT_expr_var_@4\endcsname #1~#2#3#4#5{#5#1~#2#3#4#5}%
\def\XINT_expr_onlitteral_@ #1~#2{\XINT_expr_getop #2*(#1~#2}%
\expandafter\let\csname XINT_expr_onlitteral_@1\endcsname \XINT_expr_onlitteral_@
\expandafter\def\csname XINT_expr_onlitteral_@2\endcsname #1~#2#3%
           {\XINT_expr_getop #3*(#1~#2#3}%
\expandafter\def\csname XINT_expr_onlitteral_@3\endcsname #1~#2#3#4%
           {\XINT_expr_getop #4*(#1~#2#3#4}%
\expandafter\def\csname XINT_expr_onlitteral_@4\endcsname #1~#2#3#4#5%
           {\XINT_expr_getop #5*(#1~#2#3#4#5}%
\def\XINT_expr_func_@@ #1#2#3#4~#5?%
{%
   \expandafter#1\expandafter#2\romannumeral0\xintntheltnoexpand 
                             {\xintNum{\XINT_expr_unlock#3}}{#5}#4~#5?%
}%
\def\XINT_expr_func_@@@ #1#2#3#4~#5~#6?%
{%
   \expandafter#1\expandafter#2\romannumeral0\xintntheltnoexpand 
   {\xintNum{\XINT_expr_unlock#3}}{#6}#4~#5~#6?%
}%
\def\XINT_expr_func_@@@@ #1#2#3#4~#5~#6~#7?%
{%
   \expandafter#1\expandafter#2\romannumeral0\xintntheltnoexpand 
   {\xintNum{\XINT_expr_unlock#3}}{#7}#4~#5~#6~#7?%
}%
\let\XINT_flexpr_func_@@\XINT_expr_func_@@
\let\XINT_flexpr_func_@@@\XINT_expr_func_@@@
\let\XINT_flexpr_func_@@@@\XINT_expr_func_@@@@
\def\XINT_iiexpr_func_@@ #1#2#3#4~#5?%
{%
    \expandafter#1\expandafter#2\romannumeral0\xintntheltnoexpand 
    {\XINT_expr_unlock#3}{#5}#4~#5?%
}%
\def\XINT_iiexpr_func_@@@ #1#2#3#4~#5~#6?%
{%
    \expandafter#1\expandafter#2\romannumeral0\xintntheltnoexpand 
    {\XINT_expr_unlock#3}{#6}#4~#5~#6?%
}%
\def\XINT_iiexpr_func_@@@@ #1#2#3#4~#5~#6~#7?%
{%
    \expandafter#1\expandafter#2\romannumeral0\xintntheltnoexpand 
    {\XINT_expr_unlock#3}{#7}#4~#5~#6~#7?%
}%
\catcode`? 11
%    \end{macrocode}
% \subsection{\csh{XINT_expr_op_`} for recognizing functions}
% \lverb|The "onlitteral" intercepts is for bool, togl, protect, ... but also
% for add, mul, seq, etc... Genuine functions have expr, iiexpr and
% flexpr versions (or only one or two of the three).
%
% With 1.2c "onlitteral" is also used to disambiguate variables from
% functions. However as I use only a \ifcsname test, in order to be able to
% re-define a variable as function, I move the check for being a function
% first. Each variable name now has its onlitteral_<name> associated macro
% which is the new way tacit multiplication in front of a parenthesis is
% implemented. This used to be decided much earlier at the time of
% \XINT_expr_func.
%
% The advantage of our choices for 1.2c is that the same name can be used for
% a variable or a function, the parser will apply the correct interpretation
% which is decided by the presence or not of an opening parenthesis next.|
%    \begin{macrocode}
\def\XINT_tmpa #1#2#3{% 
    \def #1##1%
    {%
        \ifcsname XINT_#3_func_##1\endcsname
          \xint_dothis{\expandafter\expandafter
                     \csname XINT_#3_func_##1\endcsname\romannumeral`&&@#2}\fi
        \ifcsname XINT_expr_onlitteral_##1\endcsname
          \xint_dothis{\csname XINT_expr_onlitteral_##1\endcsname}\fi
        \xint_orthat{\XINT_expr_unknown_function {##1}%
           \expandafter\XINT_expr_func_unknown\romannumeral`&&@#2}%
   }%
}%
\def\XINT_expr_unknown_function #1{\xintError:removed \xint_gobble_i {#1}}%
\xintFor #1 in {expr,flexpr,iiexpr} \do {%
     \expandafter\XINT_tmpa
                 \csname XINT_#1_op_`\expandafter\endcsname
                 \csname XINT_#1_oparen\endcsname
                 {#1}%
}%
\def\XINT_expr_func_unknown #1#2#3%
    {\expandafter #1\expandafter #2\csname .=0\endcsname }%
%    \end{macrocode}
% \subsection{The bool, togl, protect pseudo  ``functions''}
% \lverb|bool, togl and protect use delimited macros. They are not true
% functions, they turn off the parser to gather their "variable".|
%    \begin{macrocode}
\def\XINT_expr_onlitteral_bool #1)%
        {\expandafter\XINT_expr_getop\csname .=\xintBool{#1}\endcsname }%
\def\XINT_expr_onlitteral_togl #1)%
        {\expandafter\XINT_expr_getop\csname .=\xintToggle{#1}\endcsname }%
\def\XINT_expr_onlitteral_protect #1)%
        {\expandafter\XINT_expr_getop\csname .=\detokenize{#1}\endcsname }%
%    \end{macrocode}
% \subsection{The break  function}
% \lverb|break is a true function, the parsing via expansion of the succeeding
% material proceeded via _oparen macros as with any other function.|
%    \begin{macrocode}
\def\XINT_expr_func_break #1#2#3%
    {\expandafter #1\expandafter #2\csname.=?\romannumeral`&&@\XINT_expr_unlock #3\endcsname }%
\let\XINT_flexpr_func_break \XINT_expr_func_break
\let\XINT_iiexpr_func_break \XINT_expr_func_break
%    \end{macrocode}
% \subsection{The qint, qfrac, qfloat ``functions''}
% \lverb|New with 1.2. Allows the user to hand over quickly a big number to the
% parser, spaces not immediately removed but should be harmless in general.|
%    \begin{macrocode}
\def\XINT_expr_onlitteral_qint #1)%
        {\expandafter\XINT_expr_getop\csname .=\xintiNum{#1}\endcsname }%
\def\XINT_expr_onlitteral_qfrac #1)%
        {\expandafter\XINT_expr_getop\csname .=\xintRaw{#1}\endcsname }%
\def\XINT_expr_onlitteral_qfloat #1)%
        {\expandafter\XINT_expr_getop\csname .=\XINTinFloatdigits{#1}\endcsname }%
%    \end{macrocode}
% \subsection{seq and the implementation of dummy variables}
% \localtableofcontents
% \lverb|All of seq, add, mul, rseq, etc... (actually all of the extensive
% changes from xintexpr 1.09n to 1.1) was done around June 15-25th 2014, but the
% problem is that I did not document the code enough, and I had a hard time
% understanding in October what I had done in June. Despite the lesson, again
% being short on time, I do not document enough my current understanding of the
% innards of the beast...
%
% I added subs, and iter in October (also the [:n], [n:] list extractors),
% proving I did at least understand a bit (or rather could imitate) my earlier
% code (but don't ask me to explain \xintNewExpr !)
% 
% The \XINT_expr_onlitteral_seq_a parses: "expression, variable=list)" (when it is called
% the opening ( has been swallowed, and it looks for the ending one.) Both expression and
% list may themselves contain parentheses and commas, we allow nesting. For example
% "x^2,x=1..10)", at the end of seq_a we have {variable{expression}}{list}, in this
% example {x{x^2}}{1..10}, or more complicated "seq(add(y,y=1..x),x=1..10)" will work
% too. The variable is a single lowercase Latin letter.
%
% The complications with \xint_c_xviii in seq_f is for the recurrent thing that we don't
% know in what type of expressions we are, hence we must move back up, with some loss of
% efficiency (superfluous check for minus sign, etc...). But the code manages
% simultaneously expr, flexpr and iiexpr.|
%
% \subsubsection{\csh{XINT_expr_onlitteral_seq}}
%    \begin{macrocode}
\def\XINT_expr_onlitteral_seq 
 {\expandafter\XINT_expr_onlitteral_seq_f\romannumeral`&&@\XINT_expr_onlitteral_seq_a {}}%
\def\XINT_expr_onlitteral_seq_f #1#2{\xint_c_xviii `{seqx}#2)\relax #1}%
%    \end{macrocode}
% \subsubsection{\csh{XINT_expr_onlitteral_seq_a}}
%    \begin{macrocode}
\def\XINT_expr_onlitteral_seq_a #1#2,%
{% checks balancing of parentheses
    \ifcase\XINT_isbalanced_a \relax #1#2(\xint_bye)\xint_bye
           \expandafter\XINT_expr_onlitteral_seq_c
        \or\expandafter\XINT_expr_onlitteral_seq_b
      \else\expandafter\xintError:we_are_doomed
    \fi {#1#2},%
}%
\def\XINT_expr_onlitteral_seq_b #1,{\XINT_expr_onlitteral_seq_a {#1,}}%
\def\XINT_expr_onlitteral_seq_c #1,#2#3% #3 pour absorber le =
{%
    \XINT_expr_onlitteral_seq_d {#2{#1}}{}%
}%
\def\XINT_expr_onlitteral_seq_d #1#2#3)%
{%
    \ifcase\XINT_isbalanced_a \relax #2#3(\xint_bye)\xint_bye
        \or\expandafter\XINT_expr_onlitteral_seq_e
       \else\expandafter\xintError:we_are_doomed
    \fi
    {#1}{#2#3}%
}%
\def\XINT_expr_onlitteral_seq_e #1#2{\XINT_expr_onlitteral_seq_d {#1}{#2)}}%
%    \end{macrocode}
% \subsubsection{\csh{XINT_isbalanced_a}  for \csh{XINT_expr_onlitteral_seq_a}}
% \lverb|Expands to \xint_c_mone in case a closing ) had no opening ( matching
% it, to \@ne if opening ) had no closing ) matching it, to \z@ if expression
% was balanced.|
%    \begin{macrocode}
% use as \XINT_isbalanced_a \relax #1(\xint_bye)\xint_bye
\def\XINT_isbalanced_a #1({\XINT_isbalanced_b #1)\xint_bye }%
\def\XINT_isbalanced_b #1)#2%
   {\xint_bye #2\XINT_isbalanced_c\xint_bye\XINT_isbalanced_error }%
%    \end{macrocode}
% \lverb|if #2 is not \xint_bye, a ) was found, but there was no (. Hence error -> -1|
%    \begin{macrocode}
\def\XINT_isbalanced_error #1)\xint_bye {\xint_c_mone}%
%    \end{macrocode}
% \lverb|#2 was \xint_bye, was there a ) in original #1?|
%    \begin{macrocode}
\def\XINT_isbalanced_c\xint_bye\XINT_isbalanced_error #1%
    {\xint_bye #1\XINT_isbalanced_yes\xint_bye\XINT_isbalanced_d #1}%
%    \end{macrocode}
% \lverb|#1 is \xint_bye, there was never ( nor ) in original #1, hence OK.|
%    \begin{macrocode}
\def\XINT_isbalanced_yes\xint_bye\XINT_isbalanced_d\xint_bye )\xint_bye {\xint_c_ }%
%    \end{macrocode}
% \lverb|#1 is not \xint_bye, there was indeed a ( in original #1. We check if
% we see a ). If we do, we then loop until no ( nor ) is to be found.|
%    \begin{macrocode}
\def\XINT_isbalanced_d #1)#2%
   {\xint_bye #2\XINT_isbalanced_no\xint_bye\XINT_isbalanced_a #1#2}%
%    \end{macrocode}
% \lverb|#2 was \xint_bye, we did not find a closing ) in original #1. Error.|
%    \begin{macrocode}
\def\XINT_isbalanced_no\xint_bye #1\xint_bye\xint_bye {\xint_c_i }%
%    \end{macrocode}
% \subsubsection{\csh{XINT_allexpr_func_seqx}}
% \lverb|1.2c uses \xintthebareval, ... which strangely were not available at
% 1.1 time. This spares some tokens from \XINT_expr_seq:_d and cousins. Also now
% variables have changed their mode of operation they pick only one token which
% must be an already encapsulated value.
%
% In \XINT_allexp_seqx, #2 is the list, evaluated and encapsulated, #3 is the
% dummy variable, #4 is the expression to evaluate repeatedly.
%
% A special case is a list generated by <variable>++: then #2 is {\.=+\.=<start>}.|
%    \begin{macrocode}
\def\XINT_expr_func_seqx   #1#2{\XINT_allexpr_seqx \xintthebareeval }%
\def\XINT_flexpr_func_seqx #1#2{\XINT_allexpr_seqx \xintthebarefloateval}%
\def\XINT_iiexpr_func_seqx #1#2{\XINT_allexpr_seqx \xintthebareiieval }%
\def\XINT_allexpr_seqx #1#2#3#4%
{%
    \expandafter \XINT_expr_getop
    \csname .=\expandafter\XINT_expr_seq:_aa
           \romannumeral`&&@\XINT_expr_unlock #2!{#1#4\relax !#3}\endcsname
}%
\def\XINT_expr_seq:_aa #1{\if +#1\expandafter\XINT_expr_seq:_A\else
                                 \expandafter\XINT_expr_seq:_a\fi #1}%
%    \end{macrocode}
% \subsubsection{Evaluation over list, \csh{XINT_expr_seq:_a} with break,
% abort, omit}
% \lverb|The #2 here is \...bareeval <expression>\relax !<variable name>. The #1
% is a comma separated list of values to assign to the dummy variable. The
% \XINT_expr_seq_empty? intervenes immediately after handling of firstvalue.
%
% 1.2c has rewritten to a large extent this and other similar loops because
% the dummy variables now fetch a single encapsulated token (apart from a good
% means to lose a few hours needlessly -- as I have had to rewrite and review
% most everything, this change could make the thing more efficient if the same
% variable is used many times in an expression, but we are talking
% micro-seconds here anyhow.)|
%    \begin{macrocode}
\def\XINT_expr_seq:_a #1!#2{\expandafter\XINT_expr_seq_empty?
                            \romannumeral0\XINT_expr_seq:_b {#2}#1,^,}%
\def\XINT_expr_seq:_b #1#2#3,{%
    \if  ,#2\xint_dothis\XINT_expr_seq:_noop\fi
    \if  ^#2\xint_dothis\XINT_expr_seq:_end\fi
    \xint_orthat{\expandafter\XINT_expr_seq:_c}\csname.=#2#3\endcsname {#1}%
}%
\def\XINT_expr_seq:_noop\csname.=,#1\endcsname #2{\XINT_expr_seq:_b {#2}#1,}%
\def\XINT_expr_seq:_end \csname.=^\endcsname #1{}%
\def\XINT_expr_seq:_c #1#2{\expandafter\XINT_expr_seq:_d\romannumeral`&&@#2#1{#2}}%
\def\XINT_expr_seq:_d #1{\if #1^\xint_dothis\XINT_expr_seq:_abort\fi
                         \if #1?\xint_dothis\XINT_expr_seq:_break\fi
                         \if #1!\xint_dothis\XINT_expr_seq:_omit\fi
                         \xint_orthat{\XINT_expr_seq:_goon #1}}%
\def\XINT_expr_seq:_abort #1!#2#3#4#5^,{}%
\def\XINT_expr_seq:_break #1!#2#3#4#5^,{,#1}%
\def\XINT_expr_seq:_omit  #1!#2#3#4{\XINT_expr_seq:_b {#4}}%
\def\XINT_expr_seq:_goon  #1!#2#3#4{,#1\XINT_expr_seq:_b {#4}}%
%    \end{macrocode}
% \lverb|If all is omitted or list is empty, _empty? will fetch with
% ##1 \endcsname and construct "nil" via <space>\endcsname, if not ##1 will be
% a comma and the gobble will swallow the space token and the extra \endcsname.|
%    \begin{macrocode}
\def\XINT_expr_seq_empty? #1{%
\def\XINT_expr_seq_empty? ##1{\if ,##1\expandafter\xint_gobble_i\fi #1\endcsname }}%
\XINT_expr_seq_empty? { }%
%    \end{macrocode}
% \subsubsection{Evaluation over ++ generated lists with \csh{XINT_expr_seq:_A}}
% \lverb|This is for index lists generated by n++. The starting point will have
% been replaced by its ceil (added: in fact with version 1.1. the ceil was not
% yet evaluated, but _var_<letter> did an expansion of what they fetch). We use
% \numexpr rather than \xintInc, hence the indexing is limited to small
% integers.
%
% The 1.2c version of n++ produces a #1 here which is already a single
% \.=<value> token.|
%    \begin{macrocode}
\def\XINT_expr_seq:_A +#1!%
   {\expandafter\XINT_expr_seq_empty?\romannumeral0\XINT_expr_seq:_D #1}%
\def\XINT_expr_seq:_D #1#2{\expandafter\XINT_expr_seq:_E\romannumeral`&&@#2#1{#2}}%
\def\XINT_expr_seq:_E #1{\if #1^\xint_dothis\XINT_expr_seq:_Abort\fi
                         \if #1?\xint_dothis\XINT_expr_seq:_Break\fi
                         \if #1!\xint_dothis\XINT_expr_seq:_Omit\fi
                         \xint_orthat{\XINT_expr_seq:_Goon #1}}%
\def\XINT_expr_seq:_Abort #1!#2#3#4{}%
\def\XINT_expr_seq:_Break #1!#2#3#4{,#1}%
\def\XINT_expr_seq:_Omit  #1!#2#3%
    {\expandafter\XINT_expr_seq:_D
        \csname.=\the\numexpr \XINT_expr_unlock#3+\xint_c_i\endcsname}%
\def\XINT_expr_seq:_Goon  #1!#2#3%
    {,#1\expandafter\XINT_expr_seq:_D
        \csname.=\the\numexpr \XINT_expr_unlock#3+\xint_c_i\endcsname}%
%    \end{macrocode}
% \subsection{add, mul}
% \lverb|1.2c uses more directly the \xintiiAdd etc... macros and has
% opxadd/opxmul rather than a single opx. This is less conceptual as I use
% explicitely the associated macro names for +, * but this makes other things
% more efficient, and the code more readable.|
%    \begin{macrocode}
\def\XINT_expr_onlitteral_add 
 {\expandafter\XINT_expr_onlitteral_add_f\romannumeral`&&@\XINT_expr_onlitteral_seq_a {}}%
\def\XINT_expr_onlitteral_add_f #1#2{\xint_c_xviii `{opxadd}#2)\relax #1}%
\def\XINT_expr_onlitteral_mul 
 {\expandafter\XINT_expr_onlitteral_mul_f\romannumeral`&&@\XINT_expr_onlitteral_seq_a {}}%
\def\XINT_expr_onlitteral_mul_f #1#2{\xint_c_xviii `{opxmul}#2)\relax #1}%
%    \end{macrocode}
% \subsubsection{\csh{XINT_expr_func_opxadd}, \csh{XINT_flexpr_func_opxadd},
% \csh{XINT_iiexpr_func_opxadd} and same for mul}
% |modified 1.2c.|
%    \begin{macrocode}
\def\XINT_expr_func_opxadd   #1#2{\XINT_allexpr_opx \xintbareeval      {\xintAdd 0}}%
\def\XINT_flexpr_func_opxadd #1#2{\XINT_allexpr_opx \xintbarefloateval {\XINTinFloatAdd 0}}%
\def\XINT_iiexpr_func_opxadd #1#2{\XINT_allexpr_opx \xintbareiieval    {\xintiiAdd 0}}%
\def\XINT_expr_func_opxmul   #1#2{\XINT_allexpr_opx \xintbareeval      {\xintMul 1}}%
\def\XINT_flexpr_func_opxmul #1#2{\XINT_allexpr_opx \xintbarefloateval {\XINTinFloatMul 1}}%
\def\XINT_iiexpr_func_opxmul #1#2{\XINT_allexpr_opx \xintbareiieval    {\xintiiMul 1}}%
%    \end{macrocode}
% \lverb|#1=bareval etc, #2={Add0} ou {Mul1}, #3=liste encapsule, #4=la variable, #5=expression|
%    \begin{macrocode}
\def\XINT_allexpr_opx #1#2#3#4#5%
{% 
    \expandafter\XINT_expr_getop
    \csname.=\romannumeral`&&@\expandafter\XINT_expr_op:_a
             \romannumeral`&&@\XINT_expr_unlock #3!{#1#5\relax !#4}{#2}\endcsname
}%
\def\XINT_expr_op:_a #1!#2#3{\XINT_expr_op:_b #3{#2}#1,^,}%
%    \end{macrocode}
% \lverb|#2 in \XINT_expr_op:_b is the partial result of computation so far, not
% locked. A noop with have #4=, and #5 the next item which we need to recover.
% No need to be very efficient for that in op:_noop. In op:_d, #4 is \xintAdd or
% similar.|
%    \begin{macrocode}
\def\XINT_expr_op:_b #1#2#3#4#5,{%
    \if  ,#4\xint_dothis\XINT_expr_op:_noop\fi
    \if  ^#4\xint_dothis\XINT_expr_op:_end\fi
    \xint_orthat{\expandafter\XINT_expr_op:_c}\csname.=#4#5\endcsname {#3}#1{#2}%
}%
\def\XINT_expr_op:_c #1#2#3#4{\expandafter\XINT_expr_op:_d\romannumeral0#2#1#3{#4}{#2}}%
\def\XINT_expr_op:_d #1!#2#3#4#5%
    {\expandafter\XINT_expr_op:_b\expandafter #4\expandafter 
                            {\romannumeral`&&@#4{\XINT_expr_unlock#1}{#5}}}%
\def\XINT_expr_op:_noop\csname.=,#1\endcsname #2#3#4{\XINT_expr_seq:_b #3{#4}{#2}#1,}%
\def\XINT_expr_op:_end \csname.=^\endcsname #1#2#3{#3}%
%    \end{macrocode}
% \subsection{subs}
% \lverb|Got simpler with 1.2c as now the dummy variable fetches an already encapsulated
% value, which is anyhow the form in which we get it.|
%    \begin{macrocode}
\def\XINT_expr_onlitteral_subs 
 {\expandafter\XINT_expr_onlitteral_subs_f\romannumeral`&&@\XINT_expr_onlitteral_seq_a {}}%
\def\XINT_expr_onlitteral_subs_f #1#2{\xint_c_xviii `{subx}#2)\relax #1}%
\def\XINT_expr_func_subx   #1#2{\XINT_allexpr_subx \xintbareeval }%
\def\XINT_flexpr_func_subx #1#2{\XINT_allexpr_subx \xintbarefloateval}%
\def\XINT_iiexpr_func_subx #1#2{\XINT_allexpr_subx \xintbareiieval }%
\def\XINT_allexpr_subx #1#2#3#4% #2 is the value to assign to the dummy variable
{% #3 is the dummy variable, #4 is the expression to evaluate
    \expandafter\expandafter\expandafter\XINT_expr_getop
    \expandafter\XINT_expr_subx:_end\romannumeral0#1#4\relax !#3#2%
}%
\def\XINT_expr_subx:_end #1!#2#3{#1}%
%    \end{macrocode}
% \subsection{rseq}
% \localtableofcontents 
%
% \lverb|When func_rseq has its turn, initial segment has been scanned by
% oparen, the ; mimicking the rle of a closing parenthesis, and stopping
% further expansion. Notice that the ; is discovered during standard parsing
% mode, it may be for example {;} or arise from expansion as rseq does not use
% a delimited macro to locate it.
%
% Here and in rrseq and iter, 1.2c adds also use of \xintthebareeval, etc...|
%    \begin{macrocode}
\def\XINT_expr_func_rseq   {\XINT_allexpr_rseq \xintbareeval      \xintthebareeval      }%
\def\XINT_flexpr_func_rseq {\XINT_allexpr_rseq \xintbarefloateval \xintthebarefloateval }%
\def\XINT_iiexpr_func_rseq {\XINT_allexpr_rseq \xintbareiieval    \xintthebareiieval    }%
\def\XINT_allexpr_rseq #1#2#3%
{%
    \expandafter\XINT_expr_rseqx\expandafter #1\expandafter#2\expandafter
    #3\romannumeral`&&@\XINT_expr_onlitteral_seq_a {}%
}%
%    \end{macrocode}
% \subsubsection{\csh{XINT_expr_rseqx}}
% \lverb|The (#5) is for ++ mechanism which must have its closing parenthesis.|
%    \begin{macrocode}
\def\XINT_expr_rseqx #1#2#3#4#5%
{%
    \expandafter\XINT_expr_rseqy\romannumeral0#1(#5)\relax #3#4#2%
}%
%    \end{macrocode}
% \subsubsection{\csh{XINT_expr_rseqy}}
% \lverb|#1=valeurs pour variable (locked),
% #2=toutes les valeurs initiales  (csv,locked),
% #3=variable, #4=expr,
% #5=\xintthebareeval ou \xintthebarefloateval ou \xintthebareiieval|
%    \begin{macrocode}
\def\XINT_expr_rseqy #1#2#3#4#5%
{%
    \expandafter \XINT_expr_getop
    \csname .=\XINT_expr_unlock #2%
    \expandafter\XINT_expr_rseq:_aa
                \romannumeral`&&@\XINT_expr_unlock #1!{#5#4\relax !#3}#2\endcsname
}%
\def\XINT_expr_rseq:_aa #1{\if +#1\expandafter\XINT_expr_rseq:_A\else
                                  \expandafter\XINT_expr_rseq:_a\fi #1}%
%    \end{macrocode}
% \subsubsection{\csh{XINT_expr_rseq:_a} etc\dots}
%    \begin{macrocode}
\def\XINT_expr_rseq:_a #1!#2#3{\XINT_expr_rseq:_b {#3}{#2}#1,^,}%
\def\XINT_expr_rseq:_b #1#2#3#4,{%
     \if ,#3\xint_dothis\XINT_expr_rseq:_noop\fi
     \if ^#3\xint_dothis\XINT_expr_rseq:_end\fi
     \xint_orthat{\expandafter\XINT_expr_rseq:_c}\csname.=#3#4\endcsname
     {#1}{#2}%
}%
\def\XINT_expr_rseq:_noop\csname.=,#1\endcsname #2#3{\XINT_expr_rseq:_b {#2}{#3}#1,}%
\def\XINT_expr_rseq:_end \csname.=^\endcsname #1#2{}%
\def\XINT_expr_rseq:_c #1#2#3%
   {\expandafter\XINT_expr_rseq:_d\romannumeral`&&@#3#1~#2{#3}}%
\def\XINT_expr_rseq:_d #1{%
    \if ^#1\xint_dothis\XINT_expr_rseq:_abort\fi
    \if ?#1\xint_dothis\XINT_expr_rseq:_break\fi
    \if !#1\xint_dothis\XINT_expr_rseq:_omit\fi
    \xint_orthat{\XINT_expr_rseq:_goon #1}}%
\def\XINT_expr_rseq:_goon  #1!#2#3~#4#5{,#1\expandafter\XINT_expr_rseq:_b 
        \romannumeral0\XINT_expr_lockit {#1}{#5}}%
\def\XINT_expr_rseq:_omit  #1!#2#3~{\XINT_expr_rseq:_b }%
\def\XINT_expr_rseq:_abort #1!#2#3~#4#5#6^,{}%
\def\XINT_expr_rseq:_break #1!#2#3~#4#5#6^,{,#1}%
%    \end{macrocode}
% \subsubsection{\csh{XINT_expr_rseq:_A} etc\dots}
% \lverb |n++ for rseq. With 1.2c dummy variables pick a single token.|
%    \begin{macrocode}
\def\XINT_expr_rseq:_A +#1!#2#3{\XINT_expr_rseq:_D #1#3{#2}}%
\def\XINT_expr_rseq:_D #1#2#3%
   {\expandafter\XINT_expr_rseq:_E\romannumeral`&&@#3#1~#2{#3}}%
\def\XINT_expr_rseq:_E #1{\if #1^\xint_dothis\XINT_expr_rseq:_Abort\fi
                         \if #1?\xint_dothis\XINT_expr_rseq:_Break\fi
                         \if #1!\xint_dothis\XINT_expr_rseq:_Omit\fi
                         \xint_orthat{\XINT_expr_rseq:_Goon #1}}%
\def\XINT_expr_rseq:_Goon  #1!#2#3~#4#5%
    {,#1\expandafter\XINT_expr_rseq:_D
        \csname.=\the\numexpr \XINT_expr_unlock#3+\xint_c_i\expandafter\endcsname
     \romannumeral0\XINT_expr_lockit{#1}{#5}}%
\def\XINT_expr_rseq:_Omit  #1!#2#3~%#4#5%
    {\expandafter\XINT_expr_rseq:_D
       \csname.=\the\numexpr \XINT_expr_unlock#3+\xint_c_i\endcsname }%
\def\XINT_expr_rseq:_Abort #1!#2#3~#4#5{}%
\def\XINT_expr_rseq:_Break #1!#2#3~#4#5{,#1}%
%    \end{macrocode}
% \subsection{rrseq}
% \localtableofcontents
% \lverb|When func_rrseq has its turn, initial segment has been scanned by oparen, the ;
% mimicking the rle of a closing parenthesis, and stopping further expansion.|
%    \begin{macrocode}
\def\XINT_expr_func_rrseq   {\XINT_allexpr_rrseq \xintbareeval      \xintthebareeval      }%
\def\XINT_flexpr_func_rrseq {\XINT_allexpr_rrseq \xintbarefloateval \xintthebarefloateval }%
\def\XINT_iiexpr_func_rrseq {\XINT_allexpr_rrseq \xintbareiieval    \xintthebareiieval    }%
\def\XINT_allexpr_rrseq #1#2#3%
{%
    \expandafter\XINT_expr_rrseqx\expandafter #1\expandafter#2\expandafter
    #3\romannumeral`&&@\XINT_expr_onlitteral_seq_a {}%
}%
%    \end{macrocode}
% \subsubsection{\csh{XINT_expr_rrseqx}}
% \lverb|The (#5) is for ++ mechanism which must have its closing parenthesis.|
%    \begin{macrocode}
\def\XINT_expr_rrseqx #1#2#3#4#5%
{%
    \expandafter\XINT_expr_rrseqy\romannumeral0#1(#5)\expandafter\relax
    \expandafter{\romannumeral0\xintapply \XINT_expr_lockit
       {\xintRevWithBraces{\xintCSVtoListNonStripped{\XINT_expr_unlock #3}}}}%
    #3#4#2%
}%
%    \end{macrocode}
% \subsubsection{\csh{XINT_expr_rrseqy}}
% \lverb|#1=valeurs pour variable (locked),
% #2=initial values (reversed, one (braced) token each)
% #3=toutes les valeurs initiales  (csv,locked),
% #4=variable, #5=expr,
% #6=\xintthebareeval ou \xintthebarefloateval ou \xintthebareiieval|
%    \begin{macrocode}
\def\XINT_expr_rrseqy #1#2#3#4#5#6%
{%
    \expandafter \XINT_expr_getop
    \csname .=\XINT_expr_unlock #3%
    \expandafter\XINT_expr_rrseq:_aa
                \romannumeral`&&@\XINT_expr_unlock #1!{#6#5\relax !#4}{#2}\endcsname
}%
\def\XINT_expr_rrseq:_aa #1{\if +#1\expandafter\XINT_expr_rrseq:_A\else
                                  \expandafter\XINT_expr_rrseq:_a\fi #1}%
%    \end{macrocode}
% \subsubsection{\csh{XINT_expr_rrseq:_a} etc\dots}
% \lverb|Attention que ? a catcode 3 ici et dans iter.|
%    \begin{macrocode}
\catcode`? 3
\def\XINT_expr_rrseq:_a #1!#2#3{\XINT_expr_rrseq:_b {#3}{#2}#1,^,}%
\def\XINT_expr_rrseq:_b #1#2#3#4,{%
     \if ,#3\xint_dothis\XINT_expr_rrseq:_noop\fi
     \if ^#3\xint_dothis\XINT_expr_rrseq:_end\fi
     \xint_orthat{\expandafter\XINT_expr_rrseq:_c}\csname.=#3#4\endcsname
     {#1}{#2}%
}%
\def\XINT_expr_rrseq:_noop\csname.=,#1\endcsname #2#3{\XINT_expr_rrseq:_b {#2}{#3}#1,}%
\def\XINT_expr_rrseq:_end \csname.=^\endcsname #1#2{}%
\def\XINT_expr_rrseq:_c #1#2#3%
   {\expandafter\XINT_expr_rrseq:_d\romannumeral`&&@#3#1~#2?{#3}}%
\def\XINT_expr_rrseq:_d #1{%
    \if ^#1\xint_dothis\XINT_expr_rrseq:_abort\fi
    \if ?#1\xint_dothis\XINT_expr_rrseq:_break\fi
    \if !#1\xint_dothis\XINT_expr_rrseq:_omit\fi
    \xint_orthat{\XINT_expr_rrseq:_goon #1}%
}%
\def\XINT_expr_rrseq:_goon  #1!#2#3~#4?#5{,#1\expandafter\XINT_expr_rrseq:_b\expandafter
        {\romannumeral0\xinttrim{-1}{\XINT_expr_lockit{#1}#4}}{#5}}%
\def\XINT_expr_rrseq:_omit  #1!#2#3~{\XINT_expr_rrseq:_b }%
\def\XINT_expr_rrseq:_abort #1!#2#3~#4?#5#6^,{}%
\def\XINT_expr_rrseq:_break #1!#2#3~#4?#5#6^,{,#1}%
%    \end{macrocode}
% \subsubsection{\csh{XINT_expr_rrseq:_A} etc\dots}
% \lverb |n++ for rrseq. With 1.2C, the #1 in \XINT_expr_rrseq:_A is a single token.|
%    \begin{macrocode}
\def\XINT_expr_rrseq:_A +#1!#2#3{\XINT_expr_rrseq:_D #1{#3}{#2}}%
\def\XINT_expr_rrseq:_D #1#2#3%
   {\expandafter\XINT_expr_rrseq:_E\romannumeral`&&@#3#1~#2?{#3}}%
\def\XINT_expr_rrseq:_Goon  #1!#2#3~#4?#5%
   {,#1\expandafter\XINT_expr_rrseq:_D
       \csname.=\the\numexpr \XINT_expr_unlock#3+\xint_c_i\expandafter\endcsname
    \expandafter{\romannumeral0\xinttrim{-1}{\XINT_expr_lockit{#1}#4}}{#5}}%
\def\XINT_expr_rrseq:_Omit  #1!#2#3~%#4?#5%
    {\expandafter\XINT_expr_rrseq:_D
            \csname.=\the\numexpr \XINT_expr_unlock#3+\xint_c_i\endcsname}%
\def\XINT_expr_rrseq:_Abort #1!#2#3~#4?#5{}%
\def\XINT_expr_rrseq:_Break #1!#2#3~#4?#5{,#1}%
\def\XINT_expr_rrseq:_E #1{\if #1^\xint_dothis\XINT_expr_rrseq:_Abort\fi
                         \if #1?\xint_dothis\XINT_expr_rrseq:_Break\fi
                         \if #1!\xint_dothis\XINT_expr_rrseq:_Omit\fi
                         \xint_orthat{\XINT_expr_rrseq:_Goon #1}}%
%    \end{macrocode}
% \subsection{iter}
% \localtableofcontents
%    \begin{macrocode}
\def\XINT_expr_func_iter   {\XINT_allexpr_iter \xintbareeval      \xintthebareeval      }%
\def\XINT_flexpr_func_iter {\XINT_allexpr_iter \xintbarefloateval \xintthebarefloateval }%
\def\XINT_iiexpr_func_iter {\XINT_allexpr_iter \xintbareiieval    \xintthebareiieval    }%
\def\XINT_allexpr_iter #1#2#3%
{%
    \expandafter\XINT_expr_iterx\expandafter #1\expandafter #2\expandafter
    #3\romannumeral`&&@\XINT_expr_onlitteral_seq_a {}%
}%
%    \end{macrocode}
% \subsubsection{\csh{XINT_expr_iterx}}
% \lverb|The (#5) is for ++ mechanism which must have its closing parenthesis.|
%    \begin{macrocode}
\def\XINT_expr_iterx #1#2#3#4#5%
{%
    \expandafter\XINT_expr_itery\romannumeral0#1(#5)\expandafter\relax
    \expandafter{\romannumeral0\xintapply \XINT_expr_lockit
       {\xintRevWithBraces{\xintCSVtoListNonStripped{\XINT_expr_unlock #3}}}}%
    #3#4#2%
}%
%    \end{macrocode}
% \subsubsection{\csh{XINT_expr_itery}}
% \lverb|#1=valeurs pour variable (locked),
% #2=initial values (reversed, one (braced) token each)
% #3=toutes les valeurs initiales  (csv,locked),
% #4=variable, #5=expr,
% #6=\xintbareeval ou \xintbarefloateval ou \xintbareiieval|
%    \begin{macrocode}
\def\XINT_expr_itery #1#2#3#4#5#6%
{%
    \expandafter \XINT_expr_getop
    \csname .=%
    \expandafter\XINT_expr_iter:_aa
                \romannumeral`&&@\XINT_expr_unlock #1!{#6#5\relax !#4}{#2}\endcsname
}%
\def\XINT_expr_iter:_aa #1{\if +#1\expandafter\XINT_expr_iter:_A\else
                                  \expandafter\XINT_expr_iter:_a\fi #1}%
%    \end{macrocode}
% \subsubsection{\csh{XINT_expr_iter:_a} etc\dots}
%    \begin{macrocode}
\def\XINT_expr_iter:_a #1!#2#3{\XINT_expr_iter:_b {#3}{#2}#1,^,}%
\def\XINT_expr_iter:_b #1#2#3#4,{%
     \if ,#3\xint_dothis\XINT_expr_iter:_noop\fi
     \if ^#3\xint_dothis\XINT_expr_iter:_end\fi
     \xint_orthat{\expandafter\XINT_expr_iter:_c}\csname.=#3#4\endcsname
     {#1}{#2}%
}%
\def\XINT_expr_iter:_noop\csname.=,#1\endcsname #2#3{\XINT_expr_iter:_b {#2}{#3}#1,}%
\def\XINT_expr_iter:_end \csname.=^\endcsname #1#2%
   {\expandafter\xint_gobble_i\romannumeral0\xintapplyunbraced
          {,\XINT_expr:_unlock}{\xintReverseOrder{#1\space}}}%
\def\XINT_expr_iter:_c #1#2#3%
   {\expandafter\XINT_expr_iter:_d\romannumeral`&&@#3#1~#2?{#3}}%
\def\XINT_expr_iter:_d #1{%
    \if ^#1\xint_dothis\XINT_expr_iter:_abort\fi
    \if ?#1\xint_dothis\XINT_expr_iter:_break\fi
    \if !#1\xint_dothis\XINT_expr_iter:_omit\fi
    \xint_orthat{\XINT_expr_iter:_goon #1}%
}%
\def\XINT_expr_iter:_goon  #1!#2#3~#4?#5{\expandafter\XINT_expr_iter:_b\expandafter
        {\romannumeral0\xinttrim{-1}{\XINT_expr_lockit{#1}#4}}{#5}}%
\def\XINT_expr_iter:_omit  #1!#2#3~{\XINT_expr_iter:_b }%
\def\XINT_expr_iter:_abort #1!#2#3~#4?#5#6^,%
   {\expandafter\xint_gobble_i\romannumeral0\xintapplyunbraced
          {,\XINT_expr:_unlock}{\xintReverseOrder{#4\space}}}%
\def\XINT_expr_iter:_break #1!#2#3~#4?#5#6^,%
   {\expandafter\xint_gobble_iv\romannumeral0\xintapplyunbraced
          {,\XINT_expr:_unlock}{\xintReverseOrder{#4\space}},#1}%
\def\XINT_expr:_unlock #1{\XINT_expr_unlock #1}%
%    \end{macrocode}
% \subsubsection{\csh{XINT_expr_iter:_A} etc\dots}
% \lverb |n++ for iter. ? is of catcode 3 here.|
%    \begin{macrocode}
\def\XINT_expr_iter:_A +#1!#2#3{\XINT_expr_iter:_D #1{#3}{#2}}%
\def\XINT_expr_iter:_D #1#2#3%
   {\expandafter\XINT_expr_iter:_E\romannumeral`&&@#3#1~#2?{#3}}%
\def\XINT_expr_iter:_Goon  #1!#2#3~#4?#5%
   {\expandafter\XINT_expr_iter:_D
    \csname.=\the\numexpr \XINT_expr_unlock#3+\xint_c_i\expandafter\endcsname
    \expandafter{\romannumeral0\xinttrim{-1}{\XINT_expr_lockit{#1}#4}}{#5}}%
\def\XINT_expr_iter:_Omit  #1!#2#3~%#4?#5%
    {\expandafter\XINT_expr_iter:_D
     \csname.=\the\numexpr \XINT_expr_unlock#3+\xint_c_i\endcsname}%
\def\XINT_expr_iter:_Abort #1!#2#3~#4?#5%
   {\expandafter\xint_gobble_i\romannumeral0\xintapplyunbraced
          {,\XINT_expr:_unlock}{\xintReverseOrder{#4\space}}}%
\def\XINT_expr_iter:_Break #1!#2#3~#4?#5%
   {\expandafter\xint_gobble_iv\romannumeral0\xintapplyunbraced
          {,\XINT_expr:_unlock}{\xintReverseOrder{#4\space}},#1}%
\def\XINT_expr_iter:_E #1{\if #1^\xint_dothis\XINT_expr_iter:_Abort\fi
                         \if #1?\xint_dothis\XINT_expr_iter:_Break\fi
                         \if #1!\xint_dothis\XINT_expr_iter:_Omit\fi
                         \xint_orthat{\XINT_expr_iter:_Goon #1}}%
\catcode`? 11
%    \end{macrocode}
% \subsection{Macros handling csv lists for functions with multiple comma
% separated arguments in expressions}
% \localtableofcontents
% \lverb|These 17 macros are used inside \csname...\endcsname. These things
% are not initiated by a \romannumeral in general, but in some cases they are,
% especially when involved in an \xintNewExpr. They will then be protected
% against expansion and expand only later in contexts governed by an
% initial \romannumeral-`0. There each new item may need to be expanded, which
% would not be the case in the use for the _func_ things.|
% \subsubsection{\csh{xintANDof:csv}}
% \lverb|1.09a. For use by \xintexpr inside \csname. 1.1, je remplace
% ifTrueAelseB par iiNotZero pour des raisons d'optimisations.|
%    \begin{macrocode}
\def\xintANDof:csv #1{\expandafter\XINT_andof:_a\romannumeral`&&@#1,,^}%
\def\XINT_andof:_a #1{\if ,#1\expandafter\XINT_andof:_e
                      \else\expandafter\XINT_andof:_c\fi #1}%
\def\XINT_andof:_c #1,{\xintiiifNotZero {#1}{\XINT_andof:_a}{\XINT_andof:_no}}%
\def\XINT_andof:_no #1^{0}%
\def\XINT_andof:_e  #1^{1}% works with empty list
%    \end{macrocode}
% \subsubsection{\csh{xintORof:csv}}
% \lverb|1.09a. For use by \xintexpr.|
%    \begin{macrocode}
\def\xintORof:csv #1{\expandafter\XINT_orof:_a\romannumeral`&&@#1,,^}%
\def\XINT_orof:_a #1{\if ,#1\expandafter\XINT_orof:_e
                      \else\expandafter\XINT_orof:_c\fi #1}%
\def\XINT_orof:_c #1,{\xintiiifNotZero{#1}{\XINT_orof:_yes}{\XINT_orof:_a}}%
\def\XINT_orof:_yes #1^{1}%
\def\XINT_orof:_e   #1^{0}% works with empty list
%    \end{macrocode}
% \subsubsection{\csh{xintXORof:csv}}
% \lverb|1.09a. For use by \xintexpr (inside a \csname..\endcsname).|
%    \begin{macrocode}
\def\xintXORof:csv #1{\expandafter\XINT_xorof:_a\expandafter 0\romannumeral`&&@#1,,^}%
\def\XINT_xorof:_a #1#2,{\XINT_xorof:_b #2,#1}%
\def\XINT_xorof:_b #1{\if ,#1\expandafter\XINT_xorof:_e
                      \else\expandafter\XINT_xorof:_c\fi #1}%
\def\XINT_xorof:_c #1,#2%
           {\xintiiifNotZero {#1}{\if #20\xint_afterfi{\XINT_xorof:_a 1}%
                                   \else\xint_afterfi{\XINT_xorof:_a 0}\fi}%
                                  {\XINT_xorof:_a #2}%
           }%
\def\XINT_xorof:_e ,#1#2^{#1}% allows empty list (then returns 0)
%    \end{macrocode}
% \subsubsection{Generic csv routine}
% \lverb|1.1. generic routine. up to the loss of some efficiency, especially
% for Sum:csv and Prod:csv, where \XINTinFloat will be done twice for each
% argument.|
%    \begin{macrocode}
\def\XINT_oncsv:_empty  #1,^,#2{#2}%
\def\XINT_oncsv:_end    ^,#1#2#3#4{#1}%
\def\XINT_oncsv:_a #1#2#3%
   {\if ,#3\expandafter\XINT_oncsv:_empty\else\expandafter\XINT_oncsv:_b\fi #1#2#3}%
\def\XINT_oncsv:_b #1#2#3,%
   {\expandafter\XINT_oncsv:_c \expandafter{\romannumeral`&&@#2{#3}}#1#2}%
\def\XINT_oncsv:_c #1#2#3#4,{\expandafter\XINT_oncsv:_d \romannumeral`&&@#4,{#1}#2#3}%
\def\XINT_oncsv:_d #1%
   {\if ^#1\expandafter\XINT_oncsv:_end\else\expandafter\XINT_oncsv:_e\fi #1}%
\def\XINT_oncsv:_e #1,#2#3#4%
   {\expandafter\XINT_oncsv:_c\expandafter {\romannumeral`&&@#3{#4{#1}}{#2}}#3#4}%
%    \end{macrocode}
% \subsubsection{\csh{xintMaxof:csv}, \csh{xintiiMaxof:csv}}
% \lverb|1.09i. Rewritten for 1.1. Compatible avec liste vide donnant valeur par
% dfaut. Pas compatible avec items manquants.
% ah je m'aperois au dernier moment que je n'ai pas en effet de \xintiiMax.
% Je devrais le rajouter. En tout cas ici c'est uniquement pour xintiiexpr,
% dans il faut bien sr ne pas faire de xintNum, donc il faut un iimax.|
%    \begin{macrocode}
\def\xintMaxof:csv #1{\expandafter\XINT_oncsv:_a\expandafter\xintmax
                      \expandafter\xint_firstofone\romannumeral`&&@#1,^,{0/1[0]}}%
\def\xintiiMaxof:csv #1{\expandafter\XINT_oncsv:_a\expandafter\xintiimax
                       \expandafter\xint_firstofone\romannumeral`&&@#1,^,0}%
%    \end{macrocode}
% \subsubsection{\csh{xintMinof:csv}, \csh{xintiiMinof:csv}}
% \lverb|1.09i. Rewritten for 1.1. For use by \xintiiexpr.|
%    \begin{macrocode}
\def\xintMinof:csv #1{\expandafter\XINT_oncsv:_a\expandafter\xintmin
                       \expandafter\xint_firstofone\romannumeral`&&@#1,^,{0/1[0]}}%
\def\xintiiMinof:csv #1{\expandafter\XINT_oncsv:_a\expandafter\xintiimin
                       \expandafter\xint_firstofone\romannumeral`&&@#1,^,0}%
%    \end{macrocode}
% \subsubsection{\csh{xintSum:csv}, \csh{xintiiSum:csv}}
% \lverb|1.09a. Rewritten for 1.1. For use by \xintexpr.|
%    \begin{macrocode}
\def\xintSum:csv #1{\expandafter\XINT_oncsv:_a\expandafter\xintadd
                    \expandafter\xint_firstofone\romannumeral`&&@#1,^,{0/1[0]}}%
\def\xintiiSum:csv #1{\expandafter\XINT_oncsv:_a\expandafter\xintiiadd
                      \expandafter\xint_firstofone\romannumeral`&&@#1,^,0}%
%    \end{macrocode}
% \subsubsection{\csh{xintPrd:csv}, \csh{xintiiPrd:csv}}
% \lverb|1.09a. Rewritten for 1.1. For use by \xintexpr.|
%    \begin{macrocode}
\def\xintPrd:csv #1{\expandafter\XINT_oncsv:_a\expandafter\xintmul
                    \expandafter\xint_firstofone\romannumeral`&&@#1,^,{1/1[0]}}%
\def\xintiiPrd:csv #1{\expandafter\XINT_oncsv:_a\expandafter\xintiimul
                      \expandafter\xint_firstofone\romannumeral`&&@#1,^,1}%
%    \end{macrocode}
% \subsubsection{\csh{xintGCDof:csv}, \csh{xintLCMof:csv}}
% \lverb|1.09a. Rewritten for 1.1. For use by \xintexpr. Expansion rinstaure
% pour besoins de xintNewExpr de version 1.1|
%    \begin{macrocode}
\def\xintGCDof:csv #1{\expandafter\XINT_oncsv:_a\expandafter\xintgcd
                      \expandafter\xint_firstofone\romannumeral`&&@#1,^,1}%
\def\xintLCMof:csv #1{\expandafter\XINT_oncsv:_a\expandafter\xintlcm
                      \expandafter\xint_firstofone\romannumeral`&&@#1,^,0}%
%    \end{macrocode}
% \subsubsection{\csh{xintiiGCDof:csv}, \csh{xintiiLCMof:csv}}
% \lverb|1.1a pour \xintiiexpr. Ces histoires de ii sont pnibles  la fin.|
%    \begin{macrocode}
\def\xintiiGCDof:csv #1{\expandafter\XINT_oncsv:_a\expandafter\xintiigcd
                      \expandafter\xint_firstofone\romannumeral`&&@#1,^,1}%
\def\xintiiLCMof:csv #1{\expandafter\XINT_oncsv:_a\expandafter\xintiilcm
                      \expandafter\xint_firstofone\romannumeral`&&@#1,^,0}%
%    \end{macrocode}
% \subsubsection{\csh{XINTinFloatdigits}, \csh{XINTinFloatSqrtdigits}}
% \lverb|for \xintNewExpr matters, mainly.|
%    \begin{macrocode}
\def\XINTinFloatdigits     {\XINTinFloat [\XINTdigits]}%
\def\XINTinFloatSqrtdigits {\XINTinFloatSqrt [\XINTdigits]}%
%    \end{macrocode}
% \subsubsection{\csh{XINTinFloatMaxof:csv}, \csh{XINTinFloatMinof:csv}}
% \lverb|1.09a. Rewritten for 1.1. For use by \xintfloatexpr. Name changed in 1.09h|
%    \begin{macrocode}
\def\XINTinFloatMaxof:csv #1{\expandafter\XINT_oncsv:_a\expandafter\xintmax
                         \expandafter\XINTinFloatdigits\romannumeral`&&@#1,^,{0[0]}}%
\def\XINTinFloatMinof:csv #1{\expandafter\XINT_oncsv:_a\expandafter\xintmin
                         \expandafter\XINTinFloatdigits\romannumeral`&&@#1,^,{0[0]}}%
%    \end{macrocode}
% \subsubsection{\csh{XINTinFloatSum:csv}, \csh{XINTinFloatPrd:csv}}
% \lverb|1.09a. Rewritten for 1.1. For use by \xintfloatexpr.|
%    \begin{macrocode}
\def\XINTinFloatSum:csv #1{\expandafter\XINT_oncsv:_a\expandafter\XINTinfloatadd
                        \expandafter\XINTinFloatdigits\romannumeral`&&@#1,^,{0[0]}}%
\def\XINTinFloatPrd:csv #1{\expandafter\XINT_oncsv:_a\expandafter\XINTinfloatmul
                        \expandafter\XINTinFloatdigits\romannumeral`&&@#1,^,{1[0]}}%
%    \end{macrocode}
% \subsection{The num, reduce, abs, sgn, frac, floor, ceil, sqr, sqrt, sqrtr, float,
% round, trunc, mod, quo, rem, gcd, lcm, max, min, \textasciigrave
% +\textasciigrave, \textasciigrave
% \texorpdfstring{\protect\lowast}{*}\textasciigrave, ?, !, not, all, any,
% xor, if, ifsgn, first, last, even, odd, and reversed functions}
% \localtableofcontents
%    \begin{macrocode}
\def\XINT_expr_twoargs #1,#2,{{#1}{#2}}%
\def\XINT_expr_argandopt #1,#2,#3.#4#5%
{%
    \if\relax#3\relax\expandafter\xint_firstoftwo\else
                     \expandafter\xint_secondoftwo\fi
    {#4}{#5[\xintNum {#2}]}{#1}%
}%
\def\XINT_expr_oneortwo #1#2#3,#4,#5.%
{%
    \if\relax#5\relax\expandafter\xint_firstoftwo\else
                     \expandafter\xint_secondoftwo\fi
    {#1{0}}{#2{\xintNum {#4}}}{#3}%
}%
\def\XINT_iiexpr_oneortwo #1#2,#3,#4.%
{%
    \if\relax#4\relax\expandafter\xint_firstoftwo\else
                     \expandafter\xint_secondoftwo\fi
    {#1{0}}{#1{#3}}{#2}%
}%
\def\XINT_expr_func_num #1#2#3%
    {\expandafter #1\expandafter #2\csname.=\xintNum {\XINT_expr_unlock #3}\endcsname }%
\let\XINT_flexpr_func_num\XINT_expr_func_num
\let\XINT_iiexpr_func_num\XINT_expr_func_num
% [0] added Oct 25. For interaction with SPRaw::csv
\def\XINT_expr_func_reduce #1#2#3%
  {\expandafter #1\expandafter #2\csname.=\xintIrr {\XINT_expr_unlock #3}[0]\endcsname }%
\let\XINT_flexpr_func_reduce\XINT_expr_func_reduce
% no \XINT_iiexpr_func_reduce
\def\XINT_expr_func_abs #1#2#3%
  {\expandafter #1\expandafter #2\csname.=\xintAbs {\XINT_expr_unlock #3}\endcsname }%
\let\XINT_flexpr_func_abs\XINT_expr_func_abs
\def\XINT_iiexpr_func_abs #1#2#3%
  {\expandafter #1\expandafter #2\csname.=\xintiiAbs {\XINT_expr_unlock #3}\endcsname }%
\def\XINT_expr_func_sgn #1#2#3%
  {\expandafter #1\expandafter #2\csname.=\xintSgn {\XINT_expr_unlock #3}\endcsname }%
\let\XINT_flexpr_func_sgn\XINT_expr_func_sgn
\def\XINT_iiexpr_func_sgn #1#2#3%
  {\expandafter #1\expandafter #2\csname.=\xintiiSgn {\XINT_expr_unlock #3}\endcsname }%
\def\XINT_expr_func_frac #1#2#3%
  {\expandafter #1\expandafter #2\csname.=\xintTFrac {\XINT_expr_unlock #3}\endcsname }%
\def\XINT_flexpr_func_frac #1#2#3{\expandafter #1\expandafter #2\csname 
    .=\XINTinFloatFracdigits {\XINT_expr_unlock #3}\endcsname }%
%    \end{macrocode}
% \lverb|no \XINT_iiexpr_func_frac|
%    \begin{macrocode}
\def\XINT_expr_func_floor #1#2#3%
  {\expandafter #1\expandafter #2\csname .=\xintFloor {\XINT_expr_unlock #3}\endcsname }%
\let\XINT_flexpr_func_floor\XINT_expr_func_floor
%    \end{macrocode}
% \lverb|The floor and ceil functions in \xintiiexpr require protect(a/b) or,
% better, \qfrac(a/b); else the / will be executed first and do an integer
% rounded division.|
%    \begin{macrocode}
\def\XINT_iiexpr_func_floor #1#2#3%
{%
  \expandafter #1\expandafter #2\csname.=\xintiFloor {\XINT_expr_unlock #3}\endcsname }%
\def\XINT_expr_func_ceil #1#2#3%
  {\expandafter #1\expandafter #2\csname .=\xintCeil {\XINT_expr_unlock #3}\endcsname }%
\let\XINT_flexpr_func_ceil\XINT_expr_func_ceil
\def\XINT_iiexpr_func_ceil #1#2#3%
{%
  \expandafter #1\expandafter #2\csname.=\xintiCeil {\XINT_expr_unlock #3}\endcsname }%
\def\XINT_expr_func_sqr #1#2#3%
    {\expandafter #1\expandafter #2\csname.=\xintSqr {\XINT_expr_unlock #3}\endcsname }%
\def\XINT_flexpr_func_sqr #1#2#3%
{%
    \expandafter #1\expandafter #2\csname
    .=\XINTinFloatMul{\XINT_expr_unlock #3}{\XINT_expr_unlock #3}\endcsname
}%
\def\XINT_iiexpr_func_sqr #1#2#3%
  {\expandafter #1\expandafter #2\csname.=\xintiiSqr {\XINT_expr_unlock #3}\endcsname }%
\def\XINT_expr_func_sqrt #1#2#3%
{%
    \expandafter #1\expandafter #2\csname .=%
    \expandafter\XINT_expr_argandopt
    \romannumeral`&&@\XINT_expr_unlock#3,,.\XINTinFloatSqrtdigits\XINTinFloatSqrt
    \endcsname
}%
\let\XINT_flexpr_func_sqrt\XINT_expr_func_sqrt
\def\XINT_iiexpr_func_sqrt #1#2#3%
 {\expandafter #1\expandafter #2\csname.=\xintiiSqrt {\XINT_expr_unlock #3}\endcsname }%
\def\XINT_iiexpr_func_sqrtr #1#2#3%
 {\expandafter #1\expandafter #2\csname.=\xintiiSqrtR {\XINT_expr_unlock #3}\endcsname }%
\def\XINT_expr_func_round #1#2#3%
{%
    \expandafter #1\expandafter #2\csname .=%
    \expandafter\XINT_expr_oneortwo
    \expandafter\xintiRound\expandafter\xintRound
    \romannumeral`&&@\XINT_expr_unlock #3,,.\endcsname
}%
\let\XINT_flexpr_func_round\XINT_expr_func_round
\def\XINT_iiexpr_func_round #1#2#3%
{%
    \expandafter #1\expandafter #2\csname .=%
    \expandafter\XINT_iiexpr_oneortwo\expandafter\xintiRound
    \romannumeral`&&@\XINT_expr_unlock #3,,.\endcsname
}%
\def\XINT_expr_func_trunc #1#2#3%
{%
    \expandafter #1\expandafter #2\csname .=%
    \expandafter\XINT_expr_oneortwo
    \expandafter\xintiTrunc\expandafter\xintTrunc
    \romannumeral`&&@\XINT_expr_unlock #3,,.\endcsname
}%
\let\XINT_flexpr_func_trunc\XINT_expr_func_trunc
\def\XINT_iiexpr_func_trunc #1#2#3%
{%
    \expandafter #1\expandafter #2\csname .=%
    \expandafter\XINT_iiexpr_oneortwo\expandafter\xintiTrunc
    \romannumeral`&&@\XINT_expr_unlock #3,,.\endcsname
}%
\def\XINT_expr_func_float #1#2#3%
{%
    \expandafter #1\expandafter #2\csname .=%
    \expandafter\XINT_expr_argandopt
    \romannumeral`&&@\XINT_expr_unlock #3,,.\XINTinFloatdigits\XINTinFloat
    \endcsname
}%
\let\XINT_flexpr_func_float\XINT_expr_func_float
% \XINT_iiexpr_func_float not defined
\def\XINT_expr_func_mod #1#2#3%
{%
    \expandafter #1\expandafter #2\csname .=%
    \expandafter\expandafter\expandafter\xintMod
    \expandafter\XINT_expr_twoargs
    \romannumeral`&&@\XINT_expr_unlock #3,\endcsname
}%
\def\XINT_flexpr_func_mod #1#2#3%
{%
    \expandafter #1\expandafter #2\csname .=%
    \expandafter\XINTinFloatMod
    \romannumeral`&&@\expandafter\XINT_expr_twoargs
    \romannumeral`&&@\XINT_expr_unlock #3,\endcsname
}%
\def\XINT_iiexpr_func_mod #1#2#3%
{%
    \expandafter #1\expandafter #2\csname .=%
    \expandafter\expandafter\expandafter\xintiiMod
    \expandafter\XINT_expr_twoargs
    \romannumeral`&&@\XINT_expr_unlock #3,\endcsname
}%
\def\XINT_expr_func_quo #1#2#3%
{%
    \expandafter #1\expandafter #2\csname .=%
    \expandafter\expandafter\expandafter\xintiQuo
    \expandafter\XINT_expr_twoargs
    \romannumeral`&&@\XINT_expr_unlock #3,\endcsname
}%
\let\XINT_flexpr_func_quo\XINT_expr_func_quo
\def\XINT_iiexpr_func_quo #1#2#3%
{%
    \expandafter #1\expandafter #2\csname .=%
    \expandafter\expandafter\expandafter\xintiiQuo
    \expandafter\XINT_expr_twoargs
    \romannumeral`&&@\XINT_expr_unlock #3,\endcsname
}%
\def\XINT_expr_func_rem #1#2#3%
{%
    \expandafter #1\expandafter #2\csname .=%
    \expandafter\expandafter\expandafter\xintiRem
    \expandafter\XINT_expr_twoargs
    \romannumeral`&&@\XINT_expr_unlock #3,\endcsname
}%
\let\XINT_flexpr_func_rem\XINT_expr_func_rem
\def\XINT_iiexpr_func_rem #1#2#3%
{%
    \expandafter #1\expandafter #2\csname .=%
    \expandafter\expandafter\expandafter\xintiiRem
    \expandafter\XINT_expr_twoargs
    \romannumeral`&&@\XINT_expr_unlock #3,\endcsname
}%
\def\XINT_expr_func_gcd #1#2#3%
   {\expandafter #1\expandafter #2\csname
                                      .=\xintGCDof:csv{\XINT_expr_unlock #3}\endcsname }%
\let\XINT_flexpr_func_gcd\XINT_expr_func_gcd
\def\XINT_iiexpr_func_gcd #1#2#3%
   {\expandafter #1\expandafter #2\csname
                                      .=\xintiiGCDof:csv{\XINT_expr_unlock #3}\endcsname }%
\def\XINT_expr_func_lcm #1#2#3%
    {\expandafter #1\expandafter #2\csname
                                      .=\xintLCMof:csv{\XINT_expr_unlock #3}\endcsname }%
\let\XINT_flexpr_func_lcm\XINT_expr_func_lcm
\def\XINT_iiexpr_func_lcm #1#2#3%
    {\expandafter #1\expandafter #2\csname
                                      .=\xintiiLCMof:csv{\XINT_expr_unlock #3}\endcsname }%
\def\XINT_expr_func_max #1#2#3%
    {\expandafter #1\expandafter #2\csname
                                      .=\xintMaxof:csv{\XINT_expr_unlock #3}\endcsname }%
\def\XINT_iiexpr_func_max #1#2#3%
    {\expandafter #1\expandafter #2\csname
                                     .=\xintiiMaxof:csv{\XINT_expr_unlock #3}\endcsname }%
\def\XINT_flexpr_func_max #1#2#3%
    {\expandafter #1\expandafter #2\csname
                               .=\XINTinFloatMaxof:csv{\XINT_expr_unlock #3}\endcsname }%
\def\XINT_expr_func_min #1#2#3%
    {\expandafter #1\expandafter #2\csname
                                      .=\xintMinof:csv{\XINT_expr_unlock #3}\endcsname }%
\def\XINT_iiexpr_func_min #1#2#3%
    {\expandafter #1\expandafter #2\csname
                                     .=\xintiiMinof:csv{\XINT_expr_unlock #3}\endcsname }%
\def\XINT_flexpr_func_min #1#2#3%
    {\expandafter #1\expandafter #2\csname
                               .=\XINTinFloatMinof:csv{\XINT_expr_unlock #3}\endcsname }%
\expandafter\def\csname XINT_expr_func_+\endcsname #1#2#3%
    {\expandafter #1\expandafter #2\csname
                                        .=\xintSum:csv{\XINT_expr_unlock #3}\endcsname }%
\expandafter\def\csname XINT_flexpr_func_+\endcsname #1#2#3%
    {\expandafter #1\expandafter #2\csname
                                 .=\XINTinFloatSum:csv{\XINT_expr_unlock #3}\endcsname }%
\expandafter\def\csname XINT_iiexpr_func_+\endcsname #1#2#3%
    {\expandafter #1\expandafter #2\csname
                                      .=\xintiiSum:csv{\XINT_expr_unlock #3}\endcsname }%
\expandafter\def\csname XINT_expr_func_*\endcsname #1#2#3%
    {\expandafter #1\expandafter #2\csname
                                        .=\xintPrd:csv{\XINT_expr_unlock #3}\endcsname }%
\expandafter\def\csname XINT_flexpr_func_*\endcsname #1#2#3%
    {\expandafter #1\expandafter #2\csname
                                 .=\XINTinFloatPrd:csv{\XINT_expr_unlock #3}\endcsname }%
\expandafter\def\csname XINT_iiexpr_func_*\endcsname #1#2#3%
    {\expandafter #1\expandafter #2\csname
                                      .=\xintiiPrd:csv{\XINT_expr_unlock #3}\endcsname }%
\def\XINT_expr_func_? #1#2#3%
    {\expandafter #1\expandafter #2\csname
                                   .=\xintiiIsNotZero {\XINT_expr_unlock #3}\endcsname }%
\let\XINT_flexpr_func_? \XINT_expr_func_?
\let\XINT_iiexpr_func_? \XINT_expr_func_?
\def\XINT_expr_func_! #1#2#3%
 {\expandafter #1\expandafter #2\csname.=\xintiiIsZero {\XINT_expr_unlock #3}\endcsname }%
\let\XINT_flexpr_func_! \XINT_expr_func_!
\let\XINT_iiexpr_func_! \XINT_expr_func_!
\def\XINT_expr_func_not #1#2#3%
 {\expandafter #1\expandafter #2\csname.=\xintiiIsZero {\XINT_expr_unlock #3}\endcsname }%
\let\XINT_flexpr_func_not \XINT_expr_func_not
\let\XINT_iiexpr_func_not \XINT_expr_func_not
\def\XINT_expr_func_all #1#2#3%
    {\expandafter #1\expandafter #2\csname
                                      .=\xintANDof:csv{\XINT_expr_unlock #3}\endcsname }%
\let\XINT_flexpr_func_all\XINT_expr_func_all
\let\XINT_iiexpr_func_all\XINT_expr_func_all
\def\XINT_expr_func_any #1#2#3%
    {\expandafter #1\expandafter #2\csname
                                       .=\xintORof:csv{\XINT_expr_unlock #3}\endcsname }%
\let\XINT_flexpr_func_any\XINT_expr_func_any
\let\XINT_iiexpr_func_any\XINT_expr_func_any
\def\XINT_expr_func_xor #1#2#3%
    {\expandafter #1\expandafter #2\csname
                                      .=\xintXORof:csv{\XINT_expr_unlock #3}\endcsname }%
\let\XINT_flexpr_func_xor\XINT_expr_func_xor
\let\XINT_iiexpr_func_xor\XINT_expr_func_xor
\def\xintifNotZero: #1,#2,#3,{\xintiiifNotZero{#1}{#2}{#3}}%
\def\XINT_expr_func_if #1#2#3%
    {\expandafter #1\expandafter #2\csname
         .=\expandafter\xintifNotZero:\romannumeral`&&@\XINT_expr_unlock #3,\endcsname }%
\let\XINT_flexpr_func_if\XINT_expr_func_if
\let\XINT_iiexpr_func_if\XINT_expr_func_if
\def\xintifSgn: #1,#2,#3,#4,{\xintiiifSgn{#1}{#2}{#3}{#4}}%
\def\XINT_expr_func_ifsgn #1#2#3%
{%
    \expandafter #1\expandafter #2\csname
         .=\expandafter\xintifSgn:\romannumeral`&&@\XINT_expr_unlock #3,\endcsname
}%
\let\XINT_flexpr_func_ifsgn\XINT_expr_func_ifsgn
\let\XINT_iiexpr_func_ifsgn\XINT_expr_func_ifsgn
\def\XINT_expr_func_first #1#2#3%
    {\expandafter #1\expandafter #2\csname.=\expandafter\XINT_expr_func_firsta 
     \romannumeral`&&@\XINT_expr_unlock #3,^\endcsname }%
\def\XINT_expr_func_firsta #1,#2^{#1}%
\let\XINT_flexpr_func_first\XINT_expr_func_first
\let\XINT_iiexpr_func_first\XINT_expr_func_first
\def\XINT_expr_func_last #1#2#3% will not work in \xintNewExpr if macro param involved
    {\expandafter #1\expandafter #2\csname.=\expandafter\XINT_expr_func_lasta 
     \romannumeral`&&@\XINT_expr_unlock #3,^\endcsname }%
\def\XINT_expr_func_lasta #1,#2%
   {\if ^#2 #1\expandafter\xint_gobble_ii\fi \XINT_expr_func_lasta #2}%
\let\XINT_flexpr_func_last\XINT_expr_func_last
\let\XINT_iiexpr_func_last\XINT_expr_func_last
\def\XINT_expr_func_odd #1#2#3%
    {\expandafter #1\expandafter #2\csname.=\xintOdd{\XINT_expr_unlock #3}\endcsname}% 
\let\XINT_flexpr_func_odd\XINT_expr_func_odd
\def\XINT_iiexpr_func_odd #1#2#3%
    {\expandafter #1\expandafter #2\csname.=\xintiiOdd{\XINT_expr_unlock #3}\endcsname}% 
\def\XINT_expr_func_even #1#2#3%
    {\expandafter #1\expandafter #2\csname.=\xintEven{\XINT_expr_unlock #3}\endcsname}% 
\let\XINT_flexpr_func_even\XINT_expr_func_even
\def\XINT_iiexpr_func_even #1#2#3%
    {\expandafter #1\expandafter #2\csname.=\xintiiEven{\XINT_expr_unlock #3}\endcsname}% 
\def\XINT_expr_func_nuple #1#2#3%
   {\expandafter #1\expandafter #2\csname .=\XINT_expr_unlock #3\endcsname }%
\let\XINT_flexpr_func_nuple\XINT_expr_func_nuple
\let\XINT_iiexpr_func_nuple\XINT_expr_func_nuple
%    \end{macrocode}
% \lverb|1.2c 
% hesitated but left the function "reversed" from 1.1 with this name, not "reverse".
% But the inner not public macro got renamed into \xintReverse::csv.|
%    \begin{macrocode}
\def\XINT_expr_func_reversed #1#2#3%
   {\expandafter #1\expandafter #2\csname .=%
                   \xintReverse::csv {\XINT_expr_unlock #3}\endcsname }%
\let\XINT_flexpr_func_reversed\XINT_expr_func_reversed
\let\XINT_iiexpr_func_reversed\XINT_expr_func_reversed
\def\xintReverse::csv #1% should be done directly, of course
   {\xintListWithSep,{\xintRevWithBraces {\xintCSVtoListNonStripped{#1}}}}%
%    \end{macrocode}
% \subsection{f-expandable versions of the \csh{xintSeqB::csv} and alike routines, for
% \csh{xintNewExpr}}
% \localtableofcontents
% \subsubsection{\csh{xintSeqB:f:csv}}
% \lverb|Produces in f-expandable way. If the step is zero, gives empty result
% except if start and end coincide.|
%    \begin{macrocode}
\def\xintSeqB:f:csv #1#2%
   {\expandafter\XINT_seqb:f:csv \expandafter{\romannumeral0\xintraw{#2}}{#1}}%
\def\XINT_seqb:f:csv #1#2{\expandafter\XINT_seqb:f:csv_a\romannumeral`&&@#2#1!}%
\def\XINT_seqb:f:csv_a #1#2;#3;#4!{%
   \expandafter\xint_gobble_i\romannumeral`&&@%
   \xintifCmp {#3}{#4}\XINT_seqb:f:csv_bl\XINT_seqb:f:csv_be\XINT_seqb:f:csv_bg
   #1{#3}{#4}{}{#2}}%
\def\XINT_seqb:f:csv_be #1#2#3#4#5{,#2}%
\def\XINT_seqb:f:csv_bl #1{\if #1p\expandafter\XINT_seqb:f:csv_pa\else
                                  \xint_afterfi{\expandafter,\xint_gobble_iv}\fi }%
\def\XINT_seqb:f:csv_pa #1#2#3#4{\expandafter\XINT_seqb:f:csv_p\expandafter
                                 {\romannumeral0\xintadd{#4}{#1}}{#2}{#3,#1}{#4}}%
\def\XINT_seqb:f:csv_p #1#2%
{%
   \xintifCmp {#1}{#2}\XINT_seqb:f:csv_pa\XINT_seqb:f:csv_pb\XINT_seqb:f:csv_pc
   {#1}{#2}%
}%
\def\XINT_seqb:f:csv_pb #1#2#3#4{#3,#1}%
\def\XINT_seqb:f:csv_pc #1#2#3#4{#3}%
\def\XINT_seqb:f:csv_bg #1{\if #1n\expandafter\XINT_seqb:f:csv_na\else
                                  \xint_afterfi{\expandafter,\xint_gobble_iv}\fi }%
\def\XINT_seqb:f:csv_na #1#2#3#4{\expandafter\XINT_seqb:f:csv_n\expandafter
                                 {\romannumeral0\xintadd{#4}{#1}}{#2}{#3,#1}{#4}}%
\def\XINT_seqb:f:csv_n #1#2%
{%
   \xintifCmp {#1}{#2}\XINT_seqb:f:csv_nc\XINT_seqb:f:csv_nb\XINT_seqb:f:csv_na
   {#1}{#2}%
}%
\def\XINT_seqb:f:csv_nb #1#2#3#4{#3,#1}%
\def\XINT_seqb:f:csv_nc #1#2#3#4{#3}%
%    \end{macrocode}
%\subsubsection{\csh{xintiiSeqB:f:csv}}
% \lverb|Produces in f-expandable way. If the step is zero, gives empty result
% except if start and end coincide.
%
% 2015/11/11. I correct a typo dating back to release 1.1 (2014/10/29): the
% macro name had a "b" rather than "B", hence was not functional (causing
% \xintNewIIExpr to fail on inputs such as #1..[1]..#2).|
%    \begin{macrocode}
\def\xintiiSeqB:f:csv #1#2%
   {\expandafter\XINT_iiseqb:f:csv \expandafter{\romannumeral`&&@#2}{#1}}%
\def\XINT_iiseqb:f:csv #1#2{\expandafter\XINT_iiseqb:f:csv_a\romannumeral`&&@#2#1!}%
\def\XINT_iiseqb:f:csv_a #1#2;#3;#4!{%
   \expandafter\xint_gobble_i\romannumeral`&&@%
   \xintSgnFork{\XINT_Cmp {#3}{#4}}%
                 \XINT_iiseqb:f:csv_bl\XINT_seqb:f:csv_be\XINT_iiseqb:f:csv_bg
   #1{#3}{#4}{}{#2}}%
\def\XINT_iiseqb:f:csv_bl #1{\if #1p\expandafter\XINT_iiseqb:f:csv_pa\else
                                  \xint_afterfi{\expandafter,\xint_gobble_iv}\fi }%
\def\XINT_iiseqb:f:csv_pa #1#2#3#4{\expandafter\XINT_iiseqb:f:csv_p\expandafter
                               {\romannumeral0\xintiiadd{#4}{#1}}{#2}{#3,#1}{#4}}%
\def\XINT_iiseqb:f:csv_p #1#2%
{%
    \xintSgnFork{\XINT_Cmp {#1}{#2}}%
    \XINT_iiseqb:f:csv_pa\XINT_iiseqb:f:csv_pb\XINT_iiseqb:f:csv_pc {#1}{#2}%
}%
\def\XINT_iiseqb:f:csv_pb #1#2#3#4{#3,#1}%
\def\XINT_iiseqb:f:csv_pc #1#2#3#4{#3}%
\def\XINT_iiseqb:f:csv_bg #1{\if #1n\expandafter\XINT_iiseqb:f:csv_na\else
                                  \xint_afterfi{\expandafter,\xint_gobble_iv}\fi }%
\def\XINT_iiseqb:f:csv_na #1#2#3#4{\expandafter\XINT_iiseqb:f:csv_n\expandafter
                               {\romannumeral0\xintiiadd{#4}{#1}}{#2}{#3,#1}{#4}}%
\def\XINT_iiseqb:f:csv_n #1#2%
{%
    \xintSgnFork{\XINT_Cmp {#1}{#2}}%
    \XINT_seqb:f:csv_nc\XINT_seqb:f:csv_nb\XINT_iiseqb:f:csv_na {#1}{#2}%
}%
%    \end{macrocode}
%\subsubsection{\csh{XINTinFloatSeqB:f:csv}}
% \lverb|Produces in f-expandable way. If the step is zero, gives empty result
% except if start and end coincide. This is all for \xintNewExpr.|
%    \begin{macrocode}
\def\XINTinFloatSeqB:f:csv #1#2{\expandafter\XINT_flseqb:f:csv \expandafter
   {\romannumeral0\XINTinfloat [\XINTdigits]{#2}}{#1}}%
\def\XINT_flseqb:f:csv #1#2{\expandafter\XINT_flseqb:f:csv_a\romannumeral`&&@#2#1!}%
\def\XINT_flseqb:f:csv_a #1#2;#3;#4!{%
   \expandafter\xint_gobble_i\romannumeral`&&@%
   \xintifCmp {#3}{#4}\XINT_flseqb:f:csv_bl\XINT_seqb:f:csv_be\XINT_flseqb:f:csv_bg
   #1{#3}{#4}{}{#2}}%
\def\XINT_flseqb:f:csv_bl #1{\if #1p\expandafter\XINT_flseqb:f:csv_pa\else
                                  \xint_afterfi{\expandafter,\xint_gobble_iv}\fi }%
\def\XINT_flseqb:f:csv_pa #1#2#3#4{\expandafter\XINT_flseqb:f:csv_p\expandafter
                          {\romannumeral0\XINTinfloatadd{#4}{#1}}{#2}{#3,#1}{#4}}%
\def\XINT_flseqb:f:csv_p #1#2%
{%
    \xintifCmp {#1}{#2}%
    \XINT_flseqb:f:csv_pa\XINT_flseqb:f:csv_pb\XINT_flseqb:f:csv_pc {#1}{#2}%
}%
\def\XINT_flseqb:f:csv_pb #1#2#3#4{#3,#1}%
\def\XINT_flseqb:f:csv_pc #1#2#3#4{#3}%
\def\XINT_flseqb:f:csv_bg #1{\if #1n\expandafter\XINT_flseqb:f:csv_na\else
                                  \xint_afterfi{\expandafter,\xint_gobble_iv}\fi }%
\def\XINT_flseqb:f:csv_na #1#2#3#4{\expandafter\XINT_flseqb:f:csv_n\expandafter
                          {\romannumeral0\XINTinfloatadd{#4}{#1}}{#2}{#3,#1}{#4}}%
\def\XINT_flseqb:f:csv_n #1#2%
{%
    \xintifCmp {#1}{#2}%
    \XINT_seqb:f:csv_nc\XINT_seqb:f:csv_nb\XINT_flseqb:f:csv_na {#1}{#2}%
}%
%    \end{macrocode}
% \subsection{User defined functions: \csh{xintdeffunc}, \csh{xintdefiifunc},
% \csh{xintdeffloatfunc}}
% \localtableofcontents \lverb|1.2c (November 11-12, 2015). It is possible to
% overload a variable name with a function name (and conversely). The function
% interpretation with be used only if followed by an opening parenthesis,
% disabling the tacit multiplication usually applied to variables. Crazy
% things such as add(f(f), f=1..10) are possible if there is a function "f".
% Or we can use "e" both for an exponential function and the Euler constant.
%
% November 13: function candidates names first completely expanded, then
% detokenized and cleaned of spaces. Should xintexpr log the meaning of the
% underlying macro implementing the functions ? |
%    \begin{macrocode}
\catcode`: 12
\def\XINT_tmpa #1#2#3#4%
{%
  \def #1##1(##2):=##3;{%
   \edef\XINT_expr_tmpa{##1}%
   \edef\XINT_expr_tmpa
       {\expandafter\xint_zapspaces\detokenize\expandafter{\XINT_expr_tmpa} \xint_gobble_i}%
   \def\XINT_expr_tmpb {0}%
   \def\XINT_expr_tmpc {##3}%
   \xintFor ####1 in {##2} \do
      {\edef\XINT_expr_tmpb {\the\numexpr\XINT_expr_tmpb+\xint_c_i}%
       \edef\XINT_expr_tmpc {subs(\unexpanded\expandafter{\XINT_expr_tmpc},%
                             ####1=################\XINT_expr_tmpb)}%
      }%
   \expandafter#3\csname XINT_#2_userfunc_\XINT_expr_tmpa\endcsname
                              [\XINT_expr_tmpb]{\XINT_expr_tmpc}%
   \expandafter\XINT_expr_defuserfunc
     \csname XINT_#2_func_\XINT_expr_tmpa\expandafter\endcsname
     \csname XINT_#2_userfunc_\XINT_expr_tmpa\endcsname
   \ifxintverbose\xintMessage {info}{xintexpr}
        {Function \XINT_expr_tmpa\space for \string\xint #4 parser
         associated to \string\XINT_#2_userfunc_\XINT_expr_tmpa\space 
         with meaning \expandafter\meaning
         \csname XINT_#2_userfunc_\XINT_expr_tmpa\endcsname}%
   \fi
  }%
}%
\catcode`: 11
\XINT_tmpa\xintdeffunc     {expr}  \XINT_NewFunc     {expr}%
\XINT_tmpa\xintdefiifunc   {iiexpr}\XINT_NewIIFunc   {iiexpr}%
\XINT_tmpa\xintdeffloatfunc{flexpr}\XINT_NewFloatFunc{floatexpr}%
\def\XINT_expr_defuserfunc #1#2{%
    \def #1##1##2##3{\expandafter ##1\expandafter ##2%
     \csname .=\expandafter #2\romannumeral-`0\XINT_expr_unlock ##3,\endcsname
    }%
}%
%    \end{macrocode}
% \subsection{\csh{xintNewExpr}, \csh{xintNewIExpr}, \csh{xintNewFloatExpr},
% \csh{xintNewIIExpr}}
% \localtableofcontents
% \subsubsection{\csh{xintApply::csv}}
% \lverb|Don't ask me what this if for. I wrote it in June 2014, and we are now
% late October 2014.|
%    \begin{macrocode}
\def\xintApply::csv #1#2%
   {\expandafter\XINT_applyon::_a\expandafter {\romannumeral`&&@#2}{#1}}%
\def\XINT_applyon::_a #1#2{\XINT_applyon::_b {#2}{}#1,,}%
\def\XINT_applyon::_b #1#2#3,{\expandafter\XINT_applyon::_c \romannumeral`&&@#3,{#1}{#2}}%
\def\XINT_applyon::_c #1{\if #1,\expandafter\XINT_applyon::_end
                                \else\expandafter\XINT_applyon::_d\fi #1}%
\def\XINT_applyon::_d #1,#2{\expandafter\XINT_applyon::_e\romannumeral`&&@#2{#1},{#2}}%
\def\XINT_applyon::_e #1,#2#3{\XINT_applyon::_b {#2}{#3, #1}}%
\def\XINT_applyon::_end #1,#2#3{\xint_secondoftwo #3}%
%    \end{macrocode}
% \subsubsection{\csh{xintApply:::csv}}
%    \begin{macrocode}
\def\xintApply:::csv #1#2#3%
   {\expandafter\XINT_applyon:::_a\expandafter{\romannumeral`&&@#2}{#1}{#3}}%
\def\XINT_applyon:::_a #1#2#3{\XINT_applyon:::_b {#2}{#3}{}#1,,}%
\def\XINT_applyon:::_b #1#2#3#4,%
   {\expandafter\XINT_applyon:::_c \romannumeral`&&@#4,{#1}{#2}{#3}}%
\def\XINT_applyon:::_c #1{\if #1,\expandafter\XINT_applyon:::_end
                     \else\expandafter\XINT_applyon:::_d\fi #1}%
\def\XINT_applyon:::_d #1,#2#3%
   {\expandafter\XINT_applyon:::_e\expandafter
    {\romannumeral`&&@\xintApply::csv {#2{#1}}{#3}},{#2}{#3}}%
\def\XINT_applyon:::_e #1,#2#3#4{\XINT_applyon:::_b {#2}{#3}{#4, #1}}%
\def\XINT_applyon:::_end #1,#2#3#4{\xint_secondoftwo #4}%
%    \end{macrocode}
% \subsubsection{\csh{XINT_expr_RApply::csv}, \csh{XINT_expr_LApply::csv},
% \csh{XINT_expr_RLApply:::csv}}
% \lverb|The #1 in _Rapply will start with a ~. No risk of glueing to previous
% ~expandafter during the \scantokens.
%
% Attention ici et dans la suite ~ avec catcode 12 (et non pas 3 comme
% ailleurs dans xintexpr).|
%    \begin{macrocode}
\catcode`~ 12
\def\XINT_expr_RApply::csv #1#2#3#4%
   {~xintApply::csv{~expandafter#1~xint_exchangetwo_keepbraces{#4}}{#3}}%
\def\XINT_expr_LApply::csv #1#2#3#4{~xintApply::csv{#1{#3}}{#4}}%
\def\XINT_expr_RLApply:::csv #1#2{~xintApply:::csv{#1}}%
%    \end{macrocode}
% \subsubsection{Mysterious stuff}
% \lverb|actually I dimly remember that the whole point is to allow maximal
% evaluation as long as macro parameters not encountered. Else it would be
% easier. \xintNewIExpr \f [2]{[12] #1+#2+3*6*1} will correctly compute the
% 18.
%
% Comments finally added 2015/12/11: the whole point here is to either expand
% completely a macro such as \xintAdd if it is has numeric arguments (the
% original macro is stored by \xintNewExpr in \xintNEAdd, which is not a good
% name anyhow, as I was reading it as Not Expand, whereas it is exactly the
% opposite and NE stands for New Expr), or handle the case when one of the two
% parameters only is numerical (the other being either a macro parameter, or a
% previously found macro not be expanded -- this is recursive), or none of
% them. In that case though, the non-numerical parameter may well stand
% ultimately for a whole list. Hence the various \xintApply one finds above.
%
% Indeed the catcode 12 dollar sign is used to signal a "virtual list"
% argument, a catcode 3 ~ will signal a "non-expandable". This happens when
% something add a "virtual list" argument, we must now leave the macros with a
% ~ meaning that it will become a real macro during the final \scantokens.
% Such "~" macro names will be created when they have a macro parameter as
% argument, or another "~" macro name, or a dollar prefixed argument as
% created by the NewExpr version of the \xintSeq::csv type macros which create
% comma separated lists.
%
% This 1.1 (2014/10/29) code works amazingly well allowing frankly amazing
% things such as the parsing by \xintNewExpr of [#1..[#2]..#3][#4:#5]. But we
% need to have a translation into exclusively f-expandable macros (avoiding
% \csname...\endcsname, but if absolutely needed perhaps I will do it
% ultimately.) And for the iterating loops seq, iter, etc..., we have no
% equivalent if the list of indices is not explicit. We succeed in doing it
% with explicit list, but if start, step, or end contains a macro parameter we
% are stuck (how could test for omit, abort, break work ?). Or we would need
% macro versions.
%
% ~ and $ of catcode 12 in what follows.|
%    \begin{macrocode}
\catcode`$ 12 % $
\def\XINT_xptwo_getab_b #1#2!#3%
   {\expandafter\XINT_xptwo_getab_c\romannumeral`&&@#3!#1{#1#2}}%
\def\XINT_xptwo_getab_c #1#2!#3#4#5#6{#1#3{#5}{#6}{#1#2}{#4}}%
\def\xint_ddfork #1$$#2#3\krof {#2}% $$
\def\XINT_NEfork #1#2{\xint_ddfork
                          #1#2\XINT_expr_RLApply:::csv
                           #1$\XINT_expr_RApply::csv% $
                           $#2\XINT_expr_LApply::csv% $
                            $${\XINT_NEfork_nn #1#2}% $$
                      \krof }%
\def\XINT_NEfork_nn #1#2#3#4{%
        \if #1##\xint_dothis{#3}\fi
        \if  #1~\xint_dothis{#3}\fi
        \if #2##\xint_dothis{#3}\fi
        \if  #2~\xint_dothis{#3}\fi
        \xint_orthat {\csname #4NE\endcsname }%
        }%
\def\XINT_NEfork_one #1#2!#3#4#5#6{%
    \if ###1\xint_dothis {#3}\fi
    \if  ~#1\xint_dothis {#3}\fi
    \if  $#1\xint_dothis {~xintApply::csv{#3#5}}\fi %$
    \xint_orthat {\csname #4NE\endcsname #6}{#1#2}%
}%
\toks0 {}%
\xintFor #1 in {DivTrunc,iiDivTrunc,iiDivRound,Mod,iiMod,iRound,Round,iTrunc,Trunc,%
        Lt,Gt,Eq,LtorEq,GtorEq,Neq,AND,OR,XOR,iQuo,iRem,Add,Sub,Mul,Div,Pow,E,%
        iiAdd,iiSub,iiMul,iiPow,iiQuo,iiRem,iiE,SeqA::csv,iiSeqA::csv}\do
 {\toks0
  \expandafter{\the\toks0% no space!
  \expandafter\let\csname xint#1NE\expandafter\endcsname\csname xint#1\expandafter
  \endcsname\expandafter\def\csname xint#1\endcsname ####1####2{%
        \expandafter\XINT_NEfork
        \romannumeral`&&@\expandafter\XINT_xptwo_getab_b
        \romannumeral`&&@####2!{####1}{~xint#1}{xint#1}}%
  }%
}% cela aurait-il un sens d'ajouter Raw et iNum ( cause de qint, qfrac,
 % qfloat?). Pas le temps d'y rflchir. Je ne fais rien.
\xintFor #1 in {Num,Irr,Abs,iiAbs,Sgn,iiSgn,TFrac,Floor,iFloor,Ceil,iCeil,%
    Sqr,iiSqr,iiSqrt,iiSqrtR,iiIsZero,iiIsNotZero,iiifNotZero,iiifSgn,%
    Odd,Even,iiOdd,iiEven,Opp,iiOpp,iiifZero,Fac,iiFac,Bool,Toggle}\do
{\toks0
  \expandafter{\the\toks0%
  \expandafter\let\csname xint#1NE\expandafter\endcsname\csname xint#1\expandafter
  \endcsname\expandafter\def\csname xint#1\endcsname ####1{%
      \expandafter\XINT_NEfork_one\romannumeral`&&@####1!{~xint#1}{xint#1}{}{}}%
  }%
}%
\toks0
  \expandafter{\the\toks0
  \let\XINTinFloatFacNE\XINTinFloatFac
  \def\XINTinFloatFac ##1{%
        \expandafter\XINT_NEfork_one
        \romannumeral`&&@##1!{~XINTinFloatFac}{XINTinFloatFac}{}{}}%
  }%
\xintFor #1 in {Add,Sub,Mul,Div,Power,E,Mod,SeqA::csv}\do
{\toks0
  \expandafter{\the\toks0%
  \expandafter\let\csname XINTinFloat#1NE\expandafter\endcsname
                                \csname XINTinFloat#1\expandafter\endcsname
  \expandafter\def\csname XINTinFloat#1\endcsname ####1####2{%
        \expandafter\XINT_NEfork
        \romannumeral`&&@\expandafter\XINT_xptwo_getab_b
        \romannumeral`&&@####2!{####1}{~XINTinFloat#1}{XINTinFloat#1}}%
  }%
}%
\xintFor #1 in {XINTinFloatdigits,XINTinFloatFracdigits,XINTinFloatSqrtdigits}\do
{\toks0
  \expandafter{\the\toks0%
  \expandafter\let\csname #1NE\expandafter\endcsname\csname #1\expandafter
  \endcsname\expandafter\def\csname #1\endcsname ####1{\expandafter
       \XINT_NEfork_one\romannumeral`&&@####1!{~#1}{#1}{}{}}%
  }%
}%
\xintFor #1 in {xintSeq::csv,xintiiSeq::csv,XINTinFloatSeq::csv}\do
 {\toks0
  \expandafter{\the\toks0% no space
  \expandafter\let\csname #1NE\expandafter\endcsname\csname #1\expandafter
  \endcsname\expandafter\def\csname #1\endcsname ####1####2{%
        \expandafter\XINT_NEfork
        \romannumeral`&&@\expandafter\XINT_xptwo_getab_b
        \romannumeral`&&@####2!{####1}{$noexpand$#1}{#1}}%
  }%
}%
\xintFor #1 in {xintSeqB,xintiiSeqB,XINTinFloatSeqB}\do
 {\toks0
  \expandafter{\the\toks0% no space
  \expandafter\let\csname #1::csvNE\expandafter\endcsname\csname #1::csv\expandafter
  \endcsname\expandafter\def\csname #1::csv\endcsname ####1####2{%
        \expandafter\XINT_NEfork
        \romannumeral`&&@\expandafter\XINT_xptwo_getab_b
        \romannumeral`&&@####2!{####1}{$noexpand$#1:f:csv}{#1::csv}}%
  }%
}%
\toks0
  \expandafter{\the\toks0
  \let\XINTinFloatNE\XINTinFloat
  \def\XINTinFloat [##1]##2{% not ultimately general, but got tired
        \expandafter\XINT_NEfork_one
        \romannumeral`&&@##2!{~XINTinFloat[##1]}{XINTinFloat}{}{[##1]}}%
  \let\XINTinFloatSqrtNE\XINTinFloatSqrt
  \def\XINTinFloatSqrt [##1]##2{%
        \expandafter\XINT_NEfork_one
        \romannumeral`&&@##2!{~XINTinFloatSqrt[##1]}{XINTinFloatSqrt}{}{[##1]}}%
}%
\xintFor #1 in {ANDof,ORof,XORof,iiMaxof,iiMinof,iiSum,iiPrd,
                GCDof,LCMof,Sum,Prd,Maxof,Minof}\do
{\toks0
  \expandafter{\the\toks0\expandafter\def\csname xint#1:csv\endcsname {~xint#1:csv}}%
}%
\xintFor #1 in
   {XINTinFloatMaxof,XINTinFloatMinof,XINTinFloatSum,XINTinFloatPrd}\do
{\toks0
  \expandafter{\the\toks0\expandafter\def\csname #1:csv\endcsname {~#1:csv}}%
}%
%    \end{macrocode}
% \lverb|~xintListSel::csv must have space after it, the reason being in
% \XINT_expr_until_:_b which inserts a : as fist token of something which will
% reappear later following ~xintListSel::csv.
%
% Notice that 1.1 was chicken and did not even try to expand the Reverse and
% ListSel by fear of the complexities and overhead of checking whether it
% contained macro parameters (possibly embedded in sub-macros).|
%    \begin{macrocode}
\toks0 \expandafter{\the\toks0
                     \def\xintReverse::csv {~xintReverse::csv }%
                     \def\xintListSel::csv {~xintListSel::csv }%
}%
\odef\XINT_expr_redefinemacros {\the\toks0}% Not \edef ! (subtle)
\def\XINT_expr_redefineprints
{%
   \def\XINT_flexpr_noopt
     {\expandafter\XINT_flexpr_withopt_b\expandafter-\romannumeral0\xintbarefloateval }%
   \def\XINT_flexpr_withopt_b ##1##2%
     {\expandafter\XINT_flexpr_wrap\csname .;##1.=\XINT_expr_unlock  ##2\endcsname }%
   \def\XINT_expr_unlock_sp ##1.;##2##3.=##4!%
     {\if -##2\expandafter\xint_firstoftwo\else\expandafter\xint_secondoftwo\fi 
      \XINTdigits{{##2##3}}{##4}}%
   \def\XINT_expr_print     ##1{\expandafter\xintSPRaw::csv\expandafter  
                             {\romannumeral`&&@\XINT_expr_unlock ##1}}%
   \def\XINT_iiexpr_print   ##1{\expandafter\xintCSV::csv\expandafter  
                             {\romannumeral`&&@\XINT_expr_unlock ##1}}%
   \def\XINT_boolexpr_print ##1{\expandafter\xintIsTrue::csv\expandafter
                               {\romannumeral`&&@\XINT_expr_unlock ##1}}%
%    \end{macrocode}
% \lverb|$indent 1) spaces after ::csv needed to separate from possible later stuff.
% Well I currently don't recall what I meant by that. 
%
% 2) due to redefinitions done above of \XINT_flexpr_noopt, etc..., no need to
% redefine \xintFloat::csv as it is not used (sub-expressions not supported),
% it is \xintPFloat::csv which is neutralized.|
%    \begin{macrocode}
   \def\xintCSV::csv     {~xintCSV::csv    }%
   \def\xintSPRaw::csv   {~xintSPRaw::csv  }% 
   \def\xintPFloat::csv  {~xintPFloat::csv }%
   \def\xintIsTrue::csv  {~xintIsTrue::csv }%
   \def\xintRound::csv   {~xintRound::csv  }%
}%
\toks0 {}%
%    \end{macrocode}
% \subsubsection{\csh{xintNewExpr}, ..., at last.}
% \lverb|1.2c modifications to accomodate \XINT_expr_deffunc_newexpr etc..|
%    \begin{macrocode}
\def\xintNewExpr      {\XINT_NewExpr{}\XINT_expr_redefineprints\xint_firstofone\xinttheexpr      }%
\def\xintNewFloatExpr {\XINT_NewExpr{}\XINT_expr_redefineprints\xint_firstofone\xintthefloatexpr }%
\def\xintNewIExpr     {\XINT_NewExpr{}\XINT_expr_redefineprints\xint_firstofone\xinttheiexpr     }%
\def\xintNewIIExpr    {\XINT_NewExpr{}\XINT_expr_redefineprints\xint_firstofone\xinttheiiexpr    }%
\def\xintNewBoolExpr  {\XINT_NewExpr{}\XINT_expr_redefineprints\xint_firstofone\xinttheboolexpr  }%
%    \end{macrocode}
% \lverb|1.2c for \xintdeffunc, \xintdefiifunc, \xintdeffloatfunc.|
%    \begin{macrocode}
\def\XINT_NewFunc      {\XINT_NewExpr,{}\xint_gobble_i\xintthebareeval      }%
\def\XINT_NewFloatFunc {\XINT_NewExpr,{}\xint_gobble_i\xintthebarefloateval }%
\def\XINT_NewIIFunc    {\XINT_NewExpr,{}\xint_gobble_i\xintthebareiieval    }%
\def\XINT_newexpr_clean #1>{\noexpand\romannumeral`&&@}%
%    \end{macrocode}
% \lverb|1.2c adds optional logging. For this needed to pass to _NewExpr_a the
% macro name as parameter. And _NewExpr itself receives two new parameters to
% treat both \xintNewExpr and \xintdeffunc.
%
% The #4 stands for the macro to be defined. Versions earlier than 1.2c had
% #1#2[#3], which was very bad for people applying LaTeX syntax
% \xintNewExpr {\foo} [5] for example as #2 would be {\foo}<space>. That
% didn't bother me much, but there is also the issue of \2<space>. Changed in
% 1.2d.
%
% Up to and including 1.2c the definition was global. Starting with 1.2d it is
% done locally.|
%    \begin{macrocode}
\def\XINT_NewExpr #1#2#3#4#5#6[#7]%
{%
 \begingroup
    \ifcase #7\relax
        \toks0 {\endgroup\def#5}%
    \or \toks0 {\endgroup\def#5##1#1}%
    \or \toks0 {\endgroup\def#5##1#1##2#1}%
    \or \toks0 {\endgroup\def#5##1#1##2#1##3#1}%
    \or \toks0 {\endgroup\def#5##1#1##2#1##3#1##4#1}%
    \or \toks0 {\endgroup\def#5##1#1##2#1##3#1##4#1##5#1}%
    \or \toks0 {\endgroup\def#5##1#1##2#1##3#1##4#1##5#1##6#1}%
    \or \toks0 {\endgroup\def#5##1#1##2#1##3#1##4#1##5#1##6#1##7#1}%
    \or \toks0 {\endgroup\def#5##1#1##2#1##3#1##4#1##5#1##6#1##7#1##8#1}%
    \or \toks0 {\endgroup\def#5##1#1##2#1##3#1##4#1##5#1##6#1##7#1##8#1##9#1}%
    \fi
    \xintexprSafeCatcodes
    \XINT_expr_redefinemacros
    #2%
    \XINT_NewExpr_a #3#4#5%
}%
%    \end{macrocode}
% \lverb|& attention que & est de catcode 14
% $catcode38 12
% For the 1.2a release I replaced all \romannumeral-`0 by a fancier
% \romannumeral`&&@ (with & of catcode 7). I got lucky here that it worked,
% despite @ being of catcode comment (anyhow \input xintexpr.sty would not
% have compiled if not, and I would have realized immediately). But to be
% honest I wouldn't have been 100$% sure
% beforehand that &&@ worked also with @ comment character. I now know.
%
% 1.2d's \xintNewExpr makes a local definition. In earlier releases, the
% definition was global.|
%    \begin{macrocode}
\catcode`~ 13 \catcode`@ 14 \catcode`\% 6 \catcode`# 12 \catcode`$ 11 @ $
\def\XINT_NewExpr_a %1%2%3%4@
{@
    \def\XINT_tmpa %%1%%2%%3%%4%%5%%6%%7%%8%%9{%4}@
    \def~{$noexpand$}@
    \catcode`: 11 \catcode`_ 11 
    \catcode`# 12 \catcode`~ 13 \escapechar 126
    \endlinechar -1 \everyeof {\noexpand }@
    \edef\XINT_tmpb
    {\scantokens\expandafter
     {\romannumeral`&&@\expandafter%2\XINT_tmpa {#1}{#2}{#3}{#4}{#5}{#6}{#7}{#8}{#9}\relax}@
    }@
    \escapechar 92 \catcode`# 6 \catcode`$ 0 @ $
    \edef\XINT_tmpa %%1%%2%%3%%4%%5%%6%%7%%8%%9@
    {\scantokens\expandafter{\expandafter\XINT_newexpr_clean\meaning\XINT_tmpb}}@
    \the\toks0\expandafter{\XINT_tmpa{%%1}{%%2}{%%3}{%%4}{%%5}{%%6}{%%7}{%%8}{%%9}}@
    %1{\ifxintverbose
        \xintMessage{info}{xintexpr}@
                    {\string%3\space now with meaning \meaning%3}@
       \fi}@
}@
\catcode`% 14
\let\xintexprRestoreCatcodes\empty
\def\xintexprSafeCatcodes
{%
    \edef\xintexprRestoreCatcodes  {%
        \catcode59=\the\catcode59   % ;
        \catcode34=\the\catcode34   % "
        \catcode63=\the\catcode63   % ?
        \catcode124=\the\catcode124 % |
        \catcode38=\the\catcode38   % &
        \catcode33=\the\catcode33   % !
        \catcode93=\the\catcode93   % ]
        \catcode91=\the\catcode91   % [
        \catcode94=\the\catcode94   % ^
        \catcode95=\the\catcode95   % _
        \catcode47=\the\catcode47   % /
        \catcode41=\the\catcode41   % )
        \catcode40=\the\catcode40   % (
        \catcode42=\the\catcode42   % *
        \catcode43=\the\catcode43   % +
        \catcode62=\the\catcode62   % >
        \catcode60=\the\catcode60   % <
        \catcode58=\the\catcode58   % :
        \catcode46=\the\catcode46   % .
        \catcode45=\the\catcode45   % -
        \catcode44=\the\catcode44   % ,
        \catcode61=\the\catcode61   % =
        \catcode32=\the\catcode32\relax % space
    }%
        \catcode59=12  % ;
        \catcode34=12  % "
        \catcode63=12  % ?
        \catcode124=12 % |
        \catcode38=4   % &
        \catcode33=12  % !
        \catcode93=12  % ]
        \catcode91=12  % [
        \catcode94=7   % ^
        \catcode95=8   % _
        \catcode47=12  % /
        \catcode41=12  % )
        \catcode40=12  % (
        \catcode42=12  % *
        \catcode43=12  % +
        \catcode62=12  % >
        \catcode60=12  % <
        \catcode58=12  % :
        \catcode46=12  % .
        \catcode45=12  % -
        \catcode44=12  % ,
        \catcode61=12  % =
        \catcode32=10  % space
}%
\let\XINT_tmpa\relax \let\XINT_tmpb\relax \let\XINT_tmpc\relax
\XINT_restorecatcodes_endinput%
%    \end{macrocode}
% \DeleteShortVerb{\|}
% \MakePercentComment
%</xintexpr>
%<*dtx>
\StoreCodelineNo {xintexpr}

\def\mymacro #1{\mymacroaux #1}
\def\mymacroaux #1#2{\strut \csname #1nameimp\endcsname:& \dtt{ #2.}\tabularnewline }
\indent
\begin{tabular}[t]{r@{}r}
\xintApplyInline\mymacro\storedlinecounts
\end{tabular}
\def\mymacroaux #1#2{#2}%
%
\parbox[t]{10cm}{Total number of code lines:
    \dtt{\the\numexpr
    \xintListWithSep+{\xintApply\mymacro\storedlinecounts}\relax }.
    Among those, release 1.2 has about 3000 lines starting with either 
    \{\% or \}\%.% en fait 3013 mais je devrais automatiser.

    Each package starts with circa \dtt{50} lines dealing with catcodes,
    package identification and reloading management, also for Plain
    \TeX\strut. Version {\xintbndlversion} of {\xintbndldate}.\par
}

% il faut que je patche doc.sty pour faire a automatiquement:
%
% $ grep -c -e "^{%" xint*sty
%
% $ grep -c -e "^}%" xint*sty

\CharacterTable
 {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
  Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
  Digits        \0\1\2\3\4\5\6\7\8\9
  Exclamation   \!     Double quote  \"     Hash (number) \#
  Dollar        \$     Percent       \%     Ampersand     \&
  Acute accent  \'     Left paren    \(     Right paren   \)
  Asterisk      \*     Plus          \+     Comma         \,
  Minus         \-     Point         \.     Solidus       \/
  Colon         \:     Semicolon     \;     Less than     \<
  Equals        \=     Greater than  \>     Question mark \?
  Commercial at \@     Left bracket  \[     Backslash     \\
  Right bracket \]     Circumflex    \^     Underscore    \_
  Grave accent  \`     Left brace    \{     Vertical bar  \|
  Right brace   \}     Tilde         \~}
\CheckSum {27233}%
\makeatletter\check@checksum\makeatother
\Finale
%% End of file xint.dtx
