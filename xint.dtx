% -*- coding: iso-latin-1; -*-
% This file: xint.dtx (1.03, 2013/04/14)
%%
%%----------------------------------------------------------------
%% The xint bundle (version 1.03 of April 14, 2013)
%<xint>%% xint: Expandable operations on long numbers
%<xintgcd>%% xintgcd: Euclidean algorithm with xint package 
%<xintfrac>%% xintfrac: Expandable operations on fractions  
%<xintseries>%% xintseries: Expandable partial sums with xint package
%% Copyright (C) 2013 by Jean-Francois B. 
%%----------------------------------------------------------------
%%
% Style files in the bundle:
% (base) xint.sty       Expandable operations on long numbers
%        xintgcd.sty    Euclidean algorithm with xint package
%        xintfrac.sty   Expandable operations on fractions
%        xintseries.sty Expandable partial sums with xint package
% 
%  This work consists of the source file xint.dtx and of its derived files
%  xint.sty, xintgcd.sty, xintfrac.sty, xintseries.sty, xint.ins and the
%  documentation xint.pdf (or xint.dvi).
%
%     This work may be distributed and/or modified under the
%     conditions of the LaTeX Project Public License, either
%     version 1.3c of this license or (at your option) any later
%     version. This version of this license is in 
%          http://www.latex-project.org/lppl/lppl-1-3c.txt
%     and the latest version of this license is in
%          http://www.latex-project.org/lppl.txt
%     and version 1.3 or later is part of all distributions of
%     LaTeX version 2005/12/01 or later. 
% 
% The author of this work is Jean-Francois B. <2589111+jfbu@users.noreply.github.com>. 
% This work has the LPPL maintenance status `author-maintained'.
% 
%  Installation and Usage:
%  =======================
%
%  Run tex or latex on xint.dtx.
% 
%  This will extract the style files xint.sty, xintgcd.sty, xintfrac.sty,
%  xintseries.sty (and xint.ins). Files with the same names and in the
%  same repertory will be overwritten. The tex (not latex) run will stop
%  with the complaint that it does not understand \NeedsTeXFormat, but the
%  style files will already have been extracted by that time.
%
%  Alternatively, run tex or latex on xint.ins if available.
%
%  To get xint.pdf run pdflatex thrice on xint.dtx
%  
%      xint.sty, xintgcd.sty, xintfrac.sty, xintseries.sty
%                 -> TDS:tex/generic/xint/
%      xint.dtx   -> TDS:source/generic/xint/
%      xint.pdf   -> TDS:doc/generic/xint/
% 
% It may be necessary to then refresh the TeX installation filename
% database.
%
%  Usage with LaTeX: \usepackage{xint}
%                    \usepackage{xintgcd}    % (loads xint)
%                    \usepackage{xintfrac}   % (loads xint)
%                    \usepackage{xintseries} % (loads xintfrac)
%
%  Usage with TeX:   \input xint.sty\relax   
%                    \input xintgcd.sty\relax    % (loads xint)
%                    \input xintfrac.sty\relax   % (loads xint)
%                    \input xintseries.sty\relax % (loads xintfrac)
%
%<*none>
\def\pkgversion{1.03}
\def\pkgdate{2013/04/14}
\def\lasttimestamp{Time-stamp: <15-04-2013 10:58:29 CEST jfb>}
\def\striptimestamp #1 <#2 #3 #4 #5>{#2 at #3 #4}
\def\getdocdate #1 <#2-#3-#4 #5>{#4/#3/#2}
\edef\docdate{\expandafter\getdocdate\lasttimestamp}
\edef\dtxtimestamp{\expandafter\striptimestamp\lasttimestamp}
\begingroup
\input docstrip.tex
\askforoverwritefalse
\generate{\nopreamble
\file{xint.ins}{\from{xint.dtx}{ins}}
\usepreamble\defaultpreamble
\file{xint.sty}{\from{xint.dtx}{xint}}
\file{xintgcd.sty}{\from{xint.dtx}{xintgcd}}
\file{xintfrac.sty}{\from{xint.dtx}{xintfrac}}
\file{xintseries.sty}{\from{xint.dtx}{xintseries}}}
\endgroup
\iffalse
%</none>
%<*ins>
%----------- to .ins file ----------------------------------------
%%
%% This is a generated file. Run tex or latex on this file to
%% extract xint.sty, xintgcd.sty, xintfrac.sty and xintseries.sty
%% from xint.dtx
%%
%% See xint.dtx for the statements of copyright and conditions of
%% distribution and/or modification of this work.
%%
\input docstrip.tex
\askforoverwritefalse
\generate{\usepreamble\defaultpreamble
\file{xint.sty}{\from{xint.dtx}{xint}}
\file{xintgcd.sty}{\from{xint.dtx}{xintgcd}}
\file{xintfrac.sty}{\from{xint.dtx}{xintfrac}}
\file{xintseries.sty}{\from{xint.dtx}{xintseries}}}
\endbatchfile
%----------- end of .ins file ------------------------------------
%</ins>
%<*none>
\fi
\NeedsTeXFormat{LaTeX2e}
\ProvidesFile{xint.dtx}[bundle source and documentation (\dtxtimestamp)]

\documentclass[a4paper,11pt,abstract]{scrdoc}
\pagestyle{headings}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}

%---- GEOMETRY WILL BE CHANGED FOR SOURCE CODE SECTIONS

\usepackage[hscale=0.66,vscale=0.75]{geometry}

%---- WE NEED OUR BEAUTIFUL SELVES

%% checking that dependencies are all-right
%\usepackage{xint}
%\usepackage{xintgcd}
%\usepackage{xintfrac}

\usepackage{xintseries}
\usepackage{xintgcd}

%---- CHANGING TOCDEPTH MIDWAY THROUGH THE MAIN TOC

\usepackage{etoc}
\makeatletter

\def\toctransition {%
    \addtocontents {toc}{\protect\newtocdepth {1}}%
    % \setcounter{tocdepth}{1}% à cause des bookmarks de hyperref, 
    % \def\etocaftertitlehook {\c@tocdepth 2 }% pour les local tocs
    % non finalement puisque je laisse tocdepth à 2 globalement plus besoin
    \let\newtocdepth\@gobble % mais ne pas oublier ça
    \etocmulticolstyle [1]{\subsection *{Contents}}%
    \def\@pnumwidth{2em}% attention ce n'est pas une longueur.
    % fait pour problème de overfull box au niveau des numéros de
    % page dans les local tocs des sections implémentations
}
% qu'est-ce qu'il faut pas faire !
%     (à cause de la gestion des bookmarks par hyperref)
% je ne veux pas le sous-sections de la partie implémentation dans les
% bookmarks, ou peut-être si en fait je les veux aussi? ce n'est pas gênant
% dans les bookmarks.
\def\newtocdepth #1{\c@tocdepth #1 } % ainsi on modifie localement seulement
\makeatother

%--- TXFONTS, AND TXTT MADE SMALLER AND ALLOWING HYPHENATION

\usepackage{txfonts}
% malheureusement, comme j'utilise des diacritiques dans mes
% parties commentées, imprimées verbatim, je ne pourrai pas
% utiliser dvipdfmx qui a un problème avec txtt

\DeclareFontFamily{T1}{txtt}{}
\DeclareFontShape{T1}{txtt}{m}{n}{	%medium
     <->s*[.96] t1xtt%
}{}
\DeclareFontShape{T1}{txtt}{m}{sc}{	%cap & small cap
     <->s*[.96] t1xttsc%
}{}
\DeclareFontShape{T1}{txtt}{m}{sl}{	%slanted
     <->s*[.96] t1xttsl%
}{}
\DeclareFontShape{T1}{txtt}{m}{it}{	%italic
     <->ssub * txtt/m/sl%
}{}
\DeclareFontShape{T1}{txtt}{m}{ui}{   	%unslanted italic
     <->ssub * txtt/m/sl%
}{}
\DeclareFontShape{T1}{txtt}{bx}{n}{	%bold extended
     <->t1xbtt%
}{}
\DeclareFontShape{T1}{txtt}{bx}{sc}{	%bold extended cap & small cap
     <->t1xbttsc%
}{}
\DeclareFontShape{T1}{txtt}{bx}{sl}{	%bold extended slanted
     <->t1xbttsl%
}{}
\DeclareFontShape{T1}{txtt}{bx}{it}{	%bold extended italic
     <->ssub * txtt/bx/sl%
}{}
\DeclareFontShape{T1}{txtt}{bx}{ui}{  	%bold extended unslanted italic
     <->ssub * txtt/bx/sl%
}{}
\DeclareFontShape{T1}{txtt}{b}{n}{	%bold
     <->ssub * txtt/bx/n%
}{}
\DeclareFontShape{T1}{txtt}{b}{sc}{	%bold cap & small cap
     <->ssub * txtt/bx/sc%
}{}
\DeclareFontShape{T1}{txtt}{b}{sl}{	%bold slanted
     <->ssub * txtt/bx/sl%
}{}
\DeclareFontShape{T1}{txtt}{b}{it}{   	%bold italic
     <->ssub * txtt/bx/it%
}{}
\DeclareFontShape{T1}{txtt}{b}{ui}{   	%bold unslanted italic
     <->ssub * txtt/bx/ui%
}{}

\usepackage{xspace}
\usepackage{color}
\usepackage{framed}

\definecolor{joli}{RGB}{225,95,0}
\definecolor{JOLI}{RGB}{225,95,0}
\definecolor{BLUE}{RGB}{0,0,255}
\definecolor{niceone}{RGB}{38,128,192}

\usepackage[english]{babel}

\usepackage[pdfencoding=pdfdoc,bookmarks=true]{hyperref}

\hypersetup{%
linktoc=all,%
breaklinks=true,%
hidelinks,%
pdfauthor={Jean-Fran\c cois B.},%
pdftitle={The xint bundle},%
pdfsubject={Arithmetic with TeX},%
pdfkeywords={Expansion, arithmetic, TeX},%
pdfstartview=FitH,%
pdfpagemode=UseOutlines}


%---- OUR CLEVER PRIVATE LITTLE MACRO FOR CENTERED LINES
\makeatletter
% 7 mars 2013
% This macro allows to conveniently center a line inside a paragraph and still
% use therein \verb or other commands changing catcodes.
% A proposito, the \LaTeX \centerline uses \hsize and not \linewidth ! 

\newcommand*\centeredline {%
      \ifhmode \\\relax
        \def\centeredline@{\hss\egroup\hskip\z@skip }%
      \else 
        \def\centeredline@{\hss\egroup }%
      \fi
      \afterassignment\@centeredline
      \let\next=}
\def\@centeredline 
{\hbox to \linewidth \bgroup \hss \bgroup \aftergroup\centeredline@ }
\makeatother

%---- ALLOWING COMMENTS INSIDE VERBATIM BLOCKS
\makeatletter
\let\original@check@percent\check@percent
\let\check@percent\relax
\makeatother

%---- A MORE FLEXIBLE \verb
\makeatletter
% le \verb de doc.sty est très chiant car il a retiré 
% \verbatim@font pour mettre un \ttfamily hard-coded
% à la place. 
% 
% Par ailleurs j'en ai marre des erreurs dues au fait que mes
% paragraphes reformatés dans emacs passent à la ligne au milieu
% d'un \verb. Je décide donc d'annuler l'effet du \dospecials sur les
% espaces dans la source. Et donc je retire le \verb@eol@error et
% il n'y a donc plus lieu d'un comportement différent pour
% l'impression des blancs, donné par la version étoilée.
% 
% Et il n'y avait donc pas de \obeylines puisque la fin de ligne
% devenait un message d'erreur dans \verb@eol@error 
%
% De plus je retire le \do@noligs qui me gêne plutôt qu'autre chose,
% surtout maintenant que les espaces ne sont pas des control spaces
% attention au signe - par contre
%
\def\noligminus {\kern \z@ \char`\-}
\begingroup\catcode`\-\active
\gdef\verb {\relax \ifmmode \hbox \else \leavevmode \null \fi
  \bgroup \verbatim@font
  \let \do \@makeother \dospecials \catcode`\-\active
  \let-\noligminus \catcode32 10 \@ifstar {\@sverb }{\@sverb }}
\endgroup
% ça c'est pour mes petits morceaux de code:
\def\verbatim@font {\ttfamily }
\def\MacroFont{\ttfamily\baselineskip12pt\relax}
% Mais j'ai besoin d'un verbatim différent pour les nombres car je
% ne veux pas passer en mode mathématique et je ne veux pas les 0
% du txtt pour cela. Comme je n'utilise pas de tabulation, je vais
% utiliser & 
\catcode`\& 13
\def&{\begingroup\let\do\@makeother\dospecials\catcode`\& 13 \@jfverb }
\def\@jfverb #1&{#1\endgroup }
\makeatother

% Note: il n'y a plus de \hyphenchar-1 dans le \DeclareFontFamily de t1txtt
% ATTENTION CEPENDANT À CE QUI SE PASSE EN CAS DE CHANGEMENT DE TAILLE

\DeclareRobustCommand\csa[1]{{\ttfamily\char`\\#1}}

\DeclareRobustCommand\csb[1]{\hyperref[#1]{\color{blue}\ttfamily\char`\\#1}}

\DeclareRobustCommand\csbnolk[1]{{\color{blue}\ttfamily\char`\\#1}}

\newcommand\csh[1]{\texorpdfstring{\csa{#1}}{\textbackslash #1}}
\newcommand\csbh[1]{\texorpdfstring{\csbnolk{#1}}{\textbackslash #1}}

\newcommand\xintname {\texorpdfstring
                      {{\color{joli}\ttfamily\bfseries xint}}
                      {xint}\xspace}

\newcommand\xintgcdname{\texorpdfstring
                        {{\color{joli}\ttfamily\bfseries xintgcd}}
                        {xintgcd}\xspace}

\newcommand\xintfracname{\texorpdfstring
                        {{\color{joli}\ttfamily\bfseries xintfrac}}
                        {xintfrac}\xspace}
\newcommand\xintseriesname{\texorpdfstring
                        {{\color{joli}\ttfamily\bfseries xintseries}}
                        {xintseries}\xspace}
\frenchspacing
\renewcommand\familydefault\sfdefault

%---- WE WANT TO SEE ALL THOSE NUMBERS
\def\allownumbersplit #1%
{%
    \ifx #1\relax \else #1\hskip 0pt plus 1pt\relax
    \expandafter\allownumbersplit\fi
}%
\def\printnumber #1%
{\expandafter\expandafter\expandafter
    \allownumbersplit #1\relax }% Expands twice before printing.

\begin{document}
\thispagestyle{empty}
\rmfamily

\begin{center}
  {\normalfont\Large The \xintname bundle: \xintname, \xintgcdname,
  \xintfracname, and \xintseriesname.\par}%
  \textsc{Jean-François B.}\par
  \footnotesize \ttfamily 
  2589111+jfbu@users.noreply.github.com\\
  Package version: \pkgversion\ (\pkgdate)\\
  Documentation generated from the source file\\
  with timestamp ``\dtxtimestamp''
\end{center}

\begin{abstract}
  The \xintname package implements with expandable \TeX{} macros
  the basic arithmetic operations of addition, subtraction,
  multiplication and division, as applied to arbitrarily long
  numbers represented as chains of digits with an optional minus
  sign.

  The \xintgcdname package provides implementations of the
  Euclidean algorithm and of its typesetting. The \xintfracname
  package extends the scope of \xintname to fractional numbers of
  arbitrary sizes ; \xintseriesname provides some basic
  functionality based on the \xintname and \xintfracname packages
  for computing in an expandable manner partial sums of series and
  power series with fractional coefficients.

  The packages may be used with Plain and with \LaTeX. All macros
  dealing with computations work purely by expansion, and may thus
  be used almost everywhere in \TeX{}.
\end{abstract}


% à cause des XX.YY, mais franchement tout ce qui concerne la
% table des matières est une catastrophe de conception avec LaTeX
% et scrartcl n'améliore pas les choses tant que ça ici.
\makeatletter
\def\l@subsection {\bprot@dottedtocline {2}{1.5em}{2.8em}}
\makeatother

\tableofcontents

\section{Origins of this package}

The package |bigintcalc| by \textsc{Heiko Oberdiek} already
provides expandable arithmetic operations on ``big integers'',
exceeding the \TeX{} limits (of &2^{31}-1&), so why another
one? 

I got started on this in early March 2013, via a thread on the
|c.t.tex| usenet group, where \textsc{Ulrich D\,i\,e\,z} used the
previously cited package together with a macro (|\ReverseOrder|)
which I had contributed to another thread. \footnote{the
  \csa{ReverseOrder} could be avoided in that circumstance, but it
  does play a crucial r\^ole here.} What I had learned in this
other thread thanks to interaction with \textsc{Ulrich D\,i\,e\,z} and
\textsc{GL} on expandable manipulations of tokens motivated me to
try my hands at addition and multiplication.

I wrote macros \csa{bigMul} and \csa{bigAdd} which I posted to the
newsgroup; they appeared to work comparatively fast. These first
versions did not use the \eTeX{} \csa{numexpr} macro, they worked
one digit at a time, having previously stored carry-arithmetic in
1200 macros.

I noticed that the |bigintcalc| package used the \csa{numexpr}
\eTeX{} primitive when available, but (as far as I could tell) not
to do computations many digits at a time. Using \csa{numexpr} for
one digit at a time for \csa{bigAdd} and \csa{bigMul} slowed them
a tiny bit but avoided cluttering \TeX{} memory with the 1200
macros storing pre-computed digit arithmetic. I wondered if some speed
could be gained by using \csa{numexpr} to do four digits at a time
for elementary multiplications (as the maximal admissible number
for \csa{numexpr} has ten digits).

The present package is the result of this initial questioning. 

\begin{framed}\centering
  \xintname requires the \eTeX{} \csa{numexpr} primitive.
\end{framed}

I have aimed at speed wherever I could, and to the extent that I
could guess what was more efficient for \TeX{}. 

% After a while
% though I did opt for more readable coding style in those parts of
% the code which were not at the heart of repeatedly used loops. In
% particular I started using \csa{ifnum} and \csa{ifcase} constructs
% which I had completely avoided so far, working only with macro
% expansions.

I wrote a version of addition which does \csa{numexpr} operations eight
digits at a time, but its additional overhead made it a bit slower
for numbers of up to a few hundreds digits and it became faster only for
numbers with thousands of digits; for such sizes multiplication starts
taking a noticeable time, so I have chosen to retain the addition routine
which was most efficient for numbers having a few dozens to a few
hundreds digits.

% This implementation is thus a \TeX nical thing, quite different
% from what one would do in a structured programming language like
% |C|, although the underlying algorithms are just the standard
% steps applied to hand computations (nothing fancy like
% Fast Fourier Transform...).

By the way, I used the word `speed', and yes \xintname enjoys
working `fast and efficiently' (within many quotes...) with 200
digits numbers, but surely any program in |C| using the |CPU| and
pointers to the memory for arithmetic operations on arrays of
numbers would do computations thousands of times faster (or more,
I don't know) than what \TeX{} can achieve when manipulating strings of
ASCII representations of digits via a game on up to nine
parameters per macro! And, besides, the underlying
algorithms used by \xintname are just the standard hand
computation methods, nothing fancy like Fast Fourier Transform.


\begin{framed}
  Even within \TeX{} it is possible to set up arithmetic
  operations working orders of magnitude faster than what
  \xintname achieves,\footnotemark[2]\ but this does (I guess)
  require the capacity to do assignments to memory storage. The
  arithmetic implemented by \xintname does not do any assignment
  and works by pure macro expansion: this has a toll on
  speed.\footnotemark[3]\ Nevertheless, numbers with less than
  thirty digits are quite ``small'' from the point of view of the
  package, and a great many operations on such numbers can be done
  in a document without real noticeable impact on the compilation
  time.
\end{framed}

To see \xintname in action on the traditional computations of
$\pi$ and $\log 2$, jump to the
\hyperref[xintFxPtPowerSeries]{\color{blue}{\csa{xintFxPtPowerSeries}
    documentation}}.

\footnotetext[2]{this is well demonstrated by the
  \href{http://www.ctan.org/pkg/pi}{\color{niceone}pi computing file} by
  \textsc{D. Roegel} from 1996. As will be seen at the end of this
  manual, the \textsc{Machin formula} to compute $\pi$ can also be
  implemented (in a completely expandable way) with the help of
  \xintfracname and \xintseriesname: on my laptop it computes 200 digits
  in less than one second, but this is much slower than what pi.tex
  achieves.}

\footnotetext[3]{not to mention the impact on coding style; after
  having now completed the main work on these packages, the author
  feels he cannot do anything in \TeX{} but expansion-only compatible
  macros... }

\setcounter{footnote}{3}


\section{Expansions}

Except for the assignments or typesetting macros, the bundle
macros are constructed to work in expansion-only context. For
example, with the following code snippet within |myfile.tex|:
\begin{verbatim}
\newwrite\outfile
\immediate\openout\outfile \jobname-out\relax
\immediate\write\outfile {\xintQuo{\xintiPow{2}{1000}}{\xintFac{100}}}
% \immediate\closeout\outfile
\end{verbatim}
the tex run creates a file |myfile-out.tex|
containing the decimal representation of the integer quotient &2^{1000}/100!&.
Such macros can also be used inside a |\csname...\endcsname|, and
of course in an |\edef|.

\edef\x{\xintQuo{\xintiPow {2}{1000}}{\xintFac{100}}}
\edef\y{\xintLen{\x}}

Furthermore the package macros give their final results in two
expansion steps. They twice expand their arguments so that they
can be arbitrarily chained. Hence \centeredline{%
  |\xintLen{\xintQuo{\xintiPow{2}{1000}}{\xintFac{100}}}|} expands
in two steps and tells us that &[2^{1000}/100!]& has {\y}
digits. This is not so many, let us print them here:
\printnumber\x. 

For the sake of typesetting this documentation and not have big numbers
extend into the margin and go beyond the page physical limits, I use
these commands (not provided by the package):
\begin{verbatim}
\def\allownumbersplit #1%
{%
    \ifx #1\relax \else #1\hskip 0pt plus 1pt\relax
    \expandafter\allownumbersplit\fi
}%
\def\printnumber #1%
{\expandafter\expandafter\expandafter\allownumbersplit #1\relax }% 
% Expands twice before printing.
\end{verbatim}
which is used for example as |\printnumber {\xintQuo{\xintiPow
{2}{1000}}{\xintFac{100}}}|. Or, the computation can be done inside
an \csa{edef}: |\edef\mynumber {\|\texttt{xint\-Quo}|{\xintiPow
{2}{1000}}{\xintFac{100}}}| followed by |\printnumber\mynumber|. The macro
is not part of the package and would need additional thinking for more
general use.

Important points, to be noted, related to the double expansion of arguments:
\begin{enumerate}
\item When I say that the macros expand twice their arguments,
  this means that they expand the first token seen (for each
  argument), then expand again the first token of the result of
  the first expansion. For example
  \centeredline{|\def\x{12}\def\y{34}|%
    |\xintAdd {\x}{\x\y}|} is \emph{not} a legal construct. It works here
  by sheer luck as the |\y| gets expanded inside a |\numexpr|. But
  this would fail in general: if you need a more complete
  (expandable...) expansion of your initial input, you should use
  the \fbox{\csa{bigintcalcNum}} macro from the |bigintcalc|
  package. Or, outside of an expandable-only context, just massage
  your inputs through \csa{edef}'s.

\item Unfortunately, after |\def\x {12}|, one can not use just
  {\color{blue}|-\x|} as input to one of the package macros: the rules above
  explain that the twice expansion will act only on the minus sign,
  hence do nothing. The only way is to use the \csb{xintiOpp}
  macro, which replaces a number with its opposite. Example: |\xintiAdd
  {\xint|\-|iOpp\x}{\x}|\,=\,{\xintiAdd {\xintiOpp\x}{\x}}.

\def\x {12}%
\item With the definition \centeredline{%
    |\def\AplusBC #1#2#3{\xintiAdd {#1}{\xintiMul {#2}{#3}}}|} one
  obtains an expandable macro producing the expected result, not
  in two, but rather in three steps: a first expansion is consumed
  by the macro expanding to its definition. As a result {|\xintiAdd
    {\AplusBC {1}{2}{3}}{4}|} would then miserably fail. The
  solution is to use the \emph{lowercase} form of 
  \csa{xintiAdd}: \smallskip\centeredline {|\def\AplusBC
    #1#2#3{|{\color{blue}|\romannumeral0\xintiadd |}|{#1}{\xintiMul {#2}{#3}}}|}
  
  and then \csa{AplusBC} will share the same properties as do the
  other \xintname `primitive' macros.
% ENFIN DÉBARRASSÉ DES TRÈS TRÈS TRÈS CHIANTS EOL ERROR DE \verb !!!

  Don't leave any space after the zero, and use the lowercase form
  \emph{only} for the external highest level of chained commands.
  All \xintname provided public macros have such a lowercase form
  precisely to facilitate building-up higher level macros based on them.
\end{enumerate}

\section {Inputs (integers)}

\begin{framed}
  \TeX{}'s count registers cannot be directly used but must be
  prefixed by |\the| or |\number|. The same for \csa{numexpr}
  expressions.
\end{framed}

Each one of the package macros first does a double expansion of its
arguments, and it expects the ensuing numbers to be strings of digits
with one (and not more) optional minus sign (and not a plus
sign).\footnote{these conditions are relaxed (\emph{only} for the
  extended macros) when \xintfracname is loaded: the number, even zero,
  may start with many minus signs; but plus signs are still forbidden.}
The first digit is not zero if there are more than one digit. And |-0|
is not legal input. Syntax such as |\xintMul\A\B| is accepted and
equivalent\footnote{see however near the end of
  \hyperref[sec:outputs]{\color{niceone}this later section} for the
  important difference when used in contexts where \TeX{} expects a
  number, such as following an \csa{ifcase} or an \csa{ifnum}.} to
|\xintMul {\A}{\B}|. Or course |\xintAdd\xintMul\A\B\C| does not work,
the product operation must be put within braces:
|\xintAdd{\xintMul\A\B}\C|.

It would be nice to have a functional form |\add(x,\mul(y,z))| but
this is not provided by the package. Arguments must be either
within braces or a single control sequence.

For the multiplication and the division (but not for addition and
subtraction), the  inputs must have each at most
&2^{31}-9=&{\xintiSub{\xintiPow {2}{31}}{9}} digits.\footnote{when
  \xintfracname is loaded, this restriction on the length of the
  numbers becomes a general one.}

I guess anyhow that this is way way way beyond what is possible in
terms of memory in any implementation of \TeX{}. But if the
situation did arise nevertheless of such a gigantic input, an
arithmetic overflow would occur (after some long time I guess)
during the computation by \xintname of the lengths of the inputs,
as this computation uses \csa{numexpr} for successive additions of
the number |8| to itself until the whole input has been parsed.
\footnote{it is the macro \csa{xintLen} (used by the
  multiplication and the division algorithms) which will trigger
  an arithmetic overflow if it is called with an input of more
  than {\xintiSub{\xintiPow {2}{31}}{9}} digits. I decided it wasn't
  worth it to add to the code of \csa{xintLen} a safeguard against
  this potential arithmetic overflow: it would have some general
  impact on speed, whereas the situation can not realistically
  occur (or even not at all, I admit not having double-checked the
  intrinsinc \TeX{} memory limitations).}

Also: the factorial function \csa{xintFac} will refuse to
(start...) compute |N!| if |N| $\geq$ 1000000000, and the power function
|\xintiPow {A}{B}|, when the absolute value \verb+|A|+ is at
least two, will refuse to start the computation if |B| $\geq$ 1000000000
(the minimal outcome is &2^{1000000000}& which has 301029996 digits...).

In those latter cases, no arithmetic overflow will happen, but the
compilation log will report an ``undefined control sequence
error'', where the name of the control sequence indicates the
source of the error (this method is copied from package
|bigintcalc|). Errors of this type do not stop the computation,
which (generally) will output a zero.

No check is done on the format of the inputs after the initial
twice expansion. Often, but not always, something starting with a
|0| will be assumed to be zero (throwing or not what comes after
the zero away). Plus signs are not accepted and will cause errors.
Spaces should be avoided.

The sole exception is the macro \csb{xintNum} which accepts numbers
starting with an arbitrary long sequence of plus signs, minus signs,
followed by zeros and will remove all of them, keeping only the correct
sign: \centeredline{|\xintNum
  {+-+-+----++-++----00000000009876543210}|\texttt{=\xintNum
    {+-+-+----++-++----0000000009876543210}}} But don't insert zeros
within the initial signs. An empty string is also acceptable input:
|\xintNum {}|\texttt{=\xintNum{}}. As with all other package macros,
\csa{xintNum} expands twice its argument, and obtains its final result
in two expansion steps.

\section{Inputs (fractions)}

When package \xintfracname is loaded, there is a wider range of
input formats to most macros (some, such as \csb{xintQuo} which
computes the quotient in an euclidean division, remain
``integer-only'', and the previous section applies).

\edef\z {\xintAdd
    {367.8920280/---278.289287}{-109.2882/270.12898}}

Here is a typical computation: \centeredline{|\xintAdd
    {367.8920280/---278.289287}{-109.2882/270.12898}|}%
  \centeredline{\texttt{=\z}}%
  \centeredline{\texttt{=\xintIrr\z{} (irreducible)}}%
  \centeredline{\texttt{=\xintTrunc {50}{\z}\dots}} Signs (on
  input) may thus be either at the numerator or denominator, or at
  both (chains of |-| are ok, but still no |+| sign). 
An optional decimal point is
  authorized, both in the numerator and the denominator. It is
  also licit to use |\A/\B| as input if each of |\A| and |\B|
  expands in at most two steps to a ``decimal number'' as
  examplified above by the numerators and denominators. Or one may
  have just one macro |\C| which expands to such a ``fraction with
  optional decimal points'', or mixed things such as |\A
  245/7.77|, where the numerator will be the concatenation of the
  expansion of |\A| and |245|. But, as explained already |123\A|
  is a no-go.

  Lastly, input such as |16000/289072[17]| (or |3[-4]|) is
  accepted and represents, respectively |(16000/289072)10^{17}|
  and |3|\raisebox{.5ex}{|.|}|10^{-4}|. It is possible to use
  |\A/\B[17]| if |\A| expands to |16000| and |\B| to |289072|, or
  |\A| if |\A| expands to |3[-4]|. However, NEITHER the numerator
  NOR the denominator\strut{} may then have a decimal
  point.\vadjust{\vskip-\dp\strutbox
          \hbox{\smash{\color{niceone}\llap{\strut\small 
          IMPORTANT!\ $\Bigg\{$\ }}}\vskip\dp\strutbox }
  And, for this format,
  ONLY the numerator may carry a UNIQUE minus sign (and no
  superfluous zeros).

  This format with a power of ten represented by a number within
  square brackets is used by the \xintfracname macros for output.
  It is allowed for user input but the parsing is minimal and it
  is very important to follow the above rules. This reduced
  flexibility, compared to the format without the square brackets,
  allows chaining package macros without too much speed impact, as
  they always output computation results in the |A/B[n]| form (or
  |A[n]|). \footnote{see however the \csb{xintFrac} and
    \csb{xintFwOver} macros for print only, inside math mode.}

All computations done by \xintfracname on fractions are exact.
Even when the inputs contains decimal points, it does not make
the package switch to a (currently non-existent) `floating-point'
mode: the inputs are converted into an exact internal representation.


Generally speaking, there should be no spaces in the inputs
(although most would be harmless, most of the time; the devil
being in the details, it is best to just not take chances with
these spaces).

\edef\z {\xintSub {\xintMul {2.3}{\xintPow {5.6}{3}}}  {17728/189.5}}

It would certainly be nice to be able to input directly expressions such as
|2.3*5.6^3-17728/189.5|, but this is not possible. One must use, for
example:
 \centeredline{|\xintSub {\xintMul {2.3}{\xintPow
    {5.6}{3}}}  {17728/189.5}|} or, an option in this case is:
\centeredline{|\xintAdd {\xintPrd {{2.3}{5.6}{5.6}{5.6}}}{-17728/189.5}|}%
\centeredline{\texttt{=\z =\xintIrr\z =\xintTrunc {15}\z\dots}}


\section{Outputs (integers)}\label{sec:outputs}

The output of macros of the \xintname package, when it consists of
a single integer number, is in the normalized form previously
described.\footnote{see the next section for the modifications
  brought by loading the \xintfracname package.}

Some macros
have an output consisting of more than one number, each one is
then within braces. For example \csb{xintDivision} gives first the
quotient and then the remainder, each of them within braces. This
is for programming purposes to avoid having to do twice the
division, once for the quotient, the other one for the remainder: but
of course macros \csb{xintQuo} and \csb{xintRem} are provided for easier
direct access.

\def\n{\string{N\string}}
\def\x{\string{x\string}}

The macro \csb{xintDecSplit}\x\n\ cuts its second
argument |N| at a location specified by its first argument |x|, and returns the
two pieces one after the other, each within braces. Depending on the value of
|x| and the length of |N|, the first, or the second, output of
\csa{xintDecSplit} may be \emph{empty}. Leading zeros in the second
string of digits are neither removed. This is the only situation where a package
macro may output something which would need to be input to \csa{xintNum} before
further processing by the other package macros.

When using things such as |\ifcase \xintSgn{\A}| one has to leave
a space after the closing brace for \TeX{} to
stop its scanning for a number: once \TeX{} has finished expanding
|\xintSgn{\A}| and has so far obtained either |1|, |0|, or |-1|, a
space (or something `unexpandable') must stop it looking for more
digits. Using |\ifcase\xintSgn\A| without the braces is very dangerous,
because the blanks (including the end of line) following |\A| will be
skipped and not serve to stop the number which |\ifcase| is looking for.
With |\def\A{1}|:
\begin{verbatim}
\ifcase \xintSgn\A   0\or OK\else ERROR\fi   ---> gives ERROR
\ifcase \xintSgn{\A} 0\or OK\else ERROR\fi   ---> gives OK
\end{verbatim}
% \def\A{1}
% \ifcase \xintSgn\A   0\or OK\else ERROR\fi\ 
% \ifcase \xintSgn{\A} 0\or OK\else ERROR\fi

\section{Outputs (fractions)}

When the package \xintfracname is loaded, the routines
\csb{xintAdd}, \csb{xintSub}, \csb{xintMul}, \csb{xintPow},
\csb{xintSum}, \csb{xintPrd} are modified to allow fractions on
input,\footnote{of course, the power function does not accept a
  fractional exponent. Or rather, does not expect, and errors will
  result if one is provided.}\,\footnote{macros \csb{xintiAdd},
  \csb{xintiSub}, \csb{xintiMul}, \csb{xintiPow}, \csb{xintiSum},
  \csb{xintiPrd} are the original ones dealing only with integers.
  They are available as synonyms, also when \xintfracname is not
  loaded. }\,\footnote{also \csb{xintCmp}, \csb{xintSgn},
  \csb{xintOpp}, \csb{xintAbs}, \csb{xintMax}, \csb{xintMin} are
  extended to fractions and have their integer-only initial
  synonyms.} and always produce on output a fractional number
|f=A/B[n]| where |A| and |B| are integers, with |B| positive, and
|n| is a signed ``small'' integer (\emph{i.e} less in absolute
value than |2^{31}-9|). This represents |(A/B)| times |10^n|. The
fraction |f| may be, and generally is, reducible, and |A| and |B|
may well end up with zeros (\emph{i.e.} |n| does not contain all
powers of 10). Conversely, this format is accepted on input (and
is parsed more quickly than fractions containing decimal
points).\footnote{at each stage of the computations, the sum of
  |n| and the length of |A|, or of the absolute value of |n| and
  the length of |B|, must be kept less than
  |2\string^\string{31\string}-9|.}

As the present document loads the \xintfracname package, most
examples with integers will use the \csb{xintiAdd},
\csb{xintiSub}, \csb{xintiMul}, \csb{xintiPow}, \csb{xintiSum},
\csb{xintiPrd}, macros which are the original un-modified
integer-only versions. This is mandatory in particular when using
their ouput as input to integer-only macros such as \csb{xintQuo}.


The macro \csb{xintREZ} (remove zeros) puts all powers of ten into
the |[n]|, and removes the |B| if it is less than |1|. The macro
\csb{xintIrr} transforms |f| into its unique irreducible
representative |C/D|, and prints |C| if |D=1|.

The macro \csb{xintTrunc}|{N}{f}| prints\footnote{`prints' does
  not mean that this macro is only for outputting; to the contrary
  it is recommended to use it in intermediate results when doing
  things such as computing $\sum_{n=1}^{1000} \frac1n$, else the
  numbers manipulated by \xintname will be as big as $1000!$.
  Besides the package does not provide any `printing' facility;
  such facilities are necessary as \TeX{} by default will print a
  long number on a single line extending beyond the page limits.
  The \csa{printnumber} macro used in this documentation is just
  one way to deal with this problem (some other method should be
  used to guarantee that digits occupy the same width always.)}
the decimal expansion of |f| with |N| digits after the decimal
point.\footnote{the current release does not provide a macro to
  get the period of the decimal expansion.} Currently, it does not
verify that |N| is non-negative and strange things could happen
with a negative |N|. Of course a negative |f| is no problem,
needless to say. When the original fraction is negative and its
truncation has only zeros, it is printed as |-0.0...0|, with |N|
zeros following the decimal point: 
\centeredline{|\xintTrunc {5}{\xintPow {-13}{-9}}=|\texttt{\xintTrunc {5}{\xintPow {-13}{-9}}}}%
\centeredline{|\xintTrunc {20}{\xintPow {-13}{-9}}=|\texttt{\xintTrunc {20}{\xintPow {-13}{-9}}}} 
The output always contains a
decimal point (even for |N=0|) followed by |N| digits, except when
the original fraction was zero. In that case the output is |0|,
with no decimal point.
\centeredline{|\xintTrunc {10}{\xintSum {{1/2}{1/3}{1/5}{-31/30}}}=|%
\texttt{\xintTrunc {10}{\xintSum {{1/2}{1/3}{1/5}{-31/30}}}}}

The output of \csb{xintTrunc} may of course serve as input to the other
macros. And this is almost necessary when summing hundreds of
terms of a series with fractional coefficients, as the exact
rational number quickly becomes quite big (when doing the sum from
|n=|1 to |n=|1000 of |1/n|, the raw denominator is &1000!&, which
has 2568 digits) ; but for less than fifty terms with small
denominators it is often possible to work with the exact
value without too much toll on the compilation time. 

The macro \csb{xintiTrunc}|{N}{f}| is like \csa{xintTrunc}|{N}{f}|
followed by multiplication by |10^N|. Thus, it ouputs an integer
in a format acceptable by the integer-only macros. This is also
convenient when computing partial sums of series: it is a bit
faster to sum with \csb{xintiSeries} the integers produced by
\csa{xintiTrunc}|{N}| than it is to use the general
\csb{xintSeries} on the decimal numbers produced by
\csa{xintTrunc}|{N}|. These latter macros belong to the \xintseriesname
package.

Needless to say when using \csa{xintTrunc} or \csa{xintiTrunc} on
intermediate computations the ending digits of the final result
are, pending further analysis, only indications of those of the
fraction an exact computation would have produced.

\edef\z {\xintPow {1.01}{100}}

To get the integer part of the decimal expansion of |f|, use
|\xintiTrunc{0}{f}|: \centeredline{|\xintiTrunc {0}{\xintPow
    {1.01}{100}}=|\texttt{\xintiTrunc {0}\z}}%
\centeredline{|\xintTrunc {10}{\xintPow
    {1.01}{100}}=|\texttt{\xintTrunc {10}\z}}

\section{Assignments}

\xintAssign\xintBezout{357}{323}\to\tmpA\tmpB\tmpU\tmpV\tmpD

It might not be necessary to maintain at all times complete
expandability. For example why not allow oneself the two definitions
|\edef\A {\xintQuo{100}{3}}| and |\edef\B {\xintRem {100}{3}}|. A special
  syntax is provided to make these things more efficient, as the package
  provides 
 \csa{xintDivision} which computes both quotient and
  remainder at the same time:
  \centeredline{\csb{xintAssign}\csa{xintDivision}|{100}{3}|\csbnolk{to}|\A\B|}
  \centeredline{\csb{xintAssign}\csa{xintDivision}%
|{\xintiPow {2}{1000}}{\xintFac{100}}|\csbnolk{to}|\A\B|} gives
\xintAssign\xintDivision{\xintiPow {2}{1000}}{\xintFac{100}}\to\A\B
|\meaning\A|\texttt{: \expandafter\allownumbersplit\meaning\A\relax} and
|\meaning\B|\texttt{: \expandafter\allownumbersplit\meaning\B\relax}. 


  Another example (which uses a macro from the \xintgcdname
  package):
  \centeredline{\csb{xintAssign}\csa{xintBezout}|{357}{323}|%
    \csbnolk{to}|\A\B\U\V\D|} is equivalent to setting |\A| to
  \texttt{\tmpA}, |\B| to \texttt{\tmpB}, |\U| to \texttt{\tmpU},
  |\V| to \texttt{\tmpV}, and |\D| to \texttt{\tmpD}. And indeed
  (\tmpU)$\times$\tmpA-(\tmpV)$\times$\tmpB=
   \xintiSub{\xintiMul\tmpU\tmpA}{\xintiMul\tmpV\tmpB}
  is a Bezout Identity.

  \xintAssign\xintBezout{3570902836026}{200467139463}\to\tmpA\tmpB\tmpU\tmpV\tmpD
  \centeredline{\csb{xintAssign}\csa{xintBezout}|{3570902836026}{200467139463}|%
    \csbnolk{to}|\A\B\U\V\D|} gives then |\U|\texttt{:
    \expandafter\allownumbersplit\meaning\tmpU\relax}, |\V|\texttt{:
    \expandafter\allownumbersplit\meaning\tmpV\relax} and |\D=|\texttt{\tmpD}.

  When one does not know in advance the number of tokens, one can
  use \csa{xintAssignArray} or its synonym \csa{xintDigitsOf}:
  \centeredline{\csb{xintDigitsOf}\csa{xintiPow}|{2}{100}|\csbnolk{to}\csa{Out}}
  This defines \csa{Out} to be macro with one parameter,
  \csa{Out}|{0}| gives the size |N| of the array and
  \csa{Out}|{n}|, for |n| from |1| to |N| then gives the |n|th
  element of the array, here the |n|th digit of &2^{100}&, from
  the most significant to the least significant. As usual, the
  generated macro \csa{Out} is completely expandable and expands twice its
  (unique) argument. Consider the following code snippet:
\begin{verbatim}
\newcount\cnta
\newcount\cntb
\begingroup
\xintDigitsOf\xintiPow{2}{100}\to\Out
\cnta = 1
\cntb = 0
\loop
\advance \cntb \xintiSqr{\Out{\the\cnta}}
\ifnum \cnta < \Out{0}
\advance\cnta 1
\repeat

|2^{100}| (=\xintiPow {2}{100}) has \Out{0} digits and the sum of
their squares is \the\cntb. These digits are, from the least to
the most significant: \cnta = \Out{0} 
\loop \Out{\the\cnta}\ifnum \cnta > 1 \advance\cnta -1 , \repeat.
\endgroup
\end{verbatim}

\newcount\cnta
\newcount\cntb
\begingroup
\xintDigitsOf\xintiPow{2}{100}\to\Out
\cnta = 1
\cntb = 0
\loop
\advance \cntb \xintiSqr{\Out{\the\cnta}}
\ifnum \cnta < \Out{0}
\advance\cnta 1
\repeat

&2^{100}& (=\xintiPow {2}{100}) has \Out{0} digits and the sum of
their squares is \the\cntb. These digits are, from the least to
the most significant: \cnta = \Out{0} 
\loop \Out{\the\cnta}\ifnum \cnta > 1 \advance\cnta -1 , \repeat.
\endgroup

We used a group in order to release the memory taken by the
\csa{Out} array: indeed internally, besides \csa{Out} itself,
additional macros are defined which are \csa{Out0}, \csa{Out00},
\csa{Out1}, \csa{Out2}, ..., \csa{OutN}, where |N| is the size of
the array (which is the value returned by |\Out{0}|; the digits
are parts of the names not arguments). 

The command \csb{xintRelaxArray}\csa{Out} sets all these macros to
\csa{relax}, but it was simpler to put everything withing a group.

Needless to say \csb{xintAssign}, \csb{xintAssignArray} and
\csb{xintDigitsOf} do not do any check on whether the macros they
define are already defined.

In the example above, we deliberately broke all rules of complete
expandability, but had we wanted to compute the sum of the digits,
not the sum of the squares, we could just have written:
\centeredline{\csb{xintiSum}|{\xintiPow{2}{100}}=|\texttt{%
    \xintiSum{\xintiPow{2}{100}}}} Indeed, \csa{xintiSum} is usually
used as in \centeredline{%
  \csb{xintiSum}|{{123}{-345}{\xintFac{7}}{\xintiOpp{\xintRem{3347}{591}}}}=|\texttt{%
    \xintiSum{{123}{-345}{\xintFac{7}}{\xintiOpp{\xintRem{3347}{591}}}}}}
but in the example above each digit of &2^{100}& is treated as
would have been a summand enclosed within braces, due to the rules
of \TeX{} for parsing macro arguments.

Note that |{-\xintRem{3347}{591}}| is not a valid input, because
the double expansion will apply only to the minus sign and leave
unaffected the |\xintRem|. So we used \csa{xint}\-|iOpp| which replaces
a number with its opposite.

As a last example of use of \csa{xintAssignArray} here is one line
from the source code of the \xintgcdname macro
\csb{xintTypesetEuclideAlgorithm}:
\centeredline{|\xintAssignArray\xintEuclideAlgorithm
  {#1}{#2}\to\U|}
This is done inside a group. After this command |\U{1}| contains
the number |N| of steps of the algorithm (not to be confused with
|\U{0}=2N+4| which is the number of elements in the |\U| array),
and the GCD is to be found in |\U{3}|, a convenient location
between |\U{2}| and |\U{4}| which are (absolute values of the
twice expansion of) the
initial inputs. Then follow |N| quotients and remainders
from the first to the last step of the algorithm. The
\csa{xintTypesetEuclideAlgorithm} macro organizes this data
for typesetting: this is just an example of one way to do it. 


%% As an example: \xintTypesetEuclideAlgorithm {2362001530033}{981106461701}

\section{Error messages}

We employ the same method as in the |bigintcalc| package. But the
error is always thrown \emph{before} the end of the
|\romannumeral0| expansion so as to not disturb further processing
of the token stream, if the operation was a secondary one whose
output is expected by a first one. Here is the list of possible
errors:
\begin{verbatim}
\xintError:ArrayIndexIsNegative
\xintError:ArrayIndexBeyondLimit
\xintError:FactorialOfNegativeNumber
\xintError:FactorialOfTooBigNumber
\xintError:DivisionByZero
\xintError:FractionRoundedToZero
\xintError:ExponentTooBig
\xintError:TooBigDecimalShift
\xintError:TooBigDecimalSplit
\xintError:NoBezoutForZeros
\end{verbatim}

\section{Package namespace}

Inner macros of \xintname, \xintgcdname, \xintfracname, and
\xintseriesname all begin either with |\XINT@| or with |\xint@|.
The package public commands all start with |\xint|. The major
forms have their initials capitalized, and lowercase forms,
prefixed with |\romannumeral0|, allow definitions of further
macros expanding in two steps to their full expansion (and can
thus be chained with the `primitive' \xintname macros). Some other
control sequence names are used only as delimiters, and left
undefined.

The |\xintReverseOrder|\marg{tokens} macro uses |\xint@UNDEF| and
|\xint@undef| as dummy tokens and can be used on arbitrary token
strings not containing these control sequence names. Anything
within braces is treated as one unit: one level of exterior braces
is removed and the contents are not reverted.

% \clearpage
\section{Loading and usage}

\begin{verbatim}
 Usage with LaTeX: \usepackage{xint}
                   \usepackage{xintgcd}    % (loads xint)
                   \usepackage{xintfrac}   % (loads xint)
                   \usepackage{xintseries} % (loads xintfrac)

 Usage with TeX:   \input xint.sty\relax   
                   \input xintgcd.sty\relax    % (loads xint)
                   \input xintfrac.sty\relax   % (loads xint)
                   \input xintseries.sty\relax % (loads xintfrac)
\end{verbatim}

We have added, directly copied from packages by \textsc{Heiko
  Oberdiek}, a mecanism of re-load and \eTeX{} detection,
especially for Plain \TeX{}. As \eTeX{} is required, the
executable |tex| can not be used, |etex| or |pdftex| (version
|1.40| or later) or ..., must
be invoked.

Furthermore, the packages \xintgcdname and \xintfracname will
check for previous loading of \xintname, and will try to load it
if this was not already done. And package \xintseriesname loads
\xintfracname.

Also inspired from the \textsc{Heiko Oberdiek} packages we have
included a complete catcode protection mecanism. The packages may
be loaded in any catcode configuration satisfying these
requirements: the percent is comment character, the backslash is
escape character, digits have category code other and letters have
category code letter. Nothing else is assumed, and the previous
configuration is restored after the loading of the packages.

This is for the loading of the packages. For the actual use of the
macros, note that when feeding them with negative numbers the
minus sign must have category code other, as is standard.

The components of the \xintname bundle presuppose that the usual
\csa{space} and \csa{empty} macros are pre-defined, which is the case in
Plain \TeX{} as well as in \LaTeX.

Lastly, the macros \csa{xintRelaxArray} (of \xintname) and
\csa{xintTypesetEuclideAlgorithm} and
\csa{xintTypesetBezoutAlgorithm} (of \xintgcdname) use 
\csa{loop}, both Plain and \LaTeX{} incarnations are
compatible. \csa{xintTypesetBezoutAlgorithm} also uses the
\csa{endgraf} macro.
 

\section{Installation}

\begin{verbatim}
 Run tex or latex on xint.dtx.

 This will extract the style files xint.sty, xintgcd.sty, xintfrac.sty,
 xintseries.sty (and xint.ins). Files with the same names and in the
 same repertory will be overwritten. The tex (not latex) run will stop
 with the complaint that it does not understand \NeedsTeXFormat, but the
 style files will already have been extracted by that time.

 Alternatively, run tex or latex on xint.ins if available.

 To get xint.pdf run pdflatex thrice on xint.dtx
 
     xint.sty, xintgcd.sty, xintfrac.sty, xintseries.sty
                -> TDS:tex/generic/xint/
     xint.dtx   -> TDS:source/generic/xint/
     xint.pdf   -> TDS:doc/generic/xint/

It may be necessary to then refresh the TeX installation filename
database.
\end{verbatim}


\section{Commands of the \xintname package}

\def\n{\string{N\string}}
\def\m{\string{M\string}}
\def\x{\string{x\string}}

\n{} (resp. \m{} or \x) stands for a normalised number within braces as
described in the documentation, or for a control sequence expanding in at most
two steps to such a number (without the braces!), or for a control sequence
within braces expanding in at most two steps to such a number, of for material
within braces which expands to such a number after two expansions of the first
token.

Some of these macros are extended by \xintfracname to accept fractions on input,
and to output a fraction (except for those which output |1|, |0| or |-1|). This
will be mentioned and the original macro \csa{xintAbc} remains then available
under the name \csa{xintiAbc}.

The integer-only macros are more efficient on integers, even for simple things
such as determining the sign of a number, as there is always some overhead due
to parsing the fraction format on input; however except if one does really a lot
of computations, there is no need in general to employ the integer-only
variants, apart from one mandatory context:\vadjust{\vskip-\dp\strutbox
          \hbox{\smash{\color{niceone}\llap{\strut\small 
          IMPORTANT!\ $\Bigg\{$\ }}}\vskip\dp\strutbox }
when they are inside\strut{}  other
integer-only macros. For example |\xintQuo {\xintMul {2}{3}}{2}| will generate
an error when \xintfracname is loaded, because |\xintMul {2}{3}| outputs
|6/1[0]| which |\xintQuo| will not understand. So |\xintQuo {\xintiMul
  {2}{3}}{2}| is mandatory. And, when one has something which one knows to be an
integer such as |\xintMul {1/2}{12}|, one can use either |\xintIrr {\xintMul
  {1/2}{12}}| or |\xintiTrunc {0}{\xintMul {1/2}{12}}| to produce it in the
format which will be understood by integer-only macros.



\subsection{\csbh{xintRev}} \label{xintRev}

\csa{xintRev\n} will revert the order of the digits of the number,
keeping the optional sign. Leading zeros
resulting from the operation are not removed (see the
\csa{xintNum} macro for this).
\centeredline{|\xintRev{-123000}|\texttt{=\xintRev{-123000}}}
\centeredline{|\xintNum{\xintRev{-123000}}|\texttt{=\xintNum{\xintRev{-123000}}}}

\subsection{\csbh{xintReverseOrder}}\label{xintReverseOrder}

\csa{xintReverseOrder}\marg{token\_list} does not do any
expansion of its argument and just reverses the order of the
tokens. Brace pairs encountered are removed once and the enclosed
material does not get reverted.
\centeredline{|\xintReverseOrder{\xintDigitsOf\xintiPow {2}{100}\to\Stuff}|}
\centeredline{gives: \ttfamily
\expandafter\expandafter\expandafter\detokenize
\expandafter\expandafter\expandafter{%
\xintReverseOrder{\xintDigitsOf\xintiPow {2}{100}\to\Stuff}}}

\subsection{\csbh{xintNum}}\label{xintNum}

\csa{xintNum\n} removes chains of plus or minus signs, followed by
zeros.
\centeredline{|\xintNum{+---++----+--000000000367941789479}|\texttt
{=\xintNum{+---++----+--000000000367941789479}}}

\subsection{\csbh{xintLen}}\label{xintiLen}

\csa{xintLen\n} returns the length of the number, not counting the
sign.
\centeredline{|\xintLen{-12345678901234567890123456789}|\texttt
  {=\xintLen{-12345678901234567890123456789}}} Extended by
\xintfracname to fractions: the length of |A/B[n]| is the length
of |A| plus the length of |B| plus the absolute value of |n| and
minus one (an integer input as |N| is internally |N/1[0]| so the
minus one means that the extended \csa{xintLen} behaves the same
as the original for integers). The whole thing should sum up to
less than circa &2^{31}&.

\subsection{\csbh{xintLength}}\label{xintLength}

\csa{xintLength}\marg{token\_list} does not do any expansion of
its argument and just counts how many tokens there are. Things
enclosed in braces count as one.
\centeredline{|\xintLength {\xintiPow {2}{100}}=|\texttt{\xintLength
    {\xintiPow{2}{100}}}}
\centeredline{${}\neq{}$|\xintLen {\xintiPow {2}{100}}=|\texttt{\xintLen
    {\xintiPow{2}{100}}}}


\subsection{\csbh{xintAssign}}\label{xintAssign}

\csa{xintAssign}\meta{braced things}\csa{to}%
\meta{as many cs as they are things} defines (without checking if
something gets overwritten) the control sequences on the right of
\csa{to} to be the complete expansions of the successive things on
the left of \csa{to} enclosed within braces. 

Important: a double expansion is applied first to the material
extending up to \csa{to}.

\xintAssign\xintiPow {7}{13}\to\SevenToThePowerThirteen
\xintAssign\xintDivision{1000000000000}{133333333}\to\Q\R

As a special exception, if after this initial double expansion a
brace does not immediately follows \csa{xintAssign}, it is assumed
that there is only one control sequence to define and it is then
defined to be the complete expansion of the material between
\csa{xintAssign} and \csa{to}.
\centeredline{|\xintAssign\xintDivision{1000000000000}{133333333}\to\Q\R|}
\centeredline{|\meaning\Q: |\texttt{\meaning\Q}, |\meaning\R:
  |\texttt{\meaning\R}} \centeredline{|\xintAssign\xintiPow
  {7}{13}\to\SevenToThePowerThirteen|}
\centeredline{|\SevenToThePowerThirteen=|\texttt{\SevenToThePowerThirteen}}

Of course this macro and its cousins completely break usage in
pure expansion contexts, as assignments are made via the
\csa{edef} primitive.

\subsection{\csbh{xintAssignArray}}\label{xintAssignArray}

\xintAssignArray\xintBezout {1000}{113}\to\Bez

\csa{xintAssignArray}\meta{braced things}\csa{to}\csa{myArray} first
double expands the first token then defines \csa{myArray} to be a
macro with one parameter, such that \csa{myArray\n} expands in two
steps (which include the twice-expansion of \texttt{\n}) to give
the |N|th braced thing, itself completely expanded.
\csa{myArray}|{0}| returns the number |M| of elements of the array
so that the successive elements are \csa{myArray}|{1}|, \dots,
\csa{myArray}|{M}|. \centeredline{|\xintAssignArray\xintBezout
  {1000}{113}\to\Bez|} will set |\Bez{0}| to \texttt{\Bez0},
|\Bez{1}| to \texttt{\Bez1}, |\Bez{2}| to \texttt{\Bez2},
|\Bez{3}| to \texttt{\Bez3}, |\Bez{4}| to \texttt{\Bez4}, and
|\Bez{5}| to \texttt{\Bez5}:
(\Bez3)${}\times{}$\Bez1${}-{}$(\Bez4)${}\times{}$\Bez2${}={}$\Bez5.

\subsection{\csbh{xintRelaxArray}}\label{xintRelaxArray}

\csa{xintRelaxArray}\csa{myArray} sets to \csa{relax} all 
macros which were defined by the previous \csa{xintAssignArray}
with \csa{myArray} as array name. 

\subsection{\csbh{xintDigitsOf}}\label{xintDigitsOf}

This is a synonym for \csa{xintAssignArray}, to be used to define
an array giving all the digits of a given number.
\begingroup\xintDigitsOf\xintiPow {7}{500}\to\digits
\centeredline{|\xintDigitsOf\xintiPow {7}{500}\to\digits|}
\noindent &7^500& has |\digits{0}=|\digits{0} digits, and the 123rd among them
(starting from the most significant) is
|\digits{123}=|\digits{123}.
\endgroup 


\subsection{\csbh{xintSgn}}\label{xintiSgn}

\csa{xintSgn\n} returns 1 if the number is positive, 0 if it is
zero and -1 if it is negative. Extended by \xintfracname to fractions.

\subsection{\csbh{xintOpp}}\label{xintiOpp}

\csa{xintOpp\n} returns the opposite |-N| of the number |N|.
Extended by \xintfracname to fractions.


\subsection{\csbh{xintAbs}}\label{xintiAbs}

\csa{xintAbs\n} returns the absolute value of the number. Extended
by \xintfracname to fractions. 

\subsection{\csbh{xintAdd}}\label{xintiAdd}

\csa{xintAdd\n\m} returns the sum of the two numbers. Extended by
\xintfracname to fractions.

\subsection{\csbh{xintSub}}\label{xintiSub}

\csa{xintSub\n\m} returns the difference |N-M|. Extended by
\xintfracname to fractions.

\subsection{\csbh{xintCmp}}\label{xintiCmp}

\csa{xintCmp\n\m} returns 1 if |N>M|, 0 if |N=M|, and -1 if |N<M|.
Extended by \xintfracname to fractions.

\subsection{\csbh{xintGeq}}\label{xintGeq}

\csa{xintGeq\n\m} returns 1 if the absolute value of the first
number is at least equal to the absolute value of the second
number. If \verb+|N|<|M|+ it returns 0.

\subsection{\csbh{xintMax}}\label{xintiMax}

\csa{xintMax\n\m} returns the largest of the two in the sense of the order
structure on the relative integers (\emph{i.e.} the right-most number if they
are put on a line with positive numbers on the right): |\xintiMax
{-5}{-6}=|\texttt{\xintiMax{-5}{-6}}. Extended by \xintfracname to fractions.

\subsection{\csbh{xintMin}}\label{xintiMin}

\csa{xintMin\n\m} returns the smallest of the two in the sense of the order
structure on the relative integers (\emph{i.e.} the left-most number if they are
put on a line with positive numbers on the right): |\xintiMin
{-5}{-6}=|\texttt{\xintiMin{-5}{-6}}. Extended by \xintfracname to fractions.

\subsection{\csbh{xintSum}}\label{xintiSum}

\csa{xintSum}\marg{braced things} after expanding its argument
twice expects to find a sequence of tokens (or braced material).
Each is twice-expanded, and the sum of all these numbers is
returned. 
\centeredline{%
  \csa{xintiSum}|{{123}{-98763450}{\xintFac{7}}{\xintiMul{3347}{591}}}=|\texttt{%
    \xintiSum{{123}{-98763450}{\xintFac{7}}{\xintiMul{3347}{591}}}}}
\centeredline{\csa{xintiSum}|{1234567890}=|\texttt{%
     \xintiSum{1234567890}}}
An empty sum is no error and returns zero: |\xintiSum
{}=|\texttt{\xintiSum {}}. A sum with only one
term returns that number: |\xintiSum {{-1234}}=|\texttt{\xintiSum
  {{-1234}}}. Attention that |\xintiSum {-1234}| is not legal input
and will make the \TeX{} run fail. On the other hand  |\xintiSum
{1234}=|\texttt{\xintiSum{1234}}. Extended by \xintfracname
to fractions.

\subsection{\csbh{xintSumExpr}}\label{xintiSumExpr}

\csa{xintSum}\meta{braced things}\csa{relax} is to what
\csa{xintSum} reduces after its initial double expansion of its
argument. \centeredline{%
  \csa{xintiSumExpr}| {123}{-98763450}|%
  |{\xintFac{7}}{\xintiMul{3347}{591}}\relax=|\texttt{%
    \xintiSumExpr
    {123}{-98763450}{\xintFac{7}}{\xintiMul{3347}{591}}\relax}}

Note: I am not so happy with the name which seems to suggest that the
|+| sign should be used instead of braces. Perhaps this will change
in the future.

Extended by \xintfracname to fractions.

\subsection{\csbh{xintMul}}\label{xintiMul}
{\small Modified in bundle version |1.03|.\par}

\csa{xintMul\n\m} returns the product of the two numbers. Starting
with release |1.03| of \xintname, the macro checks the lengths of
the two numbers and then activates its algorithm with the best (or
at least, hoped-so) choice of which one to put first. This makes
the macro a bit slower for numbers up to 50 digits, but may give
substantial speed gain when one of the number has 100 digits or more.
Extended by \xintfracname to fractions.

\subsection{\csbh{xintSqr}}\label{xintiSqr}

\csa{xintSqr\n} returns the square. Extended by \xintfracname to fractions.

\subsection{\csbh{xintPrd}}\label{xintiPrd}

\csa{xintPrd}\marg{braced things} after expanding its argument
twice expects to find a sequence of tokens (or braced material).
Each is twice-expanded, and the product of all these numbers is
returned. \centeredline{%
  \csa{xintiPrd}|{{-9876}{\xintFac{7}}{\xintiMul{3347}{591}}}=|%
  \texttt{%
    \xintiPrd{{-9876}{\xintFac{7}}{\xintiMul{3347}{591}}}}}
\centeredline{\csa{xintiPrd}|{123456789123456789}=|\texttt{%
    \xintiPrd{123456789123456789}}} An empty product is no error
and returns 1: |\xintiPrd {}=|\texttt{\xintiPrd {}}. A product
reduced to a single term returns this number: |\xintiPrd
{{-1234}}=|\texttt{\xintiPrd {{-1234}}}. Attention that |\xintiPrd
{-1234}| is not legal input and will make the \TeX{} compilation
fail. On the other hand |\xintiPrd {1234}=|\texttt{\xintiPrd
  {1234}}.
\centeredline{&2^{200}3^{100}7^{100}&}
\centeredline{=|\xintiPrd {{\xintiPow {2}{200}}{\xintiPow
    {3}{100}}{\xintiPow {7}{100}}}|}
=\expandafter\expandafter\expandafter\allownumbersplit
   \xintiPrd {{\xintiPow {2}{200}}{\xintiPow {3}{100}}{\xintiPow
    {7}{100}}}\relax
\centeredline{=|\xintiPow {\xintiMul {\xintiPow {42}{9}}{43008}}{10}|}
Extended by \xintfracname to fractions.

% \printnumber{%
%    \xintPow {\xintMul {\xintPow {42}{9}}{43008}}{10}}

\subsection{\csbh{xintProductExpr}}\label{xintiProductExpr}

\csa{xintProductExpr}\meta{braced things}\csa{relax} is to what
\csa{xintPrd} reduces after its initial double expansion of its
argument. 
\centeredline{\csa{xintiProductExpr}| 123456789123456789\relax=|\texttt{%
     \xintiProductExpr 123456789123456789\relax}}

Note: I am not so happy with the name which seems to suggest that the
|*| sign should be used instead of braces. Perhaps this will change
in the future.

Extended by \xintfracname to fractions.

\subsection{\csbh{xintFac}}\label{xintFac}

\csa{xintFac\n} returns the factorial. It is an error if the
argument is negative or at least &10^9&. It is not recommended to
launch the computation of things such as &100000!&, if you need
your computer for other tasks. 

% temps obsolètes, mettre à jour
% On my laptop &1000!& (2568 digits)
% is computed in a little less than ten seconds, &2000!& (5736
% digits) is computed in a little less than one hundred seconds, and
% &3000!& (which has 9131 digits) needs close to seven minutes\dots
% I have no idea how much time &10000!& would need (do rather
% &9999!& if you can, the algorithm has some overhead at the
% transition from &N=9999& to &10000& and higher; &10000!& has 35660
% digits). Not to mention &100000!& which, from the Stirling formula,
% should have 456574 digits.

\subsection{\csbh{xintPow}}\label{xintiPow}

\csa{xintPow\n\m} returns |N^M|. When |M| is zero, this is 1. Some
cases (|N| zero and |M| negative, \verb+|N|>1+ and |M| negative,
\verb+|N|>1+ and |M| at least &10^9&) make \xintname throw errors. 

Extended by \xintfracname to fractions. Of course, negative
exponents do not then cause errors anymore. 


\subsection{\csbh{xintDivision}}\label{xintDivision}

\csa{xintDivision\n\m} returns |{quotient Q}{remainder R}|. This
is euclidean division: |N = QM + R|, |0|${}\leq{}$\verb+R < |M|+. So the
remainder is always non-negative and the formula |N = QM + R|
always holds independently of the signs of |N| or |M|. Division by
zero is of course an error (even if |N| vanishes) and returns |{0}{0}|.

This macro is integer only and not to be confused with the \xintfracname macro
\csb{xintDiv} which divides one fraction by another.

\subsection{\csbh{xintQuo}}\label{xintQuo}

\csa{xintQuo\n\m} returns the quotient from the euclidean division. When both
|N| and |M| are positive one has \csa{xintQuo\n\m}|=\xintiTrunc {0}{N/M}| (using
package \xintfracname).

\subsection{\csbh{xintRem}}\label{xintRem}

\csa{xintRem\n\m} returns the remainder from the euclidean division.


\subsection{\csbh{xintFDg}}\label{xintFDg}

\csa{xintFDg\n} returns the first digit (most significant) of the
decimal expansion.

\subsection{\csbh{xintLDg}}\label{xintLDg}

\csa{xintLDg\n} returns the least significant digit. When the
number is positive, this is the same as the remainder in the
euclidean division by ten.

\subsection{\csbh{xintMON}, \csbh{xintMMON}}\label{xintMON}\label{xintMMON}
{\small New in bundle version |1.03|.\par}

\csa{xintMON\n} returns |(-1)^N| and \csa{xintMMON\n} returns
|(-1)^{N-1}|. \centeredline{|\xintMON {-280914019374101929}=|\texttt{\xintMON
  {280914019374101929}}, |\xintMMON
{-280914019374101929}=|\texttt{\xintMMON {280914019374101929}}}

\subsection{\csbh{xintOdd}}\label{xintOdd}

\csa{xintOdd\n} is 1 if the number is odd and 0 otherwise. 

\subsection{\csbh{xintDSL}}\label{xintDSL}

\csa{xintDSL\n} is decimal shift left, \emph{i.e.} multiplication
by ten.

\subsection{\csbh{xintDSR}}\label{xintDSR}

\csa{xintDSR\n} is decimal shift right, \emph{i.e.} it removes the
last digit (keeping the sign). For a positive number, this is the
same as the quotient from the euclidean division by ten (of
course, done in a more efficient manner than via the general
division algorithm). For |N| from |-9| to |-1|, the macro returns
|0|.

\subsection{\csbh{xintDSH}}\label{xintDSH}

\csa{xintDSH\x\n} is parametrized decimal shift. When |x| is
negative, it is like iterating \csa{xintDSL} \verb+|x|+ times
(\emph{i.e.} multiplication by &10^{-&|x|&}&). When |x| positive,
it is like iterating \csa{DSR} |x| times (and is more efficient of
course), and for a non-negative |N| this is thus the same as the
quotient from the euclidean division by |10^x|. 

\subsection{\csbh{xintDSHr}, \csbh{xintDSx}}\label{xintDSHr}\label{xintDSx}
{\small New in bundle version |1.01|.\par}

\csa{xintDSHr\x\n} expects |x| to be zero or positive and it returns
then a value |R| which is correlated to the value |Q| returned by
\csa{xintDSH\x\n} in the following manner:
\begin{itemize}
\item if |N| is
  positive or zero, |Q| and |R| are the quotient and remainder in
  the euclidean division by |10^x| (obtained in a more efficient
  manner than using \csa{xintDivision}),
\item if |N| is negative let
  |Q1| and |R1| be the quotient and remainder in the euclidean
  division by |10^x| of the absolute value of |N|. If |Q1|
  does not vanish, then |Q=-Q1| and |R=R1|. If |Q1| vanishes, then
  |Q=0| and |R=-R1|.
\item for |x=0|, |Q=N| and |R=0|.
\end{itemize}
So one has |N = 10^x Q + R| if |Q| turns out to be zero or
positive, and |N = 10^x Q - R| if |Q| turns out to be negative,
which is exactly the case when |N| is at most |-10^x|.


\csa{xintDSx\x\n} for |x| negative is exactly as
\csa{xintDSH\x\n}, \emph{i.e.} multiplication by &10^{-&|x|&}&.
For |x| zero or positive it returns the two numbers |{Q}{R}|
described above, each one within braces. So |Q| is
\csa{xintDSH\x\n}, and |R| is \csa{xintDSHr\x\n}, but computed
simultaneously.

\begin{flushleft}
  \xintAssign\xintDSx {-1}{-123456789}\to\M 
  \noindent{|\xintAssign\xintDSx {-1}{-123456789}\to\M|}\\
  |\meaning\M: |\texttt{\meaning\M}.\\
  \xintAssign\xintDSx {-20}{1234567689}\to\M 
  {|\xintAssign\xintDSx {-20}{123456789}\to\M|}\\ 
  |\meaning\M: |\texttt{\meaning\M}.\\
  \xintAssign\xintDSx{0}{-123004321}\to\Q\R 
  {|\xintAssign\xintDSx {0}{-123004321}\to\Q\R|}\\
  \noindent|\meaning\Q: |\texttt{\meaning\Q}, |\meaning\R:
  |\texttt{\meaning\R.}\\
  |\xintDSH {0}{-123004321}=|\texttt{\xintDSH {0}{-123004321}},
  |\xintDSHr {0}{-123004321}=|\texttt{\xintDSHr {0}{-123004321}}\\
  \xintAssign\xintDSx {6}{-123004321}\to\Q\R 
  {|\xintAssign\xintDSx {6}{-123004321}\to\Q\R|}\\ 
  |\meaning\Q: |\texttt{\meaning\Q},
  |\meaning\R: |\texttt{\meaning\R.}\\
  |\xintDSH {6}{-123004321}=|\texttt{\xintDSH {6}{-123004321}},
  |\xintDSHr {6}{-123004321}=|\texttt{\xintDSHr {6}{-123004321}}\\
  \xintAssign\xintDSx {8}{-123004321}\to\Q\R 
  {|\xintAssign\xintDSx {8}{-123004321}\to\Q\R|}\\ 
  |\meaning\Q: |\texttt{\meaning\Q},
  |\meaning\R: |\texttt{\meaning\R.} \\
  |\xintDSH {8}{-123004321}=|\texttt{\xintDSH {8}{-123004321}},
  |\xintDSHr {8}{-123004321}=|\texttt{\xintDSHr {8}{-123004321}}\\
  \xintAssign\xintDSx {9}{-123004321}\to\Q\R 
  {|\xintAssign\xintDSx {9}{-123004321}\to\Q\R|}\\ 
  |\meaning\Q: |\texttt{\meaning\Q},
  |\meaning\R: |\texttt{\meaning\R.}\\
  |\xintDSH {9}{-123004321}=|\texttt{\xintDSH {9}{-123004321}},
  |\xintDSHr {9}{-123004321}=|\texttt{\xintDSHr {9}{-123004321}}\\
\end{flushleft}

\subsection{\csbh{xintDecSplit}}\label{xintDecSplit}

{\small This has been modified in bundle version |1.01|.\par}

\csa{xintDecSplit\x\n} cuts the number into two pieces (each one within a
pair of enclosing braces). First the sign if present is \emph{removed}.
Then, for |x| positive or null, the second piece contains the |x| least
significant digits (\emph{empty} if |x=0|) and the first piece the remaining
digits (\emph{empty} when |x| equals or exceeds the length of |N|).
Leading zeros in the second piece are not removed. When |x| is negative
the first piece contains the \verb+|x|+ most significant digits and the
second piece the remaining digits (\emph{empty} if &|x|& equals or exceeds
the length of |N|). Leading zeros in this second piece are not removed.
So the absolute value of the original number is always the concatenation
of the first and second piece.

{\footnotesize This macro's behavior for |N| non-negative is final and will not
  change. I am still hesitant about what to do with the sign of a
  negative |N|.\par}


\xintAssign\xintDecSplit {0}{-123004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {0}{-123004321}\to\L\R|}
\noindent|\meaning\L: |\texttt{\meaning\L}, |\meaning\R: |\texttt{\meaning\R.}
\xintAssign\xintDecSplit {5}{-123004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {5}{-123004321}\to\L\R|}
|\meaning\L: |\texttt{\meaning\L}, |\meaning\R: |\texttt{\meaning\R.}
\xintAssign\xintDecSplit {9}{-123004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {9}{-123004321}\to\L\R|}
|\meaning\L: |\texttt{\meaning\L}, |\meaning\R: |\texttt{\meaning\R.}
\xintAssign\xintDecSplit {10}{-123004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {10}{-123004321}\to\L\R|}
|\meaning\L: |\texttt{\meaning\L}, |\meaning\R: |\texttt{\meaning\R.}
\xintAssign\xintDecSplit {-5}{-12300004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {-5}{-12300004321}\to\L\R|}
|\meaning\L: |\texttt{\meaning\L}, |\meaning\R: |\texttt{\meaning\R.}
\xintAssign\xintDecSplit {-11}{-12300004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {-11}{-12300004321}\to\L\R|}
|\meaning\L: |\texttt{\meaning\L}, |\meaning\R: |\texttt{\meaning\R.}
\xintAssign\xintDecSplit {-15}{-12300004321}\to\L\R
\centeredline{|\xintAssign\xintDecSplit {-15}{-12300004321}\to\L\R|}
|\meaning\L: |\texttt{\meaning\L}, |\meaning\R: |\texttt{\meaning\R.}

\subsection{\csbh{xintDecSplitL}}\label{xintDecSplitL}

\csa{xintDecSplitL\x\n} returns the first piece after the action
of \csa{xintDecSplit}.

\subsection{\csbh{xintDecSplitR}}\label{xintDecSplitR}

\csa{xintDecSplitR\x\n} returns the second piece after the action
of \csa{xintDecSplit}.


\section{Commands of the \xintgcdname package}


\subsection{\csbh{xintGCD}}\label{xintGCD}

\csa{xintGCD\n\m} computes the greatest common divisor. It is
positive, except when both |N| and |M| vanish, in which case the macro
returns zero.
\centeredline{\csa{xintGCD}|{10000}{1113}=|\texttt{\xintGCD{10000}{1113}}}
\centeredline{|\xintGCD{123456789012345}{9876543210321}=|\texttt
              {\xintGCD{123456789012345}{9876543210321}}}

\subsection{\csbh{xintBezout}}\label{xintBezout}

\xintAssign{{\xintBezout {10000}{1113}}}\to\X
\xintAssign {\xintBezout {10000}{1113}}\to\A\B\U\V\D

\csa{xintBezout\n\m} returns five numbers |A|, |B|, |U|, |V|, |D| within
braces. |A| is the first (twice-expanded) input number, |B| the
second, |D| is the GCD, and \texttt{UA - VB = D}. 
\centeredline{|\xintAssign {{\xintBezout {10000}{1113}}}\to\X|}
\centeredline{|\meaning\X: |\texttt{\meaning\X }.}
\noindent{|\xintAssign {\xintBezout {10000}{1113}}\to\A\B\U\V\D|}\\
|\A: |\texttt{\A },
|\B: |\texttt{\B },
|\U: |\texttt{\U },
|\V: |\texttt{\V },
|\D: |\texttt{\D }.\\
\xintAssign {\xintBezout {123456789012345}{9876543210321}}\to\A\B\U\V\D
\noindent{|\xintAssign {\xintBezout {123456789012345}{9876543210321}}\to\A\B\U\V\D
|}\\
|\A: |\texttt{\A },
|\B: |\texttt{\B },
|\U: |\texttt{\U },
|\V: |\texttt{\V },
|\D: |\texttt{\D }.


\subsection{\csbh{xintEuclideAlgorithm}}\label{xintEuclideAlgorithm}

\xintAssign {{\xintEuclideAlgorithm {10000}{1113}}}\to\X

\def\restorebracecatcodes
   {\catcode`\{=1 \catcode`\}=2 }

\def\allowlistsplit 
   {\catcode`\{=12 \catcode`\}=12 \allowlistsplita }

\def\allowlistsplitx {\futurelet\listnext\allowlistsplitxx }

\def\allowlistsplitxx {\ifx\listnext\relax \restorebracecatcodes
                        \else \expandafter\allowlistsplitxxx \fi }
\begingroup
\catcode`\[=1
\catcode`\]=2
\catcode`\{=12
\catcode`\}=12
\gdef\allowlistsplita #1{[#1\allowlistsplitx {]
\gdef\allowlistsplitxxx {#1}%
     [{#1}\hskip 0pt plus 1pt \allowlistsplitx ]
\endgroup

\csa{xintEuclideAlgorithm\n\m} applies the Euclide algorithm and
keeps a copy of all quotients and remainders. 
\centeredline{|\xintAssign {{\xintEuclideAlgorithm {10000}{1113}}}\to\X|}

|\meaning\X: |\texttt{\expandafter\allowlistsplit\meaning\X 
                      \relax }.
The first token is the number of steps, the second is |N|, the
third is the GCD, the fourth is |M| then the first quotient and
remainder, the second quotient and remainder, \dots until the
final quotient and last (zero) remainder.

\subsection{\csbh{xintBezoutAlgorithm}}\label{xintBezoutAlgorithm}

\catcode`\& 4

\xintAssign {{\xintBezoutAlgorithm {10000}{1113}}}\to\X

\csa{xintBezoutAlgorithm\n\m} applies the Euclide algorithm and
keeps a copy of all quotients and remainders. Furthermore it
computes the entries of the successive products of the 2 by 2 matrices 
$\left(\vcenter{\halign {\,#&\,#\cr q & 1 \cr 1 & 0 \cr}}\right)$
formed from the quotients arising in the algorithm.
\centeredline{|\xintAssign {{\xintEuclideAlgorithm {10000}{1113}}}\to\X|}

|\meaning\X: |\texttt{\expandafter\allowlistsplit\meaning\X \relax}.

The first token is the number of steps, the second is |N|, then
|0|, |1|, the GCD, |M|, |1|, |0|, the first quotient, the first
remainder, the top left entry of the first matrix, the bottom left
entry, and then these four things at each step until the end.

\catcode`\& 13

\subsection{\csbh{xintTypesetEuclideAlgorithm}}\label{xintTypesetEuclideAlgorithm}

This macro is just an example of how to organize the data returned
by \csa{xintEuclideAlgorithm}. Copy the source code to a new macro
and modify it to what is needed.
\centeredline{|\xintTypesetEuclideAlgorithm
  {123456789012345}{9876543210321}|} \xintTypesetEuclideAlgorithm
{123456789012345}{9876543210321}


\subsection{\csbh{xintTypesetBezoutAlgorithm}}\label{xintTypesetBezoutAlgorithm}

This macro is just an example of how to organize the data returned
by \csa{xintBezoutAlgorithm}. Copy the source code to a new macro
and modify it to what is needed.
\centeredline{|\xintTypesetBezoutAlgorithm {10000}{1113}|}
\xintTypesetBezoutAlgorithm {10000}{1113}

\section{Commands of the \xintfracname package}

The general rule of the bundle that each macro first double-expands each one of
its arguments applies.

\subsection{\csbh{xintLen}}\label{xintLen}

The original macro is extended to accept a fraction on input.
\centeredline {|\xintLen {201710/298219}=|\texttt{\xintLen {201710/298219}},
|\xintLen {1234/1}=|\texttt{\xintLen {1234/1}}, |\xintLen {1234}=|\texttt{\xintLen {1234}}}

\subsection{\csbh{xintNumerator}}\label{xintNumerator}

This returns the numerator corresponding to the internal representation of the
fraction:\footnote{recall that the |[]| construct excludes presence of a decimal
  point.} \centeredline{|\xintNumerator
  {178000/25600000[17]}=|\texttt{\xintNumerator {178000/25600000[17]}}}%
\centeredline{|\xintNumerator {178.000/25600000}=|\texttt{\xintNumerator
    {178.000/25600000}}} As shown by the examples, no simplification of the
input is done. For a result uniquely associated to the value of the fraction
first apply \csa{xintIrr}.

\subsection{\csbh{xintDenominator}}\label{xintDenominator}

This returns the denominator corresponding to the internal representation of the
fraction:\footnote{recall that the |[]| construct excludes presence of a decimal
  point.} \centeredline{|\xintDenominator
  {178000/25600000[17]}=|\texttt{\xintDenominator {178000/25600000[17]}}}%
\centeredline{|\xintDenominator {178.000/25600000}=|\texttt{\xintDenominator
    {178.000/25600000}}} As shown by the examples, no simplification of the
input is done. The denominator looks wrong in the second example, but the
numerator was tacitly multiplied by &1000& through the removal of the decimal
point.   For a result uniquely associated to the value of the fraction
first apply \csa{xintIrr}.

\subsection{\csbh{xintFrac}}\label{xintFrac}

This is a \LaTeX{} only command, to be used in math mode only. It will print a
fraction, internally represented as something equivalent to |A/B[n]| as |\frac
{A}{B}10^n|. The power of ten is omitted when |n=0| and the denominator is
omitted when it is one, the number is then separated from the power of ten by a
|\cdot|. |$\xintFrac {178.000/25600000}$| gives $\xintFrac {178.000/25600000}$,
|$\xintFrac {178.000/1}$| gives $\xintFrac {178.000/1}$ and |$\xintFrac
{3.5/5.7}$| gives $\xintFrac {3.5/5.7}$. As shown by the examples, no
simplification of the input is done (apart from removing the decimal points and
moving the sign to the numerator).


\subsection{\csbh{xintFwOver}}\label{xintFwOver}

This does the same as \csa{xintFrac} except that the \csa{over} primitive is
used for the fraction (in case the denominator is not one; and a pair of braces
contains the |A\over B| part). |$\xintFwOver {178.000/25600000}$| gives
$\xintFwOver {178.000/25600000}$, |$\xintFwOver {178.000/1}$| gives $\xintFwOver
{178.000/1}$ and |$\xintFwOver {3.5/5.7}$| gives $\xintFwOver {3.5/5.7}$.

\subsection{\csbh{xintSum}, \csbh{xintSumExpr}}\label{xintSum}\label{xintSumExpr}

The originals are extended to accept fractions on input. Their outputs will now
always be in the form |A/B[n]| or |A[n]| and thus cannot be used inside
integer-only macros. 
The originals are preserved as \csa{xintiSum} and \csa{xintiSumExpr}.


\subsection{\csbh{xintPrd}, \csbh{xintProductExpr}}\label{xintPrd}\label{xintProductExpr}

The originals are extended to accept fractions on input. Their outputs will now
always be in the form |A/B[n]| or |A[n]| and thus cannot be used inside
integer-only macros. 
The originals are preserved as \csa{xintiPrd} and \csa{xintiPrdExpr}.


\subsection{\csbh{xintREZ}}\label{xintREZ}

This command normalizes a fraction by removing the powers of ten in its
numerator and denominator: |\xintREZ {178000/25600000[17]}=|\texttt{\xintREZ
  {178000/25600000[17]}}. As shown by the example, it does not otherwise
simplify the fraction.

\subsection{\csbh{xintIrr}}\label{xintIrr}

This puts the fraction into its unique irreducible form: \centeredline{|\xintIrr
  {178.256/256.178}=|%
  \texttt{\xintIrr {178.256/256.178}}${}=\xintFrac{\xintIrr
    {178.256/256.178}[0]}$}%
Note that the current implementation does not cleverly first factor powers of 2
and 5, so input such as |\xintIrr {2/3[100]}| will make \xintfracname do the
Euclidean division of |2|\raisebox{.5ex}{|.|}|10^{100}| by |3|, which is a bit
stupid.

To avoid some overhead in the parsing by |\xintFrac| of the output of
|\xintIrr|, add a |[0]|: |\xintFrac {\xintIrr {178.256/256.178}[0]}|. This
advice is only for \csa{xintIrr} (or \csa{xintJrr}) as these macros do not have
the |[n]| systematically present in the outputs of the other macros, |[n]| whose
rôle is also to signal that the format can be parsed in a minimal way, as it is
not arbitrary user-input but beautiful package crafted output...


\subsection{\csbh{xintJrr}}\label{xintJrr}

This also puts the fraction into its unique irreducible form:
\centeredline{|\xintJrr {178.256/256.178}=|%
  \texttt{\xintJrr {178.256/256.178}}}%
This is faster than \csa{xintIrr} for fractions having a substantial common
factor in the numerator and the denominator, as  here:
|\xintJrr {\xintiMul{\xintFac {15}}{\xintFac
    {15}}/\xintiMul{\xintFac{10}}{\xintFac{30}}}=|\texttt{%
  \xintJrr {\xintiMul{\xintFac {15}}{\xintFac
      {15}}/\xintiMul{\xintFac{10}}{\xintFac{30}}}}. But to notice the
difference one would need computations with much bigger numbers than in this
example.


\subsection{\csbh{xintTrunc}}\label{xintTrunc}

\csa{xintTrunc}|{N}{f}| outputs the start of the decimal expansion of the
fraction |f|, with |N| digits after the decimal point. The argument |N| should
be non-negative. When |N=0|, the integer part of |f| results, with an ending
decimal point. Only when |f| evaluates to zero does \csa{xintTrunc} not print
the decimal point. When |f| is not zero, the sign is maintained in the output,
also when the digits are all zero. \centeredline{|\xintTrunc
  {20}{-803.2028/20905.298}=|\texttt{\xintTrunc {20}{-803.2028/20905.298}}} The
digits printed are exact up to and including the last one.

\subsection{\csbh{xintiTrunc}}\label{xintiTrunc}

\csa{xintiTrunc}|{N}{f}| outputs the integer equal to |10^N| times what
\csa{xintTrunc}|{N}{f}| would return. \centeredline{|\xintiTrunc
  {20}{-803.2028/20905.298}=|\texttt{\xintiTrunc {20}{-803.2028/20905.298}}} The
difference between \csa{xintTrunc}|{0}{f}| and \csa{xintiTrunc}|{0}{f}| is that
the former cannot be used inside integer-only macros, whereas the latter
removes the decimal point, and never returns |-0| (and of course removes
all superfluous leading zeros.)

\subsection{\csbh{xintMul}}\label{xintMul}

The original macro is extended to accept fractions on input. Its output will now
always be in the form |A/B[n]| or |A[n]| and thus cannot be used inside
integer-only macros. 
The original is preserved as \csa{xintiMul}.

\subsection{\csbh{xintSqr}}\label{xintSqr}

The original macro is extended to accept a fraction on input. Its output will now
always be in the form |A/B[n]| or |A[n]| and thus cannot be used inside
integer-only macros. 
The original is preserved as \csa{xintiSqr}.

\subsection{\csbh{xintPow}}\label{xintPow}

The original macro is extended to accept a fraction on input (the exponent must
be a signed integer of course). Its output will now always be in the form
|A/B[n]| or |A[n]| and thus cannot be used directly inside integer-only macros.
The original is preserved as \csa{xintiPow}.

\subsection{\csbh{xintDiv}}\label{xintDiv}

\csa{xintDiv}|{f}{g}| computes the fraction |f/g|. As with all other computation
macros, no simplification is done on the output, which is in the form
|A/B[n]| or |A[n]| and cannot be used directly inside
integer-only macros.

\subsection{\csbh{xintAdd}}\label{xintAdd}

The original macro is extended to accept fractions on input. Its output will now
always be in the form |A/B[n]| or |A[n]| and thus cannot be used directly inside
integer-only macros.
The original is preserved as \csa{xintiAdd}.

\subsection{\csbh{xintSub}}\label{xintSub}

The original macro is extended to accept fractions on input. Its output will now
always be in the form |A/B[n]| or |A[n]| and thus cannot be used directly inside
integer-only macros.
The original is preserved as \csa{xintiSub}.

\subsection{\csbh{xintCmp}}\label{xintCmp}

The macro is extended to fractions. 
The original, which skips the overhead of
the fraction format parsing, is preserved as \csa{xintiCmp}.

\subsection{\csbh{xintMax}}\label{xintMax}

The macro is extended to fractions. The re-defined version cannot be used
directly inside integer-only macros anymore. The original is preserved as
\csa{xintiMax}.

\subsection{\csbh{xintMin}}\label{xintMin}

The macro is extended to fractions. The re-defined version cannot be used
directly inside integer-only macros anymore. The original is preserved as
\csa{xintiMin}.

\subsection{\csbh{xintSgn}}\label{xintSgn}

The macro is extended to fractions. The original, which skips the overhead of
the fraction format parsing, is preserved as \csa{xintiSgn}.

\subsection{\csbh{xintOpp}}\label{xintOpp}

The macro is extended to fractions. The re-defined version cannot be used
directly inside integer-only macros anymore. The original is preserved as
\csa{xintiOpp}.

\subsection{\csbh{xintAbs}}\label{xintAbs}

The macro is extended to fractions. The re-defined version cannot be used
directly inside integer-only macros anymore. The original is preserved as
\csa{xintiAbs}.


\section{Commands of the \xintseriesname package}

There will be some exceptions to the general rule that
each macro first double-expands each one of its arguments.

\subsection{\csbh{xintSeries}}\label{xintSeries}

\def\coeff #1{\romannumeral0\xintmon{#1}/#1.5} % (-1)^n/(n+1/2)
\edef\w {\xintSeries {0}{50}{\coeff}}
\edef\z {\xintJrr {\w}[0]}

\csa{xintSeries}|{A}{B}{\coeff}| evaluates the sum of all values of the |\coeff
{n}| from |n=A| to and including |n=B|. The initial and final indices must
(after double-expansion) obey the \TeX{} constraint of being explicit numbers of
values at most |2^31-1| (these conditions are not checked by the macro). The
|\coeff| macro (which, as argument to \csa{xintSeries} is double-expanded only
at the time of computing the successive |\coeff {n}|) should be defined as a
one-parameter command, accepting on input a number (not a count register) and
needing at most two expansions to compute its final result.
\begin{verbatim}
\def\coeff #1{\romannumeral0\xintmon{#1}/#1.5} % (-1)^n/(n+1/2)
\edef\w {\xintSeries {0}{50}{\coeff}}
\edef\z {\xintJrr {\w}[0]}  
% \xintJrr as a big common factor is suspected.
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} = \xintFrac\z \]
\end{verbatim}
\vspace*{-\baselineskip}
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} = \xintFrac\z \]
For info, before action by |\xintJrr| the inner representation of the result
has a denominator of  |\xintLen {\xintDenominator\w}=|\xintLen
{\xintDenominator\w} digits. 

\subsection{\csbh{xintiSeries}}\label{xintiSeries}

\def\coeff #1{\romannumeral0\xintitrunc {40}{\xintMON{#1}/#1.5}} 

\csa{xintiSeries}|{A}{B}{\coeff}| evaluates the sum of all values of the |\coeff
{n}| from |n=A| to and including |n=B|. The initial and final indices must
(after double-expansion) obey the \TeX{} constraint of being explicit numbers of
values at most |2^31-1| (these conditions are not checked by the macro). The
|\coeff| macro (which, as argument to \csa{xintSeries} is double-expanded only
at the time of computing the successive |\coeff {n}|) should be defined as a
one-parameter command, accepting on input a number (not a count register) and
needing at most two expansions to compute its final result, \emph{which must be
  an integer}, in the format understood by the package integer-only
\csa{xintiAdd}.
\begin{verbatim}
\def\coeff #1{\romannumeral0\xintitrunc {40}{\xintMON{#1}/#1.5}} 
% (-1)^n/(n+1/2), with 40 digits post decimal point, as an integer
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} \approx
        \xintTrunc {40}{\xintiSeries {0}{50}{\coeff}[-40]}\dots\]
\end{verbatim}
\vspace*{-\baselineskip}
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} \approx
        \xintTrunc {40}{\xintiSeries {0}{50}{\coeff}[-40]}\dots\]
We should have cut out some of the final digits, rather than print all 40 of
them. For comparison the decimal expansion of the exact result is:
\[ \sum_{n=0}^{n=50} \frac{(-1)^n}{n+\frac12} = \xintTrunc {40}{\z}\dots\]

\subsection{\csbh{xintPowerSeries}}\label{xintPowerSeries}

\csa{xintPowerSeries}|{A}{B}{\coeff}{x}| evaluates the sum of
|\coeff{n}|\raisebox{.5ex}{|.|}|x^n| from |n=A| up to and including |n=B|. The
initial and final indices must (after double-expansion) obey the \TeX{}
constraint of being explicit numbers of values at most |2^31-1| (these
conditions are not checked by the macro). The |\coeff| macro (which, as argument
to \csa{xintPowerSeries} is double-expanded only at the time of computing the
successive |\coeff{n}|) should be defined as a one-parameter command, accepting
on input a number (not a count register) and needing at most two expansions to
compute its final result.

The |x| can be either a fraction directly input or a macro expanding in at most
two steps to such a fraction. It is actually more efficient for the various
macro expansions done by \TeX{} to encapsulate the fraction |x| in a macro (say
|\x|), if it has big numerators and denominators, as the less tokens there are,
the faster it goes, and some amount of shuffling around of the data given as the
fourth parameter to \csa{xintPowerSeries} is done internally, repeatedly. And,
for greater efficiency |x| should be a fraction in |A/B[n]| format.

Note though that this macro computes the \emph{exact} result, which may quickly
become a very big (possibly highly reducible) fraction.
\begin{verbatim}
\def\geom #1{1[0]} % the geometric series
\def\x {5/17[0]}   
\[ \sum_{n=0}^{n=20} \Bigl(\frac 5{17}\Bigr)^n 
 =\xintFrac{\xintIrr{\xintPowerSeries {0}{20}{\geom}{\x}}}
 =\xintFrac{\xintDiv{\xintiSub{\xintiPow {17}{21}}{\xintiPow{5}{21}}}
   {\xintiSub{\xintiPow {17}{21}}{\xintiMul {5}{\xintiPow {17}{20}}}}}\]
% a parser for arbitrary algebraic expressions with the +,-,/,*,and ^
% operations would dearly appreciated here ; but implementing a
% completely expandable one would quite a lot of work.
\end{verbatim}
\def\geom #1{1[0]} % the geometric series
\def\x {5/17[0]}   %  
\[ \sum_{n=0}^{n=20} \Bigl(\frac 5{17}\Bigr)^n 
 =\xintFrac{\xintIrr{\xintPowerSeries {0}{20}{\geom}{\x}}}
 =\xintFrac{\xintDiv{\xintiSub{\xintiPow {17}{21}}{\xintiPow{5}{21}}}
          {\xintiSub{\xintiPow {17}{21}}{\xintiMul {5}{\xintiPow {17}{20}}}}}\]
Check it by hand\dots you can guess the common factor by looking at the last two
digits of the two denominators!

% checking:

% \xintIrr {69091933912531895722624092/5757661159377657976885341}

% \xintIrr {48770776879770870268819212/4064231406647572522401601}

% gives 12 in both cases. Hourrah!

\begin{verbatim}
\def\coefflog #1{1/#1[0]}% 1/n
\def\x {1/2[0]}%
\[ \log 2 \approx \sum_{n=1}^{20} \frac1n \frac1{2^n} 
    = \xintFrac {\xintIrr {\xintPowerSeries {1}{20}{\coefflog}{\x}}}\]
\end{verbatim}
\def\coefflog #1{1/#1[0]} % 1/n
\def\x {1/2[0]}%
\[ \log 2 \approx \sum_{n=1}^{20} \frac1n \frac1{2^n} 
         = \xintFrac {\xintIrr {\xintPowerSeries
             {1}{20}{\coefflog}{\x}}}\]


\begin{verbatim}
\def\coeffarctg  #1{1/\the\numexpr\xintMON{#1}*(2*#1+1)\relax }% 
% the above gives (-1)^n/(2n+1). The sign being in the denominator, 
%             **** no [0] should be added ****, 
% else nothing is guaranteed to work (even if it could by sheer luck)
\def\x {1/25[0]}% 1/5^2
\[\mathrm{Arctg}(\frac15)\approx
            \frac15\sum_{n=0}^{15} \frac{(-1)^n}{(2n+1)25^n} 
= \xintFrac{\xintIrr {\xintDiv 
            {\xintPowerSeries {0}{15}{\coeffarctg}{\x}}{5}}}\]
\end{verbatim}
\def\coeffarctg  #1{1/\the\numexpr \xintMON{#1}*(2*#1+1)\relax }% (-1)^n/(2n+1)
\def\x {1/25[0]}% 1/5^2
\[\mathrm{Arctg}(\frac15)\approx
            \frac15\sum_{n=0}^{15} \frac{(-1)^n}{(2n+1)25^n} 
= \xintFrac{\xintIrr {\xintDiv 
            {\xintPowerSeries {0}{15}{\coeffarctg}{\x}}{5}}}\]


\subsection{\csbh{xintFxPtPowerSeries}}\label{xintFxPtPowerSeries}

\csa{xintFxPtPowerSeries}|{A}{B}{\coeff}{x}{D}| computes the sum of 
|\coeff{n}|\raisebox{.5ex}{|.|}|x^n| from |n=A| to |n=B| with each term of the
series being truncated to |D| digits after the decimal point. 

More precisely the first power |x^A| is computed exactly, then truncated. Then
each successive power is obtained from the previous one by multiplication by the
exact original value of |x|, then truncating. And
|\coeff{n}|\raisebox{.5ex}{|.|}|x^n| is obtained from that by multiplying by
|\coeff{n}| (untruncated) and then truncating. Finally the sum is computed
exactly.

Apart from that \csa{xintFxPtPowerSeries} (where |FxPt| means `fixed-point') is
like \csa{xintPowerSeries}. There should be a variant for things of the
type $\sum c_n \frac {x^n}{n!}$ to avoid having to compute the factorial
from scratch at each coefficient, the same way \csa{xintFxPtPowerSeries}
does not compute |x^n| from scratch at each |n|. For the next package
release (perhaps).


\def\coeffexp #1{1/\xintFac {#1}[0]}% [0] for faster parsing
\def\x {-1/2[0]}%
\def\ApproxExp #1#2{\xintFxPtPowerSeries {0}{#1}{\coeffexp}{\x}{#2}}%
\newcount\cnta 

\noindent\begin{minipage}{0.3\linewidth}
\centeredline{$e^{-\frac12}\approx{}$}%
\cnta 0 
\loop
$\ApproxExp {\the\cnta}{20}$\\
\ifnum\cnta<19
\advance\cnta 1
\repeat\par
\end{minipage}
\hfil
\begin{minipage}{0.65\linewidth}
\ttfamily\hyphenchar\font-1
\begin{verbatim}
\def\coeffexp #1{1/\xintFac {#1}[0]}% 
\def\x {-1/2[0]}% [0] for faster parsing
\def\ApproxExp #1#2{\xintFxPtPowerSeries 
                 {0}{#1}{\coeffexp}{\x}{#2}}%
\centeredline{$e^{-\frac12}\approx{}$}%
\cnta 0 % previously declared \count register
\loop
$\ApproxExp {\the\cnta}{20}$\\
% truncates 20 digits after decimal point
\ifnum\cnta<19
\advance\cnta 1
\repeat\par
% One should **not** trust the final digits, 
% independently of how many terms we compute,
% as errors from the initial terms will never
% disappear! and their cumulative value can
% make the last digit(s) wrong (especially when
% it is a 0 or a 9). We can see it is the case
% here via the computation with more digits:
\end{verbatim}
\end{minipage}%\medskip
\centeredline{|\xintFxPtPowerSeries {0}{30}{\coeffexp}{\x}{25}=|%
\texttt{\hyphenchar\font45 \xintFxPtPowerSeries {0}{30}{\coeffexp}{\x}{25}}}

\catcode`\& 4

\edef\z{\xintIrr {\xintPowerSeries {0}{19}{\coeffexp}{\x}}}

It is no difficulty for \xintfracname to compute exactly, with the
help of \csa{xintPowerSeries} and \csa{xintIrr}, the nineteenth partial
sum, and to then give the (start of the) exact decimal expansion (again
we see that the last digit from a `truncated' computation was wrong):
\[\halign {\hfil#&$#$&$#$\hfil\cr
|\xintPowerSeries {0}{19}{\coeffexp}{\x}|
&{}={}& \displaystyle\xintFrac{\z}\cr
\vphantom{\vrule height 15pt depth 3pt width 0pt }&{}={}& 
      \xintTrunc {25}{\z}\dots\cr }\]
Thus, one should always
estimate a priori how many ending digits are not reliable (and secretly
re-do the computation with at least five more digits...). 

\catcode`\& 13

\begin{verbatim}
\def\coefflog #1{1/#1[0]}% 1/n
\def\xa {13/256[0]}%  we will compute log(1-13/256)
\def\xb {1/9[0]}%     we will compute log(1-1/9)
\def\LogTwo #1% this #1 may be a count register, if desired  
%  get log(2)=-2log(1-13/256)- 5log(1-1/9) with #1 digits precision
{% 
  \romannumeral0\expandafter\LogTwoDoIt \expandafter
    % Nb Terms for 1/9:
  {\the\numexpr (#1+5)*150/143\expandafter}\expandafter
    % Nb Terms for 13/256:
  {\the\numexpr (#1+5)*100/129\expandafter}\expandafter
  {\the\numexpr #1+5\expandafter}\expandafter{\the\numexpr #1\relax }%
}%
\def\LogTwoDoIt #1#2#3#4% 
%  #1=nb of terms for 1/9, #2=nb of terms for 13/256, 
{% #3=nb of digits for computations, #4 for printing
 \xinttrunc {#4}
 {\xintAdd
  {\xintMul {2}{\xintFxPtPowerSeries {1}{#2}{\coefflog}{\xa}{#3}}}
  {\xintMul {5}{\xintFxPtPowerSeries {1}{#1}{\coefflog}{\xb}{#3}}}%
 }%
}%
\[ \log 2 = \LogTwo {60}\dots\]
\end{verbatim}
\vspace*{-\baselineskip}
\def\coefflog #1{1/#1[0]}% 1/n
\def\xa {13/256[0]}% we will compute log(1-13/256)
\def\xb {1/9[0]}%    we will compute log(1-1/9)
\def\LogTwo #1% get log(2)=-2log(1-13/256)- 5log(1-1/9) with #1 digits precision
{% this #1 may be a count register, if desired
    \romannumeral0\expandafter\LogTwoDoIt \expandafter
    {\the\numexpr (#1+5)*150/143\expandafter}\expandafter % Nb Terms for 1/9
    {\the\numexpr (#1+5)*100/129\expandafter}\expandafter % Nb Terms for 13/256
    {\the\numexpr #1+5\expandafter}\expandafter{\the\numexpr #1\relax }%
}% 
\def\LogTwoDoIt #1#2#3#4% #1=nb of terms for 1/9, #2=nb of terms for 13/256, 
{%                     #3=nb of digits for computations, #4 for printing
  \xinttrunc {#4}
    {\xintAdd
      {\xintMul {2}{\xintFxPtPowerSeries {1}{#2}{\coefflog}{\xa}{#3}}}
      {\xintMul {5}{\xintFxPtPowerSeries {1}{#1}{\coefflog}{\xb}{#3}}}%
    }%
}%
\[ \log 2 = \LogTwo {60}\dots\]

\begin{verbatim}
% pi = 16 Arctg(1/5) - 4 Arctg(1/239) (John Machin's formula)
\def\coeffarctg #1{\romannumeral0\xintmon{#1}/% 
                                       \the\numexpr 2*#1+1\relax [0]}% 
% the above computes (-1)^n/(2n+1).
% Recall the xint macro \xintMON which does '(-1)^N' but ATTENTION: It
% is MANDATORY that \coeffarctg #1 gives the final numerato in two
% expansion steps (the denominator is then identified as what follows
% after the slash and will be subjected to its own additional two
% expansion steps). If we had written \xintMON {#1} then this would not
% have been the case, because one expansion step is used by the
% expansion of \coeffarctg to its definition. Most of the time not
% respecting these guidelines provokes errors on compilation, but here,
% as I discovered making the mistake myself, if we had written \xintMON
% {#1} the computation would have silently proceeded to a WRONG final
% value! So please follow the package's author instructions.
% Alternative: 
% \def\coeffarctg #1{1/\the\numexpr\xintMON{#1}*(2*#1+1)\relax }%
\def\xa {1/25[0]}%      1/5^2, the [0] for faster parsing
\def\xb {1/57121[0]}% 1/239^2, the [0] for faster parsing
\def\Machin #1{% \Machin {\mycount} is allowed
    \romannumeral0\expandafter\MachinA \expandafter
     % number of terms for arctg(1/5):
    {\the\numexpr (#1+4)*5/7\expandafter}\expandafter 
     % number of terms for arctg(1/239):  
    {\the\numexpr (#1+4)*10/45\expandafter}\expandafter
     % do the computations with 4 additional digits:
    {\the\numexpr #1+4\expandafter}\expandafter
     % allow #1 to be a count register:
    {\the\numexpr #1\relax }}%
\def\MachinA #1#2#3#4% 
% #4: digits to keep after decimal point for printing
% #3=#4+4: digits for computing intermediate results
{\xinttrunc {#4}    % lowercase! produces the space to stop \romannumeral
 {\xintiSub         % does the final subtraction exactly with integers
  {\xintiTrunc {#3} % produces an integer for \xintiSub
   {\xintMul {16/5}{\xintFxPtPowerSeries {0}{#1}{\coeffarctg}{\xa}{#3}}}}
  {\xintiTrunc {#3} % above and below the main stuff
   {\xintMul{4/239}{\xintFxPtPowerSeries {0}{#2}{\coeffarctg}{\xb}{#3}}}}%
  [-#3]}}           % this [-n] is ok as it follows an *integer*
\[ \pi = \Machin {60}\dots \]
\end{verbatim}
\vspace*{-\baselineskip}
\def\coeffarctg #1{\romannumeral0\xintmon{#1}/\the\numexpr 2*#1+1\relax }% 
\def\xa {1/25[0]}%      1/5^2, the [0] for faster parsing
\def\xb {1/57121[0]}% 1/239^2, the [0] for faster parsing
\def\Machin #1{% #1 may be a count register, \Machin {\mycount} is allowed
    \romannumeral0\expandafter\MachinA \expandafter
     % number of terms for arctg(1/5):
    {\the\numexpr (#1+4)*5/7\expandafter}\expandafter 
     % number of terms for arctg(1/239):  
    {\the\numexpr (#1+4)*10/45\expandafter}\expandafter
     % do the computations with 4 additional digits:
    {\the\numexpr #1+4\expandafter}\expandafter
     % allow #1 to be a count register:
    {\the\numexpr #1\relax }}%
\def\MachinA #1#2#3#4% 
% #4: digits to keep after decimal point for printing
% #3=#4+4: digits for computing intermediate results
{\xinttrunc {#4}
 {\xintiSub     % does the final subtraction exactly with integers
  {\xintiTrunc {#3} % produces an integer for \xintiSub
   {\xintMul {16/5}{\xintFxPtPowerSeries {0}{#1}{\coeffarctg}{\xa}{#3}}}}
  {\xintiTrunc {#3}   % above and below the main stuff
   {\xintMul{4/239}{\xintFxPtPowerSeries {0}{#2}{\coeffarctg}{\xb}{#3}}}}%
  [-#3]}}       % this [-n] is ok as it follows an *integer*
\[ \pi = \Machin {60}\dots \]

You want more digits? (and have some time?) Copy this code to a Plain
\TeX{} or \LaTeX{} document loading \xintseriesname, and compile:
\begin{verbatim}
\newwrite\outfile
\immediate\openout\outfile \jobname-out\relax
\immediate\write\outfile {\Machin {1000}}
\immediate\closeout\outfile
\end{verbatim}
This will create a file with the correct first 1000 digits of $\pi$
after the decimal point. On my laptop this took about 44 seconds last
time I tried (and for 200 digits it is less than 1 second). As mentioned
in the introduction, the file
\href{http://www.ctan.org/pkg/pi}{\color{niceone}pi.tex} by \textsc{D.
  Roegel} shows that orders of magnitude faster computations are
possible within \TeX{}, but recall our constraints of complete
expandability and be merciful, please.



\catcode`\& 4

\makeatletter
\let\check@percent\original@check@percent
\StopEventually{\check@checksum\end{document}\endinput}
\makeatother

\newgeometry{hmarginratio=4:3,hscale=0.75}

\def\MacroFont{\ttfamily\small\baselineskip12pt\relax}

\toctransition

\MakePercentIgnore
% 
% \catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
% \let</none>\relax
% \def<*xint>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12}
%
%</none>
%<*xint>
% \section {Package \xintname implementation}
% 
% The commenting of the macros is currently (\docdate) very
% sparse. Some comments may be left-overs from previous versions
% of the macro, with parameters in another order for example.
%
% \localtableofcontents
% \subsection{Catcodes, \eTeX{} detection, reload detection}
% 
% The method for package identification and reload detection is
% copied verbatim from the packages by \textsc{Heiko Oberdiek}.
%
% The method for catcodes was also inspired by these packages, we
% proceed slightly differently. 
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \expandafter\let\expandafter\x\csname ver@xint.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xint}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax % plain-TeX, first loading
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
      \else
        \y{xint}{I was already loaded, aborting input}%
        \aftergroup\endinput
      \fi
    \fi
  \fi
  \def\ChangeCatcodesIfInputNotAborted
  {%
      \endgroup
      \edef\XINT@restorecatcodes@endinput
      {%
        \catcode47=\the\catcode47   % /
        \catcode41=\the\catcode41   % )
        \catcode40=\the\catcode40   % (
        \catcode42=\the\catcode42   % *
        \catcode43=\the\catcode43   % +
        \catcode62=\the\catcode62   % >
        \catcode60=\the\catcode60   % <
        \catcode58=\the\catcode58   % :
        \catcode46=\the\catcode46   % .
        \catcode45=\the\catcode45   % -
        \catcode44=\the\catcode44   % ,
        \catcode35=\the\catcode35   % #
        \catcode64=\the\catcode64   % @
        \catcode125=\the\catcode125 % }
        \catcode123=\the\catcode123 % {
        \endlinechar=\the\endlinechar
        \catcode13=\the\catcode13   % ^^M
        \catcode32=\the\catcode32   % 
        \catcode61=\the\catcode61   % =
        \noexpand\endinput
      }%
      \def\XINT@setcatcodes
      {%
        \catcode61=12   % =
        \catcode32=10   % space
        \catcode13=5    % ^^M
        \endlinechar=13 % 
        \catcode123=1   % {
        \catcode125=2   % }
        \catcode64=11   % @
        \catcode35=6    % #
        \catcode44=12   % ,
        \catcode45=12   % -
        \catcode46=12   % .
        \catcode58=11   % : (made letter for error cs)
        \catcode60=12   % <
        \catcode62=12   % >
        \catcode43=12   % +
        \catcode42=12   % *
        \catcode40=12   % (
        \catcode41=12   % )
        \catcode47=12   % /
      }%
      \XINT@setcatcodes
  }%
\ChangeCatcodesIfInputNotAborted 
%    \end{macrocode}
% \subsection{Package identification}
%
% Copied verbatim from \textsc{Heiko Oberdiek}'s packages.
%
%    \begin{macrocode}
\begingroup
  \catcode91=12 % [
  \catcode93=12 % ]
  \catcode58=12 % : (does not really matter, was letter)
  \expandafter\ifx\csname ProvidesPackage\endcsname\relax
    \def\x#1#2#3[#4]{\endgroup
      \immediate\write-1{Package: #3 #4}%
      \xdef#1{#4}%
    }%
  \else
    \def\x#1#2[#3]{\endgroup
      #2[{#3}]%
      \ifx#1\@undefined
        \xdef#1{#3}%
      \fi
      \ifx#1\relax
        \xdef#1{#3}%
      \fi
    }%
  \fi
\expandafter\x\csname ver@xint.sty\endcsname
\ProvidesPackage{xint}%
  [2013/04/14 v1.03 Expandable operations on long numbers (jfB)]%
%    \end{macrocode}
% \subsection{Token management macros}
%    \begin{macrocode}
\def\xint@gobble       #1{}%
\def\xint@gobble@one   #1{}%
\def\xint@gobble@two   #1#2{}%
\def\xint@gobble@three #1#2#3{}%
\def\xint@gobble@four  #1#2#3#4{}%
\def\xint@gobble@five  #1#2#3#4#5{}%
\def\xint@gobble@six   #1#2#3#4#5#6{}%
\def\xint@gobble@seven #1#2#3#4#5#6#7{}%
\def\xint@gobble@eight #1#2#3#4#5#6#7#8{}%
\def\xint@firstoftwo   #1#2{#1}%
\def\xint@secondoftwo  #1#2{#2}%
\def\xint@firstoftwo@andstop  #1#2{ #1}%
\def\xint@secondoftwo@andstop #1#2{ #2}%
\def\xint@exchangetwo@keepbraces #1#2{{#2}{#1}}%
\def\xint@exchangetwo@keepbraces@andstop #1#2{ {#2}{#1}}%
\def\xint@xpxp@andstop {\expandafter\expandafter\expandafter\space }%
\def\xint@minus@andstop { -}%
\def\xint@r     #1\R {}%
\def\xint@w     #1\W {}%
\def\xint@z     #1\Z {}%
\def\xint@zero  #10{}%
\def\xint@one   #11{}%
\def\xint@minus #1-{}%
\def\xint@relax #1\relax {}%
\def\xint@quatrezeros #10000{}%
\def\xint@bracedundef {\xint@undef }%
\def\xint@UDzerofork      #10\dummy  #2#3\xint@UDkrof {#2}%
\def\xint@UDsignfork      #1-\dummy  #2#3\xint@UDkrof {#2}%
\def\xint@UDwfork         #1\W\dummy #2#3\xint@UDkrof {#2}%
\def\xint@UDzerosfork     #100\dummy #2#3\xint@UDkrof {#2}%
\def\xint@UDonezerofork   #110\dummy #2#3\xint@UDkrof {#2}%
\def\xint@UDzerominusfork #10-\dummy #2#3\xint@UDkrof {#2}%
\def\xint@UDsignsfork     #1--\dummy #2#3\xint@UDkrof {#2}%
\def\xint@afterfi #1#2\fi {\fi #1}%
%    \end{macrocode}
% \subsection{\csh{xintRev}, \csh{xintReverseOrder}}
% \begin{verbatim}
% \xintRev: fait la double expansion, vérifie le signe
% \xintReverseOrder: ne fait PAS la double expansion, ne regarde
% PAS le signe.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintRev {\romannumeral0\xintrev }%
\def\xintrev #1%
{% 
    \expandafter\expandafter\expandafter
      \xint@rev
    \expandafter\expandafter\expandafter
      {#1}%
}%
\def\xint@rev #1%
{%
    \XINT@rev@fork #1\Z
}%
\def\XINT@rev@fork #1#2%
{%
    \xint@UDsignfork
      #1\dummy \XINT@rev@negative
       -\dummy \XINT@rev@nonnegative
    \xint@UDkrof
    #1#2%
}%
\def\XINT@rev@negative #1#2\Z
{%
    \expandafter \space \expandafter -\romannumeral0\XINT@rev {#2}%
}%
\def\XINT@rev@nonnegative #1\Z
{%
    \XINT@rev {#1}%
}%
\def\XINT@Rev {\romannumeral0\XINT@rev }%
\let\xintReverseOrder \XINT@Rev
\def\XINT@rev #1%  
{%
    \XINT@rord@main {}#1%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
}%
\def\XINT@rord@main #1#2#3#4#5#6#7#8#9%  
{%
    \XINT@strip@undef #9\XINT@rord@cleanup\xint@undef
    \XINT@rord@main {#9#8#7#6#5#4#3#2#1}%
}%
\def\XINT@rord@cleanup\xint@undef\XINT@rord@main #1#2\xint@UNDEF 
{%
    \expandafter\space\XINT@strip@UNDEF #1%
}%
\def\XINT@strip@undef #1\xint@undef {}%
\def\XINT@strip@UNDEF #1\xint@UNDEF {}%
%    \end{macrocode}
% \subsection{\csh{XINT@RQ}}
% \begin{verbatim}
% cette macro renverse et ajoute le nombre minimal de zéros à
% la fin pour que la longueur soit alors multiple de 4
% \romannumeral0\XINT@RQ {}<le truc à renverser>\R\R\R\R\R\R\R\R\Z
% Attention, ceci n'est utilisé que pour des chaînes de chiffres, et donc le
% comportement avec des {..} ou autres espaces n'a fait l'objet d'aucune
% attention 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@RQ #1#2#3#4#5#6#7#8#9%  
{%
    \xint@r  #9\XINT@RQ@end\R
    \XINT@RQ {#9#8#7#6#5#4#3#2#1}%
}%
\def\XINT@RQ@end\R\XINT@RQ #1#2\Z 
{%
    \XINT@RQ@end@ #1\Z
}%
\def\XINT@RQ@end@ #1#2#3#4#5#6#7#8%  
{%
    \xint@r #8\XINT@RQ@end@viii 
            #7\XINT@RQ@end@vii
            #6\XINT@RQ@end@vi
            #5\XINT@RQ@end@v
            #4\XINT@RQ@end@iv
            #3\XINT@RQ@end@iii
            #2\XINT@RQ@end@ii
            \R\XINT@RQ@end@i
            \Z #2#3#4#5#6#7#8%
}%
\def\XINT@RQ@end@viii #1\Z #2#3#4#5#6#7#8#9\Z { #9}%
\def\XINT@RQ@end@vii  #1\Z #2#3#4#5#6#7#8#9\Z { #8#9000}%
\def\XINT@RQ@end@vi   #1\Z #2#3#4#5#6#7#8#9\Z { #7#8#900}%
\def\XINT@RQ@end@v    #1\Z #2#3#4#5#6#7#8#9\Z { #6#7#8#90}%
\def\XINT@RQ@end@iv   #1\Z #2#3#4#5#6#7#8#9\Z { #5#6#7#8#9}%
\def\XINT@RQ@end@iii  #1\Z #2#3#4#5#6#7#8#9\Z { #4#5#6#7#8#9000}%
\def\XINT@RQ@end@ii   #1\Z #2#3#4#5#6#7#8#9\Z { #3#4#5#6#7#8#900}%
\def\XINT@RQ@end@i      \Z #1#2#3#4#5#6#7#8\Z { #1#2#3#4#5#6#7#80}%
%    \end{macrocode}
% \subsection{\csh{XINT@cuz}}
%    \begin{macrocode}
\def\xint@cleanupzeros@andstop #1#2#3#4%
{\expandafter
    \space
    \the\numexpr #1#2#3#4\relax 
}%
\def\xint@cleanupzeros@nospace #1#2#3#4%
{%
    \the\numexpr #1#2#3#4\relax 
}%
\def\XINT@Rev@andcleanupzeros #1%
{%
    \romannumeral0\expandafter
        \xint@cleanupzeros@andstop 
    \romannumeral0\XINT@rord@main {}#1%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% routine CleanUpZeros. Utilisée en particulier par la
% soustraction.
% INPUT:  longueur **multiple de 4**  (<-- ATTENTION)
% OUTPUT: on a retiré tous les leading zéros, on n'est **plus*
% nécessairement de longueur 4n
% Délimiteur pour @main: \W\W\W\W\W\W\W\Z avec SEPT \W
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@cuz #1%
{%
    \XINT@cuz@loop #1\W\W\W\W\W\W\W\Z%
}%
\def\XINT@cuz@loop #1#2#3#4#5#6#7#8%
{%
    \xint@w #8\xint@cuz@enda\W
    \xint@z #8\xint@cuz@endb\Z
    \XINT@cuz@checka {#1#2#3#4#5#6#7#8}%
}%
\def\xint@cuz@enda #1\XINT@cuz@checka #2%
{%
    \xint@cuz@endaa #2%
}%
\def\xint@cuz@endaa #1#2#3#4#5\Z 
{%
    \expandafter\space\the\numexpr #1#2#3#4\relax
}%
\def\xint@cuz@endb\Z\XINT@cuz@checka #1{ 0}%
\def\XINT@cuz@checka #1%
{%
    \expandafter \XINT@cuz@checkb \the\numexpr #1\relax
}%
\def\XINT@cuz@checkb #1%
{%
    \xint@zero #1\xint@cuz@backtoloop 0\XINT@cuz@Stop #1%
}%
\def\XINT@cuz@Stop #1\W #2\Z{ #1}%
\def\xint@cuz@backtoloop 0\XINT@cuz@Stop 0{\XINT@cuz@loop }%
%    \end{macrocode}
% \subsection{\csh{XINT@isOne}}
% Added in |1.03|.
%    \begin{macrocode}
\def\XINT@isOne #1{\romannumeral0\XINT@isone #1\W\Z }%
\def\XINT@isone #1#2%
{%
    \xint@one #1\XINT@isone@b 1\expandafter\space\expandafter 0\xint@z #2%
}%
\def\XINT@isone@b #1\xint@z #2%
{%
   \xint@w #2\XINT@isone@yes\W\expandafter\space\expandafter 0\xint@z
}%
\def\XINT@isone@yes #1\Z{ 1}%
%    \end{macrocode}
% \subsection{\csh{xintNum}}
% \begin{verbatim}
% For example \xintNum {----+-+++---+----000000000000003}
% \end{verbatim}
%    \begin{macrocode}
\def\xintNum {\romannumeral0\xintnum }%
\def\xintnum #1%
{%
 \expandafter\expandafter\expandafter
    \XINT@num
 \expandafter\expandafter\expandafter
    {#1}%
}%
\def\XINT@Num {\romannumeral0\XINT@num }%
\def\XINT@num #1{\XINT@num@loop #1\R\R\R\R\R\R\R\R\Z }%
\def\XINT@num@loop #1#2#3#4#5#6#7#8%
{% 
    \xint@r #8\XINT@num@end\R\XINT@num@NumEight #1#2#3#4#5#6#7#8%
}%
\def\XINT@num@end\R\XINT@num@NumEight #1\R #2\Z
{%
    \expandafter\space\the\numexpr #1+0\relax
}%
\def\XINT@num@NumEight #1#2#3#4#5#6#7#8%
{%
    \ifnum \numexpr #1#2#3#4#5#6#7#8+0\relax = 0
      \xint@afterfi {\expandafter\XINT@num@keepsign@a
                     \the\numexpr #1#2#3#4#5#6#7#81\relax}%
    \else
      \xint@afterfi {\expandafter\XINT@num@finish
                     \the\numexpr #1#2#3#4#5#6#7#8\relax}%
    \fi
}%
\def\XINT@num@keepsign@a #1%
{%
    \xint@one#1\XINT@num@gobacktoloop 1\XINT@num@keepsign@b  
}%
\def\XINT@num@gobacktoloop 1\XINT@num@keepsign@b {\XINT@num@loop }%
\def\XINT@num@keepsign@b #1{\XINT@num@loop -}%
\def\XINT@num@finish #1\R #2\Z { #1}%
%    \end{macrocode}
% \subsection{\csh{xintLen}, \csh{xintLength}}
% \begin{verbatim}
% \xintLen    -> fait la double expansion, ne compte PAS le signe
% \xintLength -> ne fait PAS la double expansion, compte le signe
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintiLen {\romannumeral0\xintilen }%
\def\xintilen #1%
{%
    \expandafter\expandafter\expandafter
    \XINT@length@fork #1\R\R\R\R\R\R\R\R\Z
}%
\let\xintLen\xintiLen \let\xintlen\xintilen
\def\XINT@Len #1{\romannumeral0\XINT@length@fork #1\R\R\R\R\R\R\R\R\Z }%
\def\XINT@length@fork #1%
{%
    \expandafter\XINT@length@loop
    \xint@UDsignfork
      #1\dummy {{0}}%
       -\dummy {{0}#1}%
    \xint@UDkrof
}%
\def\XINT@Length #1{\romannumeral0\XINT@length@loop {0}#1\R\R\R\R\R\R\R\R\Z }%
\def\XINT@length #1{\XINT@length@loop {0}#1\R\R\R\R\R\R\R\R\Z }%
\let\xintLength\XINT@Length
\def\XINT@length@loop #1#2#3#4#5#6#7#8#9%  
{%
    \xint@r  #9\XINT@length@end {#2#3#4#5#6#7#8#9}\R
    \expandafter\XINT@length@loop\expandafter {\the\numexpr #1+8\relax}%
}%
\def\XINT@length@end #1\R\expandafter\XINT@length@loop\expandafter #2#3\Z
{%
    \XINT@length@end@ #1\W\W\W\W\W\W\W\W\Z {#2}%
}%
\def\XINT@length@end@ #1\R #2#3#4#5#6#7#8#9\Z 
{%
    \xint@w #2\XINT@length@end@i
            #3\XINT@length@end@ii
            #4\XINT@length@end@iii
            #5\XINT@length@end@iv
            #6\XINT@length@end@v
            #7\XINT@length@end@vi
            #8\XINT@length@end@vii
            \W\XINT@length@end@viii
}%
\def\XINT@length@end@viii #1%
    {\expandafter\space\the\numexpr #1-8\relax}%
\def\XINT@length@end@vii  #1\XINT@length@end@viii #2%
    {\expandafter\space\the\numexpr #2-7\relax}%
\def\XINT@length@end@vi   #1\XINT@length@end@viii #2%
    {\expandafter\space\the\numexpr #2-6\relax}%
\def\XINT@length@end@v    #1\XINT@length@end@viii #2%
    {\expandafter\space\the\numexpr #2-5\relax}%
\def\XINT@length@end@iv   #1\XINT@length@end@viii #2%
    {\expandafter\space\the\numexpr #2-4\relax}%
\def\XINT@length@end@iii  #1\XINT@length@end@viii #2%
    {\expandafter\space\the\numexpr #2-3\relax}%
\def\XINT@length@end@ii   #1\XINT@length@end@viii #2%
    {\expandafter\space\the\numexpr #2-2\relax}%
\def\XINT@length@end@i    #1\XINT@length@end@viii #2%
    {\expandafter\space\the\numexpr #2-1\relax}%
%    \end{macrocode}
% \subsection{\csh{xintAssign}, \csh{xintAssignArray}, \csh{xintDigitsOf}}
% \begin{verbatim}
% \xintAssign {a}{b}..{z}\to\A\B...\Z, 
% \xintAssignArray {a}{b}..{z}\to\U
% version 1.01 corrects an oversight in 1.0 related to the value of
% \escapechar at the time of using \xintAssignArray or \xintRelaxArray
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintAssign #1\to
{%
    \expandafter\expandafter\expandafter
    \XINT@assign@a #1{}\to
}%
\def\XINT@assign@a #1% attention to the # at the beginning of next line
#{%
    \def\xint@temp {#1}%
    \ifx\empty\xint@temp
        \expandafter\XINT@assign@b 
    \else
        \expandafter\XINT@assign@B
    \fi
}%
\def\XINT@assign@b #1#2\to #3%
{% 
    \edef #3{#1}\def\xint@temp {#2}%
    \ifx\empty\xint@temp
      \else
      \xint@afterfi{\XINT@assign@a #2\to }%
    \fi
}%
\def\XINT@assign@B #1\to #2%
{%
    \edef #2{\xint@temp}%
}%
\def\xintRelaxArray #1%
{%
    \edef\XINT@restoreescapechar {\escapechar\the\escapechar\relax}%
    \escapechar -1
    \edef\xint@arrayname {\string #1}%
    \XINT@restoreescapechar
    \expandafter\let\expandafter\xint@temp
                \csname\xint@arrayname 0\endcsname
    \count 255 0
    \loop
      \global\expandafter\let
             \csname\xint@arrayname\the\count255\endcsname\relax
      \ifnum \count 255 < \xint@temp
      \advance\count 255 1
    \repeat  
    \global\expandafter\let\csname\xint@arrayname 00\endcsname\relax
    \global\let #1\relax    
}%
\def\xintAssignArray #1\to #2%
{% 
    \edef\XINT@restoreescapechar {\escapechar\the\escapechar\relax}%
    \escapechar -1
    \edef\xint@arrayname {\string #1}%
    \XINT@restoreescapechar
    \count 255 0
        \expandafter\expandafter\expandafter
    \XINT@assignarray@loop #1\xint@undef 
    \csname\xint@arrayname 00\endcsname
    \csname\xint@arrayname 0\endcsname 
    {\xint@arrayname}%
    #2%
}%
\def\XINT@assignarray@loop #1%
{%
    \def\xint@temp {#1}%
    \ifx\xint@bracedundef\xint@temp
       \edef\xint@temp{\the\count 255 }%
       \expandafter\let\csname\xint@arrayname0\endcsname\xint@temp
       \expandafter\XINT@assignarray@end
    \else
       \advance\count 255 1
       \expandafter\edef
          \csname\xint@arrayname\the\count 255\endcsname{\xint@temp}%
       \expandafter\XINT@assignarray@loop
    \fi
}%
\def\XINT@assignarray@end {\expandafter\XINT@assignarray@@end  }%
\def\XINT@assignarray@@end #1%
{%
    \expandafter\XINT@assignarray@@@end\expandafter #1%
}%
\def\XINT@assignarray@@@end #1#2#3%
{%
    \expandafter\XINT@assignarray@@@@end
    \expandafter #1\expandafter #2\expandafter{#3}%
}%
\def\XINT@assignarray@@@@end #1#2#3#4%
{%
    \def #4##1%
    {\romannumeral0%
        \expandafter\expandafter\expandafter
          #1%
        \expandafter\expandafter\expandafter
          {##1}%
    }%
    \def #1##1%
    {%
        \ifnum ##1< 0
            \xint@afterfi {\xintError:ArrayIndexIsNegative
                           \expandafter\space 0}%
        \else
            \xint@afterfi {%
              \ifnum ##1> #2
                  \xint@afterfi {\xintError:ArrayIndexBeyondLimit
                                 \expandafter\space 0}%
              \else
                  \xint@afterfi
                  {\expandafter\expandafter\expandafter
                   \space\csname #3##1\endcsname}%
              \fi}%
        \fi
     }%
}%
\let\xintDigitsOf\xintAssignArray
%    \end{macrocode}
% \subsection{\csh{xintSgn}}
%    \begin{macrocode}
\def\xintiSgn {\romannumeral0\xintisgn }%
\def\xintisgn #1%
{%
    \expandafter\expandafter\expandafter
    \XINT@sgn #1\Z%
}%
\let\xintSgn\xintiSgn \let\xintsgn\xintisgn
\def\XINT@Sgn #1{\romannumeral0\XINT@sgn #1\Z }%
\def\XINT@sgn #1%
{%
    \xint@xpxp@andstop
    \xint@UDzerominusfork
      #1-\dummy  {\expandafter0}%  zero
      0#1\dummy  {\expandafter-\expandafter1}% n\'egatif
       0-\dummy  {\expandafter1}%  positif
    \xint@UDkrof
    \xint@z
}%
%    \end{macrocode}
% \subsection{\csh{xintOpp}}
%    \begin{macrocode}
\def\xintiOpp {\romannumeral0\xintiopp }%
\def\xintiopp #1%
{%
    \expandafter\expandafter\expandafter
        \XINT@opp #1%
}%
\let\xintOpp\xintiOpp \let\xintopp\xintiopp
\def\XINT@Opp #1{\romannumeral0\XINT@opp #1}%
\def\XINT@opp #1%
{%
    \expandafter\space
    \xint@UDzerominusfork
      #1-\dummy  0%      zero
      0#1\dummy  {}%     negative
       0-\dummy  {-#1}%  positive
    \xint@UDkrof
}%
%    \end{macrocode}
% \subsection{\csh{xintAbs}}
%    \begin{macrocode}
\def\xintiAbs {\romannumeral0\xintiabs }%
\def\xintiabs #1%
{%
    \expandafter\expandafter\expandafter
    \XINT@abs #1%
}%
\let\xintAbs\xintiAbs \let\xintabs\xintiabs
\def\XINT@Abs #1{\romannumeral0\XINT@abs #1}%
\def\XINT@abs #1%
{%
    \xint@UDsignfork
      #1\dummy  \space
       -\dummy  { #1}%
    \xint@UDkrof
}%
%    \end{macrocode}
% \begin{verbatim}
%-----------------------------------------------------------------
%-----------------------------------------------------------------
% ARITHMETIC OPERATIONS: ADDITION, SUBTRACTION, SUMS, 
% MULTIPLICATION, PRODUCTS, FACTORIAL, POWERS, EUCLIDEAN DIVISION.
%
% Release 1.03 re-organizes sub-routines to facilitate future developments: the
% diverse variants of addition, with diverse conditions on inputs and output are
% first listed; they will be used in multiplication, or in the summation, or in
% the power routines. 
%
% ADDITION
% I: \XINT@add@A
% INPUT:
% \romannumeral0\XINT@add@A 0{}<N1>\W\X\Y\Z <N2>\W\X\Y\Z
%     1.    <N1> et <N2> renversés 
%     2.    de longueur 4n (avec des leading zéros éventuels)
%     3.    l'un des deux ne doit pas se terminer par 0000
% [Donc on peut avoir 0000 comme input si l'autre est >0 et ne se termine pas en
% 0000 bien sûr]. On peut avoir l'un des deux vides. Mais alors l'autre ne doit
% être ni vide ni 0000.
% OUTPUT: la somme <N1>+<N2>, order normal, plus sur 4n, pas de leading zeros
% La procédure est plus rapide lorsque la longueur de <N2> est supérieure à
% celle de <N1>
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@add@A #1#2#3#4#5#6%  
{%
    \xint@w 
    #3\xint@add@az 
    \W\XINT@add@AB #1{#3#4#5#6}{#2}% 
}%
\def\xint@add@az\W\XINT@add@AB #1#2%  
{%
    \XINT@add@AC@checkcarry #1% 
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% ici #2 est prévu pour l'addition, mais attention il devra être renversé pour
% \numexpr. #3 = résultat partiel. #4 = chiffres qui restent. On vérifie si le
% deuxième nombre s'arrête.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@add@AB #1#2#3#4\W\X\Y\Z #5#6#7#8%  
{%
    \xint@w 
    #5\xint@add@bz 
    \W\XINT@add@ABE #1#2{#8#7#6#5}{#3}#4\W\X\Y\Z 
}%
\def\XINT@add@ABE #1#2#3#4#5#6%
{\expandafter
    \XINT@add@ABEA\the\numexpr #1+10#5#4#3#2+#6\relax.%
}%
\def\XINT@add@ABEA #1#2#3.#4%  
{%
    \XINT@add@A  #2{#3#4}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% ici le deuxième nombre est fini
% #6 part à la poubelle, #2#3#4#5 est le #2 dans \XINT@add@AB
% on ne vérifie pas la retenue cette fois, mais les fois suivantes
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xint@add@bz\W\XINT@add@ABE #1#2#3#4#5#6%
{\expandafter
    \XINT@add@CC\the\numexpr #1+10#5#4#3#2\relax.%
}%
\def\XINT@add@CC #1#2#3.#4%  
{%
    \XINT@add@AC@checkcarry  #2{#3#4}% on va examiner et \'eliminer #2
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% retenue plus chiffres qui restent de l'un des deux nombres.
% #2 = résultat partiel
% #3#4#5#6 = summand, avec plus significatif à droite
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@add@AC@checkcarry #1%
{%
    \xint@zero #1\xint@add@AC@nocarry 0\XINT@add@C 
}%
\def\xint@add@AC@nocarry 0\XINT@add@C #1#2\W\X\Y\Z
{%
    \expandafter
    \xint@cleanupzeros@andstop
    \romannumeral0%
    \XINT@rord@main {}#2%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
    #1%
}%
\def\XINT@add@C #1#2#3#4#5%  
{%
    \xint@w 
    #2\xint@add@cz 
    \W\XINT@add@CD {#5#4#3#2}{#1}%
}%
\def\XINT@add@CD #1%
{\expandafter
    \XINT@add@CC\the\numexpr 1+10#1\relax.%
}%
\def\xint@add@cz\W\XINT@add@CD #1#2{ 1#2}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Addition II: \XINT@addr@A. 
% INPUT:
% \romannumeral0\XINT@addr@A 0{}<N1>\W\X\Y\Z <N2>\W\X\Y\Z
% Comme \XINT@add@A, la différence principale c'est qu'elle donne son résultat
% aussi *sur 4n*, renversé. De plus cette variante accepte que l'un ou même les
% deux inputs soient vides.  
% Utilisé par la sommation.
% INPUT: comme pour \XINT@add@A
%     1.    <N1> et <N2> renversés 
%     2.    de longueur 4n (avec des leading zéros éventuels)
%     3.    l'un des deux ne doit pas se terminer par 0000
% OUTPUT: la somme <N1>+<N2>, *aussi renversée* et *sur 4n*
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@addr@A #1#2#3#4#5#6%  
{%
    \xint@w 
    #3\xint@addr@az 
    \W\XINT@addr@B #1{#3#4#5#6}{#2}% 
}%
\def\xint@addr@az\W\XINT@addr@B #1#2%  
{%
    \XINT@addr@AC@checkcarry #1%
}%
\def\XINT@addr@B #1#2#3#4\W\X\Y\Z #5#6#7#8%  
{%
    \xint@w 
    #5\xint@addr@bz 
    \W\XINT@addr@E #1#2{#8#7#6#5}{#3}#4\W\X\Y\Z 
}%
\def\XINT@addr@E #1#2#3#4#5#6%
{\expandafter
    \XINT@addr@ABEA\the\numexpr #1+10#5#4#3#2+#6\relax
}%
\def\XINT@addr@ABEA #1#2#3#4#5#6#7%  
{%
    \XINT@addr@A  #2{#7#6#5#4#3}%
}%
\def\xint@addr@bz\W\XINT@addr@E #1#2#3#4#5#6%
{\expandafter
    \XINT@addr@CC\the\numexpr #1+10#5#4#3#2\relax
}%
\def\XINT@addr@CC #1#2#3#4#5#6#7%  
{%
    \XINT@addr@AC@checkcarry  #2{#7#6#5#4#3}%
}%
\def\XINT@addr@AC@checkcarry #1%
{%
    \xint@zero #1\xint@addr@AC@nocarry 0\XINT@addr@C 
}%
\def\xint@addr@AC@nocarry 0\XINT@addr@C #1#2\W\X\Y\Z { #1#2}%
\def\XINT@addr@C #1#2#3#4#5%  
{%
    \xint@w 
    #2\xint@addr@cz 
    \W\XINT@addr@D {#5#4#3#2}{#1}%
}%
\def\XINT@addr@D #1%
{\expandafter
    \XINT@addr@CC\the\numexpr 1+10#1\relax
}%
\def\xint@addr@cz\W\XINT@addr@D #1#2{ #21000}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% ADDITION III, \XINT@addm@A
% INPUT:
% \romannumeral0\XINT@addm@A 0{}<N1>\W\X\Y\Z <N2>\W\X\Y\Z
%     1.    <N1> et <N2> renversés
%     2.    <N1> de longueur 4n ; <N2> non
%     3.    <N2> est *garanti au moins aussi long* que <N1>
% OUTPUT: la somme <N1>+<N2>, ordre normal, pas sur 4n, leading zeros retirés.
% Utilisé par la multiplication.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@addm@A #1#2#3#4#5#6%  
{%
    \xint@w 
    #3\xint@addm@az 
    \W\XINT@addm@AB #1{#3#4#5#6}{#2}% 
}%
\def\xint@addm@az\W\XINT@addm@AB #1#2%  
{%
    \XINT@addm@AC@checkcarry #1%
}%
\def\XINT@addm@AB #1#2#3#4\W\X\Y\Z #5#6#7#8%  
{%
    \XINT@addm@ABE #1#2{#8#7#6#5}{#3}#4\W\X\Y\Z 
}%
\def\XINT@addm@ABE #1#2#3#4#5#6%
{\expandafter
    \XINT@addm@ABEA\the\numexpr #1+10#5#4#3#2+#6\relax.%
}%
\def\XINT@addm@ABEA #1#2#3.#4%  
{%
    \XINT@addm@A  #2{#3#4}%
}%
\def\XINT@addm@AC@checkcarry #1%
{%
    \xint@zero #1\xint@addm@AC@nocarry 0\XINT@addm@C 
}%
\def\xint@addm@AC@nocarry 0\XINT@addm@C #1#2\W\X\Y\Z
{%
    \expandafter
    \xint@cleanupzeros@andstop
    \romannumeral0%
    \XINT@rord@main {}#2%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
    #1%
}%
\def\XINT@addm@C #1#2#3#4#5%  
{%
    \xint@w 
    #5\xint@addm@cw
    #4\xint@addm@cx 
    #3\xint@addm@cy 
    #2\xint@addm@cz 
    \W\XINT@addm@CD {#5#4#3#2}{#1}%
}%
\def\XINT@addm@CD #1%
{\expandafter
    \XINT@addm@CC\the\numexpr 1+10#1\relax.%
}%
\def\XINT@addm@CC #1#2#3.#4%  
{%
    \XINT@addm@AC@checkcarry  #2{#3#4}%
}%
\def\xint@addm@cw 
    #1\xint@addm@cx
    #2\xint@addm@cy
    #3\xint@addm@cz
    \W\XINT@addm@CD 
{\expandafter
    \XINT@addm@CDw\the\numexpr 1+#1#2#3\relax.%
}%
\def\XINT@addm@CDw #1.#2#3\X\Y\Z 
{%
    \XINT@addm@end #1#3%
}%
\def\xint@addm@cx 
    #1\xint@addm@cy
    #2\xint@addm@cz
    \W\XINT@addm@CD 
{\expandafter
    \XINT@addm@CDx\the\numexpr 1+#1#2\relax.%
}%
\def\XINT@addm@CDx #1.#2#3\Y\Z 
{%
    \XINT@addm@end #1#3%
}%
\def\xint@addm@cy 
    #1\xint@addm@cz
    \W\XINT@addm@CD
{\expandafter
    \XINT@addm@CDy\the\numexpr 1+#1\relax.%
}%
\def\XINT@addm@CDy  #1.#2#3\Z 
{%
    \XINT@addm@end #1#3%
}%
\def\xint@addm@cz\W\XINT@addm@CD #1#2#3{\XINT@addm@end #1#3}%
\def\XINT@addm@end #1#2#3#4#5%
{\expandafter\space\the\numexpr #1#2#3#4#5\relax 
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% ADDITION IV, variante \XINT@addp@A
% INPUT:
% \romannumeral0\XINT@addp@A 0{}<N1>\W\X\Y\Z <N2>\W\X\Y\Z
%     1.    <N1> et <N2> renversés
%     2.    <N1> de longueur 4n ; <N2> non
%     3.    <N2> est *garanti au moins aussi long* que <N1>
% OUTPUT: la somme <N1>+<N2>, dans l'ordre renversé, sur 4n, et en faisant
% attention de ne pas terminer en 0000.
% Utilisé par la multiplication servant pour le calcul des puissances.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@addp@A #1#2#3#4#5#6%  
{%
    \xint@w 
    #3\xint@addp@az 
    \W\XINT@addp@AB #1{#3#4#5#6}{#2}% 
}%
\def\xint@addp@az\W\XINT@addp@AB #1#2%  
{%
    \XINT@addp@AC@checkcarry #1%
}%
\def\XINT@addp@AC@checkcarry #1%
{%
    \xint@zero #1\xint@addp@AC@nocarry 0\XINT@addp@C 
}%
\def\xint@addp@AC@nocarry 0\XINT@addp@C 
{%
    \XINT@addp@F
}%
\def\XINT@addp@AB #1#2#3#4\W\X\Y\Z #5#6#7#8%  
{%
    \XINT@addp@ABE #1#2{#8#7#6#5}{#3}#4\W\X\Y\Z 
}%
\def\XINT@addp@ABE #1#2#3#4#5#6%
{\expandafter
    \XINT@addp@ABEA\the\numexpr #1+10#5#4#3#2+#6\relax
}%
\def\XINT@addp@ABEA #1#2#3#4#5#6#7%  
{% 
   \XINT@addp@A  #2{#7#6#5#4#3}%<-- attention on met donc \`a droite
}%
\def\XINT@addp@C #1#2#3#4#5%  
{%
    \xint@w 
    #5\xint@addp@cw
    #4\xint@addp@cx 
    #3\xint@addp@cy 
    #2\xint@addp@cz 
    \W\XINT@addp@CD   {#5#4#3#2}{#1}%
}%
\def\XINT@addp@CD #1%
{\expandafter
    \XINT@addp@CC\the\numexpr 1+10#1\relax
}%
\def\XINT@addp@CC #1#2#3#4#5#6#7%
{%
    \XINT@addp@AC@checkcarry  #2{#7#6#5#4#3}%
}%
\def\xint@addp@cw 
    #1\xint@addp@cx
    #2\xint@addp@cy
    #3\xint@addp@cz
    \W\XINT@addp@CD 
{\expandafter
    \XINT@addp@CDw\the\numexpr 1+10#1#2#3\relax
}%
\def\XINT@addp@CDw #1#2#3#4#5#6%  
{%
    \xint@quatrezeros #2#3#4#5\XINT@addp@endDw@zeros 
                          0000\XINT@addp@endDw #2#3#4#5%
}%
\def\XINT@addp@endDw@zeros 0000\XINT@addp@endDw 0000#1\X\Y\Z{ #1}%
\def\XINT@addp@endDw #1#2#3#4#5\X\Y\Z{ #5#4#3#2#1}%
\def\xint@addp@cx 
    #1\xint@addp@cy
    #2\xint@addp@cz
    \W\XINT@addp@CD 
{\expandafter
    \XINT@addp@CDx\the\numexpr 1+100#1#2\relax
}%
\def\XINT@addp@CDx #1#2#3#4#5#6%  
{%
    \xint@quatrezeros #2#3#4#5\XINT@addp@endDx@zeros
                          0000\XINT@addp@endDx #2#3#4#5%
}%
\def\XINT@addp@endDx@zeros 0000\XINT@addp@endDx 0000#1\Y\Z{ #1}%
\def\XINT@addp@endDx #1#2#3#4#5\Y\Z{ #5#4#3#2#1}%
\def\xint@addp@cy 
    #1\xint@addp@cz
    \W\XINT@addp@CD 
{\expandafter
    \XINT@addp@CDy\the\numexpr 1+1000#1\relax
}%
\def\XINT@addp@CDy #1#2#3#4#5#6%  
{%
    \xint@quatrezeros #2#3#4#5\XINT@addp@endDy@zeros
                          0000\XINT@addp@endDy #2#3#4#5%
}%
\def\XINT@addp@endDy@zeros 0000\XINT@addp@endDy 0000#1\Z{ #1}%
\def\XINT@addp@endDy #1#2#3#4#5\Z{ #5#4#3#2#1}%
\def\xint@addp@cz\W\XINT@addp@CD #1#2{ #21000}%
\def\XINT@addp@F #1#2#3#4#5%  
{%
    \xint@w 
    #5\xint@addp@Gw
    #4\xint@addp@Gx 
    #3\xint@addp@Gy 
    #2\xint@addp@Gz 
    \W\XINT@addp@G   {#2#3#4#5}{#1}%
}%
\def\XINT@addp@G #1#2%
{%
    \XINT@addp@F {#2#1}%
}%
\def\xint@addp@Gw 
    #1\xint@addp@Gx
    #2\xint@addp@Gy
    #3\xint@addp@Gz
    \W\XINT@addp@G #4%
{%
    \xint@quatrezeros  #3#2#10\XINT@addp@endGw@zeros 
                          0000\XINT@addp@endGw #3#2#10%
}%
\def\XINT@addp@endGw@zeros 0000\XINT@addp@endGw 0000#1\X\Y\Z{ #1}%
\def\XINT@addp@endGw #1#2#3#4#5\X\Y\Z{ #5#1#2#3#4}%
\def\xint@addp@Gx
    #1\xint@addp@Gy
    #2\xint@addp@Gz
    \W\XINT@addp@G #3%
{%
    \xint@quatrezeros  #2#100\XINT@addp@endGx@zeros 
                         0000\XINT@addp@endGx #2#100%
}%
\def\XINT@addp@endGx@zeros 0000\XINT@addp@endGx 0000#1\Y\Z{ #1}%
\def\XINT@addp@endGx #1#2#3#4#5\Y\Z{ #5#1#2#3#4}%
\def\xint@addp@Gy
    #1\xint@addp@Gz
    \W\XINT@addp@G #2%
{%
    \xint@quatrezeros   #1000\XINT@addp@endGy@zeros 
                         0000\XINT@addp@endGy #1000%
}%
\def\XINT@addp@endGy@zeros 0000\XINT@addp@endGy 0000#1\Z{ #1}%
\def\XINT@addp@endGy #1#2#3#4#5\Z{ #5#1#2#3#4}%
\def\xint@addp@Gz\W\XINT@addp@G #1#2{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintAdd}}
%    \begin{macrocode}
\def\xintiAdd {\romannumeral0\xintiadd }%
\def\xintiadd #1%
{%
    \expandafter\expandafter\expandafter
           \xint@add
    \expandafter\expandafter\expandafter
           {#1}%
}%
\let\xintAdd\xintiAdd \let\xintadd\xintiadd
\def\xint@add #1#2%
{%
    \expandafter\expandafter\expandafter
    \XINT@add@fork #2\Z #1\Z 
}%
\def\XINT@Add #1#2{\romannumeral0\XINT@add@fork #2\Z #1\Z }%
\def\XINT@add #1#2{\XINT@add@fork #2\Z #1\Z }%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
%    ADDITION 
% Ici #1#2 vient du *deuxième* argument de \xintAdd
% et  #3#4 donc du *premier* [algo plus efficace lorsque
% le premier est plus long que le second]
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@add@fork #1#2\Z #3#4\Z
{%
    \xint@UDzerofork
      #1\dummy \XINT@add@secondiszero
      #3\dummy \XINT@add@firstiszero
       0\dummy 
        {\xint@UDsignsfork
          #1#3\dummy \XINT@add@minusminus          % #1 = #3 = -
           #1-\dummy \XINT@add@minusplus           % #1 = -
           #3-\dummy \XINT@add@plusminus           % #3 = -
            --\dummy \XINT@add@plusplus
         \xint@UDkrof }%
    \xint@UDkrof
    {#2}{#4}#1#3%
}%
\def\XINT@add@secondiszero #1#2#3#4{ #4#2}%
\def\XINT@add@firstiszero #1#2#3#4{ #3#1}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1 vient du *deuxième* et #2 vient du *premier*
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@add@minusminus #1#2#3#4%
{%
    \expandafter\space\expandafter-%
    \romannumeral0\XINT@add@pre {#2}{#1}%
}%
\def\XINT@add@minusplus #1#2#3#4%
{%
    \XINT@sub@pre {#4#2}{#1}%
}%
\def\XINT@add@plusminus #1#2#3#4%
{%
    \XINT@sub@pre {#3#1}{#2}%
}%
\def\XINT@add@plusplus #1#2#3#4%
{%
    \XINT@add@pre {#4#2}{#3#1}%
}%
\def\XINT@add@pre #1%
{%
  \expandafter\XINT@add@@pre\expandafter{%
  \romannumeral0\XINT@RQ {}#1\R\R\R\R\R\R\R\R\Z
  }%
}%
\def\XINT@add@@pre #1#2%
{% 
    \expandafter\XINT@add@A
        \expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT@RQ {}#2\R\R\R\R\R\R\R\R\Z
        \W\X\Y\Z #1\W\X\Y\Z
}%
%    \end{macrocode}
% \subsection{\csh{xintSub}}
%    \begin{macrocode}
\def\xintiSub {\romannumeral0\xintisub }%
\def\xintisub #1%
{%
    \expandafter\expandafter\expandafter
           \xint@sub
    \expandafter\expandafter\expandafter
           {#1}%
}%
\let\xintSub\xintiSub \let\xintsub\xintisub
\def\xint@sub #1#2%
{%
    \expandafter\expandafter\expandafter
    \XINT@sub@fork #2\Z #1\Z 
}%
\def\XINT@Sub #1#2{\romannumeral0\XINT@sub@fork #2\Z #1\Z }%
\def\XINT@sub #1#2{\XINT@sub@fork #2\Z #1\Z }%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% SOUSTRACTION
% #3#4-#1#2
% #3#4 vient du *premier*
% #1#2 vient du *second*
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@sub@fork #1#2\Z #3#4\Z
{%
    \xint@UDsignsfork
          #1#3\dummy \XINT@sub@minusminus
           #1-\dummy \XINT@sub@minusplus   % attention, #3=0 possible
           #3-\dummy \XINT@sub@plusminus   % attention, #1=0 possible
            --\dummy {\xint@UDzerofork
                      #1\dummy \XINT@sub@secondiszero
                      #3\dummy \XINT@sub@firstiszero
                       0\dummy \XINT@sub@plusplus
                      \xint@UDkrof }%
    \xint@UDkrof
    {#2}{#4}#1#3%
}%
\def\XINT@sub@secondiszero #1#2#3#4{ #4#2}%
\def\XINT@sub@firstiszero  #1#2#3#4{ -#3#1}%
\def\XINT@sub@plusplus #1#2#3#4%
{%
    \XINT@sub@pre {#4#2}{#3#1}%
}%
\def\XINT@sub@minusminus #1#2#3#4%
{%
    \XINT@sub@pre {#1}{#2}%
}%
\def\XINT@sub@minusplus #1#2#3#4% 
{%
    \xint@zero #4\xint@sub@mp0\XINT@add@pre {#4#2}{#1}%
}%
\def\xint@sub@mp0\XINT@add@pre #1#2{ #2}%
\def\XINT@sub@plusminus #1#2#3#4% 
{%
    \xint@zero #3\xint@sub@pm0\expandafter\space\expandafter-%
    \romannumeral0\XINT@add@pre {#2}{#3#1}%
}%
\def\xint@sub@pm #1\XINT@add@pre #2#3{ -#2}%
\def\XINT@sub@pre #1%
{%
  \expandafter\XINT@sub@@pre\expandafter{%
  \romannumeral0\XINT@RQ {}#1\R\R\R\R\R\R\R\R\Z
  }%
}%
\def\XINT@sub@@pre #1#2%
{% 
    \expandafter\XINT@sub@A
        \expandafter1\expandafter{\expandafter}%
    \romannumeral0\XINT@RQ {}#2\R\R\R\R\R\R\R\R\Z
        \W\X\Y\Z #1 \W\X\Y\Z
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% \romannumeral0\XINT@sub@A 1{}<N1>\W\X\Y\Z<N2>\W\X\Y\Z
% N1 et N2 sont présentés à l'envers ET ON A RAJOUTÉ DES ZÉROS
% POUR QUE LEURS LONGUEURS À CHACUN SOIENT MULTIPLES DE 4, MAIS
% AUCUN NE SE TERMINE EN 0000
% output: N2 - N1
% Elle donne le résultat dans le **bon ordre**, avec le bon signe,
% et sans zéros superflus.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@sub@A #1#2#3\W\X\Y\Z #4#5#6#7%  
{%
    \xint@w 
    #4\xint@sub@az 
    \W\XINT@sub@B #1{#4#5#6#7}{#2}#3\W\X\Y\Z 
}%
\def\XINT@sub@B #1#2#3#4#5#6#7%  
{%
    \xint@w 
    #4\xint@sub@bz 
    \W\XINT@sub@onestep #1#2{#7#6#5#4}{#3}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% d'abord la branche principale
% #6 = 4 chiffres de N1, plus significatif en *premier*, 
% #2#3#4#5 chiffres de N2, plus significatif en *dernier*
% On veut N2 - N1.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@sub@onestep #1#2#3#4#5#6%
{\expandafter
    \XINT@sub@backtoA\the\numexpr 11#5#4#3#2-#6+#1-1\relax.%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% ON PRODUIT LE RÉSULTAT DANS LE BON ORDRE
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@sub@backtoA #1#2#3.#4%
{%
    \XINT@sub@A #2{#3#4}%
}%
\def\xint@sub@bz 
    \W\XINT@sub@onestep #1#2#3#4#5#6#7%
{%
    \xint@UDzerofork
      #1\dummy  \XINT@sub@C   % une retenue
       0\dummy  \XINT@sub@D   % pas de retenue
    \xint@UDkrof
    {#7}#2#3#4#5%
}%
\def\XINT@sub@D #1#2\W\X\Y\Z
{%
    \expandafter
    \xint@cleanupzeros@andstop
    \romannumeral0%
    \XINT@rord@main {}#2%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
    #1%
}%
\def\XINT@sub@C #1#2#3#4#5%
{%
    \xint@w 
    #2\xint@sub@cz 
    \W\XINT@sub@AC@onestep {#5#4#3#2}{#1}%
}%
\def\XINT@sub@AC@onestep #1%
{\expandafter
    \XINT@sub@backtoC\the\numexpr 11#1-1\relax.%
}%
\def\XINT@sub@backtoC #1#2#3.#4%
{%
    \XINT@sub@AC@checkcarry #2{#3#4}% la retenue va \^etre examin\'ee
}%
\def\XINT@sub@AC@checkcarry #1%
{%
    \xint@one #1\xint@sub@AC@nocarry 1\XINT@sub@C 
}%
\def\xint@sub@AC@nocarry 1\XINT@sub@C #1#2\W\X\Y\Z
{%
    \expandafter
    \XINT@cuz@loop
    \romannumeral0%
    \XINT@rord@main {}#2%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
    #1\W\W\W\W\W\W\W\Z
}%
\def\xint@sub@cz\W\XINT@sub@AC@onestep #1%
{%
    \XINT@cuz
}%
\def\xint@sub@az\W\XINT@sub@B #1#2#3#4#5#6#7%  
{%
    \xint@w 
    #4\xint@sub@ez 
    \W\XINT@sub@Eenter #1{#3}#4#5#6#7%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% le premier nombre continue, le résultat sera < 0.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@sub@Eenter #1#2%
{%
    \expandafter
    \XINT@sub@E\expandafter1\expandafter{\expandafter}%
    \romannumeral0%
    \XINT@rord@main {}#2%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
    \W\X\Y\Z #1%
}%
\def\XINT@sub@E #1#2#3#4#5#6%
{%
    \xint@w #3\xint@sub@F\W\XINT@sub@Eonestep
    #1{#6#5#4#3}{#2}%
}%
\def\XINT@sub@Eonestep #1#2%
{\expandafter
    \XINT@sub@backtoE\the\numexpr 110000-#2+#1-1\relax.%
}%
\def\XINT@sub@backtoE #1#2#3.#4%
{%
    \XINT@sub@E #2{#3#4}%
}%
\def\xint@sub@F\W\XINT@sub@Eonestep #1#2#3#4%
{%
    \xint@UDonezerofork
      #4#1\dummy {\XINT@sub@Fdec 0}% soustraire  1. Et faire signe -
      #1#4\dummy {\XINT@sub@Finc 1}% additionner 1. Et faire signe -
        10\dummy  \XINT@sub@DD   % terminer. Mais avec signe -
    \xint@UDkrof
    {#3}%
}%
\def\XINT@sub@DD
{\expandafter\space\expandafter-\romannumeral0\XINT@sub@D }%
\def\XINT@sub@Fdec #1#2#3#4#5#6%
{%
    \xint@w 
    #3\xint@sub@Fdec@finish\W\XINT@sub@Fdec@onestep
    #1{#6#5#4#3}{#2}%
}%
\def\XINT@sub@Fdec@onestep #1#2%
{\expandafter
    \XINT@sub@backtoFdec\the\numexpr 11#2+#1-1\relax.%
}%
\def\XINT@sub@backtoFdec #1#2#3.#4%
{%
    \XINT@sub@Fdec #2{#3#4}%
}%
\def\xint@sub@Fdec@finish\W\XINT@sub@Fdec@onestep #1#2%
{%
    \expandafter\space\expandafter-\romannumeral0\XINT@cuz
}%
\def\XINT@sub@Finc #1#2#3#4#5#6%
{%
    \xint@w 
    #3\xint@sub@Finc@finish\W\XINT@sub@Finc@onestep
    #1{#6#5#4#3}{#2}%
}%
\def\XINT@sub@Finc@onestep #1#2%
{\expandafter
    \XINT@sub@backtoFinc\the\numexpr 10#2+#1\relax.%
}%
\def\XINT@sub@backtoFinc #1#2#3.#4%
{%
    \XINT@sub@Finc #2{#3#4}%
}%
\def\xint@sub@Finc@finish\W\XINT@sub@Finc@onestep #1#2#3%
{%
    \xint@UDzerofork
     #1\dummy {\expandafter\space\expandafter-%
               \xint@cleanupzeros@nospace}%
      0\dummy { -1}%
    \xint@UDkrof
    #3%
}%
\def\xint@sub@ez\W\XINT@sub@Eenter #1%
{%
    \xint@UDzerofork
      #1\dummy \XINT@sub@K             %     il y a une retenue
       0\dummy \XINT@sub@L             %     pas de retenue
    \xint@UDkrof
}%
\def\XINT@sub@L #1\W\X\Y\Z 
   {\XINT@cuz@loop #1\W\W\W\W\W\W\W\Z }%
\def\XINT@sub@K #1%
{%
    \expandafter
    \XINT@sub@KK\expandafter1\expandafter{\expandafter}%
    \romannumeral0%
    \XINT@rord@main {}#1%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
}%
\def\XINT@sub@KK #1#2#3#4#5#6%
{%
    \xint@w 
    #3\xint@sub@KK@finish\W\XINT@sub@KK@onestep
    #1{#6#5#4#3}{#2}%
}%
\def\XINT@sub@KK@onestep #1#2%
{\expandafter
    \XINT@sub@backtoKK\the\numexpr 109999-#2+#1\relax.%
}%
\def\XINT@sub@backtoKK #1#2#3.#4%
{%
    \XINT@sub@KK #2{#3#4}%
}%
\def\xint@sub@KK@finish\W\XINT@sub@KK@onestep #1#2#3%
{%
    \expandafter\space\expandafter-\romannumeral
    0\XINT@cuz@loop #3\W\W\W\W\W\W\W\Z
}%
%    \end{macrocode}
% \subsection{\csh{xintCmp}}
%    \begin{macrocode}
\def\xintiCmp {\romannumeral0\xinticmp }%
\def\xinticmp #1%
{%
    \expandafter\expandafter\expandafter
        \xint@cmp
    \expandafter\expandafter\expandafter
        {#1}%
}%
\let\xintCmp\xintiCmp \let\xintcmp\xinticmp
\def\xint@cmp #1#2%
{%
    \expandafter\expandafter\expandafter
    \XINT@cmp@fork #2\Z #1\Z 
}%
\def\XINT@Cmp #1#2{\romannumeral0\XINT@cmp@fork #2\Z #1\Z }%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
%    COMPARAISON 
% 1 si #3#4>#1#2, 0 si #3#4=#1#2, -1 si #3#4<#1#2
% #3#4 vient du *premier*
% #1#2 vient du *second*
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@cmp@fork #1#2\Z #3#4\Z
{%
    \xint@UDsignsfork
          #1#3\dummy \XINT@cmp@minusminus
           #1-\dummy \XINT@cmp@minusplus   
           #3-\dummy \XINT@cmp@plusminus   
            --\dummy {\xint@UDzerosfork
                      #1#3\dummy \XINT@cmp@zerozero
                       #10\dummy \XINT@cmp@zeroplus
                       #30\dummy \XINT@cmp@pluszero
                        00\dummy \XINT@cmp@plusplus
                      \xint@UDkrof }%
    \xint@UDkrof
    {#2}{#4}#1#3%
}%
\def\XINT@cmp@minusplus #1#2#3#4{ 1}%
\def\XINT@cmp@plusminus #1#2#3#4{ -1}%
\def\XINT@cmp@zerozero  #1#2#3#4{ 0}%
\def\XINT@cmp@zeroplus  #1#2#3#4{ 1}%
\def\XINT@cmp@pluszero  #1#2#3#4{ -1}%
\def\XINT@cmp@plusplus #1#2#3#4%
{%
    \XINT@cmp@pre {#4#2}{#3#1}%
}%
\def\XINT@cmp@minusminus #1#2#3#4%
{%
    \XINT@cmp@pre {#1}{#2}%
}%
\def\XINT@cmp@pre #1%
{%
  \expandafter\XINT@cmp@@pre\expandafter{%
  \romannumeral0\XINT@RQ {}#1\R\R\R\R\R\R\R\R\Z
  }%
}%
\def\XINT@cmp@@pre #1#2%
{% 
    \expandafter\XINT@cmp@A
    \expandafter1\expandafter{\expandafter}%
    \romannumeral0\XINT@RQ {}#2\R\R\R\R\R\R\R\R\Z
        \W\X\Y\Z #1\W\X\Y\Z
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% COMPARAISON
% N1 et N2 sont présentés à l'envers ET ON A RAJOUTÉ DES ZÉROS
% POUR QUE LEURS LONGUEURS À CHACUN SOIENT MULTIPLES DE 4, MAIS
% AUCUN NE SE TERMINE EN 0000
% routine appelée via \XINT@cmp@A 1{}<N1>\W\X\Y\Z<N2>\W\X\Y\Z
% ATTENTION RENVOIE 1 SI N1 < N2, 0 si N1 = N2, -1 si N1 > N2
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@cmp@A #1#2#3\W\X\Y\Z #4#5#6#7%  
{%
    \xint@w 
    #4\xint@cmp@az 
    \W\XINT@cmp@B #1{#4#5#6#7}{#2}#3\W\X\Y\Z 
}%
\def\XINT@cmp@B #1#2#3#4#5#6#7%  
{%
    \xint@w 
    #4\xint@cmp@bz 
    \W\XINT@cmp@onestep #1#2{#7#6#5#4}{#3}%
}%
\def\XINT@cmp@onestep #1#2#3#4#5#6%
{\expandafter
    \XINT@cmp@backtoA\the\numexpr 11#5#4#3#2-#6+#1-1\relax.%
}%
\def\XINT@cmp@backtoA #1#2#3.#4%
{%
    \XINT@cmp@A #2{#3#4}%
}%
\def\xint@cmp@bz 
    \W\XINT@cmp@onestep #1\Z { 1}%
\def\xint@cmp@az\W\XINT@cmp@B #1#2#3#4#5#6#7%  
{%
    \xint@w 
    #4\xint@cmp@ez 
    \W\XINT@cmp@Eenter #1{#3}#4#5#6#7%
}%
\def\XINT@cmp@Eenter #1\Z { -1}%
\def\xint@cmp@ez\W\XINT@cmp@Eenter #1%
{%
    \xint@UDzerofork
      #1\dummy \XINT@cmp@K             %     il y a une retenue
       0\dummy \XINT@cmp@L             %     pas de retenue
    \xint@UDkrof
}%
\def\XINT@cmp@K #1\Z { -1}%
\def\XINT@cmp@L #1{\XINT@OneIfPositive@main #1}%
\def\XINT@OneIfPositive #1%
{%
    \XINT@OneIfPositive@main #1\W\X\Y\Z%
}%
\def\XINT@OneIfPositive@main #1#2#3#4%
{%
    \xint@z #4\xint@OneIfPositive@terminated\Z\XINT@OneIfPositive@onestep
    #1#2#3#4%
}%
\def\xint@OneIfPositive@terminated\Z\XINT@OneIfPositive@onestep\W\X\Y\Z { 0}%
\def\XINT@OneIfPositive@onestep #1#2#3#4%
{%
    \expandafter
    \XINT@OneIfPositive@check
    \the\numexpr #1#2#3#4\relax
}%
\def\XINT@OneIfPositive@check #1%
{%
    \xint@zero
    #1\xint@OneIfPositive@backtomain 0\XINT@OneIfPositive@finish #1%
}%
\def\XINT@OneIfPositive@finish #1\W\X\Y\Z{ 1}%
\def\xint@OneIfPositive@backtomain 0\XINT@OneIfPositive@finish 0%
                   {\XINT@OneIfPositive@main }%
%    \end{macrocode}
% \subsection{\csh{xintGeq}}
% \begin{verbatim}
%    PLUS GRAND OU ÉGAL
% attention compare les **valeurs absolues**
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintGeq {\romannumeral0\xintgeq }%
\def\xintgeq #1%
{%
    \expandafter\expandafter\expandafter
      \xint@geq
    \expandafter\expandafter\expandafter
      {#1}%
}%
\def\xint@geq #1#2%
{\expandafter\expandafter\expandafter
       \XINT@geq@fork #2\Z #1\Z 
}%
\def\XINT@Geq #1#2{\romannumeral0\XINT@geq@fork #2\Z #1\Z }%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
%    PLUS GRAND OU ÉGAL 
% ATTENTION, TESTE les VALEURS ABSOLUES
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@geq@fork #1#2\Z #3#4\Z
{%
    \xint@UDzerofork
      #1\dummy \XINT@geq@secondiszero % |#1#2|=0
      #3\dummy \XINT@geq@firstiszero % |#1#2|>0
       0\dummy {\xint@UDsignsfork
                  #1#3\dummy \XINT@geq@minusminus
                   #1-\dummy \XINT@geq@minusplus   
                   #3-\dummy \XINT@geq@plusminus
                    --\dummy \XINT@geq@plusplus
                \xint@UDkrof }%
    \xint@UDkrof
    {#2}{#4}#1#3%
}%
\def\XINT@geq@secondiszero     #1#2#3#4{ 1}%
\def\XINT@geq@firstiszero      #1#2#3#4{ 0}%
\def\XINT@geq@plusplus  #1#2#3#4%
         {\XINT@geq@pre {#4#2}{#3#1}}%
\def\XINT@geq@minusminus  #1#2#3#4%
         {\XINT@geq@pre {#2}{#1}}%
\def\XINT@geq@minusplus #1#2#3#4%
         {\XINT@geq@pre {#4#2}{#1}}%
\def\XINT@geq@plusminus #1#2#3#4%
         {\XINT@geq@pre {#2}{#3#1}}%
\def\XINT@geq@pre #1%
{%
  \expandafter\XINT@geq@@pre\expandafter{%
  \romannumeral0\XINT@RQ {}#1\R\R\R\R\R\R\R\R\Z
  }%
}%
\def\XINT@geq@@pre #1#2%
{% 
    \expandafter\XINT@geq@A
    \expandafter1\expandafter{\expandafter}%
    \romannumeral0\XINT@RQ {}#2\R\R\R\R\R\R\R\R\Z
        \W\X\Y\Z #1 \W\X\Y\Z
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% PLUS GRAND OU ÉGAL
% N1 et N2 sont présentés à l'envers ET ON A RAJOUTÉ DES ZÉROS
% POUR QUE LEURS LONGUEURS À CHACUN SOIENT MULTIPLES DE 4, MAIS
% AUCUN NE SE TERMINE EN 0000
% routine appelée via 
% \romannumeral0\XINT@geq@A 1{}<N1>\W\X\Y\Z<N2>\W\X\Y\Z
% ATTENTION RENVOIE 1 SI N1 < N2 ou N1 = N2 et 0 si N1 > N2
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@geq@A #1#2#3\W\X\Y\Z #4#5#6#7%  
{%
    \xint@w 
    #4\xint@geq@az 
    \W\XINT@geq@B #1{#4#5#6#7}{#2}#3\W\X\Y\Z 
}%
\def\XINT@geq@B #1#2#3#4#5#6#7%  
{%
    \xint@w 
    #4\xint@geq@bz 
    \W\XINT@geq@onestep #1#2{#7#6#5#4}{#3}%
}%
\def\XINT@geq@onestep #1#2#3#4#5#6%
{\expandafter
    \XINT@geq@backtoA\the\numexpr 11#5#4#3#2-#6+#1-1\relax.%
}%
\def\XINT@geq@backtoA #1#2#3.#4%
{%
    \XINT@geq@A #2{#3#4}%
}%
\def\xint@geq@bz\W\XINT@geq@onestep #1\W\X\Y\Z { 1}%
\def\xint@geq@az\W\XINT@geq@B #1#2#3#4#5#6#7%  
{%
    \xint@w 
    #4\xint@geq@ez 
    \W\XINT@geq@Eenter #1%
}%
\def\XINT@geq@Eenter #1\W\X\Y\Z { 0}%
\def\xint@geq@ez\W\XINT@geq@Eenter #1%
{%
    \xint@UDzerofork
      #1\dummy { 0}             %     il y a une retenue
       0\dummy { 1}             %     pas de retenue
    \xint@UDkrof
}%
%    \end{macrocode}
% \subsection{\csh{xintMax}}
% \begin{verbatim}
% The rationale is that it is more efficient than using \xintCmp.
% 1.03 makes the code a tiny bit slower but easier to re-use for fractions. 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintiMax {\romannumeral0\xintimax }%
\def\xintimax #1%
{%
    \expandafter\expandafter\expandafter
        \xint@max
    \expandafter\expandafter\expandafter
        {#1}%
}%
\let\xintMax\xintiMax \let\xintmax\xintimax
\def\xint@max #1#2%
{%
    \expandafter\expandafter\expandafter
    \XINT@max@pre
    \expandafter\expandafter\expandafter {#2}{#1}%
}%
\def\XINT@max@pre #1#2{\XINT@max@fork #1\Z #2\Z {#2}{#1}}%
\def\XINT@Max #1#2{\romannumeral0\XINT@max@fork #2\Z #1\Z {#1}{#2}}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #3#4 vient du *premier*
% #1#2 vient du *second*
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@max@fork #1#2\Z #3#4\Z
{%
    \xint@UDsignsfork
          #1#3\dummy \XINT@max@minusminus  % A < 0, B < 0
           #1-\dummy \XINT@max@minusplus   % B < 0, A >= 0   
           #3-\dummy \XINT@max@plusminus   % A < 0, B >= 0 
            --\dummy {\xint@UDzerosfork
                      #1#3\dummy \XINT@max@zerozero % A = B = 0
                       #10\dummy \XINT@max@zeroplus % B = 0, A > 0
                       #30\dummy \XINT@max@pluszero % A = 0, B > 0
                        00\dummy \XINT@max@plusplus % A, B > 0
                      \xint@UDkrof }%
    \xint@UDkrof
    {#2}{#4}#1#3%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% A = #4#2, B = #3#1
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@max@zerozero  #1#2#3#4{\xint@firstoftwo@andstop }%
\def\XINT@max@zeroplus  #1#2#3#4{\xint@firstoftwo@andstop }%
\def\XINT@max@pluszero  #1#2#3#4{\xint@secondoftwo@andstop }%
\def\XINT@max@minusplus #1#2#3#4{\xint@firstoftwo@andstop }%
\def\XINT@max@plusminus #1#2#3#4{\xint@secondoftwo@andstop }%
\def\XINT@max@plusplus  #1#2#3#4%
{%
    \ifodd\XINT@Geq {#4#2}{#3#1}
      \expandafter\xint@firstoftwo@andstop
    \else
      \expandafter\xint@secondoftwo@andstop
    \fi
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #3=-, #4=-, #1 = |B| = -B, #2 = |A| = -A
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@max@minusminus #1#2#3#4%
{%
    \ifodd\XINT@Geq {#1}{#2}
      \expandafter\xint@firstoftwo@andstop
    \else
      \expandafter\xint@secondoftwo@andstop
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintMin}}
%    \begin{macrocode}
\def\xintiMin {\romannumeral0\xintimin }%
\def\xintimin #1%
{%
    \expandafter\expandafter\expandafter
        \xint@min
    \expandafter\expandafter\expandafter
        {#1}%
}%
\let\xintMin\xintiMin \let\xintmin\xintimin
\def\xint@min #1#2%
{%
    \expandafter\expandafter\expandafter
    \XINT@min@pre
    \expandafter\expandafter\expandafter {#2}{#1}%
}%
\def\XINT@min@pre #1#2{\XINT@min@fork #1\Z #2\Z {#2}{#1}}%
\def\XINT@Min #1#2{\romannumeral0\XINT@min@fork #2\Z #1\Z {#1}{#2}}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #3#4 vient du *premier*
% #1#2 vient du *second*
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@min@fork #1#2\Z #3#4\Z
{%
    \xint@UDsignsfork
          #1#3\dummy \XINT@min@minusminus  % A < 0, B < 0
           #1-\dummy \XINT@min@minusplus   % B < 0, A >= 0   
           #3-\dummy \XINT@min@plusminus   % A < 0, B >= 0 
            --\dummy {\xint@UDzerosfork
                      #1#3\dummy \XINT@min@zerozero % A = B = 0
                       #10\dummy \XINT@min@zeroplus % B = 0, A > 0
                       #30\dummy \XINT@min@pluszero % A = 0, B > 0
                        00\dummy \XINT@min@plusplus % A, B > 0
                      \xint@UDkrof }%
    \xint@UDkrof
    {#2}{#4}#1#3%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% A = #4#2, B = #3#1
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@min@zerozero  #1#2#3#4{\xint@firstoftwo@andstop }%
\def\XINT@min@zeroplus  #1#2#3#4{\xint@secondoftwo@andstop }%
\def\XINT@min@pluszero  #1#2#3#4{\xint@firstoftwo@andstop }%
\def\XINT@min@minusplus #1#2#3#4{\xint@secondoftwo@andstop }%
\def\XINT@min@plusminus #1#2#3#4{\xint@firstoftwo@andstop }%
\def\XINT@min@plusplus #1#2#3#4%
{%
    \ifodd\XINT@Geq {#4#2}{#3#1}
      \expandafter\xint@secondoftwo@andstop
    \else
      \expandafter\xint@firstoftwo@andstop
    \fi
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #3=-, #4=-, #1 = |B| = -B, #2 = |A| = -A
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@min@minusminus #1#2#3#4%
{%
    \ifodd\XINT@Geq {#1}{#2}
      \expandafter\xint@secondoftwo@andstop
    \else
      \expandafter\xint@firstoftwo@andstop
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintSum}, \csh{xintSumExpr}}
% \begin{verbatim}
% \xintSum {{a}{b}...{z}}
% \xintSumExpr {a}{b}...{z}\relax
% 1.03 (drastically) simplifies and makes the routines more efficient (for big
% computations). Also the way \xintSum and \xintSumExpr ...\relax are related.
% has been modified. Now \xintSumExpr \z \relax is accepted input when
% \z expands to a list of braced terms (prior only \xintSum {\z} or \xintSum \z
% was possible).  
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintiSum {\romannumeral0\xintisum }%
\def\xintisum #1{\xintisumexpr #1\relax }%
\def\xintiSumExpr {\romannumeral0\xintisumexpr }%
\def\xintisumexpr
{%
    \expandafter\expandafter\expandafter\XINT@sumexpr
}%
\let\xintSum\xintiSum \let\xintsum\xintisum 
\let\xintSumExpr\xintiSumExpr \let\xintsumexpr\xintisumexpr
\def\XINT@sumexpr {\XINT@sum@loop {0000}{0000}}%
\def\XINT@sum@loop #1#2#3%
{%
    \xint@relax #3\XINT@sum@finished\relax
    \expandafter\expandafter\expandafter
    \XINT@sum@checksign #3\Z {#1}{#2}%
}%
\def\XINT@sum@checksign #1%
{%
    \xint@zero #1\XINT@sum@skipzeroinput0%
    \xint@UDsignfork
      #1\dummy \XINT@sum@N
       -\dummy {\XINT@sum@P #1}%
    \xint@UDkrof
}%
\def\XINT@sum@skipzeroinput #1\xint@UDkrof #2\Z {\XINT@sum@loop }%
\def\XINT@sum@P #1\Z #2%
{%
    \expandafter\XINT@sum@loop\expandafter
    {\romannumeral0\expandafter
     \XINT@addr@A\expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT@RQ {}#1\R\R\R\R\R\R\R\R\Z
    \W\X\Y\Z #2\W\X\Y\Z }%
}%
\def\XINT@sum@N #1\Z #2#3%
{%
    \expandafter\XINT@sum@NN\expandafter
    {\romannumeral0\expandafter
     \XINT@addr@A\expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT@RQ {}#1\R\R\R\R\R\R\R\R\Z
    \W\X\Y\Z #3\W\X\Y\Z }{#2}%
}%
\def\XINT@sum@NN #1#2{\XINT@sum@loop {#2}{#1}}%
\def\XINT@sum@finished #1\Z #2#3%
{%
    \XINT@sub@A 1{}#3\W\X\Y\Z #2\W\X\Y\Z
}%
%    \end{macrocode}
% \subsection{\csh{xintMul}}
%    \begin{macrocode}
\def\xintiMul {\romannumeral0\xintimul }%
\def\xintimul #1%
{%
    \expandafter\expandafter\expandafter
        \xint@mul
    \expandafter\expandafter\expandafter
        {#1}%
}%
\let\xintMul\xintiMul \let\xintmul\xintimul
\def\xint@mul #1#2%
{\expandafter\expandafter\expandafter
       \XINT@mul@fork #2\Z #1\Z 
}%
\def\XINT@Mul #1#2{\romannumeral0\XINT@mul@fork #2\Z #1\Z }%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
%   MULTIPLICATION
% Ici #1#2 = 2e input et #3#4 = 1er input 
% Release 1.03 adds some overhead to first compute and compare the
% lengths of the two inputs. The algorithm is asymmetrical and whether
% the first input is the longest or the shortest sometimes has a strong
% impact. 50 digits times 1000 digits used to be 5 times faster
% than 1000 digits times 50 digits. With the new code, the user input
% order does not matter as it is decided by the routine what is best.
% This is important for  the extension to fractions, as there is no way
% then to generally control or guess the most frequent sizes of the
% inputs besides actually computing their lengths.  
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@mul@fork #1#2\Z #3#4\Z
{%
    \xint@UDzerofork
      #1\dummy \XINT@mul@zero
      #3\dummy \XINT@mul@zero
       0\dummy 
        {\xint@UDsignsfork
          #1#3\dummy \XINT@mul@minusminus          % #1 = #3 = -
           #1-\dummy {\XINT@mul@minusplus #3}%          % #1 = -
           #3-\dummy {\XINT@mul@plusminus #1}%          % #3 = -
            --\dummy {\XINT@mul@plusplus #1#3}%
         \xint@UDkrof }%
    \xint@UDkrof
    {#2}{#4}%
}%
\def\XINT@mul@zero #1#2{ 0}%
\def\XINT@mul@minusminus #1#2%
{%
      \expandafter\XINT@mul@choice@a
      \expandafter{\romannumeral0\XINT@length {#2}}%
      {\romannumeral0\XINT@length {#1}}{#1}{#2}%
}%
\def\XINT@mul@minusplus #1#2#3%
{%
      \expandafter\space\expandafter-\romannumeral0\expandafter
      \XINT@mul@choice@a
      \expandafter{\romannumeral0\XINT@length {#1#3}}%
      {\romannumeral0\XINT@length {#2}}{#2}{#1#3}%
}%
\def\XINT@mul@plusminus #1#2#3%
{%
      \expandafter\space\expandafter-\romannumeral0\expandafter
      \XINT@mul@choice@a
      \expandafter{\romannumeral0\XINT@length {#3}}%
      {\romannumeral0\XINT@length {#1#2}}{#1#2}{#3}%
}%
\def\XINT@mul@plusplus #1#2#3#4%
{%
      \expandafter\XINT@mul@choice@a
      \expandafter{\romannumeral0\XINT@length {#2#4}}%
      {\romannumeral0\XINT@length {#1#3}}{#1#3}{#2#4}%
}%
\def\XINT@mul@choice@a #1#2%
{%
      \expandafter\XINT@mul@choice@b \expandafter{#2}{#1}%
}%
\def\XINT@mul@choice@b #1#2%
{%
    \ifnum #1<5
       \expandafter\XINT@mul@choice@littlebyfirst
    \else
    \ifnum #2<5
      \expandafter\expandafter\expandafter
                  \XINT@mul@choice@littlebysecond
      \else
      \expandafter\expandafter\expandafter
                  \XINT@mul@choice@compare
      \fi
    \fi      
    {#1}{#2}%
}%
\def\XINT@mul@choice@littlebyfirst #1#2#3#4%
{%
    \expandafter\XINT@mul@M
    \expandafter{\the\numexpr #3\expandafter}%
    \romannumeral0\XINT@RQ {}#4\R\R\R\R\R\R\R\R\Z \Z\Z\Z\Z
}%
\def\XINT@mul@choice@littlebysecond #1#2#3#4%
{%
    \expandafter\XINT@mul@M
    \expandafter{\the\numexpr #4\expandafter}%
    \romannumeral0\XINT@RQ {}#3\R\R\R\R\R\R\R\R\Z \Z\Z\Z\Z
}%
\def\XINT@mul@choice@compare #1#2%
{%
    \ifnum #1>#2
        \expandafter \XINT@mul@choice@i
    \else
        \expandafter \XINT@mul@choice@ii
    \fi
    {#1}{#2}%
}%
\def\XINT@mul@choice@i #1#2%
{%
   \ifcase \numexpr (#2-3)/4\relax
   \or \xint@afterfi {\ifnum #1<330 \expandafter \XINT@mul@choice@same
                      \else  \expandafter \XINT@mul@choice@permute \fi}%  
   \or \xint@afterfi {\ifnum #1<168 \expandafter \XINT@mul@choice@same
                      \else  \expandafter \XINT@mul@choice@permute \fi}%  
   \or \xint@afterfi {\ifnum #1<109 \expandafter \XINT@mul@choice@same
                      \else  \expandafter \XINT@mul@choice@permute \fi}%  
   \or \xint@afterfi {\ifnum #1<80 \expandafter \XINT@mul@choice@same
                      \else  \expandafter \XINT@mul@choice@permute \fi}%  
   \or \xint@afterfi {\ifnum #1<66 \expandafter \XINT@mul@choice@same
                      \else  \expandafter \XINT@mul@choice@permute \fi}%  
   \or \xint@afterfi {\ifnum #1<52 \expandafter \XINT@mul@choice@same
                      \else  \expandafter \XINT@mul@choice@permute \fi}%  
   \else \expandafter \XINT@mul@choice@permute
   \fi
}% 
\def\XINT@mul@choice@ii #1#2%
{%
   \ifcase \numexpr (#1-3)/4\relax
   \or \xint@afterfi {\ifnum #2<330 \expandafter \XINT@mul@choice@permute
                      \else  \expandafter \XINT@mul@choice@same \fi}%  
   \or \xint@afterfi {\ifnum #2<168 \expandafter \XINT@mul@choice@permute
                      \else  \expandafter \XINT@mul@choice@same \fi}%  
   \or \xint@afterfi {\ifnum #2<109 \expandafter \XINT@mul@choice@permute
                      \else  \expandafter \XINT@mul@choice@same \fi}%  
   \or \xint@afterfi {\ifnum #2<80 \expandafter \XINT@mul@choice@permute
                      \else  \expandafter \XINT@mul@choice@same \fi}%  
   \or \xint@afterfi {\ifnum #2<66 \expandafter \XINT@mul@choice@permute
                      \else  \expandafter \XINT@mul@choice@same \fi}%  
   \or \xint@afterfi {\ifnum #2<52 \expandafter \XINT@mul@choice@permute
                      \else  \expandafter \XINT@mul@choice@same \fi}%  
   \else \expandafter \XINT@mul@choice@same
   \fi
}% 
\def\XINT@mul@choice@same #1#2%
{%
      \expandafter
          \XINT@mul@enter\romannumeral0%
          \XINT@RQ {}#1\R\R\R\R\R\R\R\R\Z
          \W\X\Y\Z #2\W\X\Y\Z 
}%
\def\XINT@mul@choice@permute #1#2%
{%
      \expandafter
          \XINT@mul@enter\romannumeral0%
          \XINT@RQ {}#2\R\R\R\R\R\R\R\R\Z
          \W\X\Y\Z #1\W\X\Y\Z 
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Cette portion de routine d'addition se branche directement sur @addr@ lorsque
% le premier nombre est épuisé, ce qui est garanti arriver avant le second
% nombre. Elle produit son résultat toujours sur 4n, renversé. Ses deux inputs
% sont garantis sur 4n.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@mul@Ar #1#2#3#4#5#6%  
{%
    \xint@z #6\xint@mul@br\Z\XINT@mul@Br #1{#6#5#4#3}{#2}% 
}%
\def\xint@mul@br\Z\XINT@mul@Br #1#2%  
{%
     \XINT@addr@AC@checkcarry #1%
}%
\def\XINT@mul@Br #1#2#3#4\W\X\Y\Z #5#6#7#8%
{\expandafter
    \XINT@mul@ABEAr\the\numexpr #1+10#2+#8#7#6#5\relax.{#3}#4\W\X\Y\Z
}%
\def\XINT@mul@ABEAr #1#2#3#4#5#6.#7%
{%
    \XINT@mul@Ar #2{#7#6#5#4#3}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% << Petite >> multiplication.
% mul@Mr renvoie le résultat *à l'envers*, sur *4n*
% \romannumeral0\XINT@mul@Mr {<n>}<N>\Z\Z\Z\Z
% Fait la multiplication de <N> par <n>, qui est < 10000.
% <N> est présenté *à l'envers*, sur *4n*. Lorsque <n> vaut 0, donne 0000.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@mul@Mr #1%
{%
    \expandafter
    \XINT@mul@Mr@checkifzeroorone
    \expandafter{\the\numexpr #1\relax}%
}%
\def\XINT@mul@Mr@checkifzeroorone #1%
{%
    \ifcase #1
      \expandafter\XINT@mul@Mr@zero
    \or 
      \expandafter\XINT@mul@Mr@one
    \else
      \expandafter\XINT@mul@Nr
    \fi
    {0000}{}{#1}%
}%
\def\XINT@mul@Mr@zero #1\Z\Z\Z\Z { 0000}%
\def\XINT@mul@Mr@one #1#2#3#4\Z\Z\Z\Z { #4}%
\def\XINT@mul@Nr #1#2#3#4#5#6#7%
{% 
    \xint@z #4\xint@mul@pr\Z\XINT@mul@Pr {#1}{#3}{#7#6#5#4}{#2}{#3}%
}%
\def\XINT@mul@Pr #1#2#3%
{\expandafter
    \XINT@mul@Lr\the\numexpr 10000#1+#2*#3\relax 
}%
\def\XINT@mul@Lr 1#1#2#3#4#5#6#7#8#9%
{%
    \XINT@mul@Nr {#1#2#3#4}{#9#8#7#6#5}%
}%
\def\xint@mul@pr\Z\XINT@mul@Pr #1#2#3#4#5%
{%
    \xint@quatrezeros #1\XINT@mul@Mr@end@nocarry 0000\XINT@mul@Mr@end@carry
    #1{#4}%
}%
\def\XINT@mul@Mr@end@nocarry 0000\XINT@mul@Mr@end@carry 0000#1{ #1}%
\def\XINT@mul@Mr@end@carry #1#2#3#4#5{ #5#4#3#2#1}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% << Petite >> multiplication.
%renvoie le résultat *à l'endroit*, avec *nettoyage des leading zéros*.
% \romannumeral0\XINT@mul@M  {<n>}<N>\Z\Z\Z\Z
% Fait la multiplication de <N> par <n>, qui est < 10000.
% <N> est présenté *à l'envers*, sur *4n*. 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@mul@M #1%
{\expandafter
    \XINT@mul@M@checkifzeroorone
    \expandafter{\the\numexpr #1\relax}%
}%
\def\XINT@mul@M@checkifzeroorone #1%
{%
    \ifcase #1
      \expandafter\XINT@mul@M@zero
    \or 
      \expandafter\XINT@mul@M@one
    \else
      \expandafter\XINT@mul@N
    \fi
    {0000}{}{#1}%
}%
\def\XINT@mul@M@zero #1\Z\Z\Z\Z { 0}%
\def\XINT@mul@M@one #1#2#3#4\Z\Z\Z\Z 
{%
    \expandafter
       \xint@cleanupzeros@andstop
    \romannumeral0\XINT@rev{#4}%
}%
\def\XINT@mul@N #1#2#3#4#5#6#7%
{% 
    \xint@z #4\xint@mul@p\Z\XINT@mul@P {#1}{#3}{#7#6#5#4}{#2}{#3}%
}%
\def\XINT@mul@P #1#2#3%
{\expandafter
    \XINT@mul@L\the\numexpr 10000#1+#2*#3\relax 
}%
\def\XINT@mul@L 1#1#2#3#4#5#6#7#8#9%
{%
    \XINT@mul@N {#1#2#3#4}{#5#6#7#8#9}%
}%
\def\xint@mul@p\Z\XINT@mul@P #1#2#3#4#5%
{%
    \XINT@mul@M@end #1#4%
}%
\def\XINT@mul@M@end #1#2#3#4#5#6#7#8%
{\expandafter\space
   \the\numexpr #1#2#3#4#5#6#7#8\relax
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Routine de multiplication principale
% délimiteur \W\X\Y\Z
% Le résultat partiel est toujours maintenu avec significatif à
% droite et il a un nombre multiple de 4 de chiffres
% \romannumeral0\XINT@mul@enter <N1>\W\X\Y\Z <N2>\W\X\Y\Z
% avec <N1> *renversé*, *longueur 4n* (zéros éventuellement ajoutés
% au-delà du chiffre le plus significatif)
% et <N2> dans l'ordre *normal*, et pas forcément longueur 4n.
% pas de signes
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@mul@enter #1\W\X\Y\Z #2#3#4#5%
{% 
    \xint@w
    #5\xint@mul@enterw 
    #4\xint@mul@enterx 
    #3\xint@mul@entery 
    #2\xint@mul@enterz 
    \W\XINT@mul@start {#2#3#4#5}#1\W\X\Y\Z 
}%
\def\xint@mul@enterw 
    #1\xint@mul@enterx 
    #2\xint@mul@entery 
    #3\xint@mul@enterz
    \W\XINT@mul@start  #4#5\W\X\Y\Z \X\Y\Z 
{%
    \XINT@mul@M {#3#2#1}#5\Z\Z\Z\Z 
}%
\def\xint@mul@enterx 
    #1\xint@mul@entery 
    #2\xint@mul@enterz
    \W\XINT@mul@start  #3#4\W\X\Y\Z \Y\Z 
{%
    \XINT@mul@M {#2#1}#4\Z\Z\Z\Z 
}%
\def\xint@mul@entery 
    #1\xint@mul@enterz
    \W\XINT@mul@start  #2#3\W\X\Y\Z \Z 
{%
    \XINT@mul@M {#1}#3\Z\Z\Z\Z 
}%
\def\XINT@mul@start #1#2\W\X\Y\Z 
{\expandafter 
    \XINT@mul@main \expandafter
    {\romannumeral0\XINT@mul@Mr {#1}#2\Z\Z\Z\Z}#2\W\X\Y\Z 
}%
\def\XINT@mul@main #1#2\W\X\Y\Z #3#4#5#6%
{%
    \xint@w 
    #6\xint@mul@mainw
    #5\xint@mul@mainx 
    #4\xint@mul@mainy 
    #3\xint@mul@mainz 
    \W\XINT@mul@compute {#1}{#3#4#5#6}#2\W\X\Y\Z 
}%
\def\XINT@mul@compute #1#2#3\W\X\Y\Z 
{\expandafter 
    \XINT@mul@main \expandafter
           {\romannumeral0\expandafter
    \XINT@mul@Ar \expandafter0\expandafter{\expandafter}%
                 \romannumeral0\XINT@mul@Mr {#2}#3\Z\Z\Z\Z 
    \W\X\Y\Z 0000#1\W\X\Y\Z }#3\W\X\Y\Z 
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Ici, le deuxième nombre se termine. Fin du calcul. On utilise la variante
% \XINT@addm@A de l'addition car on sait que le deuxième terme est au moins
% aussi long que le premier. Lorsque le multiplicateur avait longueur 4n, la
% dernière addition a fourni le résultat à l'envers, il faut donc encore le
% renverser. 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xint@mul@mainw 
    #1\xint@mul@mainx 
    #2\xint@mul@mainy 
    #3\xint@mul@mainz
    \W\XINT@mul@compute  #4#5#6\W\X\Y\Z \X\Y\Z 
{%
    \expandafter
    \XINT@addm@A \expandafter0\expandafter{\expandafter}%
          \romannumeral0%
    \XINT@mul@Mr {#3#2#1}#6\Z\Z\Z\Z
                 \W\X\Y\Z 000#4\W\X\Y\Z 
}%
\def\xint@mul@mainx 
    #1\xint@mul@mainy 
    #2\xint@mul@mainz
    \W\XINT@mul@compute  #3#4#5\W\X\Y\Z \Y\Z 
{%
    \expandafter
    \XINT@addm@A \expandafter0\expandafter{\expandafter}%
          \romannumeral0%
    \XINT@mul@Mr {#2#1}#5\Z\Z\Z\Z 
               \W\X\Y\Z 00#3\W\X\Y\Z 
}%
\def\xint@mul@mainy 
    #1\xint@mul@mainz
    \W\XINT@mul@compute  #2#3#4\W\X\Y\Z \Z 
{%
    \expandafter
    \XINT@addm@A \expandafter0\expandafter{\expandafter}%
          \romannumeral0%
    \XINT@mul@Mr {#1}#4\Z\Z\Z\Z 
             \W\X\Y\Z 0#2\W\X\Y\Z 
}%
\def\xint@mul@mainz\W\XINT@mul@compute #1#2#3\W\X\Y\Z 
{%
    \expandafter
    \xint@cleanupzeros@andstop\romannumeral0\XINT@rev{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
%   Variante de la Multiplication
%   \romannumeral0\XINT@mulr@enter <N1>\W\X\Y\Z <N2>\W\X\Y\Z
%   Ici <N1> est à l'envers sur 4n, et <N2> est à l'endroit, pas sur 4n, comme
%   dans \XINT@mul@enter, mais le résultat est lui-même fourni *à l'envers*, sur
%   *4n* (en faisant attention de ne pas avoir 0000 à la fin).
% Utilisé par le calcul des puissances et aussi par la division.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@mulr@enter #1\W\X\Y\Z #2#3#4#5%
{% 
    \xint@w          
    #5\xint@mulr@enterw 
    #4\xint@mulr@enterx 
    #3\xint@mulr@entery 
    #2\xint@mulr@enterz 
    \W\XINT@mulr@start {#2#3#4#5}#1\W\X\Y\Z 
}%
\def\xint@mulr@enterw 
    #1\xint@mulr@enterx 
    #2\xint@mulr@entery 
    #3\xint@mulr@enterz
    \W\XINT@mulr@start  #4#5\W\X\Y\Z \X\Y\Z 
{%
    \XINT@mul@Mr {#3#2#1}#5\Z\Z\Z\Z 
}%
\def\xint@mulr@enterx 
    #1\xint@mulr@entery 
    #2\xint@mulr@enterz
    \W\XINT@mulr@start  #3#4\W\X\Y\Z \Y\Z 
{%
    \XINT@mul@Mr {#2#1}#4\Z\Z\Z\Z 
}%
\def\xint@mulr@entery 
    #1\xint@mulr@enterz
    \W\XINT@mulr@start  #2#3\W\X\Y\Z \Z 
{%
    \XINT@mul@Mr {#1}#3\Z\Z\Z\Z 
}%
\def\XINT@mulr@start #1#2\W\X\Y\Z 
{\expandafter 
    \XINT@mulr@main \expandafter
    {\romannumeral0\XINT@mul@Mr {#1}#2\Z\Z\Z\Z }#2\W\X\Y\Z 
}%
\def\XINT@mulr@main #1#2\W\X\Y\Z #3#4#5#6%
{%
    \xint@w 
    #6\xint@mulr@mainw
    #5\xint@mulr@mainx 
    #4\xint@mulr@mainy 
    #3\xint@mulr@mainz 
    \W\XINT@mulr@compute {#1}{#3#4#5#6}#2\W\X\Y\Z 
}%
\def\XINT@mulr@compute #1#2#3\W\X\Y\Z 
{\expandafter 
    \XINT@mulr@main \expandafter
    {\romannumeral0\expandafter
       \XINT@mul@Ar \expandafter0\expandafter{\expandafter}%
       \romannumeral0\XINT@mul@Mr {#2}#3\Z\Z\Z\Z \W\X\Y\Z 0000#1\W\X\Y\Z 
    }#3\W\X\Y\Z 
}%
\def\xint@mulr@mainw 
    #1\xint@mulr@mainx 
    #2\xint@mulr@mainy 
    #3\xint@mulr@mainz
    \W\XINT@mulr@compute #4#5#6\W\X\Y\Z \X\Y\Z 
{\expandafter
    \XINT@addp@A 
    \expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT@mul@Mr {#3#2#1}#6\Z\Z\Z\Z
                 \W\X\Y\Z 000#4\W\X\Y\Z
}%
\def\xint@mulr@mainx 
    #1\xint@mulr@mainy 
    #2\xint@mulr@mainz
    \W\XINT@mulr@compute  #3#4#5\W\X\Y\Z \Y\Z 
{\expandafter
    \XINT@addp@A 
    \expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT@mul@Mr {#2#1}#5\Z\Z\Z\Z 
                 \W\X\Y\Z 00#3\W\X\Y\Z
}%
\def\xint@mulr@mainy 
    #1\xint@mulr@mainz
    \W\XINT@mulr@compute #2#3#4\W\X\Y\Z \Z 
{\expandafter
    \XINT@addp@A 
    \expandafter0\expandafter{\expandafter}%
    \romannumeral0\XINT@mul@Mr {#1}#4\Z\Z\Z\Z 
                 \W\X\Y\Z 0#2\W\X\Y\Z
}%
\def\xint@mulr@mainz\W\XINT@mulr@compute #1#2#3\W\X\Y\Z { #1}%
%    \end{macrocode}
% \subsection{\csh{xintSqr}}
%    \begin{macrocode}
\def\xintiSqr {\romannumeral0\xintisqr }%
\def\xintisqr #1%
{%
    \expandafter\expandafter\expandafter
    \XINT@sqr
    \expandafter\expandafter\expandafter
    {\xintiAbs{#1}}% fait l'expansion de #1 et se d\'ebarrasse du signe
}%
\let\xintSqr\xintiSqr \let\xintsqr\xintisqr
\def\XINT@sqr #1%
{\expandafter
          \XINT@mul@enter
          \romannumeral0%
          \XINT@RQ {}#1\R\R\R\R\R\R\R\R\Z
          \W\X\Y\Z #1\W\X\Y\Z 
}%
%    \end{macrocode}
% \subsection{\csh{xintPrd}, \csh{xintProductExpr}}
% \begin{verbatim}
% \xintPrd {{a}...{z}}
% \xintProductExpr {a}...{z}\relax
% Release 1.02 modified the product routine.  The earlier version was faster in
% situations where each new term is bigger than the product of all previous
% terms, a situation which arises in the algorithm for computing powers. The
% 1.02 version was changed to be more efficient on big products, where the new
% term is small compared to what has been computed so far (the power algorithm
% now has its own product routine). 
% 
% Finally, the 1.03 version just simplifies everything as the multiplication now
% decides what is best, with the price of a little overhead. So the code has
% been dramatically reduced here. 
% 
% In 1.03 I also modify the way \xintPrd and \xintProductExpr ...\relax are
% related. Now \xintProductExpr \z \relax is accepted input when \z expands
% to a list of braced terms (prior only \xintPrd {\z} or \xintPrd \z was
% possible). 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintiPrd {\romannumeral0\xintiprd }%
\def\xintiprd #1{\xintiproductexpr #1\relax }%
\let\xintPrd\xintiPrd 
\let\xintprd\xintiprd
\def\xintiProductExpr {\romannumeral0\xintiproductexpr }%
\def\xintiproductexpr
{%
    \expandafter\expandafter\expandafter\XINT@productexpr
}%
\let\xintProductExpr\xintiProductExpr 
\let\xintproductexpr\xintiproductexpr
\def\XINT@productexpr {\XINT@prod@loop {1}}%
\def\XINT@prod@loop #1#2%
{%
    \xint@relax #2\XINT@prod@finished\relax
    \expandafter\XINT@prod@loop\expandafter
         {\romannumeral0\xintimul {#2}{#1}}%
}%
\def\XINT@prod@finished #1#2#3#4#5%
{%
    \XINT@prod@finished@ #5%
}%
\def\XINT@prod@finished@ #1#2#3#4#5{ #5}%
%    \end{macrocode}
% \subsection{\csh{xintFac}}
% \begin{verbatim}
% Modified with 1.02 and again in 1.03 for greater efficiency. I am tempted,
% here and elsewhere, to use \ifcase\XINT@Geq  {#1}{1000000000}  rather than
% \ifnum\XINT@Length {#1}>9 but for the time being I leave things as they stand.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintFac {\romannumeral0\xintfac }%
\def\xintfac #1%
{%
    \expandafter\expandafter\expandafter
        \XINT@fac@fork
    \expandafter\expandafter\expandafter
        {#1}%
}%
\def\XINT@Fac {\romannumeral0\XINT@fac@fork }%
\def\XINT@fac@fork #1%
{%
    \ifcase\xintiSgn {#1}
       \xint@afterfi{\expandafter\space\expandafter 1\xint@gobble }%
    \or
       \expandafter\XINT@fac@checklength
    \else
       \xint@afterfi{\xintError:FactorialOfNegativeNumber
                \expandafter\space\expandafter 1\xint@gobble }%
    \fi
    {#1}%
}%
\def\XINT@fac@checklength #1%
{%
    \ifnum \XINT@Length {#1}> 9 
         \xint@afterfi{\xintError:FactorialOfTooBigNumber
                       \expandafter\space\expandafter 1\xint@gobble }%
    \else
         \xint@afterfi{\ifnum #1>9999
                          \expandafter\XINT@fac@big@loop
                       \else
                          \expandafter\XINT@fac@loop
                       \fi }%
    \fi
    {#1}%
}%
\def\XINT@fac@big@loop #1{\XINT@fac@big@loop@main {10000}{#1}{}}%
\def\XINT@fac@big@loop@main #1#2#3%
{%
    \ifnum #1<#2
        \expandafter
            \XINT@fac@big@loop@main
        \expandafter
           {\the\numexpr #1+1\expandafter }%
    \else
        \expandafter\XINT@fac@big@docomputation
    \fi
    {#2}{#3{#1}}%
}%
\def\XINT@fac@big@docomputation #1#2%
{%
    \expandafter \XINT@fac@bigcompute@loop \expandafter
    {\romannumeral0\XINT@fac@loop {9999}}#2\relax
}%
\def\XINT@fac@bigcompute@loop #1#2%
{%
    \xint@relax #2\XINT@fac@bigcompute@end\relax
    \expandafter\XINT@fac@bigcompute@loop\expandafter
    {\expandafter\XINT@mul@enter
     \romannumeral0\XINT@RQ {}#2\R\R\R\R\R\R\R\R\Z
     \W\X\Y\Z #1\W\X\Y\Z }% 
}%
\def\XINT@fac@bigcompute@end #1#2#3#4#5%
{%
    \XINT@fac@bigcompute@end@ #5%
}%
\def\XINT@fac@bigcompute@end@ #1\R #2\Z \W\X\Y\Z #3\W\X\Y\Z { #3}%
\def\XINT@fac@loop #1{\XINT@fac@loop@main 1{1000}{#1}}%
\def\XINT@fac@loop@main #1#2#3%
{%
    \ifnum #3>#1
    \else
        \expandafter\XINT@fac@loop@exit
    \fi
    \expandafter\XINT@fac@loop@main\expandafter
    {\the\numexpr #1+1\expandafter }\expandafter
    {\romannumeral0\XINT@mul@Mr {#1}#2\Z\Z\Z\Z }%
    {#3}%
}%
\def\XINT@fac@loop@exit #1#2#3#4#5#6#7%
{%
    \XINT@fac@loop@exit@ #6%
}%
\def\XINT@fac@loop@exit@ #1#2#3%
{%
    \XINT@mul@M 
}%
%    \end{macrocode}
% \subsection{\csh{xintPow}}
% \begin{verbatim}
% 1.02 modified the \XINT@posprod routine, and this meant that the original
% version was moved here and renamed to \XINT@pow@posprod, as it was well
% adapted for computing powers. Then I moved in 1.03 the special variants of
% multiplication (hence of addition) which were needed to earlier in this file. 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintiPow {\romannumeral0\xintipow }%
\def\xintipow #1%
{%
    \expandafter\expandafter\expandafter
       \xint@pow
       #1\Z%
}%
\let\xintPow\xintiPow \let\xintpow\xintipow
\def\xint@pow #1#2\Z 
{% 
    \xint@UDsignfork
      #1\dummy \XINT@pow@Aneg
       -\dummy \XINT@pow@Anonneg
    \xint@UDkrof
       #1{#2}%
}%
\def\XINT@pow@Aneg #1#2#3%
{%
   \expandafter\expandafter\expandafter
      \XINT@pow@Aneg@
   \expandafter\expandafter\expandafter
      {#3}{#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% B = #1, xpxp déjà fait
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@pow@Aneg@ #1%
{%
   \ifcase\XINT@Odd{#1}
   \or \expandafter\XINT@pow@Aneg@Bodd
   \fi
   \XINT@pow@Anonneg@ {#1}%
}%
\def\XINT@pow@Aneg@Bodd #1%
{%
    \expandafter\XINT@opp\romannumeral0\XINT@pow@Anonneg@ 
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% B = #3, faire le xpxp
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@pow@Anonneg #1#2#3%
{%
   \expandafter\expandafter\expandafter
      \XINT@pow@Anonneg@
   \expandafter\expandafter\expandafter
   {#3}{#1#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1 = B, #2 = |A|
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@pow@Anonneg@ #1#2%
{%
    \ifcase\XINT@Cmp {#2}{1}
        \expandafter\XINT@pow@AisOne
    \or 
        \expandafter\XINT@pow@AatleastTwo
    \else
        \expandafter\XINT@pow@AisZero
    \fi
    {#1}{#2}%
}%
\def\XINT@pow@AisOne #1#2{ 1}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1 = B
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@pow@AisZero #1#2%
{%
     \ifcase\XINT@Sgn {#1}
         \xint@afterfi { 1}%
     \or
         \xint@afterfi { 0}%
     \else
         \xint@afterfi {\xintError:DivisionByZero\space 0}%
     \fi
}%
\def\XINT@pow@AatleastTwo #1%
{%
    \ifcase\XINT@Sgn {#1}
        \expandafter\XINT@pow@BisZero
    \or
        \expandafter\XINT@pow@checkBlength
    \else
        \expandafter\XINT@pow@BisNegative
    \fi
    {#1}%
}%
\def\XINT@pow@BisNegative #1#2{\xintError:FractionRoundedToZero\space 0}%
\def\XINT@pow@BisZero #1#2{ 1}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% B = #1 > 0, A = #2 > 1
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@pow@checkBlength #1#2%
{%
    \ifnum\xintiLen{#1} >9 
        \expandafter\XINT@pow@BtooBig
    \else
        \expandafter\XINT@pow@loop
    \fi
    {#1}{#2}\XINT@pow@posprod
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
}%
\def\XINT@pow@BtooBig #1\xint@UNDEF #2\xint@UNDEF
               {\xintError:ExponentTooBig\space 0}%
\def\XINT@pow@loop #1#2%
{%
    \ifnum #1 = 1
        \expandafter\XINT@pow@loop@end 
    \else
        \xint@afterfi{\expandafter\XINT@pow@loop@a
            \expandafter{\the\numexpr 2*(#1/2)-#1\expandafter }% b mod 2
            \expandafter{\the\numexpr #1-#1/2\expandafter }%     [b/2]
            \expandafter{\romannumeral0\xintisqr{#2}}}%
    \fi
    {{#2}}%
}%
\def\XINT@pow@loop@end {\romannumeral0\XINT@rord@main {}\relax }%
\def\XINT@pow@loop@a #1%
{%
    \ifnum #1 = 1
        \expandafter\XINT@pow@loop
    \else
        \expandafter\XINT@pow@loop@throwaway
    \fi
}%
\def\XINT@pow@loop@throwaway #1#2#3%
{%
   \XINT@pow@loop {#1}{#2}% 
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
%    Routine de produit servant pour le calcul des puissances. Chaque nouveau
%    terme est plus grand que ce qui a déjà été calculé. Par conséquent on a
%    intérêt à le conserver en second dans la routine de multiplication, donc le
%    précédent calcul a intérêt à avoir été donné sur 4n, à l'envers. Il faut
%    donc modifier la multiplication pour qu'elle fasse cela. Ce qui oblige à
%    utiliser une version spéciale de l'addition également.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@pow@posprod #1%
{%
    \XINT@pow@pprod@checkifempty #1\Z
}%
\def\XINT@pow@pprod@checkifempty #1%
{%
    \xint@relax #1\XINT@pow@pprod@emptyproduct\relax 
    \XINT@pow@pprod@RQfirst #1%
}%
\def\XINT@pow@pprod@emptyproduct #1\Z { 1}%
\def\XINT@pow@pprod@RQfirst #1\Z
{%
    \expandafter\XINT@pow@pprod@getnext\expandafter
    {\romannumeral0\XINT@RQ {}#1\R\R\R\R\R\R\R\R\Z}%
}%
\def\XINT@pow@pprod@getnext #1#2%
{%
    \XINT@pow@pprod@checkiffinished #2\Z {#1}%
}%
\def\XINT@pow@pprod@checkiffinished #1%
{%
    \xint@relax #1\XINT@pow@pprod@end\relax 
    \XINT@pow@pprod@compute #1%
}%
\def\XINT@pow@pprod@compute #1\Z #2%
{%
    \expandafter \XINT@pow@pprod@getnext  \expandafter
    {\romannumeral0\XINT@mulr@enter #2\W\X\Y\Z #1\W\X\Y\Z}%
}%
\def\XINT@pow@pprod@end\relax\XINT@pow@pprod@compute #1\Z #2%
{%
    \expandafter
    \xint@cleanupzeros@andstop
    \romannumeral0\XINT@rev {#2}%
}%
%    \end{macrocode}
% \subsection{\csh{xintDivision}, \csh{xintQuo}, \csh{xintRem}}
%    \begin{macrocode}
\def\xintQuo {\romannumeral0\xintquo }%
\def\xintRem {\romannumeral0\xintrem }%
\def\xintquo {\expandafter
                  \xint@firstoftwo@andstop
               \romannumeral0\xintdivision }%
\def\xintrem {\expandafter
                  \xint@secondoftwo@andstop
               \romannumeral0\xintdivision }%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1 = A, #2 = B. On calcule le quotient de A par B
% 1.03 adds the detection of 1 for B.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintDivision {\romannumeral0\xintdivision }%
\def\xintdivision #1%
{%
    \expandafter\expandafter\expandafter
        \xint@division
    \expandafter\expandafter\expandafter
        {#1}%
}%
\def\xint@division #1#2%
{%
    \expandafter\expandafter\expandafter
    \XINT@div@fork #2\Z #1\Z 
}%
\def\XINT@Division #1#2{\romannumeral0\XINT@div@fork #2\Z #1\Z }%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1#2 = 2e input = diviseur = B
% #3#4 = 1er input = divisé = A
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@fork #1#2\Z #3#4\Z
{%
    \xint@UDzerofork
      #1\dummy \XINT@div@BisZero
      #3\dummy \XINT@div@AisZero
       0\dummy 
        {\xint@UDsignfork
           #1\dummy \XINT@div@BisNegative  % B < 0
           #3\dummy \XINT@div@AisNegative  % A < 0, B > 0
            -\dummy \XINT@div@plusplus     % B > 0, A > 0
         \xint@UDkrof }%
    \xint@UDkrof
    {#2}{#4}#1#3% #1#2=B, #3#4=A
}%
\def\XINT@div@BisZero #1#2#3#4%
    {\xintError:DivisionByZero\space {0}{0}}%
\def\XINT@div@AisZero #1#2#3#4{ {0}{0}}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% jusqu'à présent c'est facile.
% minusplus signifie B < 0, A > 0
% plusminus signifie B > 0, A < 0
% Ici #3#1 correspond au diviseur B et #4#2 au divisé A
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@plusplus #1#2#3#4%
{%
    \XINT@div@prepare {#3#1}{#4#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% B = #3#1 < 0, A non nul positif ou négatif
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@BisNegative #1#2#3#4%
{%
    \expandafter\XINT@div@BisNegative@post
    \romannumeral0\XINT@div@fork #1\Z #4#2\Z
}%
\def\XINT@div@BisNegative@post #1#2%
{%
    \expandafter\space\expandafter
        {\romannumeral0\XINT@opp #1}{#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% B = #3#1 > 0, A =-#2< 0
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@AisNegative #1#2#3#4%
{%
    \expandafter\XINT@div@AisNegative@post
    \romannumeral0\XINT@div@prepare {#3#1}{#2}{#3#1}%
}%
\def\XINT@div@AisNegative@post #1#2%
{%
    \ifcase\xintiSgn {#2}
       \expandafter \XINT@div@AisNegative@zerorem
    \or
       \expandafter \XINT@div@AisNegative@posrem
    \fi
    {#1}{#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% en #3 on a une copie de B (à l'endroit)
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@AisNegative@zerorem #1#2#3%
{%
    \expandafter\space\expandafter
       {\romannumeral0\XINT@opp #1}{0}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1 = quotient, #2 = reste, #3 = diviseur initial (à l'endroit)
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@AisNegative@posrem #1%
{%
    \expandafter \XINT@div@AisNegative@posrem@b \expandafter
       {\romannumeral0\xintiopp {\XINT@Add{#1}{1}}}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% remplace Reste par B - Reste, après avoir remplacé Q par -(Q+1)
% de sorte que la formule a = qb + r, 0<= r < |b| est valable
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@AisNegative@posrem@b #1#2#3%
{%
    \expandafter \xint@exchangetwo@keepbraces@andstop \expandafter
    {\romannumeral0\XINT@sub {#3}{#2}}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% par la suite A et B sont > 0.
% #1 = B. Pour le moment à l'endroit.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepare #1%
{%
    \expandafter \XINT@div@prepareB@aa \expandafter
        {\romannumeral0\XINT@length {#1}}{#1}% B > 0 ici
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Calcul du plus petit K = 4n >= longueur de B
% 1.03 adds the interception of B=1
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepareB@aa #1%
{%
    \ifnum #1=1
      \expandafter\XINT@div@prepareB@ab
    \else
      \expandafter\XINT@div@prepareB@a
    \fi
    {#1}%
}%
\def\XINT@div@prepareB@ab #1#2%
{%
    \ifnum #2=1
      \expandafter\XINT@div@prepareB@BisOne
    \else 
      \xint@afterfi{\XINT@div@prepareB@e {000}{3}{4}{#2}}%
    \fi
}%
\def\XINT@div@prepareB@BisOne #1{ {#1}{0}}%
\def\XINT@div@prepareB@a #1%
{%
    \expandafter \XINT@div@prepareB@b \expandafter
        {\the\numexpr 4*((#1+1)/4)\relax}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1 = K
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepareB@b #1#2%
{%
    \expandafter \XINT@div@prepareB@c \expandafter
       {\the\numexpr #1-#2\relax}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1 = c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepareB@c #1%
{%
    \ifcase #1
          \expandafter\XINT@div@prepareB@di
    \or   \expandafter\XINT@div@prepareB@dii
    \or   \expandafter\XINT@div@prepareB@diii
    \else \expandafter\XINT@div@prepareB@div
    \fi
}%
\def\XINT@div@prepareB@di   {\XINT@div@prepareB@e {}{0}}%
\def\XINT@div@prepareB@dii  {\XINT@div@prepareB@e {0}{1}}%
\def\XINT@div@prepareB@diii {\XINT@div@prepareB@e {00}{2}}%
\def\XINT@div@prepareB@div  {\XINT@div@prepareB@e {000}{3}}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1 = zéros à rajouter à B, #2=c, #3=K, #4 = B
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepareB@e #1#2#3#4%
{%
    \XINT@div@prepareB@f #4#1\Z {#3}{#2}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% x = #1#2#3#4 = 4 premiers chiffres de B. #1 est non nul.
% Ensuite on renverse B pour calculs plus rapides par la suite.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepareB@f #1#2#3#4#5\Z
{%
    \expandafter \XINT@div@prepareB@g \expandafter
        {\romannumeral0\XINT@rev {#1#2#3#4#5}}{#1#2#3#4}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #3= K, #4 = c, #5= {} ou {0} ou {00} ou {000}, #6 = A initial
% #1 = B préparé et renversé, #2 = x = quatre premiers chiffres
% On multiplie aussi A par 10^c.
% B, x, K, c, {} ou {0} ou {00} ou {000}, A initial
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepareB@g #1#2#3#4#5#6%
{%
    \XINT@div@prepareA@a {#6#5}{#2}{#3}{#1}{#4}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% A, x, K, B, c, 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepareA@a #1%
{%
    \expandafter \XINT@div@prepareA@b \expandafter
       {\romannumeral0\XINT@length {#1}}{#1}% A >0 ici
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% L0, A, x, K, B, ...
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepareA@b #1%
{%
    \expandafter\XINT@div@prepareA@c\expandafter
    {\the\numexpr 4*((#1+1)/4)\relax}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% L, L0, A, x, K, B,...
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepareA@c #1#2%
{%
    \expandafter\XINT@div@prepareA@d \expandafter
       {\the\numexpr #1-#2\relax}{#1}%
}%
\def\XINT@div@prepareA@d #1%
{%
    \ifcase #1
          \expandafter\XINT@div@prepareA@di
    \or   \expandafter\XINT@div@prepareA@dii
    \or   \expandafter\XINT@div@prepareA@diii
    \else \expandafter\XINT@div@prepareA@div
    \fi
}%
\def\XINT@div@prepareA@di   {\XINT@div@prepareA@e {}}%
\def\XINT@div@prepareA@dii  {\XINT@div@prepareA@e {0}}%
\def\XINT@div@prepareA@diii {\XINT@div@prepareA@e {00}}%
\def\XINT@div@prepareA@div  {\XINT@div@prepareA@e {000}}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1#3 = A préparé, #2 = longueur de ce A préparé, 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@prepareA@e #1#2#3%
{%
    \XINT@div@startswitch {#1#3}{#2}% 
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% A, L, x, K, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@startswitch #1#2#3#4%
{%
    \ifnum #2 > #4
      \expandafter\XINT@div@body@a
    \else
    \ifnum #2 = #4
      \expandafter\expandafter\expandafter
          \XINT@div@final@a
    \else
      \expandafter\expandafter\expandafter
          \XINT@div@finished@a
    \fi\fi {#1}{#4}{#3}{0000}{#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% A, K, x, Q, L, B, c   
% ---- "Finished"
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@finished@a #1#2#3%
{%
    \expandafter \XINT@div@finished@b \expandafter
      {\romannumeral0\XINT@cuz {#1}}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% A, Q, L, B, c
% no leading zeros in A at this stage
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@finished@b #1#2#3#4#5%
{%
    \ifcase \XINT@Sgn {#1}
       \xint@afterfi {\XINT@div@finished@c {0}}%
    \or
       \xint@afterfi {\expandafter\XINT@div@finished@c
                      \expandafter
         {\romannumeral0\XINT@dsh@checksignx #5\Z {#1}}}%
    \fi
    {#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Reste Final, Q à renverser 
% #2 = Quotient, #1 = Reste.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@finished@c #1#2%
{%
    \expandafter \space \expandafter
        {\romannumeral0\expandafter\xint@cleanupzeros@andstop
         \romannumeral0\XINT@rev {#2}}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% ---- "Final"
% A, K, x, Q, L, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@final@a #1%
{%
    \XINT@div@final@b #1\Z
}%
\def\XINT@div@final@b #1#2#3#4#5\Z
{%
    \xint@quatrezeros #1#2#3#4\xint@div@final@c0000%
    \XINT@div@final@c {#1#2#3#4}{#1#2#3#4#5}%
}%
\def\xint@div@final@c0000\XINT@div@final@c #1{\XINT@div@finished@a }%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% a, A, K, x, Q, L, B ,c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@final@c #1#2#3#4%
{%
    \expandafter \XINT@div@final@d \expandafter
    {\the\numexpr #1/#4\relax}{#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% q, A, Q, L, B à l'envers sur 4n, c
% 1.01 code ré-écrit pour optimisations diverses
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@final@d #1#2#3#4#5% q,A,Q,L,B puis c
{% 
    \expandafter \XINT@div@final@da \expandafter
    {\romannumeral0\XINT@mul@M {#1}#5\Z\Z\Z\Z }%
    {\romannumeral0\xint@cleanupzeros@andstop #2}%
    {#1}{#3}{#5}% 
}%
\def\XINT@div@final@da #1#2%
{%
    \expandafter\XINT@div@final@db\expandafter {#2}{#1}%
}%
\def\XINT@div@final@db #1#2% A,qB, puis q,Q,B,c
{%
    \ifcase\XINT@Geq {#1}{#2}
       \expandafter\XINT@div@final@dc  % A < qB
    \or\expandafter\XINT@div@final@e   % A au moins qB
    \fi
    {#1}{#2}%
}%
\def\XINT@div@final@e #1#2#3#4#5% A,qB,q,Q,B,puis c
{%
    \expandafter\XINT@div@final@f
    \expandafter{\romannumeral0\xintisub {#1}{#2}}%
    {\romannumeral0\xintiadd {\XINT@Rev@andcleanupzeros{#4}}{#3}}%
}%
\def\XINT@div@final@dc #1#2#3% A sans leading zeros,trash,q,Q,B,c
{%
    \expandafter\XINT@div@final@dd
    \expandafter{\the\numexpr #3-1\relax}{#1}%
}%
\def\XINT@div@final@dd #1#2#3#4% q,A,Q,B puis c
{%
    \expandafter\XINT@div@final@f
    \expandafter{\romannumeral0\xintisub 
                 {#2}{\romannumeral0\XINT@mul@M {#1}#4\Z\Z\Z\Z }}%
    {\romannumeral0\xintiadd {\XINT@Rev@andcleanupzeros{#3}}{#1}}%
}%
\def\XINT@div@final@f #1#2#3% R,Q à développer,c
{%
    \ifcase \XINT@Sgn {#1}
       \xint@afterfi {\XINT@div@final@end {0}}%
    \or
       \xint@afterfi {\expandafter\XINT@div@final@end
                      \expandafter % pas de leading zeros dans #1=R
                      {\romannumeral0\XINT@dsh@checksignx #3\Z {#1}}}%
    \fi
    {#2}%
}%
\def\XINT@div@final@end #1#2%
{%
    \expandafter\space\expandafter {#2}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Boucle Principale (on reviendra en div@body@b pas div@body@a)
% A, K, x, Q, L, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@a #1%
{%
    \XINT@div@body@b #1\Z {#1}%
}%
\def\XINT@div@body@b #1#2#3#4#5#6#7#8#9\Z
{%
    \XINT@div@body@c {#1#2#3#4#5#6#7#8}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% a, A, K, x, Q, L, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@c #1#2#3%
{%
    \XINT@div@body@d {#3}{}#2\Z {#1}{#3}%
}%
\def\XINT@div@body@d #1#2#3#4#5#6%
{%
    \ifnum #1 > 0
        \expandafter
        \XINT@div@body@d
        \expandafter
        {\the\numexpr #1-4\expandafter }%
    \else
        \expandafter
        \XINT@div@body@e
    \fi
    {#6#5#4#3#2}%
}%
\def\XINT@div@body@e #1#2\Z #3%
{%
    \XINT@div@body@f {#3}{#1}{#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% a, alpha (à l'envers), alpha' (à l'endroit), K, x, Q, L, B (à l'envers), c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@f #1#2#3#4#5#6#7#8%
{%
    \expandafter\XINT@div@body@gg
    \the\numexpr (#1+(#5+1)/2)/(#5+1)+99999\relax 
    {#8}{#2}{#8}{#4}{#5}{#3}{#6}{#7}{#8}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% q1 sur six chiffres (il en a 5 au max), B, alpha, B, K, x, alpha', Q, L, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@gg #1#2#3#4#5#6%
{%
    \xint@UDzerofork
      #2\dummy \XINT@div@body@gk 
       0\dummy {\XINT@div@body@ggk #2}%
    \xint@UDkrof
    {#3#4#5#6}%
}%
\def\XINT@div@body@gk #1#2#3%
{%
    \expandafter
       \XINT@div@body@h 
    \romannumeral0\XINT@div@sub@xpxp 
    {\romannumeral0\XINT@mul@Mr {#1}#2\Z\Z\Z\Z }{#3}\Z {#1}%
}%
\def\XINT@div@body@ggk #1#2#3%
{%
    \expandafter \XINT@div@body@gggk \expandafter
    {\romannumeral0\XINT@mul@Mr {#1}0000#3\Z\Z\Z\Z }%
    {\romannumeral0\XINT@mul@Mr {#2}#3\Z\Z\Z\Z }%
    {#1#2}%  
}%
\def\XINT@div@body@gggk #1#2#3#4%
{%
    \expandafter
      \XINT@div@body@h
    \romannumeral0\XINT@div@sub@xpxp
    {\romannumeral0\expandafter\XINT@mul@Ar
     \expandafter0\expandafter{\expandafter}#2\W\X\Y\Z #1\W\X\Y\Z }%
    {#4}\Z {#3}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% alpha1 = alpha-q1 B, \Z, q1, B, K, x, alpha', Q, L, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@h #1#2#3#4#5#6#7#8#9\Z 
{%
    \ifnum #1#2#3#4>0
        \xint@afterfi{\XINT@div@body@i {#1#2#3#4#5#6#7#8}}%
    \else
        \expandafter\XINT@div@body@k
    \fi
    {#1#2#3#4#5#6#7#8#9}%
}%
\def\XINT@div@body@k #1#2#3%
{%
    \XINT@div@body@l {#1}{#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% a1, alpha1 (à l'endroit), q1, B, K, x, alpha', Q, L, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@i #1#2#3#4#5#6%
{%
    \expandafter\XINT@div@body@j
    \expandafter{\the\numexpr (#1+(#6+1)/2)/(#6+1)-1\relax }%
       {#2}{#3}{#4}{#5}{#6}%
}%
\def\XINT@div@body@j #1#2#3#4%
{%
    \expandafter \XINT@div@body@l \expandafter
    {\romannumeral0\XINT@div@sub@xpxp
       {\romannumeral0\XINT@mul@Mr {#1}#4\Z\Z\Z\Z }{\XINT@Rev{#2}}}%
    {#3+#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% alpha2 (à l'endroit, ou alpha1), q1+q2 (ou q1), K, x, alpha', Q, L, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@l #1#2#3#4#5#6#7%
{%
   \expandafter
       \XINT@div@body@m
   \the\numexpr 100000000+#2\relax
       {#6}{#3}{#7}{#1#5}{#4}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% chiffres de q, Q, K, L, A'=nouveau A, x, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@m #1#2#3#4#5#6#7#8#9%
{%
    \ifnum #2#3#4#5>0
       \xint@afterfi {\XINT@div@body@n {#9#8#7#6#5#4#3#2}}%
    \else
       \xint@afterfi {\XINT@div@body@n {#9#8#7#6}}%
    \fi
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% q renversé, Q, K, L, A', x, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@n #1#2%
{%
    \expandafter\XINT@div@body@o\expandafter
    {\romannumeral0\XINT@addr@A 0{}#1\W\X\Y\Z #2\W\X\Y\Z }%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% q+Q, K, L, A', x, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@o #1#2#3#4%
{%
    \XINT@div@body@p {#3}{#2}{}#4\Z {#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% L, K, {}, A'\Z, q+Q, x, B, c 
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@p #1#2#3#4#5#6#7%
{%
    \ifnum #1 > #2
        \xint@afterfi
        {\ifnum #4#5#6#7 > 0
           \expandafter\XINT@div@body@q
         \else
           \expandafter\XINT@div@body@repeatp
         \fi }%
    \else
        \expandafter\XINT@div@gotofinal@a
    \fi
    {#1}{#2}{#3}#4#5#6#7%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% L, K, zeros,  A' avec moins de zéros\Z, q+Q, x, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@repeatp #1#2#3#4#5#6#7%
{%
    \expandafter \XINT@div@body@p \expandafter
        {\the\numexpr #1-4\relax}{#2}{0000#3}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% L -> L-4, zeros->zeros+0000, répéter jusqu'à ce que soit L=K
% soit on ne trouve plus 0000
% nouveau L, K, zeros, nouveau A=#4, \Z, Q+q (à l'envers), x, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@body@q #1#2#3#4\Z #5#6%
{%
    \XINT@div@body@b #4\Z {#4}{#2}{#6}{#3#5}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% A, K, x, Q, L, B, c --> iterate
% ----
% Boucle Principale achevée
% ATTENTION IL FAUT AJOUTER 4 ZEROS DE MOINS QUE CEUX 
% QUI ONT ÉTÉ PRÉPARÉS DANS #3!!
% L, K (L=K), zeros, A\Z, Q, x, B, c
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@gotofinal@a #1#2#3#4\Z %
{%
    \XINT@div@gotofinal@b #3\Z {#4}{#1}%
}%
\def\XINT@div@gotofinal@b 0000#1\Z #2#3#4#5%
{%
    \XINT@div@final@a {#2}{#3}{#5}{#1#4}{#3}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% La soustraction spéciale. 
% Elle fait l'expansion (une fois pour le premier, deux fois pour le second) de
% ses arguments. Ceux-ci doivent être à l'envers sur 4n. De plus on sait a
% priori que le second est > le premier. Et le résultat de la différence est
% renvoyé **avec la même longueur que le second** (donc avec des leading zéros
% éventuels), et *à l'endroit*.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@div@sub@xpxp #1%
{%
    \expandafter \XINT@div@sub@xpxp@  \expandafter
    {#1}%
}%
\def\XINT@div@sub@xpxp@ #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@div@sub@xpxp@@
     #2\W\X\Y\Z #1\W\X\Y\Z
}%
\def\XINT@div@sub@xpxp@@
{%
    \XINT@div@sub@A 1{}%
}%
\def\XINT@div@sub@A #1#2#3#4#5#6%  
{%
    \xint@w 
    #3\xint@div@sub@az 
    \W\XINT@div@sub@B #1{#3#4#5#6}{#2}% 
}%
\def\XINT@div@sub@B #1#2#3#4\W\X\Y\Z #5#6#7#8%  
{%
    \xint@w 
    #5\xint@div@sub@bz 
    \W\XINT@div@sub@onestep #1#2{#8#7#6#5}{#3}#4\W\X\Y\Z 
}%
\def\XINT@div@sub@onestep #1#2#3#4#5#6%
{\expandafter
    \XINT@div@sub@backtoA\the\numexpr 11#5#4#3#2-#6+#1-1\relax.%
}%
\def\XINT@div@sub@backtoA #1#2#3.#4%
{%
    \XINT@div@sub@A #2{#3#4}%
}%
\def\xint@div@sub@bz 
    \W\XINT@div@sub@onestep #1#2#3#4#5#6#7%
{%
    \xint@UDzerofork
      #1\dummy  \XINT@div@sub@C   %
       0\dummy  \XINT@div@sub@D   % pas de retenue
    \xint@UDkrof
    {#7}#2#3#4#5%
}%
\def\XINT@div@sub@D #1#2\W\X\Y\Z
{%
    \expandafter\space
    \romannumeral0%
    \XINT@rord@main {}#2%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
    #1%
}%
\def\XINT@div@sub@C #1#2#3#4#5%
{%
    \xint@w 
    #2\xint@div@sub@cz 
    \W\XINT@div@sub@AC@onestep {#5#4#3#2}{#1}%
}%
\def\XINT@div@sub@AC@onestep #1%
{\expandafter
    \XINT@div@sub@backtoC\the\numexpr 11#1-1\relax.%
}%
\def\XINT@div@sub@backtoC #1#2#3.#4%
{%
    \XINT@div@sub@AC@checkcarry #2{#3#4}% la retenue va \^etre examin\'ee
}%
\def\XINT@div@sub@AC@checkcarry #1%
{%
    \xint@one #1\xint@div@sub@AC@nocarry 1\XINT@div@sub@C 
}%
\def\xint@div@sub@AC@nocarry 1\XINT@div@sub@C #1#2\W\X\Y\Z
{%
    \expandafter\space
    \romannumeral0%
    \XINT@rord@main {}#2%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
    #1%
}%
\def\xint@div@sub@cz\W\XINT@div@sub@AC@onestep #1#2{ #2}%
\def\xint@div@sub@az\W\XINT@div@sub@B #1#2#3#4\Z { #3}%
%    \end{macrocode}
% \begin{verbatim}
%-----------------------------------------------------------------
%-----------------------------------------------------------------
% DECIMAL OPERATIONS: FIRST DIGIT, LASTDIGIT, ODDNESS,
% MULTIPLICATION BY TEN, QUOTIENT BY TEN, QUOTIENT OR
% MULTIPLICATION BY POWER OF TEN, SPLIT OPERATION.
% \end{verbatim}
% \vspace*{-2\baselineskip}
% \subsection{\csh{xintFDg}}
% \begin{verbatim}
%    FIRST DIGIT
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintFDg {\romannumeral0\xintfdg }%
\def\xintfdg #1%
{%
    \expandafter\expandafter\expandafter
    \XINT@fdg #1\W\Z
}%
\def\XINT@FDg #1{\romannumeral0\XINT@fdg #1\W\Z }%
\def\XINT@fdg #1#2%
{%
    \xint@xpxp@andstop
    \xint@UDzerominusfork
      #1-\dummy  {\expandafter 0}%      zero
      0#1\dummy  {\expandafter #2}%     negative
       0-\dummy  {\expandafter #1}%  positive
    \xint@UDkrof
    \xint@z
}%
%    \end{macrocode}
% \subsection{\csh{xintLDg}}
% \begin{verbatim}
%    LAST DIGIT
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintLDg {\romannumeral0\xintldg }%
\def\xintldg #1%
{%
    \expandafter\expandafter\expandafter
        \XINT@ldg
    \expandafter\expandafter\expandafter
    {#1}%
}%
\def\XINT@LDg #1{\romannumeral0\XINT@ldg {#1}}%
\def\XINT@ldg #1%
{%
    \expandafter
    \XINT@ldg@
    \romannumeral0\XINT@rev {#1}\Z
}%
\def\XINT@ldg@ #1%
{%
    \expandafter\space\expandafter #1\xint@z
}%
%    \end{macrocode}
% \subsection{\csh{xintMON}}
% \begin{verbatim}
%    MINUS ONE TO THE POWER N
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintMON {\romannumeral0\xintmon }%
\def\xintmon #1%
{%
    \ifodd\xintLDg {#1}
        \xint@afterfi{ -1}%
    \else
        \xint@afterfi{ 1}%
    \fi
}%
\def\xintMMON {\romannumeral0\xintmmon }%
\def\xintmmon #1%
{%
    \ifodd\xintLDg {#1}
        \xint@afterfi{ 1}%
    \else
        \xint@afterfi{ -1}%
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintOdd}}
% \begin{verbatim}
%     ODDNESS
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintOdd {\romannumeral0\xintodd }%
\def\xintodd #1%
{%
    \ifodd\xintLDg{#1}
        \xint@afterfi{ 1}%
    \else
        \xint@afterfi{ 0}%
    \fi
}%
\def\XINT@Odd #1%
{\romannumeral0%
    \ifodd\XINT@LDg{#1}
        \xint@afterfi{ 1}%
    \else
        \xint@afterfi{ 0}%
    \fi
}%
%    \end{macrocode}
% \subsection{\csh{xintDSL}}
% \begin{verbatim}
%    DECIMAL SHIFT LEFT (=MULTIPLICATION PAR 10)
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintDSL {\romannumeral0\xintdsl }%
\def\xintdsl #1%
{%
    \expandafter\expandafter\expandafter
      \XINT@dsl #1\Z
}%
\def\XINT@DSL #1{\romannumeral0\XINT@dsl #1\Z }%
\def\XINT@dsl #1%
{%
    \xint@zero #1\xint@dsl@zero 0\XINT@dsl@ #1%
}%
\def\xint@dsl@zero 0\XINT@dsl@ 0#1\Z { 0}%
\def\XINT@dsl@ #1\Z { #10}%
%    \end{macrocode}
% \subsection{\csh{xintDSR}}
% \begin{verbatim}
%    DECIMAL SHIFT RIGHT (=DIVISION PAR 10)
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintDSR {\romannumeral0\xintdsr }%
\def\xintdsr #1%
{%
    \expandafter\expandafter\expandafter
       \XINT@dsr@a
    \expandafter\expandafter\expandafter
    {#1}\W\Z
}%
\def\XINT@DSR #1{\romannumeral0\XINT@dsr@a {#1}\W\Z }%
\def\XINT@dsr@a
{%
    \expandafter
       \XINT@dsr@b
    \romannumeral0\XINT@rev
}%
\def\XINT@dsr@b #1#2#3\Z
{%
    \xint@w #2\xint@dsr@onedigit\W
    \xint@minus #2\xint@dsr@onedigit-%
    \expandafter
      \XINT@dsr@removew
    \romannumeral0\XINT@rev {#2#3}%
}%
\def\xint@dsr@onedigit #1\XINT@rev #2{ 0}%
\def\XINT@dsr@removew #1\W { }%
%    \end{macrocode}
% \subsection{\csh{xintDSH}, \csh{xintDSHr}}
% \begin{verbatim}
%     DECIMAL SHIFTS
%    \xintDSH {x}{A}
% si x <= 0, fait A -> A.10^(|x|). v1.03 corrige l'oversight pour A=0.
% si x >  0, et A >=0, fait A -> quo(A,10^(x))
% si x >  0, et A < 0, fait A -> -quo(-A,10^(x))
% (donc pour x > 0 c'est comme DSR itéré x fois)
% \xintDSHr donne le `reste' (si x<=0 donne zéro).
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintDSHr {\romannumeral0\xintdshr }%
\def\xintdshr #1%
{\expandafter\expandafter\expandafter
                 \XINT@dshr@checkxpositive #1\Z
}%
\def\XINT@dshr@checkxpositive #1%
{%
    \xint@UDzerominusfork
      0#1\dummy \XINT@dshr@xzeroorneg
      #1-\dummy \XINT@dshr@xzeroorneg
       0-\dummy \XINT@dshr@xpositive
    \xint@UDkrof #1%
}%
\def\XINT@dshr@xzeroorneg #1\Z #2{ 0}%
\def\XINT@dshr@xpositive #1\Z 
{%
    \expandafter
    \xint@secondoftwo@andstop
    \romannumeral0\xintdsx {#1}%
}%
\def\xintDSH {\romannumeral0\xintdsh }%
\def\xintdsh #1#2%
{%
    \expandafter\expandafter\expandafter
      \xint@dsh 
    \expandafter\expandafter\expandafter
      {#2}{#1}%
}%
\def\xint@dsh #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@dsh@checksignx #2\Z {#1}%
}%
\def\XINT@dsh@checksignx #1%
{%
    \xint@UDzerominusfork
      #1-\dummy  \XINT@dsh@xiszero
      0#1\dummy  \XINT@dsx@xisNeg@checkA     % on passe direct dans DSx
       0-\dummy  {\XINT@dsh@xisPos #1}%
    \xint@UDkrof
}%
\def\XINT@dsh@xiszero #1\Z #2{ #2}%
\def\XINT@dsh@xisPos #1\Z #2%
{%
    \expandafter
    \xint@firstoftwo@andstop
    \romannumeral0\XINT@dsx@checksignA #2\Z {#1}% via DSx
}%
%    \end{macrocode}
% \subsection{\csh{xintDSx}}
% \begin{verbatim}
% Je fais cette routine pour la version 1.01, après modification de
% \xintDecSplit. Dorénavant \xintDSx fera appel à \xintDecSplit et de même 
% \xintDSH fera appel à \xintDSx. J'ai donc supprimé entièrement l'ancien code
% de \xintDSH et re-écrit entièrement celui de \xintDecSplit pour x positif.
% --> Attention le cas x=0 est traité dans la même catégorie que x > 0 <--
% si x < 0, fait A -> A.10^(|x|)
% si x >=  0, et A >=0, fait A -> {quo(A,10^(x))}{rem(A,10^(x))}
% si x >=  0, et A < 0, d'abord on calcule {quo(-A,10^(x))}{rem(-A,10^(x))}
%    puis, si le premier n'est pas nul on lui donne le signe -
%          si le premier est nul on donne le signe - au second.
% On peut donc toujours reconstituer l'original A par 10^x Q \pm R
% où il faut prendre le signe plus si Q est positif ou nul et le signe moins si
% Q est strictement négatif.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintDSx {\romannumeral0\xintdsx }%
\def\xintdsx #1#2%
{%
    \expandafter\expandafter\expandafter
        \xint@dsx
    \expandafter\expandafter\expandafter
    {#2}{#1}%
}%
\def\xint@dsx #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@dsx@checksignx #2\Z {#1}%
}%
\def\XINT@DSx #1#2{\romannumeral0\XINT@dsx@checksignx #1\Z {#2}}%
\def\XINT@dsx #1#2{\XINT@dsx@checksignx #1\Z {#2}}%
\def\XINT@dsx@checksignx #1%
{%
    \xint@UDzerominusfork
      #1-\dummy  \XINT@dsx@xisZero
      0#1\dummy  \XINT@dsx@xisNeg@checkA
       0-\dummy  {\XINT@dsx@xisPos #1}%
    \xint@UDkrof
}%
\def\XINT@dsx@xisZero #1\Z #2{ {#2}{0}}% attention comme x > 0
\def\XINT@dsx@xisNeg@checkA #1\Z #2%
{%
    \XINT@dsx@xisNeg@checkA@ #2\Z {#1}%
}%
\def\XINT@dsx@xisNeg@checkA@ #1#2\Z #3%
{%
    \xint@zero #1\XINT@dsx@xisNeg@Azero 0\expandafter
    \XINT@dsx@xisNeg@checkx\expandafter
    {\romannumeral0\XINT@length {#3}}{#3}\Z {#1#2}%
}%
\def\XINT@dsx@xisNeg@Azero #1#2#3#4#5#6#7#8{ 0}%
\def\XINT@dsx@xisNeg@checkx #1%
{%
    \ifnum #1> 9
       \xint@afterfi {\xintError:TooBigDecimalShift 
                      \XINT@dsx@toobigx }%
    \else 
       \expandafter \XINT@dsx@zeroloop
    \fi
}%
\def\XINT@dsx@toobigx #1#2#3{ 0}%
\def\XINT@dsx@zeroloop #1%
{%
    \ifcase #1
        \XINT@dsx@exit
    \or
        \XINT@dsx@exiti
    \or
        \XINT@dsx@exitii
    \or
        \XINT@dsx@exitiii
    \or
        \XINT@dsx@exitiv
    \or
        \XINT@dsx@exitv
    \or
        \XINT@dsx@exitvi
    \or
        \XINT@dsx@exitvii
    \else
        \xint@afterfi 
         {\expandafter 
          \XINT@dsx@zeroloop
          \expandafter {\the\numexpr #1-8}00000000%
         }%
    \fi
}%
\def\XINT@dsx@exit #1\fi #2\Z {\fi \XINT@dsx@addzeros {#2}}%
\def\XINT@dsx@exiti #1\fi #2\Z {\fi \XINT@dsx@addzeros {0#2}}%
\def\XINT@dsx@exitii #1\fi #2\Z {\fi \XINT@dsx@addzeros {00#2}}%
\def\XINT@dsx@exitiii #1\fi #2\Z {\fi \XINT@dsx@addzeros {000#2}}%
\def\XINT@dsx@exitiv #1\fi #2\Z {\fi \XINT@dsx@addzeros {0000#2}}%
\def\XINT@dsx@exitv #1\fi #2\Z {\fi \XINT@dsx@addzeros {00000#2}}%
\def\XINT@dsx@exitvi #1\fi #2\Z {\fi \XINT@dsx@addzeros {000000#2}}%
\def\XINT@dsx@exitvii #1\fi #2\Z {\fi \XINT@dsx@addzeros {0000000#2}}%
\def\XINT@dsx@addzeros #1#2{ #2#1}%
\def\XINT@dsx@xisPos #1\Z #2%
{%
    \XINT@dsx@checksignA #2\Z {#1}%
}%
\def\XINT@dsx@checksignA #1%
{%
    \xint@UDzerominusfork
      #1-\dummy  \XINT@dsx@AisZero
      0#1\dummy  \XINT@dsx@AisNeg
       0-\dummy  {\XINT@dsx@AisPos #1}%
    \xint@UDkrof
}%
\def\XINT@dsx@AisZero #1\Z #2{ {0}{0}}%
\def\XINT@dsx@AisNeg #1\Z #2%
{%
    \expandafter
      \XINT@dsx@AisNeg@dosplit@andcheckfirst
    \romannumeral0\XINT@split@checksizex {#2}{#1}%
}%
\def\XINT@dsx@AisNeg@dosplit@andcheckfirst #1%
{%
    \XINT@dsx@AisNeg@checkiffirstempty #1\Z
}%
\def\XINT@dsx@AisNeg@checkiffirstempty #1%
{%
    \xint@z #1\XINT@dsx@AisNeg@finish@zero\Z
    \XINT@dsx@AisNeg@finish@notzero #1%
}%
\def\XINT@dsx@AisNeg@finish@zero\Z
    \XINT@dsx@AisNeg@finish@notzero\Z #1%
{%
    \expandafter
        \XINT@dsx@end
    \expandafter {\romannumeral0\XINT@num {-#1}}{0}%
}%
\def\XINT@dsx@AisNeg@finish@notzero #1\Z #2%
{%
    \expandafter
        \XINT@dsx@end
    \expandafter {\romannumeral0\XINT@num {#2}}{-#1}%
}%
\def\XINT@dsx@AisPos #1\Z #2%
{%
    \expandafter
      \XINT@dsx@AisPos@finish
    \romannumeral0\XINT@split@checksizex {#2}{#1}%
}%
\def\XINT@dsx@AisPos@finish #1#2%
{%
    \expandafter
        \XINT@dsx@end
    \expandafter {\romannumeral0\XINT@num {#2}}%
                 {\romannumeral0\XINT@num {#1}}%
}%
\def\XINT@dsx@end #1#2%
{%
    \expandafter\space\expandafter{#2}{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintDecSplit}, \csh{xintDecSplitL}, \csh{xintDecSplitR}}
% \begin{verbatim}
%     DECIMAL SPLIT
% v1.01: **New** behavior, for use in future extensions of the xint bundle:
% The macro \xintDecSplit {x}{A} first replaces A with |A| (*)
% This macro cuts the number into two pieces L and R. The concatenation LR
% always reproduces |A|, and R may be empty or have leading zeros. The
% position of the cut is specified by the first argument x. If x is zero or
% positive the cut location is x slots to the left of the right end of the
% number. If x becomes equal to or larger than the length of the number then L
% becomes empty. If x is negative the location of the cut is x slots to the
% right of the left end of the number. 
% (*) warning: this may change in a future version. Only the behavior
% for A non-negative is guaranteed to remain the same.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintDecSplitL {\romannumeral0\xintdecsplitl }%
\def\xintDecSplitR {\romannumeral0\xintdecsplitr }%
\def\xintdecsplitl 
{%
    \expandafter
       \xint@firstoftwo@andstop
    \romannumeral0\xintdecsplit 
}%
\def\xintdecsplitr 
{%
    \expandafter
       \xint@secondoftwo@andstop
    \romannumeral0\xintdecsplit 
}%
\def\xintDecSplit {\romannumeral0\xintdecsplit }%
\def\xintdecsplit #1#2%
{%
    \expandafter \xint@split \expandafter
    {\romannumeral0\xintiabs {#2}}{#1}%  fait expansion de A
}%
\def\xint@split #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@split@checksizex
    \expandafter\expandafter\expandafter
    {#2}{#1}% 
}%
\def\XINT@split@checksizex #1%
{%
    \ifnum\XINT@Len {#1} > 9  
       \xint@afterfi {\xintError:TooBigDecimalSplit
                     \XINT@split@bigx }%
    \else
       \expandafter\XINT@split@xfork
    \fi
    #1\Z
}%
\def\XINT@split@bigx  #1\Z #2%
{%
    \ifcase\XINT@Sgn {#1}
    \or \xint@afterfi { {}{#2}}% positive big x
    \else  
        \xint@afterfi { {#2}{}}% negative big x
    \fi
}%
\def\XINT@split@xfork #1%
{%
    \xint@UDzerominusfork
      #1-\dummy  \XINT@split@zerosplit
      0#1\dummy  \XINT@split@fromleft
       0-\dummy  {\XINT@split@fromright #1}%
    \xint@UDkrof
}%
\def\XINT@split@zerosplit #1\Z #2{ {#2}{}}%
\def\XINT@split@fromleft #1\Z #2%
{%
    \XINT@split@fromleft@loop {#1}{}#2\W\W\W\W\W\W\W\W\Z 
}%
\def\XINT@split@fromleft@loop #1%
{%
    \ifcase #1
        \XINT@split@fromleft@endsplit
    \or
        \XINT@split@fromleft@one@andend
    \or
        \XINT@split@fromleft@two@andend
    \or
        \XINT@split@fromleft@three@andend
    \or
        \XINT@split@fromleft@four@andend
    \or
        \XINT@split@fromleft@five@andend
    \or
        \XINT@split@fromleft@six@andend
    \or
        \XINT@split@fromleft@seven@andend
    \else
        \expandafter \XINT@split@fromleft@loop@perhaps
        \expandafter
            {\the\numexpr #1-8\expandafter\expandafter\expandafter }%
        \expandafter
        \XINT@split@fromleft@eight
    \fi
}%
\def\XINT@split@fromleft@endsplit #1\fi #2#3\W #4\Z 
                       {\expandafter\space\fi {#2}{#3}}%
\def\XINT@split@fromleft@eight #1#2#3#4#5#6#7#8#9%
{%
    #9{#1#2#3#4#5#6#7#8#9}%
}%
\def\XINT@split@fromleft@loop@perhaps #1#2%
{%
    \xint@w #2\XINT@split@fromleft@toofar\W \XINT@split@fromleft@loop
    {#1}%
}%
\def\XINT@split@fromleft@toofar\W \XINT@split@fromleft@loop #1#2#3\Z
{%
    \XINT@split@fromleft@toofar@b #2\Z
}%
\def\XINT@split@fromleft@toofar@b #1\W #2\Z
{%
    \space {#1}{}%
}%
\def\XINT@split@fromleft@one@andend #1\fi 
{\fi\expandafter\XINT@split@fromleft@checkiftoofar\XINT@split@fromleft@one }%
\def\XINT@split@fromleft@one #1#2{#2{#1#2}}%
\def\XINT@split@fromleft@two@andend #1\fi 
{\fi\expandafter\XINT@split@fromleft@checkiftoofar\XINT@split@fromleft@two }%
\def\XINT@split@fromleft@two #1#2#3{#3{#1#2#3}}%
\def\XINT@split@fromleft@three@andend #1\fi 
{\fi\expandafter\XINT@split@fromleft@checkiftoofar\XINT@split@fromleft@three }%
\def\XINT@split@fromleft@three #1#2#3#4{#4{#1#2#3#4}}%
\def\XINT@split@fromleft@four@andend #1\fi 
{\fi\expandafter\XINT@split@fromleft@checkiftoofar\XINT@split@fromleft@four }%
\def\XINT@split@fromleft@four #1#2#3#4#5{#5{#1#2#3#4#5}}%
\def\XINT@split@fromleft@five@andend #1\fi 
{\fi\expandafter\XINT@split@fromleft@checkiftoofar\XINT@split@fromleft@five }%
\def\XINT@split@fromleft@five #1#2#3#4#5#6{#6{#1#2#3#4#5#6}}%
\def\XINT@split@fromleft@six@andend #1\fi 
{\fi\expandafter\XINT@split@fromleft@checkiftoofar\XINT@split@fromleft@six }%
\def\XINT@split@fromleft@six #1#2#3#4#5#6#7{#7{#1#2#3#4#5#6#7}}%
\def\XINT@split@fromleft@seven@andend #1\fi 
{\fi\expandafter\XINT@split@fromleft@checkiftoofar\XINT@split@fromleft@seven }%
\def\XINT@split@fromleft@seven #1#2#3#4#5#6#7#8{#8{#1#2#3#4#5#6#7#8}}%
\def\XINT@split@fromleft@checkiftoofar #1#2#3\W #4\Z 
{%
    \xint@w #1\XINT@split@fromleft@wenttoofar\W
    \space {#2}{#3}%
}%
\def\XINT@split@fromleft@wenttoofar\W\space #1%
{%
    \XINT@split@fromleft@wenttoofar@b #1\Z
}%
\def\XINT@split@fromleft@wenttoofar@b #1\W #2\Z
{%
    \space {#1}%
}%
\def\XINT@split@fromright #1\Z #2%
{%
    \expandafter \XINT@split@fromright@a \expandafter
    {\romannumeral0\XINT@rev {#2}}{#1}{#2}%
}%
\def\XINT@split@fromright@a #1#2%
{%
    \XINT@split@fromright@loop {#2}{}#1\W\W\W\W\W\W\W\W\Z
}%
\def\XINT@split@fromright@loop #1%
{%
    \ifcase #1
        \expandafter\XINT@split@fromright@endsplit
    \or
        \XINT@split@fromright@one@andend
    \or
        \XINT@split@fromright@two@andend
    \or
        \XINT@split@fromright@three@andend
    \or
        \XINT@split@fromright@four@andend
    \or
        \XINT@split@fromright@five@andend
    \or
        \XINT@split@fromright@six@andend
    \or
        \XINT@split@fromright@seven@andend
    \else
        \expandafter \XINT@split@fromright@loop@perhaps
        \expandafter
            {\the\numexpr
            #1-8\expandafter\expandafter\expandafter }%
        \expandafter
        \XINT@split@fromright@eight
    \fi
}%
\def\XINT@split@fromright@endsplit #1#2\W #3\Z #4%
{%
    \expandafter\space\expandafter {\romannumeral0\XINT@rev{#2}}{#1}%
}%
\def\XINT@split@fromright@eight #1#2#3#4#5#6#7#8#9%
{%
    #9{#9#8#7#6#5#4#3#2#1}%
}%
\def\XINT@split@fromright@loop@perhaps #1#2%
{%
    \xint@w #2\XINT@split@fromright@toofar\W\XINT@split@fromright@loop
    {#1}%
}%
\def\XINT@split@fromright@toofar\W\XINT@split@fromright@loop #1#2#3\Z { {}}%
\def\XINT@split@fromright@one@andend #1\fi {\fi\expandafter
      \XINT@split@fromright@checkiftoofar\XINT@split@fromright@one }%
\def\XINT@split@fromright@one #1#2{#2{#2#1}}%
\def\XINT@split@fromright@two@andend #1\fi {\fi\expandafter
      \XINT@split@fromright@checkiftoofar\XINT@split@fromright@two }%
\def\XINT@split@fromright@two #1#2#3{#3{#3#2#1}}%
\def\XINT@split@fromright@three@andend #1\fi {\fi\expandafter
      \XINT@split@fromright@checkiftoofar\XINT@split@fromright@three }%
\def\XINT@split@fromright@three #1#2#3#4{#4{#4#3#2#1}}%
\def\XINT@split@fromright@four@andend #1\fi {\fi\expandafter
      \XINT@split@fromright@checkiftoofar\XINT@split@fromright@four }%
\def\XINT@split@fromright@four #1#2#3#4#5{#5{#5#4#3#2#1}}%
\def\XINT@split@fromright@five@andend #1\fi {\fi\expandafter
      \XINT@split@fromright@checkiftoofar\XINT@split@fromright@five }%
\def\XINT@split@fromright@five #1#2#3#4#5#6{#6{#6#5#4#3#2#1}}%
\def\XINT@split@fromright@six@andend #1\fi {\fi\expandafter
      \XINT@split@fromright@checkiftoofar\XINT@split@fromright@six }%
\def\XINT@split@fromright@six #1#2#3#4#5#6#7{#7{#7#6#5#4#3#2#1}}%
\def\XINT@split@fromright@seven@andend #1\fi {\fi\expandafter
      \XINT@split@fromright@checkiftoofar\XINT@split@fromright@seven }%
\def\XINT@split@fromright@seven #1#2#3#4#5#6#7#8{#8{#8#7#6#5#4#3#2#1}}%
\def\XINT@split@fromright@checkiftoofar #1%
{%
    \xint@w #1\XINT@split@fromright@wenttoofar\W
    \XINT@split@fromright@endsplit
}%
\def\XINT@split@fromright@wenttoofar\W\XINT@split@fromright@endsplit #1\Z #2%
    { {}{#2}}%
\XINT@restorecatcodes@endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xint>\relax
%\def<*xintgcd>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xint>
%<*xintgcd>
% \section{Package \xintgcdname implementation}
% 
% The commenting is currently (\docdate) very sparse.
%
% \localtableofcontents
% \subsection{Catcodes, \eTeX{} detection, reload detection}
%
% The code for reload detection is copied from \textsc{Heiko
% Oberdiek}'s packages, and adapted here to check for previous
% loading of the master \xintname package.
%
% The method for catcodes is slightly different, but still
% directly inspired by these packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \def\space { }%
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xintgcd.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xint.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintgcd}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintgcd.sty
      \ifx\w\relax % but xint.sty not yet loaded.
         \y{xintgcd}{Package xint is required}%
         \y{xintgcd}{Will try \string\input\space xint.sty}%
         \def\z{\endgroup\input xint.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xint.sty not yet loaded.
            \y{xintgcd}{Package xint is required}%
            \y{xintgcd}{Will try \string\RequirePackage{xint}}%
            \def\z{\endgroup\RequirePackage{xint}}%
          \fi
      \else
        \y{xintgcd}{I was already loaded, aborting input}%
        \aftergroup\endinput
      \fi
    \fi
  \fi
\z%
%    \end{macrocode}
% \subsection{Confirmation of \xintname loading}
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \def\empty {}%
  \expandafter\let\expandafter\w\csname ver@xint.sty\endcsname
  \ifx\w\relax % Plain TeX, user gave a file name at the prompt
      \y{xintgcd}{Loading of package xint failed, aborting input}%
      \aftergroup\endinput
  \fi
  \ifx\w\empty % LaTeX, user gave a file name at the prompt
      \y{xintgcd}{Loading of package xint failed, aborting input}%
      \aftergroup\endinput
  \fi
\endgroup%
%    \end{macrocode}
% \subsection{Catcodes}
%
% Perhaps catcodes have changed after the loading of \xintname
% and prior to the current loading of \xintgcdname, so we can not employ
% the |\XINT@restorecatcodes@endinput| in this style file. But
% there is no problem using |\XINT@setcatcodes|.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \def\x
  {%
      \endgroup
      \edef\XINT@gcd@restorecatcodes@endinput
      {%
        \catcode36=\the\catcode36   % $
        \catcode47=\the\catcode47   % /
        \catcode41=\the\catcode41   % )
        \catcode40=\the\catcode40   % (
        \catcode42=\the\catcode42   % *
        \catcode43=\the\catcode43   % +
        \catcode62=\the\catcode62   % >
        \catcode60=\the\catcode60   % <
        \catcode58=\the\catcode58   % :
        \catcode46=\the\catcode46   % .
        \catcode45=\the\catcode45   % -
        \catcode44=\the\catcode44   % ,
        \catcode35=\the\catcode35   % #
        \catcode64=\the\catcode64   % @
        \catcode125=\the\catcode125 % }
        \catcode123=\the\catcode123 % {
        \endlinechar=\the\endlinechar
        \catcode13=\the\catcode13   % ^^M
        \catcode32=\the\catcode32   % 
        \catcode61=\the\catcode61   % =
        \noexpand\endinput
      }%
      \XINT@setcatcodes
      \catcode36=3  % $
  }%
\x
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\begingroup
  \catcode91=12 % [
  \catcode93=12 % ]
  \catcode58=12 % :
  \expandafter\ifx\csname ProvidesPackage\endcsname\relax
    \def\x#1#2#3[#4]{\endgroup
      \immediate\write-1{Package: #3 #4}%
      \xdef#1{#4}%
    }%
  \else
    \def\x#1#2[#3]{\endgroup
      #2[{#3}]%
      \ifx#1\@undefined
        \xdef#1{#3}%
      \fi
      \ifx#1\relax
        \xdef#1{#3}%
      \fi
    }%
  \fi
\expandafter\x\csname ver@xintgcd.sty\endcsname
\ProvidesPackage{xintgcd}%
  [2013/04/14 v1.03 Euclide algorithm with xint package (jfB)]%
%    \end{macrocode}
% \subsection{\csh{xintGCD}}
%    \begin{macrocode}
\def\xintGCD {\romannumeral0\xintgcd }%
\def\xintgcd #1%
{%
    \expandafter \XINT@gcd \expandafter
      {\romannumeral0\xintiabs {#1}}%
}%
\def\XINT@gcd #1#2%
{%
    \expandafter
      \XINT@gcd@fork
    \romannumeral0\xintiabs {#2}\Z #1\Z
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Ici #3#4=A, #1#2=B
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@gcd@fork #1#2\Z #3#4\Z
{%
    \xint@UDzerofork
      #1\dummy \XINT@gcd@BisZero
      #3\dummy \XINT@gcd@AisZero
       0\dummy \XINT@gcd@loop
    \xint@UDkrof
    {#1#2}{#3#4}%
}%
\def\XINT@gcd@AisZero #1#2{ #1}%
\def\XINT@gcd@BisZero #1#2{ #2}%
\def\XINT@gcd@CheckRem #1#2\Z
{%
    \xint@zero #1\xint@gcd@end0\XINT@gcd@loop {#1#2}%
}%
\def\xint@gcd@end0\XINT@gcd@loop #1#2{ #2}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #1=B, #2=A
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@gcd@loop #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@gcd@CheckRem
    \expandafter\xint@secondoftwo
    \romannumeral0\XINT@div@prepare {#1}{#2}\Z 
    {#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintBezout}}
%    \begin{macrocode}
\def\xintBezout {\romannumeral0\xintbezout }%
\def\xintbezout #1%
{%
    \expandafter\expandafter\expandafter
      \xint@bezout
    \expandafter\expandafter\expandafter
      {#1}%
}%
\def\xint@bezout #1#2%
{\expandafter\expandafter\expandafter
    \XINT@bezout@fork #2\Z #1\Z
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #3#4 = A, #1#2=B
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@fork #1#2\Z #3#4\Z
{%
    \xint@UDzerosfork
     #1#3\dummy \XINT@bezout@botharezero
      #10\dummy \XINT@bezout@secondiszero
      #30\dummy \XINT@bezout@firstiszero
       00\dummy 
        {\xint@UDsignsfork
          #1#3\dummy \XINT@bezout@minusminus % A < 0, B < 0
           #1-\dummy \XINT@bezout@minusplus  % A > 0, B < 0
           #3-\dummy \XINT@bezout@plusminus  % A < 0, B > 0
            --\dummy \XINT@bezout@plusplus   % A > 0, B > 0
         \xint@UDkrof }%
    \xint@UDkrof
    {#2}{#4}#1#3{#3#4}{#1#2}% #1#2=B, #3#4=A
}%
\def\XINT@bezout@botharezero #1#2#3#4#5#6%
{%
    \xintError:NoBezoutForZeros
    \space {0}{0}{0}{0}{0}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% attention première entrée doit être ici (-1)^n donc 1
% #4#2=0 = A, B = #3#1
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@firstiszero #1#2#3#4#5#6%
{%
    \xint@UDsignfork
      #3\dummy { {0}{#3#1}{0}{1}{#1}}%
       -\dummy { {0}{#3#1}{0}{-1}{#1}}%
    \xint@UDkrof
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #4#2= A, B = #3#1 = 0
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@secondiszero #1#2#3#4#5#6%
{%
    \xint@UDsignfork
       #4\dummy{ {#4#2}{0}{-1}{0}{#2}}%
        -\dummy{ {#4#2}{0}{1}{0}{#2}}%
    \xint@UDkrof
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% #4#2= A < 0, #3#1 = B < 0
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@minusminus #1#2#3#4%
{%
    \expandafter\XINT@bezout@mm@post
    \romannumeral0\XINT@bezout@loop@a 1{#1}{#2}1001%
}%
\def\XINT@bezout@mm@post #1#2%
{%
    \expandafter \XINT@bezout@mm@postb \expandafter
        {\romannumeral0\xintiopp{#2}}{\romannumeral0\xintiopp{#1}}%
}%
\def\XINT@bezout@mm@postb #1#2%
{%
    \expandafter
        \XINT@bezout@mm@postc
    \expandafter {#2}{#1}%
}%
\def\XINT@bezout@mm@postc #1#2#3#4#5%
{%
    \space {#4}{#5}{#1}{#2}{#3}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% minusplus  #4#2= A > 0, B < 0
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@minusplus #1#2#3#4%
{%
    \expandafter\XINT@bezout@mp@post
    \romannumeral0\XINT@bezout@loop@a 1{#1}{#4#2}1001%
}%
\def\XINT@bezout@mp@post #1#2%
{%
    \expandafter \XINT@bezout@mp@postb \expandafter
      {\romannumeral0\xintiopp {#2}}{#1}%
}%
\def\XINT@bezout@mp@postb #1#2#3#4#5%
{%
    \space {#4}{#5}{#2}{#1}{#3}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% plusminus  A < 0, B > 0
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@plusminus #1#2#3#4%
{%
    \expandafter\XINT@bezout@pm@post
    \romannumeral0\XINT@bezout@loop@a 1{#3#1}{#2}1001%
}%
\def\XINT@bezout@pm@post #1%
{%
    \expandafter \XINT@bezout@pm@postb \expandafter
        {\romannumeral0\xintiopp{#1}}%
}%
\def\XINT@bezout@pm@postb #1#2#3#4#5%
{%
    \space {#4}{#5}{#1}{#2}{#3}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% plusplus
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@plusplus #1#2#3#4%
{%
    \expandafter\XINT@bezout@pp@post
    \romannumeral0\XINT@bezout@loop@a 1{#3#1}{#4#2}1001%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% la parité (-1)^N est en #1, et on la jette ici.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@pp@post #1#2#3#4#5%
{%
    \space {#4}{#5}{#1}{#2}{#3}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% n = 0: 1BAalpha(0)beta(0)alpha(-1)beta(-1)
% n général:
% {(-1)^n}{r(n-1)}{r(n-2)}{alpha(n-1)}{beta(n-1)}{alpha(n-2)}{beta(n-2)}
% #2 = B, #3 = A
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@loop@a #1#2#3%
{%
    \expandafter\XINT@bezout@loop@b
    \expandafter{\the\numexpr -#1\expandafter }%
    \romannumeral0\XINT@div@prepare {#2}{#3}{#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Le q(n) a ici une existence éphémère, dans le version Bezout Algorithm
% il faudra le conserver. On voudra à la fin
% {{q(n)}{r(n)}{alpha(n)}{beta(n)}}
% De plus ce n'est plus (-1)^n que l'on veut mais n. (ou dans un autre ordre)
% {-(-1)^n}{q(n)}{r(n)}{r(n-1)}{alpha(n-1)}{beta(n-1)}{alpha(n-2)}{beta(n-2)}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@loop@b #1#2#3#4#5#6#7#8%
{%
    \expandafter \XINT@bezout@loop@c \expandafter
        {\romannumeral0\xintiadd{\XINT@Mul{#5}{#2}}{#7}}%
        {\romannumeral0\xintiadd{\XINT@Mul{#6}{#2}}{#8}}%
    {#1}{#3}{#4}{#5}{#6}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {alpha(n)}{->beta(n)}{-(-1)^n}{r(n)}{r(n-1)}{alpha(n-1)}{beta(n-1)}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@loop@c #1#2%
{%
    \expandafter \XINT@bezout@loop@d \expandafter
        {#2}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {beta(n)}{alpha(n)}{(-1)^(n+1)}{r(n)}{r(n-1)}{alpha(n-1)}{beta(n-1)}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@loop@d #1#2#3#4#5%
{%
    \XINT@bezout@loop@e #4\Z {#3}{#5}{#2}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% r(n)\Z {(-1)^(n+1)}{r(n-1)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@loop@e #1#2\Z 
{%
    \xint@zero #1\xint@bezout@loop@exit0\XINT@bezout@loop@f
    {#1#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {r(n)}{(-1)^(n+1)}{r(n-1)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezout@loop@f #1#2%
{%
    \XINT@bezout@loop@a {#2}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {(-1)^(n+1)}{r(n)}{r(n-1)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}
% et itération
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xint@bezout@loop@exit0\XINT@bezout@loop@f #1#2%
{%
    \ifcase #2
    \or  \expandafter\XINT@bezout@exiteven
    \else\expandafter\XINT@bezout@exitodd
    \fi
}%
\def\XINT@bezout@exiteven #1#2#3#4#5%
{%
    \space {#5}{#4}{#1}%
}%
\def\XINT@bezout@exitodd #1#2#3#4#5%
{%
    \space {-#5}{-#4}{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintEuclideAlgorithm}}
% \begin{verbatim}
% Pour Euclide: 
% {N}{A}{D=r(n)}{B}{q1}{r1}{q2}{r2}{q3}{r3}....{qN}{rN=0}
% u<2n> = u<2n+3>u<2n+2> + u<2n+4> à la n ième étape
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintEuclideAlgorithm {\romannumeral0\xinteuclidealgorithm }%
\def\xinteuclidealgorithm #1%
{%
    \expandafter \XINT@euc \expandafter
      {\romannumeral0\xintiabs {#1}}%
}%
\def\XINT@euc #1#2%
{%
    \expandafter
      \XINT@euc@fork
    \romannumeral0\xintiabs {#2}\Z #1\Z
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Ici #3#4=A, #1#2=B
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@euc@fork #1#2\Z #3#4\Z
{%
    \xint@UDzerofork
      #1\dummy \XINT@euc@BisZero
      #3\dummy \XINT@euc@AisZero
       0\dummy \XINT@euc@a
    \xint@UDkrof
    {0}{#1#2}{#3#4}{{#3#4}{#1#2}}{}\Z
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Le {} pour protéger {{A}{B}} si on s'arrête après une étape (B divise A)
% On va renvoyer:
% {N}{A}{D=r(n)}{B}{q1}{r1}{q2}{r2}{q3}{r3}....{qN}{rN=0}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@euc@AisZero #1#2#3#4#5#6{ {1}{0}{#2}{#2}{0}{0}}%
\def\XINT@euc@BisZero #1#2#3#4#5#6{ {1}{0}{#3}{#3}{0}{0}}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {n}{rn}{an}{{qn}{rn}}...{{A}{B}}{}\Z
%  an = r(n-1)
% Pour n=0 on a juste {0}{B}{A}{{A}{B}}{}\Z
% \XINT@div@prepare {u}{v} divise v par u
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@euc@a #1#2#3%
{%
    \expandafter
        \XINT@euc@b
    \expandafter {\the\numexpr #1+1\expandafter }%
    \romannumeral0\XINT@div@prepare {#2}{#3}{#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {n+1}{q(n+1)}{r(n+1)}{rn}{{qn}{rn}}...
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@euc@b #1#2#3#4%
{%
    \XINT@euc@c #3\Z {#1}{#3}{#4}{{#2}{#3}}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% r(n+1)\Z {n+1}{r(n+1)}{r(n)}{{q(n+1)}{r(n+1)}}{{qn}{rn}}...
% Test si r(n+1) est nul.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@euc@c #1#2\Z 
{%
    \xint@zero #1\xint@euc@end0\XINT@euc@a
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {n+1}{r(n+1)}{r(n)}{{q(n+1)}{r(n+1)}}...{}\Z
% Ici r(n+1) = 0. On arrête on se prépare à inverser.
% {n+1}{0}{r(n)}{{q(n+1)}{r(n+1)}}.....{{q1}{r1}}{{A}{B}}{}\Z
% On veut renvoyer:
% {N=n+1}{A}{D=r(n)}{B}{q1}{r1}{q2}{r2}{q3}{r3}....{qN}{rN=0}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xint@euc@end0\XINT@euc@a #1#2#3#4\Z%
{%
      \expandafter\xint@euc@end@
      \romannumeral0%
      \XINT@rord@main {}#4{{#1}{#3}}%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
}%
\def\xint@euc@end@ #1#2#3%
{%
    \space {#1}{#3}{#2}%
}%
%    \end{macrocode}
% \subsection{\csh{xintBezoutAlgorithm}}
% \begin{verbatim}
% Pour Bezout: objectif, renvoyer
% alpha0=1, beta0=0
% alpha(-1)=0, beta(-1)=1
% {N}{A}{0}{1}{D=r(n)}{B}{1}{0}{q1}{r1}{alpha1=q1}{beta1=1}
%       {q2}{r2}{alpha2}{beta2}....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintBezoutAlgorithm {\romannumeral0\xintbezoutalgorithm }%
\def\xintbezoutalgorithm #1%
{%
    \expandafter \XINT@bezalg \expandafter
      {\romannumeral0\xintiabs {#1}}%
}%
\def\XINT@bezalg #1#2%
{%
    \expandafter
      \XINT@bezalg@fork
    \romannumeral0\xintiabs {#2}\Z #1\Z
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Ici #3#4=A, #1#2=B
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezalg@fork #1#2\Z #3#4\Z
{%
    \xint@UDzerofork
      #1\dummy \XINT@bezalg@BisZero
      #3\dummy \XINT@bezalg@AisZero
       0\dummy \XINT@bezalg@a
    \xint@UDkrof
    0{#1#2}{#3#4}1001{{#3#4}{#1#2}}{}\Z
}%
\def\XINT@bezalg@AisZero #1#2#3\Z{ {1}{0}{0}{1}{#2}{#2}{1}{0}{0}{0}{0}{1}}%
\def\XINT@bezalg@BisZero #1#2#3#4\Z{ {1}{0}{0}{1}{#3}{#3}{1}{0}{0}{0}{0}{1}}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% pour préparer l'étape n+1 il faut
% {n}{r(n)}{r(n-1)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}
%                    {{q(n)}{r(n)}{alpha(n)}{beta(n)}}...
% division de #3 par #2
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezalg@a #1#2#3%
{%
    \expandafter
        \XINT@bezalg@b
    \expandafter {\the\numexpr #1+1\expandafter }%
    \romannumeral0\XINT@div@prepare {#2}{#3}{#2}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {n+1}{q(n+1)}{r(n+1)}{r(n)}{alpha(n)}{beta(n)}{alpha(n-1)}{beta(n-1)}...
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezalg@b #1#2#3#4#5#6#7#8%
{%
    \expandafter\XINT@bezalg@c\expandafter
     {\romannumeral0\xintiadd {\xintiMul {#6}{#2}}{#8}}%
     {\romannumeral0\xintiadd {\xintiMul {#5}{#2}}{#7}}%
     {#1}{#2}{#3}{#4}{#5}{#6}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {beta(n+1)}{alpha(n+1)}{n+1}{q(n+1)}{r(n+1)}{r(n)}{alpha(n)}{beta(n}}%
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezalg@c #1#2#3#4#5#6%
{%
    \expandafter\XINT@bezalg@d\expandafter
     {#2}{#3}{#4}{#5}{#6}{#1}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {alpha(n+1)}{n+1}{q(n+1)}{r(n+1)}{r(n)}{beta(n+1)}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezalg@d #1#2#3#4#5#6#7#8%
{%
    \XINT@bezalg@e #4\Z {#2}{#4}{#5}{#1}{#6}{#7}{#8}{{#3}{#4}{#1}{#6}}%
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% r(n+1)\Z {n+1}{r(n+1)}{r(n)}{alpha(n+1)}{beta(n+1)}
%                             {alpha(n)}{beta(n)}{q,r,alpha,beta(n+1)}
% Test si r(n+1) est nul.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\XINT@bezalg@e #1#2\Z
{%
    \xint@zero #1\xint@bezalg@end0\XINT@bezalg@a
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% Ici r(n+1) = 0. On arrête on se prépare à inverser.
% {n+1}{r(n+1)}{r(n)}{alpha(n+1)}{beta(n+1)}%
%                    {alpha(n)}{beta(n)}%
%                     {q,r,alpha,beta(n+1)}...{{A}{B}}{}\Z
% On veut renvoyer
% {N}{A}{0}{1}{D=r(n)}{B}{1}{0}{q1}{r1}{alpha1=q1}{beta1=1}
%       {q2}{r2}{alpha2}{beta2}....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xint@bezalg@end0\XINT@bezalg@a #1#2#3#4#5#6#7#8\Z 
{%
      \expandafter\xint@bezalg@end@
      \romannumeral0%
      \XINT@rord@main {}#8{{#1}{#3}}%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
}%
%    \end{macrocode}
% \vspace*{-.5\baselineskip}
% \begin{verbatim}
% {N}{D}{A}{B}{q1}{r1}{alpha1=q1}{beta1=1}{q2}{r2}{alpha2}{beta2}
%      ....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}
% On veut renvoyer
% {N}{A}{0}{1}{D=r(n)}{B}{1}{0}{q1}{r1}{alpha1=q1}{beta1=1}
%        {q2}{r2}{alpha2}{beta2}....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xint@bezalg@end@ #1#2#3#4%
{%
    \space {#1}{#3}{0}{1}{#2}{#4}{1}{0}%
}%
%    \end{macrocode}
% \subsection{\csh{xintTypesetEuclideAlgorithm}}
% \begin{verbatim}
% TYPESETTING
% Organisation: 
% {N}{A}{D}{B}{q1}{r1}{q2}{r2}{q3}{r3}....{qN}{rN=0}
% \U1 = N = nombre d'étapes, \U3 = PGCD, \U2 = A, \U4=B
% q1 = \U5, q2 = \U7 --> qn = \U<2n+3>, rn = \U<2n+4>
% bn = rn. B = r0. A=r(-1)
% r(n-2) = q(n)r(n-1)+r(n) (n e étape) (n au moins 1)
% \U{2n} = \U{2n+3} \times \U{2n+2} + \U{2n+4}, n e étape.
% avec n entre 1 et N.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintTypesetEuclideAlgorithm #1#2%
{% l'algo remplace #1 et #2 par |#1| et |#2|
  \par
  \begingroup
    \xintAssignArray\xintEuclideAlgorithm {#1}{#2}\to\U
    \edef\A{\U2}\edef\B{\U4}\edef\N{\U1}%
    \setbox 0 \vbox{\halign {$##$\cr \A\cr \B \cr}}%
    \noindent
    \count 255 1
    \loop
      \hbox to \wd 0 {\hfil$\U{\the\numexpr 2*\count 255\relax}$}%
      ${} =  \U{\the\numexpr 2*\count 255 + 3\relax}
      \times \U{\the\numexpr 2*\count 255 + 2\relax}
          +  \U{\the\numexpr 2*\count 255 + 4\relax}$%
    \ifnum \count 255 < \N
      \hfill\break
      \advance \count 255 1
    \repeat
  \par
  \endgroup
}%
%    \end{macrocode}
% \subsection{\csh{xintTypesetBezoutAlgorithm}}
% \begin{verbatim}
% Pour Bezout on a: 
% {N}{A}{0}{1}{D=r(n)}{B}{1}{0}{q1}{r1}{alpha1=q1}{beta1=1}
%             {q2}{r2}{alpha2}{beta2}....{qN}{rN=0}{alphaN=A/D}{betaN=B/D}%
% Donc 4N+8 termes
% U1 = N, U2= A, U5=D, U6=B, 
% q1 = U9, qn = U{4n+5}, n au moins 1
% rn = U{4n+6}    , n au moins -1
% alpha(n) = U{4n+7}, n au moins -1
% beta(n)  = U{4n+8}, n au moins -1
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintTypesetBezoutAlgorithm #1#2%
{%
  \par
  \begingroup
    \parindent0pt
    \xintAssignArray\xintBezoutAlgorithm {#1}{#2}\to\BEZ
    \edef\A{\BEZ2}\edef\B{\BEZ6}\edef\N{\BEZ1}% A = |#1|, B = |#2|
    \setbox 0 \vbox{\halign {$##$\cr \A\cr \B \cr}}%
    \count 255 1
    \loop
      \noindent
      \hbox to \wd 0 {\hfil$\BEZ{\the\numexpr 4*\count 255 - 2\relax}$}%
      ${} =  \BEZ{\the\numexpr 4*\count 255 + 5\relax}
      \times \BEZ{\the\numexpr 4*\count 255 + 2\relax}
          +  \BEZ{\the\numexpr 4*\count 255 + 6\relax}$\hfill\break
      \hbox to \wd 0 {\hfil$\BEZ{\the\numexpr 4*\count 255 +7\relax}$}%
      ${} = \BEZ{\the\numexpr 4*\count 255 + 5\relax}
      \times \BEZ{\the\numexpr 4*\count 255 + 3\relax}
          +  \BEZ{\the\numexpr 4*\count 255 - 1\relax}$\hfill\break
      \hbox to \wd 0 {\hfil$\BEZ{\the\numexpr 4*\count 255 +8\relax}$}% 
      ${} =  \BEZ{\the\numexpr 4*\count 255 + 5\relax}
      \times \BEZ{\the\numexpr 4*\count 255 + 4\relax}
          +  \BEZ{\the\numexpr 4*\count 255 \relax}$
      \endgraf
    \ifnum \count 255 < \N
    \advance \count 255 1
  \repeat
  \par
    \edef\U{\BEZ{\the\numexpr 4*\N + 4\relax}}%
    \edef\V{\BEZ{\the\numexpr 4*\N + 3\relax}}%
    \edef\D{\BEZ5}%
    \ifodd\N\relax
       $\U\times\A  - \V\times \B = -\D$%
    \else
       $\U\times\A - \V\times\B = \D$%
    \fi
  \par
  \endgroup
}%
\XINT@gcd@restorecatcodes@endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xintgcd>\relax
%\def<*xintfrac>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xintgcd>
%<*xintfrac>
% \section{Package \xintfracname implementation}
% 
% The commenting is currently (\docdate) very sparse.
%
% \localtableofcontents
% \subsection{Catcodes, \eTeX{} detection, reload detection}
%
% The code for reload detection is copied from \textsc{Heiko
% Oberdiek}'s packages, and adapted here to check for previous
% loading of the master \xintname package.
%
% The method for catcodes is slightly different, but still
% directly inspired by these packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \def\space { }%
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xintfrac.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xint.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintfrac}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintfrac.sty
      \ifx\w\relax % but xint.sty not yet loaded.
         \y{xintfrac}{Package xint is required}%
         \y{xintfrac}{Will try \string\input\space xint.sty}%
         \def\z{\endgroup\input xint.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xint.sty not yet loaded.
            \y{xintfrac}{Package xint is required}%
            \y{xintfrac}{Will try \string\RequirePackage{xint}}%
            \def\z{\endgroup\RequirePackage{xint}}%
          \fi
      \else
        \y{xintfrac}{I was already loaded, aborting input}%
        \aftergroup\endinput
      \fi
    \fi
  \fi
\z%
%    \end{macrocode}
% \subsection{Confirmation of \xintname loading}
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \def\empty {}%
  \expandafter\let\expandafter\w\csname ver@xint.sty\endcsname
  \ifx\w\relax % Plain TeX, user gave a file name at the prompt
      \y{xintfrac}{Loading of package xint failed, aborting input}%
      \aftergroup\endinput
  \fi
  \ifx\w\empty % LaTeX, user gave a file name at the prompt
      \y{xintfrac}{Loading of package xint failed, aborting input}%
      \aftergroup\endinput
  \fi
\endgroup%
%    \end{macrocode}
% \subsection{Catcodes}
%
% Perhaps catcodes have changed after the loading of \xintname
% and prior to the current loading of \xintfracname, so we can not employ
% the |\XINT@restorecatcodes@endinput| in this style file. But
% there is no problem using |\XINT@setcatcodes|.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \def\x
  {%
      \endgroup
      \edef\XINT@frac@restorecatcodes@endinput
      {%
        \catcode94=\the\catcode94   % ^
        \catcode93=\the\catcode93   % ]
        \catcode91=\the\catcode91   % [
        \catcode47=\the\catcode47   % /
        \catcode41=\the\catcode41   % )
        \catcode40=\the\catcode40   % (
        \catcode42=\the\catcode42   % *
        \catcode43=\the\catcode43   % +
        \catcode62=\the\catcode62   % >
        \catcode60=\the\catcode60   % <
        \catcode58=\the\catcode58   % :
        \catcode46=\the\catcode46   % .
        \catcode45=\the\catcode45   % -
        \catcode44=\the\catcode44   % ,
        \catcode35=\the\catcode35   % #
        \catcode64=\the\catcode64   % @
        \catcode125=\the\catcode125 % }
        \catcode123=\the\catcode123 % {
        \endlinechar=\the\endlinechar
        \catcode13=\the\catcode13   % ^^M
        \catcode32=\the\catcode32   % 
        \catcode61=\the\catcode61   % =
        \noexpand\endinput
      }%
      \XINT@setcatcodes
      \catcode91=12 % [
      \catcode93=12 % ]
      \catcode94=7  % ^
  }%
\x
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\begingroup
  \catcode58=12 % :
  \expandafter\ifx\csname ProvidesPackage\endcsname\relax
    \def\x#1#2#3[#4]{\endgroup
      \immediate\write-1{Package: #3 #4}%
      \xdef#1{#4}%
    }%
  \else
    \def\x#1#2[#3]{\endgroup
      #2[{#3}]%
      \ifx#1\@undefined
        \xdef#1{#3}%
      \fi
      \ifx#1\relax
        \xdef#1{#3}%
      \fi
    }%
  \fi
\expandafter\x\csname ver@xintfrac.sty\endcsname
\ProvidesPackage{xintfrac}%
  [2013/04/14 v1.03 Expandable operations on fractions (jfB)]%
%    \end{macrocode}
% \subsection{\csh{xintLen}}
%    \begin{macrocode}
\def\xintLen {\romannumeral0\xintlen }%
\def\xintlen #1%
{%
    \expandafter\XINT@flen\romannumeral0\XINT@infrac {#1}%
}%
\def\XINT@flen #1#2#3%
{%
    \expandafter\space
    \the\numexpr -1+\XINT@Abs {#1}+\XINT@Len {#2}+\XINT@Len {#3}\relax
}%
%    \end{macrocode}
% \subsection{\csh{XINT@outfrac}}
%    \begin{macrocode}
\def\XINT@outfrac #1#2#3%
{%
    \ifcase\XINT@Sgn{#3}
        \expandafter \XINT@outfrac@divisionbyzero
    \or
        \expandafter \XINT@outfrac@P
    \else
        \expandafter \XINT@outfrac@N 
    \fi
    {#2}{#3}[#1]%
}%
\def\XINT@outfrac@divisionbyzero #1#2%
    {\xintError:DivisionByZero\space #1/0}%
\def\XINT@outfrac@P #1#2%
{%
    \ifcase\XINT@Sgn{#1}
        \expandafter\XINT@outfrac@Zero
    \fi
    \space #1/#2%
}%
\def\XINT@outfrac@Zero #1[#2]{ 0[0]}%
\def\XINT@outfrac@N #1#2%
{%
    \expandafter\XINT@outfrac@N@a\expandafter
    {\romannumeral0\XINT@opp #2}{\romannumeral0\XINT@opp #1}%
}%
\def\XINT@outfrac@N@a #1#2%
{%
    \expandafter\XINT@outfrac@P\expandafter {#2}{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintNumerator}}
%    \begin{macrocode}
\def\xintNumerator {\romannumeral0\xintnumerator }%
\def\xintnumerator 
{%
    \expandafter\XINT@numer\romannumeral0\XINT@infrac
}%
\def\XINT@numer #1%
{%
    \ifcase\XINT@Sgn {#1}
      \expandafter\XINT@numer@B
    \or
      \expandafter\XINT@numer@A
    \else
      \expandafter\XINT@numer@B
    \fi 
    {#1}%
}%
\def\XINT@numer@A #1#2#3{\xint@dsh {#2}{-#1}}%
\def\XINT@numer@B #1#2#3{ #2}%
%    \end{macrocode}
% \subsection{\csh{xintDenominator}}
%    \begin{macrocode}
\def\xintDenominator {\romannumeral0\xintdenominator }%
\def\xintdenominator 
{%
    \expandafter\XINT@denom\romannumeral0\XINT@infrac
}%
\def\XINT@denom #1%
{%
    \ifcase\XINT@Sgn {#1}
      \expandafter\XINT@denom@B
    \or
      \expandafter\XINT@denom@A
    \else
      \expandafter\XINT@denom@B
    \fi 
    {#1}%
}%
\def\XINT@denom@A #1#2#3{ #3}%
\def\XINT@denom@B #1#2#3{\xint@dsh {#3}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintFrac}}
%    \begin{macrocode}
\def\xintFrac {\romannumeral0\xintfrac }%
\def\xintfrac #1%
{%
    \expandafter\XINT@@frac@A\romannumeral0\XINT@infrac {#1}%
}%
\def\XINT@@frac@A #1{\XINT@@frac@B #1\Z }%
\def\XINT@@frac@B #1#2\Z 
{%
    \xint@zero #1\XINT@@frac@C 0\XINT@@frac@D {10^{#1#2}}%
}%
\def\XINT@@frac@C #1#2#3#4#5% 
{%
    \ifcase\XINT@isOne {#5}
    \or \xint@afterfi {\expandafter\xint@firstoftwo@andstop\xint@gobble@two }%
    \fi
    \space
    \frac {#4}{#5}%
}%
\def\XINT@@frac@D #1#2#3%
{%
    \ifcase\XINT@isOne {#3}
    \or \XINT@@frac@E
    \fi
    \space
    \frac {#2}{#3}#1%
}%
\def\XINT@@frac@E \fi #1#2#3#4{\fi \space #3\cdot }%
%    \end{macrocode}
% \subsection{\csh{xintFwOver}}
%    \begin{macrocode}
\def\xintFwOver {\romannumeral0\xintfwover }%
\def\xintfwover #1%
{%
    \expandafter\XINT@fwover@A\romannumeral0\XINT@infrac {#1}%
}%
\def\XINT@fwover@A #1{\XINT@fwover@B #1\Z }%
\def\XINT@fwover@B #1#2\Z 
{%
    \xint@zero #1\XINT@fwover@C 0\XINT@fwover@D {10^{#1#2}}%
}%
\def\XINT@fwover@C #1#2#3#4#5% 
{%
    \ifcase\XINT@isOne {#5}
       \xint@afterfi { {#4\over #5}}%
    \or 
       \xint@afterfi { #4\cdot }%
    \fi
}%
\def\XINT@fwover@D #1#2#3%
{%
    \ifcase\XINT@isOne {#3}
      \xint@afterfi { {#2\over #3}}%
    \or 
      \xint@afterfi { #2\cdot }%
    \fi
    #1%
}%
%    \end{macrocode}
% \subsection{\csh{xintSum}, \csh{xintSumExpr}}
%    \begin{macrocode}
\def\xintSum {\romannumeral0\xintsum }%
\def\xintsum #1{\xintsumexpr #1\relax }%
\def\xintSumExpr {\romannumeral0\xintsumexpr }%
\def\xintsumexpr {\expandafter\expandafter\expandafter\XINT@fsumexpr }%
\def\XINT@fsumexpr {\XINT@fsum@loop {0}}%
\def\XINT@fsum@loop #1#2%
{%
    \xint@relax #2\XINT@fsum@finished\relax
    \expandafter\XINT@fsum@loop\expandafter
         {\romannumeral0\xintadd {#1}{#2}}%
}%
\def\XINT@fsum@finished #1#2#3#4#5%
{%
    \XINT@fsum@finished@ #5%
}%
\def\XINT@fsum@finished@ #1#2#3#4#5{ #4}%
%    \end{macrocode}
% \subsection{\csh{xintPrd}, \csh{xintProductExpr}}
%    \begin{macrocode}
\def\xintPrd {\romannumeral0\xintprd }%
\def\xintprd #1{\xintproductexpr #1\relax }%
\def\xintProductExpr {\romannumeral0\xintproductexpr }%
\def\xintproductexpr{\expandafter\expandafter\expandafter\XINT@fproductexpr }%
\def\XINT@fproductexpr {\XINT@fprod@loop {1}}%
\def\XINT@fprod@loop #1#2%
{%
    \xint@relax #2\XINT@fprod@finished\relax
    \expandafter\XINT@fprod@loop\expandafter
         {\romannumeral0\xintmul {#2}{#1}}%
}%
\def\XINT@fprod@finished #1#2#3#4#5%
{%
    \XINT@fprod@finished@ #5%
}%
\def\XINT@fprod@finished@ #1#2#3#4#5{ #5}%
%    \end{macrocode}
% \subsection{\csh{XINT@inFrac}}
%    \begin{macrocode}
\def\XINT@inFrac {\romannumeral0\XINT@infrac }%
\def\XINT@infrac #1%
{%
    \expandafter\expandafter\expandafter
    \XINT@infrac@ #1[\W]\Z\T
}%
\def\XINT@infrac@ #1[#2#3]#4\Z
{%
    \xint@UDwfork
      #2\dummy \XINT@infrac@A
      \W\dummy \XINT@infrac@B
    \xint@UDkrof
    #1[#2#3]#4%
}%
\def\XINT@infrac@A #1[\W]\T 
{%
    \XINT@frac #1/\W\Z 
}%
\def\XINT@infrac@B #1%
{%
    \xint@zero #1\XINT@infrac@Zero0\XINT@infrac@BB #1%
}%
\def\XINT@infrac@BB #1[\W]\T {\XINT@infrac@BC #1/\W\Z }%
\def\XINT@infrac@BC #1/#2#3\Z 
{%
    \xint@UDwfork
     #2\dummy \XINT@infrac@BCa
     \W\dummy {\expandafter\expandafter\expandafter\XINT@infrac@BCb #2}%
    \xint@UDkrof
    #3\Z #1\Z
}%
\def\XINT@infrac@BCa \Z #1[#2]#3\Z { {#2}{#1}{1}}%
\def\XINT@infrac@BCb #1[#2]/\W\Z #3\Z { {#2}{#3}{#1}}%
\def\XINT@infrac@Zero #1\T { {0}{0}{1}}%
%    \end{macrocode}
% \subsection{\csh{XINT@frac}}
%    \begin{macrocode}
\def\XINT@frac #1/#2#3\Z
{%
    \xint@UDwfork
     #2\dummy \XINT@frac@A
     \W\dummy {\expandafter\expandafter\expandafter\XINT@frac@B #2}%
    \xint@UDkrof
    #3.\W\Z #1.\W\Z
}%
\def\XINT@frac@B #1.#2#3\Z
{%
    \xint@UDwfork
      #2\dummy \XINT@frac@Ba
      \W\dummy {\XINT@frac@Bb #2}%
    \xint@UDkrof
    #3\Z #1\Z
}%
\def\XINT@frac@Bb #1/\W.\W\Z #2\Z
{%
    \expandafter \XINT@frac@C \expandafter
    {\romannumeral0\XINT@length {#1}}{#2#1}%
}%
\def\XINT@frac@Ba \Z #1/\W\Z {\XINT@frac@C {0}{#1}}%
\def\XINT@frac@A .\W\Z {\XINT@frac@C {0}{1}}%
\def\XINT@frac@C #1#2#3.#4#5\Z
{%
    \xint@UDwfork
      #4\dummy \XINT@frac@Ca
      \W\dummy {\XINT@frac@Cb #4}%
    \xint@UDkrof
    #5\Z #3\Z {#1}{#2}%
}%
\def\XINT@frac@Ca \Z #1\Z {\XINT@frac@D {0}{#1}}%
\def\XINT@frac@Cb #1.\W\Z #2\Z 
{%
    \expandafter \XINT@frac@D \expandafter
    {\romannumeral0\XINT@length {#1}}{#2#1}%
}%
\def\XINT@frac@D #1#2#3#4%
{%
    \expandafter \XINT@frac@E \expandafter
    {\the\numexpr -#1+#3\expandafter}\expandafter
    {\romannumeral0\XINT@num@loop #2\R\R\R\R\R\R\R\R\Z }%
    {\romannumeral0\XINT@num@loop #4\R\R\R\R\R\R\R\R\Z }%
}%
\def\XINT@frac@E #1#2#3%
{%
   \expandafter \XINT@frac@F  #3\Z {#2}{#1}%
}%
\def\XINT@frac@F #1%
{%
    \xint@UDzerominusfork
      #1-\dummy  \XINT@frac@Gdivisionbyzero
      0#1\dummy  \XINT@frac@Gneg
       0-\dummy  {\XINT@frac@Gpos #1}%
    \xint@UDkrof
}%
\def\XINT@frac@Gdivisionbyzero #1\Z #2#3%
{%
   \xintError:DivisionByZero 
   \expandafter\space {0}{#2}{0}%
}%
\def\XINT@frac@Gneg #1\Z #2#3%
{%
    \expandafter\XINT@frac@H \expandafter
    {\romannumeral0\XINT@opp #2}{#3}{#1}%
}%
\def\XINT@frac@H #1#2{ {#2}{#1}}%
\def\XINT@frac@Gpos #1\Z #2#3{ {#3}{#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{XINT@factortens}}
%    \begin{macrocode}
\def\XINT@factortens #1%
{%
    \expandafter\XINT@cuz@cnt@loop\expandafter
    {\expandafter}\romannumeral0\XINT@rord@main {}#1%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF
    \R\R\R\R\R\R\R\R\Z
}%
\def\XINT@cuz@cnt #1%
{%
    \XINT@cuz@cnt@loop {}#1\R\R\R\R\R\R\R\R\Z
}%
\def\XINT@cuz@cnt@loop #1#2#3#4#5#6#7#8#9%
{%
    \xint@r #9\XINT@cuz@cnt@toofara \R
    \expandafter\XINT@cuz@cnt@checka\expandafter
    {\the\numexpr #1+8\relax}{#2#3#4#5#6#7#8#9}%
}%
\def\XINT@cuz@cnt@toofara #1#2#3#4#5#6%
{%
    \XINT@cuz@cnt@toofarb {#5}#6%
}%
\def\XINT@cuz@cnt@toofarb #1#2\Z 
    {\XINT@cuz@cnt@toofarc #2\Z {#1}}%
\def\XINT@cuz@cnt@toofarc #1#2#3#4#5#6#7#8%
{%
    \xint@r #2\XINT@cuz@cnt@toofard 7%
            #3\XINT@cuz@cnt@toofard 6%
            #4\XINT@cuz@cnt@toofard 5%
            #5\XINT@cuz@cnt@toofard 4%
            #6\XINT@cuz@cnt@toofard 3%
            #7\XINT@cuz@cnt@toofard 2%
            #8\XINT@cuz@cnt@toofard 1%
            \Z #1#2#3#4#5#6#7#8%
}%
\def\XINT@cuz@cnt@toofard #1#2\Z #3\R #4\Z #5%
{%
    \expandafter\XINT@cuz@cnt@toofare
    \the\numexpr #3\relax \R\R\R\R\R\R\R\R\Z
    {\the\numexpr #5-#1\relax}\R\Z
}%
\def\XINT@cuz@cnt@toofare #1#2#3#4#5#6#7#8%
{%
    \xint@r #2\XINT@cuz@cnt@stopc 1%
            #3\XINT@cuz@cnt@stopc 2%
            #4\XINT@cuz@cnt@stopc 3%
            #5\XINT@cuz@cnt@stopc 4%
            #6\XINT@cuz@cnt@stopc 5%
            #7\XINT@cuz@cnt@stopc 6%
            #8\XINT@cuz@cnt@stopc 7%
            \Z #1#2#3#4#5#6#7#8%
}%
\def\XINT@cuz@cnt@checka #1#2%
{%
    \expandafter\XINT@cuz@cnt@checkb\the\numexpr #2\relax \Z {#1}%
}%
\def\XINT@cuz@cnt@checkb #1%
{%
    \xint@zero #1\expandafter\XINT@cuz@cnt@loop\xint@z
    0\XINT@cuz@cnt@stopa #1%
}%
\def\XINT@cuz@cnt@stopa #1\Z 
{%
    \XINT@cuz@cnt@stopb #1\R\R\R\R\R\R\R\R\Z %
}%
\def\XINT@cuz@cnt@stopb #1#2#3#4#5#6#7#8#9%
{%
    \xint@r #2\XINT@cuz@cnt@stopc 1%
            #3\XINT@cuz@cnt@stopc 2%
            #4\XINT@cuz@cnt@stopc 3%
            #5\XINT@cuz@cnt@stopc 4%
            #6\XINT@cuz@cnt@stopc 5%
            #7\XINT@cuz@cnt@stopc 6%
            #8\XINT@cuz@cnt@stopc 7%
            #9\XINT@cuz@cnt@stopc 8%
            \Z #1#2#3#4#5#6#7#8#9%
}%
\def\XINT@cuz@cnt@stopc #1#2\Z #3\R #4\Z #5%
{%
    \expandafter\XINT@cuz@cnt@stopd\expandafter
    {\the\numexpr #5-#1\relax}#3%
}%
\def\XINT@cuz@cnt@stopd #1#2\R #3\Z
{%
    \expandafter\space\expandafter
     {\romannumeral0\XINT@rord@main {}#2%
      \xint@UNDEF
        \xint@undef\xint@undef\xint@undef\xint@undef
        \xint@undef\xint@undef\xint@undef\xint@undef
      \xint@UNDEF }{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintREZ}}
%    \begin{macrocode}
\def\xintREZ {\romannumeral0\xintrez }%
\def\xintrez
{%
    \expandafter\XINT@rez@A\romannumeral0\XINT@infrac
}%
\def\XINT@rez@A #1#2%
{%
    \XINT@rez@AB #2\Z {#1}%
}%
\def\XINT@rez@AB #1%
{%
    \xint@UDzerominusfork
      #1-\dummy \XINT@rez@zero
      0#1\dummy \XINT@rez@neg
       0-\dummy {\XINT@rez@B #1}%
    \xint@UDkrof
}%
\def\XINT@rez@zero #1\Z #2#3{ 0/1[0]}%
\def\XINT@rez@neg
{\expandafter\space\expandafter-\romannumeral0\XINT@rez@B }%
\def\XINT@rez@B #1\Z 
{%
    \expandafter\XINT@rez@C\romannumeral0\XINT@factortens {#1}%
}%
\def\XINT@rez@C #1#2#3#4%
{%
    \expandafter\XINT@rez@D\romannumeral0\XINT@factortens {#4}{#3}{#2}{#1}%
}%
\def\XINT@rez@D #1#2#3#4#5%
{%
    \expandafter\XINT@rez@E\expandafter
    {\the\numexpr #3+#4-#2}{#1}{#5}%
}%
\def\XINT@rez@E #1#2#3{ #3/#2[#1]}%
%    \end{macrocode}
% \subsection{\csh{xintIrr}}
%    \begin{macrocode}
\def\XINT@@bts #1#2#3%
{%
    \ifcase\XINT@isOne {#2}
      \xint@afterfi {#3#1/#2}%
    \or
      \xint@afterfi {#3#1}%
    \fi
}%
\def\xintIrr {\romannumeral0\xintirr }%
\def\xintirr 
{%
    \expandafter\XINT@@bts
    \romannumeral0\expandafter\XINT@irr
    \romannumeral0\XINT@infrac
}%
\def\XINT@irr #1%
{%
    \ifcase\XINT@Sgn {#1}
      \expandafter\XINT@irr@B
    \or
      \expandafter\XINT@irr@A
    \else
      \expandafter\XINT@irr@B
    \fi 
    {#1}%
}%
\def\XINT@irr@A #1#2%
{%
    \expandafter \XINT@irr@AC \expandafter
    {\romannumeral0\xint@dsh {#2}{-#1}}%
}%
\def\XINT@irr@AC #1#2{\XINT@irr@C #2\Z #1\Z }%
\def\XINT@irr@B #1#2#3%
{%
    \expandafter \XINT@irr@C \romannumeral0\xint@dsh {#3}{#1}\Z #2\Z
}%
\def\XINT@irr@C #1#2\Z #3#4\Z
{%
    \xint@UDsignsfork
      #1#3\dummy \XINT@irr@minusminus          
       #1-\dummy \XINT@irr@minusplus         
       #3-\dummy \XINT@irr@plusminus        
        --\dummy \XINT@irr@plusplus  
    \xint@UDkrof
    {#4}{#2}#3#1%
}%
\def\XINT@irr@minusminus #1#2#3#4{\XINT@irr@D #1\Z #2\Z \space}%
\def\XINT@irr@minusplus #1#2#3#4{\XINT@irr@D #3#1\Z #2\Z \XINT@opp}%
\def\XINT@irr@plusminus #1#2#3#4{\XINT@irr@D #1\Z #4#2\Z \XINT@opp}%
\def\XINT@irr@plusplus  #1#2#3#4{\XINT@irr@D #3#1\Z #4#2\Z \space}%
\def\XINT@irr@D #1#2\Z #3#4\Z
{%
    \xint@UDzerosfork
       #3#1\dummy \XINT@irr@indeterminate      
       #30\dummy  \XINT@irr@divisionbyzero        
       #10\dummy  \XINT@irr@zero        
        00\dummy  \XINT@irr@nonzero@checkifone
    \xint@UDkrof      
    {#3#4}{#1#2}{#3#4}{#1#2}%
}%
\def\XINT@irr@indeterminate #1#2#3#4{\expandafter\xintError:ZeroOverZero
                                 \space 00}%
\def\XINT@irr@divisionbyzero #1#2#3#4{\expandafter\xintError:DivisionByZero
                                  \space {#2}0}%
\def\XINT@irr@zero #1#2#3#4{ 0/1}%
\def\XINT@irr@nonzero@checkifone #1%
{%
    \ifcase\XINT@isOne {#1}
      \xint@afterfi {\XINT@irr@loop@a {#1}}%
    \or
      \expandafter \XINT@irr@denomisone
    \fi
}%
\def\XINT@irr@denomisone #1#2#3{ {#1}1}%
\def\XINT@irr@loop@a #1#2%
{%
    \expandafter\XINT@irr@loop@d
    \romannumeral0\XINT@div@prepare {#1}{#2}{#1}%
}%
\def\XINT@irr@loop@d #1#2#3%
{%
    \XINT@irr@loop@e #2\Z {#3}%
}%
\def\XINT@irr@loop@e #1#2\Z
{%
    \xint@zero #1\xint@irr@loop@exit0\XINT@irr@loop@a {#1#2}%
}%
\def\xint@irr@loop@exit0\XINT@irr@loop@a #1#2#3#4%
{%
    \expandafter\XINT@irr@loop@exitb\expandafter
    {\romannumeral0\xintquo {#3}{#2}}%
    {\romannumeral0\xintquo {#4}{#2}}%
}%
\def\XINT@irr@loop@exitb #1#2%
{%
   \expandafter\space\expandafter {#2}{#1}%
}%
%    \end{macrocode}
% \subsection{\csh{xintJrr}}
%    \begin{macrocode}
\def\xintJrr {\romannumeral0\xintjrr }%
\def\xintjrr
{%
    \expandafter\XINT@@bts
    \romannumeral0\expandafter\XINT@jrr@start
    \romannumeral0\xintrez
}%
\def\XINT@jrr@start #1/#2[#3]%
{%
    \ifcase\XINT@Sgn {#3}
      \expandafter\XINT@jrr@B
    \or
      \expandafter\XINT@jrr@A
    \else
      \expandafter\XINT@jrr@B
    \fi 
    {#3}{#1}{#2}%
}%
\def\XINT@jrr@A #1#2%
{%
    \expandafter \XINT@jrr@AC \expandafter
    {\romannumeral0\xint@dsh {#2}{-#1}}%
}%
\def\XINT@jrr@AC #1#2{\XINT@jrr@C #2\Z #1\Z }%
\def\XINT@jrr@B #1#2#3%
{%
    \expandafter \XINT@jrr@C \romannumeral0\xint@dsh {#3}{#1}\Z #2\Z
}%
\def\XINT@jrr@C #1#2\Z #3#4\Z
{%
    \xint@UDsignsfork
      #1#3\dummy \XINT@jrr@minusminus          
       #1-\dummy \XINT@jrr@minusplus         
       #3-\dummy \XINT@jrr@plusminus        
        --\dummy \XINT@jrr@plusplus  
    \xint@UDkrof
    {#4}{#2}#3#1%
}%
\def\XINT@jrr@minusminus #1#2#3#4{\XINT@jrr@D #1\Z #2\Z \space }%
\def\XINT@jrr@minusplus #1#2#3#4{\XINT@jrr@D #3#1\Z #2\Z \XINT@opp }%
\def\XINT@jrr@plusminus #1#2#3#4{\XINT@jrr@D #1\Z #4#2\Z \XINT@opp }%
\def\XINT@jrr@plusplus  #1#2#3#4{\XINT@jrr@D #3#1\Z #4#2\Z \space }%
\def\XINT@jrr@D #1#2\Z #3#4\Z
{%
    \xint@UDzerosfork
       #3#1\dummy \XINT@jrr@indeterminate      
       #30\dummy  \XINT@jrr@divisionbyzero        
       #10\dummy  \XINT@jrr@zero        
        00\dummy  \XINT@jrr@nonzero@checkifone
    \xint@UDkrof      
    {#3#4}{#1#2}1001%
}%
\def\XINT@jrr@indeterminate #1#2#3#4#5#6{\expandafter\xintError:ZeroOverZero
                                 \space 00}%
\def\XINT@jrr@divisionbyzero #1#2#3#4#5#6{\expandafter\xintError:DivisionByZero
                                  \space {#2}0}%
\def\XINT@jrr@zero #1#2#3#4#5#6{ 0/1}%
\def\XINT@jrr@nonzero@checkifone #1%
{%
    \ifcase\XINT@isOne {#1}
      \xint@afterfi {\XINT@jrr@loop@a {#1}}%
    \or
      \expandafter \XINT@jrr@denomisone
    \fi
}%
\def\XINT@jrr@denomisone #1#2#3#4#5{ {#1}1}%
\def\XINT@jrr@loop@a #1#2%
{%
    \expandafter\XINT@jrr@loop@b
    \romannumeral0\XINT@div@prepare {#1}{#2}{#1}%
}%
\def\XINT@jrr@loop@b #1#2#3#4#5#6#7%
{%
    \expandafter \XINT@jrr@loop@c \expandafter
        {\romannumeral0\xintiadd{\XINT@Mul{#4}{#1}}{#6}}%
        {\romannumeral0\xintiadd{\XINT@Mul{#5}{#1}}{#7}}%
    {#2}{#3}{#4}{#5}%
}%
\def\XINT@jrr@loop@c #1#2%
{%
    \expandafter \XINT@jrr@loop@d \expandafter
        {#2}{#1}%
}%
\def\XINT@jrr@loop@d #1#2#3#4%
{%
    \XINT@jrr@loop@e #3\Z {#4}{#2}{#1}%
}%
\def\XINT@jrr@loop@e #1#2\Z
{%
    \xint@zero #1\xint@jrr@loop@exit0\XINT@jrr@loop@a {#1#2}%
}%
\def\xint@jrr@loop@exit0\XINT@jrr@loop@a #1#2#3#4#5#6%
{%
    \space {#3}{#4}%
}%
%    \end{macrocode}
% \subsection{\csh{xintTrunc}, \csh{xintiTrunc}}
%    \begin{macrocode}
\def\xintTrunc {\romannumeral0\xinttrunc }%
\def\xintiTrunc {\romannumeral0\xintitrunc }%
\def\xinttrunc #1%
{%
    \expandafter\expandafter\expandafter
       \xint@trunc
    \expandafter\expandafter\expandafter
       {#1}%
}%
\def\xint@trunc #1#2%
{%
    \expandafter\XINT@trunc@G
    \romannumeral0\expandafter\XINT@trunc@A
    \romannumeral0\XINT@infrac {#2}{#1}{#1}%
}%
\def\xintitrunc #1%
{%
    \expandafter\expandafter\expandafter
       \xint@itrunc
    \expandafter\expandafter\expandafter
       {#1}%
}%
\def\xint@itrunc #1#2%
{%
    \expandafter\XINT@itrunc@G
    \romannumeral0\expandafter\XINT@trunc@A
    \romannumeral0\XINT@infrac {#2}{#1}{#1}%
}%
\def\XINT@trunc@A #1#2#3#4%
{%
    \expandafter\XINT@trunc@checkifzero
    \expandafter{\the\numexpr #1+#4\relax}#2\Z {#3}%
}%
\def\XINT@trunc@checkifzero #1#2#3\Z 
{%
    \xint@zero #2\XINT@trunc@iszero0\XINT@trunc@B {#1}{#2#3}%
}%
\def\XINT@trunc@iszero #1#2#3#4#5{ 0\Z 0}%
\def\XINT@trunc@B #1%
{%
    \ifcase\XINT@Sgn {#1}
      \expandafter\XINT@trunc@D
    \or
      \expandafter\XINT@trunc@D
    \else
      \expandafter\XINT@trunc@C
    \fi 
    {#1}%
}%
\def\XINT@trunc@C #1#2#3%
{%
    \expandafter \XINT@trunc@E
    \romannumeral0\xint@dsh {#3}{#1}\Z #2\Z
}%
\def\XINT@trunc@D #1#2%
{%
    \expandafter \XINT@trunc@DE \expandafter
    {\romannumeral0\xint@dsh {#2}{-#1}}%
}%
\def\XINT@trunc@DE #1#2{\XINT@trunc@E #2\Z #1\Z }%
\def\XINT@trunc@E #1#2\Z #3#4\Z
{%
    \xint@UDsignsfork
          #1#3\dummy \XINT@trunc@minusminus          
           #1-\dummy {\XINT@trunc@minusplus #3}%
           #3-\dummy {\XINT@trunc@plusminus #1}%
            --\dummy {\XINT@trunc@plusplus  #3#1}%
    \xint@UDkrof
    {#4}{#2}%
}%
\def\XINT@trunc@minusminus #1#2{\xintquo {#1}{#2}\Z \space}%
\def\XINT@trunc@minusplus #1#2#3{\xintquo {#1#2}{#3}\Z \xint@minus@andstop}%
\def\XINT@trunc@plusminus #1#2#3{\xintquo {#2}{#1#3}\Z \xint@minus@andstop}%
\def\XINT@trunc@plusplus  #1#2#3#4{\xintquo {#1#3}{#2#4}\Z \space}%
\def\XINT@itrunc@G #1\Z #2#3%
{%
    \xint@zero #2\XINT@trunc@zero 0\xint@firstoftwo {#2#1}0%
}%
\def\XINT@trunc@G #1\Z #2#3%
{%
    \xint@zero #2\XINT@trunc@zero 0%
    \expandafter\XINT@trunc@H\expandafter
    {\the\numexpr\romannumeral0\XINT@length {#1}-#3\relax}{#3}{#1}#2%
}%
\def\XINT@trunc@zero 0#10{ 0}%
\def\XINT@trunc@H #1#2%
{%
    \ifnum #1 > 0
        \xint@afterfi {\XINT@trunc@Ha {#2}}%
    \else
        \xint@afterfi {\XINT@trunc@Hb {-#1}}%
    \fi
}%
\def\XINT@trunc@Ha
{%
  \expandafter\XINT@trunc@Haa\romannumeral0\xintdecsplit
}%
\def\XINT@trunc@Haa #1#2#3%
{%
    #3#1.#2%
}%
\def\XINT@trunc@Hb #1#2#3%
{%
  \expandafter #3\expandafter0\expandafter.%
  \romannumeral0\XINT@dsx@zeroloop {#1}\Z {}#2%
}%
%    \end{macrocode}
% \subsection{\csh{xintMul}}
%    \begin{macrocode}
\def\xintMul {\romannumeral0\xintmul }%
\def\xintmul #1%
{%
    \expandafter\xint@fmul\expandafter {\romannumeral0\XINT@infrac {#1}}%
}%
\def\xint@fmul #1#2%
   {\expandafter\XINT@fmul@A\romannumeral0\XINT@infrac {#2}#1}%
\def\XINT@fmul@A #1#2#3#4#5#6%
{%
    \expandafter\XINT@fmul@B
    \expandafter{\the\numexpr #1+#4\expandafter}%
    \expandafter{\romannumeral0\xintimul {#6}{#3}}%
    {\romannumeral0\xintimul {#5}{#2}}%
}%
\def\XINT@fmul@B #1#2#3%
{%
    \expandafter \XINT@fmul@C \expandafter{#3}{#1}{#2}%
}%
\def\XINT@fmul@C #1#2{\XINT@outfrac {#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintSqr}}
%    \begin{macrocode}
\def\xintSqr {\romannumeral0\xintsqr }%
\def\xintsqr #1%
{%
    \expandafter\xint@fsqr\expandafter{\romannumeral0\XINT@infrac {#1}}%
}%
\def\xint@fsqr #1{\XINT@fmul@A #1#1}%
%    \end{macrocode}
% \subsection{\csh{xintPow}}
%    \begin{macrocode}
\def\xintPow {\romannumeral0\xintpow }%
\def\xintpow #1%
{%
    \expandafter\xint@fpow\expandafter {\romannumeral0\XINT@infrac {#1}}%
}%
\def\xint@fpow #1#2%
{%
    \expandafter\expandafter\expandafter
       \XINT@fpow@fork
    #2\Z #1%
}%
\def\XINT@fpow@fork #1#2\Z
{%
    \xint@UDzerominusfork
      #1-\dummy  \XINT@fpow@zero
      0#1\dummy  \XINT@fpow@neg
       0-\dummy  {\XINT@fpow@pos #1}%
    \xint@UDkrof
    {#2}%
}%
\def\XINT@fpow@zero #1#2#3#4%
{%
    \space 1[0]%
}%
\def\XINT@fpow@pos #1#2#3#4#5%
{%
    \expandafter\XINT@fpow@pos@A\expandafter
    {\the\numexpr #1#2*#3\expandafter}\expandafter
    {\romannumeral0\xintipow {#5}{#1#2}}%
    {\romannumeral0\xintipow {#4}{#1#2}}%
}%
\def\XINT@fpow@neg #1#2#3#4%
{%
    \expandafter\XINT@fpow@pos@A\expandafter
    {\the\numexpr -#1*#2\expandafter}\expandafter
    {\romannumeral0\xintipow {#3}{#1}}%
    {\romannumeral0\xintipow {#4}{#1}}%
}%
\def\XINT@fpow@pos@A #1#2#3%
{%
    \expandafter\XINT@fpow@pos@B\expandafter {#3}{#1}{#2}%
}%
\def\XINT@fpow@pos@B #1#2{\XINT@outfrac {#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintDiv}}
%    \begin{macrocode}
\def\xintDiv {\romannumeral0\xintdiv }%
\def\xintdiv #1%
{%
    \expandafter\xint@fdiv\expandafter {\romannumeral0\XINT@infrac {#1}}%
}%
\def\xint@fdiv #1#2%
   {\expandafter\XINT@fdiv@A\romannumeral0\XINT@infrac {#2}#1}%
\def\XINT@fdiv@A #1#2#3#4#5#6%
{%
    \expandafter\XINT@fdiv@B
    \expandafter{\the\numexpr #4-#1\expandafter}%
    \expandafter{\romannumeral0\xintimul {#2}{#6}}%
    {\romannumeral0\xintimul {#3}{#5}}%
}%
\def\XINT@fdiv@B #1#2#3%
{%
    \expandafter\XINT@fdiv@C
    \expandafter{#3}{#1}{#2}%
}%
\def\XINT@fdiv@C #1#2{\XINT@outfrac {#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintAdd}}
%    \begin{macrocode}
\def\xintAdd {\romannumeral0\xintadd }%
\def\xintadd #1%
{%
    \expandafter\xint@fadd\expandafter {\romannumeral0\XINT@infrac {#1}}%
}%
\def\xint@fadd #1#2%
{\expandafter\XINT@fadd@A\romannumeral0\XINT@infrac{#2}#1}%
\def\XINT@fadd@A #1#2#3#4%
{%
    \ifnum #4 > #1
       \xint@afterfi {\XINT@fadd@B {#1}}%
    \else
       \xint@afterfi {\XINT@fadd@B {#4}}%
    \fi
    {#1}{#4}{#2}{#3}%
}%
\def\XINT@fadd@B #1#2#3#4#5#6#7%
{%
    \expandafter\XINT@fadd@C\expandafter
    {\romannumeral0\xintimul {#7}{#5}}%
    {\romannumeral0\xintiadd
    {\romannumeral0\xintimul {\xintDSH {\the\numexpr -#3+#1\relax}{#6}}{#5}}%
    {\romannumeral0\xintimul {#7}{\xintDSH {\the\numexpr -#2+#1\relax}{#4}}}%
    }%
    {#1}%
}%
\def\XINT@fadd@C #1#2#3%
{%
    \expandafter\XINT@fadd@D\expandafter {#2}{#3}{#1}%
}%
\def\XINT@fadd@D #1#2{\XINT@outfrac {#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintSub}}
%    \begin{macrocode}
\def\xintSub {\romannumeral0\xintsub }%
\def\xintsub #1%
{%
    \expandafter\xint@fsub\expandafter {\romannumeral0\XINT@infrac {#1}}%
}%
\def\xint@fsub #1#2%
   {\expandafter\XINT@fsub@A\romannumeral0\XINT@infrac {#2}#1}%
\def\XINT@fsub@A #1#2#3#4%
{%
    \ifnum #4 > #1
       \xint@afterfi {\XINT@fsub@B {#1}}%
    \else
       \xint@afterfi {\XINT@fsub@B {#4}}%
    \fi
    {#1}{#4}{#2}{#3}%
}%
\def\XINT@fsub@B #1#2#3#4#5#6#7%
{%
    \expandafter\XINT@fsub@C\expandafter
    {\romannumeral0\xintimul {#7}{#5}}%
    {\romannumeral0\xintisub
    {\romannumeral0\xintimul {\xintDSH {\the\numexpr -#3+#1\relax}{#6}}{#5}}%
    {\romannumeral0\xintimul {#7}{\xintDSH {\the\numexpr -#2+#1\relax}{#4}}}%
    }%
    {#1}%
}%
\def\XINT@fsub@C #1#2#3%
{%
    \expandafter\XINT@fsub@D\expandafter {#2}{#3}{#1}%
}%
\def\XINT@fsub@D #1#2{\XINT@outfrac {#2}{#1}}%
%    \end{macrocode}
% \subsection{\csh{xintCmp}}
%    \begin{macrocode}
\def\xintCmp {\romannumeral0\xintcmp }%
\def\xintcmp #1%
{%
    \expandafter\xint@fcmp\expandafter {\romannumeral0\XINT@infrac {#1}}%
}%
\def\xint@fcmp #1#2{\expandafter\XINT@fcmp@A\romannumeral0\XINT@infrac {#2}#1}%
\def\XINT@fcmp@A #1#2#3#4%
{%
    \ifnum #4 > #1
       \xint@afterfi {\XINT@fcmp@B {#1}}%
    \else
       \xint@afterfi {\XINT@fcmp@B {#4}}%
    \fi
    {#1}{#4}{#2}{#3}%
}%
\def\XINT@fcmp@B #1#2#3#4#5#6#7%
{%
    \xinticmp
    {\romannumeral0\xintimul {\xintDSH {\the\numexpr -#3+#1\relax}{#6}}{#5}}%
    {\romannumeral0\xintimul {#7}{\xintDSH {\the\numexpr -#2+#1\relax}{#4}}}%
}%
%    \end{macrocode}
% \subsection{\csh{xintMax}}
%    \begin{macrocode}
\def\xintMax {\romannumeral0\xintmax }%
\def\xintmax #1%
{%
    \expandafter\xint@fmax\expandafter {\romannumeral0\XINT@infrac {#1}}%
}%
\def\xint@fmax #1#2{\expandafter\XINT@outfrac
                    \romannumeral0\expandafter\XINT@fmax@A
                    \romannumeral0\XINT@infrac {#2}#1}%
\def\XINT@fmax@A #1#2#3#4#5#6%
{%
    \ifnum #4 > #1
       \xint@afterfi {\XINT@fmax@B {#1}}%
    \else
       \xint@afterfi {\XINT@fmax@B {#4}}%
    \fi
    {#1}{#4}{#2}{#3}{#5}{#6}{{#4}{#5}{#6}}{{#1}{#2}{#3}}%
}%
\def\XINT@fmax@B #1#2#3#4#5#6#7%
{%
    \expandafter\XINT@fmax@C\expandafter
    {\romannumeral0\xintimul {\xintDSH {\the\numexpr -#3+#1\relax}{#6}}{#5}}%
    {\romannumeral0\xintimul {#7}{\xintDSH {\the\numexpr -#2+#1\relax}{#4}}}%
}%
\def\XINT@fmax@C #1#2%
{%
    \expandafter\XINT@max@fork #2\Z #1\Z 
}%
%    \end{macrocode}
% \subsection{\csh{xintMin}}
%    \begin{macrocode}
\def\xintMin {\romannumeral0\xintmin }%
\def\xintmin #1%
{%
    \expandafter\xint@fmin\expandafter {\romannumeral0\XINT@infrac {#1}}%
}%
\def\xint@fmin #1#2{\expandafter\XINT@outfrac
                    \romannumeral0\expandafter\XINT@fmin@A
                    \romannumeral0\XINT@infrac {#2}#1}%
\def\XINT@fmin@A #1#2#3#4#5#6%
{%
    \ifnum #4 > #1
       \xint@afterfi {\XINT@fmin@B {#1}}%
    \else
       \xint@afterfi {\XINT@fmin@B {#4}}%
    \fi
    {#1}{#4}{#2}{#3}{#5}{#6}{{#4}{#5}{#6}}{{#1}{#2}{#3}}%
}%
\def\XINT@fmin@B #1#2#3#4#5#6#7%
{%
    \expandafter\XINT@fmin@C\expandafter
    {\romannumeral0\xintimul {\xintDSH {\the\numexpr -#3+#1\relax}{#6}}{#5}}%
    {\romannumeral0\xintimul {#7}{\xintDSH {\the\numexpr -#2+#1\relax}{#4}}}%
}%
\def\XINT@fmin@C #1#2%
{%
    \expandafter\XINT@min@fork #2\Z #1\Z 
}%
%    \end{macrocode}
% \subsection{\csh{xintSgn}}
%    \begin{macrocode}
\def\xintSgn {\romannumeral0\xintsgn }%
\def\xintsgn #1%
{%
    \expandafter\xint@fsgn\romannumeral0\XINT@infrac {#1}%
}%
\def\xint@fsgn #1#2#3{\xintisgn {#2}}%
%    \end{macrocode}
% \subsection{\csh{xintOpp}}
%    \begin{macrocode}
\def\xintOpp {\romannumeral0\xintopp }%
\def\xintopp #1%
{%
    \expandafter\xint@fopp\romannumeral0\XINT@infrac {#1}%
}%
\def\xint@fopp #1#2{\expandafter\XINT@outfrac\expandafter 
                    {\the\numexpr #1\expandafter}\expandafter
                    {\romannumeral0\XINT@opp #2}}%
%    \end{macrocode}
% \subsection{\csh{xintAbs}}
%    \begin{macrocode}
\def\xintAbs {\romannumeral0\xintabs }%
\def\xintabs #1%
{%
    \expandafter\xint@fabs\romannumeral0\XINT@infrac {#1}%
}%
\def\xint@fabs #1#2{\expandafter\XINT@outfrac\expandafter 
                    {\the\numexpr #1\expandafter}\expandafter
                    {\romannumeral0\XINT@abs #2}}%
\XINT@frac@restorecatcodes@endinput%
%    \end{macrocode}
%\catcode`\<=0 \catcode`\>=11 \catcode`\*=11 \catcode`\/=11
%\let</xintfrac>\relax
%\def<*xintseries>{\catcode`\<=12 \catcode`\>=12 \catcode`\*=12 \catcode`\/=12 }
%</xintfrac>
%<*xintseries>
% \section{Package \xintseriesname implementation}
% 
% The commenting is currently (\docdate) very sparse.
%
% \localtableofcontents
% \subsection{Catcodes, \eTeX{} detection, reload detection}
%
% The code for reload detection is copied from \textsc{Heiko
% Oberdiek}'s packages, and adapted here to check for previous
% loading of the \xintfracname package.
%
% The method for catcodes is slightly different, but still
% directly inspired by these packages.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \def\space { }%
  \let\z\endgroup
  \expandafter\let\expandafter\x\csname ver@xintseries.sty\endcsname
  \expandafter\let\expandafter\w\csname ver@xintfrac.sty\endcsname
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \expandafter
  \ifx\csname numexpr\endcsname\relax
     \y{xintseries}{\numexpr not available, aborting input}%
     \aftergroup\endinput
  \else
    \ifx\x\relax   % plain-TeX, first loading of xintseries.sty
      \ifx\w\relax % but xintfrac.sty not yet loaded.
         \y{xintseries}{Package xintfrac is required}%
         \y{xintseries}{Will try \string\input\space xintfrac.sty}%
         \def\z{\endgroup\input xintfrac.sty\relax}%
      \fi
    \else
      \def\empty {}%
      \ifx\x\empty % LaTeX, first loading,
      % variable is initialized, but \ProvidesPackage not yet seen
          \ifx\w\relax % xintfrac.sty not yet loaded.
            \y{xintseries}{Package xintfrac is required}%
            \y{xintseries}{Will try \string\RequirePackage{xintfrac}}%
            \def\z{\endgroup\RequirePackage{xintfrac}}%
          \fi
      \else
        \y{xintseries}{I was already loaded, aborting input}%
        \aftergroup\endinput
      \fi
    \fi
  \fi
\z%
%    \end{macrocode}
% \subsection{Confirmation of \xintfracname loading}
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \catcode35=6    % #
  \catcode44=12   % ,
  \catcode45=12   % -
  \catcode46=12   % .
  \catcode58=12   % :
  \expandafter
    \ifx\csname PackageInfo\endcsname\relax
      \def\y#1#2{\immediate\write-1{Package #1 Info: #2.}}%
    \else
      \def\y#1#2{\PackageInfo{#1}{#2}}%
    \fi
  \def\empty {}%
  \expandafter\let\expandafter\w\csname ver@xintfrac.sty\endcsname
  \ifx\w\relax % Plain TeX, user gave a file name at the prompt
      \y{xintseries}{Loading of package xintfrac failed, aborting input}%
      \aftergroup\endinput
  \fi
  \ifx\w\empty % LaTeX, user gave a file name at the prompt
      \y{xintseries}{Loading of package xintfrac failed, aborting input}%
      \aftergroup\endinput
  \fi
\endgroup%
%    \end{macrocode}
% \subsection{Catcodes}
%
% Perhaps catcodes have changed after the loading of \xintname and
% \xintfracname and prior to the current loading of \xintseriesname, 
% so we can not employ the |\XINT@restorecatcodes@endinput| in this style 
% file. But there is no problem using |\XINT@setcatcodes|.
%
%    \begin{macrocode}
\begingroup\catcode61\catcode48\catcode32=10\relax%
  \catcode13=5    % ^^M
  \endlinechar=13 %
  \catcode123=1   % {
  \catcode125=2   % }
  \catcode64=11   % @
  \def\x
  {%
      \endgroup
      \edef\XINT@series@restorecatcodes@endinput
      {%
        \catcode93=\the\catcode93   % ]
        \catcode91=\the\catcode91   % [
        \catcode47=\the\catcode47   % /
        \catcode41=\the\catcode41   % )
        \catcode40=\the\catcode40   % (
        \catcode42=\the\catcode42   % *
        \catcode43=\the\catcode43   % +
        \catcode62=\the\catcode62   % >
        \catcode60=\the\catcode60   % <
        \catcode58=\the\catcode58   % :
        \catcode46=\the\catcode46   % .
        \catcode45=\the\catcode45   % -
        \catcode44=\the\catcode44   % ,
        \catcode35=\the\catcode35   % #
        \catcode64=\the\catcode64   % @
        \catcode125=\the\catcode125 % }
        \catcode123=\the\catcode123 % {
        \endlinechar=\the\endlinechar
        \catcode13=\the\catcode13   % ^^M
        \catcode32=\the\catcode32   % 
        \catcode61=\the\catcode61   % =
        \noexpand\endinput
      }%
      \XINT@setcatcodes
      \catcode91=12 % [
      \catcode93=12 % ]
  }%
\x
%    \end{macrocode}
% \subsection{Package identification}
%    \begin{macrocode}
\begingroup
  \catcode58=12 % :
  \expandafter\ifx\csname ProvidesPackage\endcsname\relax
    \def\x#1#2#3[#4]{\endgroup
      \immediate\write-1{Package: #3 #4}%
      \xdef#1{#4}%
    }%
  \else
    \def\x#1#2[#3]{\endgroup
      #2[{#3}]%
      \ifx#1\@undefined
        \xdef#1{#3}%
      \fi
      \ifx#1\relax
        \xdef#1{#3}%
      \fi
    }%
  \fi
\expandafter\x\csname ver@xintseries.sty\endcsname
\ProvidesPackage{xintseries}%
  [2013/04/14 v1.03 Expandable partial sums with xint package (jfB)]%
%    \end{macrocode}
% \subsection{\csh{xintSeries}}
%    \begin{macrocode}
\def\xintSeries {\romannumeral0\xintseries }%
\def\xintseries #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@series@i
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@series@i #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@series@ii
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@series@ii #1#2#3%
{%
   \ifnum #2<#1
      \xint@afterfi { 0[0]}%
   \else
      \xint@afterfi {\XINT@series@loop {#1}{0}{#2}{#3}}%
   \fi
}%
\def\XINT@series@loop #1#2#3#4%
{%
    \ifnum #3>#1 \else \XINT@series@exit \fi
    \expandafter\XINT@series@loop\expandafter
    {\the\numexpr #1+1\expandafter }\expandafter
    {\romannumeral0\xintadd {#2}{#4{#1}}}%
    {#3}{#4}%
}%
\def\XINT@series@exit \fi #1#2#3#4#5#6#7#8%
{%
    \fi\xint@gobble@two #6%
}%
%    \end{macrocode}
% \subsection{\csh{xintiSeries}}
%    \begin{macrocode}
\def\xintiSeries {\romannumeral0\xintiseries }%
\def\xintiseries #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@iseries@i
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@iseries@i #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@iseries@ii
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@iseries@ii #1#2#3%
{%
   \ifnum #2<#1
      \xint@afterfi { 0}%
   \else
      \xint@afterfi {\XINT@iseries@loop {#1}{0}{#2}{#3}}%
   \fi
}%
\def\XINT@iseries@loop #1#2#3#4%
{%
    \ifnum #3>#1 \else \XINT@iseries@exit \fi
    \expandafter\XINT@iseries@loop\expandafter
    {\the\numexpr #1+1\expandafter }\expandafter
    {\romannumeral0\xintiadd {#2}{#4{#1}}}%
    {#3}{#4}%
}%
\def\XINT@iseries@exit \fi #1#2#3#4#5#6#7#8%
{%
    \fi\xint@gobble@two #6%
}%
%    \end{macrocode}
% \subsection{\csh{xintPowerSeries}}
%    \begin{macrocode}
\def\xintPowerSeries {\romannumeral0\xintpowerseries }%
\def\xintpowerseries #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@powseries@i
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@powseries@i #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@powseries@ii
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@powseries@ii #1#2#3#4%
{%
   \ifnum #2<#1
      \xint@afterfi { 0[0]}%
   \else
      \xint@afterfi
      {\expandafter\XINT@powseries@loop@pre\expandafter
          {\romannumeral0\xintpow {#4}{#1}}{#1}{#4}{#2}{#3}%
      }%
   \fi
}%
\def\XINT@powseries@loop@pre #1#2#3#4#5%
{%
    \ifnum #4>#2 \else\XINT@powseries@dont@i \fi
    \expandafter\XINT@powseries@loop@i\expandafter 
    {\the\numexpr #2+1\expandafter}\expandafter
    {\romannumeral0\xintmul {#5{#2}}{#1}}{#1}{#3}{#4}{#5}%
}%
\def\XINT@powseries@dont@i \fi\expandafter\XINT@powseries@loop@i
    {\fi \expandafter\XINT@powseries@dont@ii }%
\def\XINT@powseries@dont@ii #1#2#3#4#5#6{ #2}%
\def\XINT@powseries@loop@i #1#2#3#4#5%
{%
    \ifnum #5>#1 \else \XINT@powseries@exit@i \fi
    \expandafter\XINT@powseries@loop@ii\expandafter
    {\romannumeral0\xintmul {#3}{#4}}{#1}{#4}{#2}{#5}%
}%
\def\XINT@powseries@loop@ii #1#2#3#4#5#6%
{%
    \expandafter\XINT@powseries@loop@i\expandafter
    {\the\numexpr #2+1\expandafter}\expandafter
    {\romannumeral0\xintadd {#4}{\xintMul {#6{#2}}{#1}}}%
    {#1}{#3}{#5}{#6}%
}%
\def\XINT@powseries@exit@i\fi \expandafter\XINT@powseries@loop@ii
   {\fi \expandafter\XINT@powseries@exit@ii }%
\def\XINT@powseries@exit@ii #1#2#3#4#5#6%
   {\xintadd {#4}{\xintMul {#6{#2}}{#1}}}%
%    \end{macrocode}
% \subsection{\csh{xintFxPtPowerSeries}}
% \begin{verbatim}
% I am not two happy with this piece of code. Will make it more economical
% another day.
% \end{verbatim}
% \vspace*{-1.5\baselineskip}
%    \begin{macrocode}
\def\xintFxPtPowerSeries {\romannumeral0\xintfxptpowerseries }%
\def\xintfxptpowerseries #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@fppowseries@i
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@fppowseries@i #1#2%
{%
    \expandafter\expandafter\expandafter
        \XINT@fppowseries@ii
    \expandafter\expandafter\expandafter
        {#2}{#1}%
}%
\def\XINT@fppowseries@ii #1#2#3#4#5%
{%
   \ifnum #2<#1
      \xint@afterfi {\xinttrunc {#5}{0[0]}}%
   \else
      \xint@afterfi
        {\expandafter\XINT@fppowseries@loop@pre\expandafter
           {\romannumeral0\xinttrunc {#5}{\xintPow {#4}{#1}}}%
          {#1}{#4}{#2}{#3}{#5}%
        }%
   \fi
}%
\def\XINT@fppowseries@loop@pre #1#2#3#4#5#6%
{%
    \ifnum #4>#2 \else\XINT@fppowseries@dont@i \fi
    \expandafter\XINT@fppowseries@loop@i\expandafter 
    {\the\numexpr #2+1\expandafter}\expandafter
    {\romannumeral0\xintitrunc {#6}{\xintMul {#5{#2}}{#1}}}%
    {#1}{#3}{#4}{#5}{#6}%
}%
\def\XINT@fppowseries@dont@i \fi\expandafter\XINT@fppowseries@loop@i
    {\fi \expandafter\XINT@fppowseries@dont@ii }%
\def\XINT@fppowseries@dont@ii #1#2#3#4#5#6#7{\xinttrunc {#7}{#2[-#7]}}%
\def\XINT@fppowseries@loop@i #1#2#3#4#5#6#7%
{%
    \ifnum #5>#1 \else \XINT@fppowseries@exit@i \fi
    \expandafter\XINT@fppowseries@loop@ii\expandafter
    {\romannumeral0\xinttrunc {#7}{\xintMul {#3}{#4}}}%
    {#1}{#4}{#2}{#5}{#6}{#7}%
}%
\def\XINT@fppowseries@loop@ii #1#2#3#4#5#6#7%
{%
    \expandafter\XINT@fppowseries@loop@i\expandafter
    {\the\numexpr #2+1\expandafter}\expandafter
    {\romannumeral0\xintiadd {#4}{\xintiTrunc {#7}{\xintMul {#6{#2}}{#1}}}}%
    {#1}{#3}{#5}{#6}{#7}%
}%
\def\XINT@fppowseries@exit@i\fi \expandafter\XINT@fppowseries@loop@ii
   {\fi \expandafter\XINT@fppowseries@exit@ii }%
\def\XINT@fppowseries@exit@ii #1#2#3#4#5#6#7%
   {\xinttrunc {#7}%
    {\xintiAdd {#4}{\xintiTrunc {#7}{\xintMul {#6{#2}}{#1}}}[-#7]}}%
\XINT@series@restorecatcodes@endinput%
%    \end{macrocode}
% \DeleteShortVerb{\|}
% \MakePercentComment
%</xintseries>
%<*none>
\CharacterTable
 {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
  Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
  Digits        \0\1\2\3\4\5\6\7\8\9
  Exclamation   \!     Double quote  \"     Hash (number) \#
  Dollar        \$     Percent       \%     Ampersand     \&
  Acute accent  \'     Left paren    \(     Right paren   \)
  Asterisk      \*     Plus          \+     Comma         \,
  Minus         \-     Point         \.     Solidus       \/
  Colon         \:     Semicolon     \;     Less than     \<
  Equals        \=     Greater than  \>     Question mark \?
  Commercial at \@     Left bracket  \[     Backslash     \\
  Right bracket \]     Circumflex    \^     Underscore    \_
  Grave accent  \`     Left brace    \{     Vertical bar  \|
  Right brace   \}     Tilde         \~}

\CheckSum{9336}

\Finale
%%
%% End of file `xint.dtx'.

